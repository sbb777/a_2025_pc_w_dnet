# netX 90 MMIO7 동작 원리 상세 설명

이 문서는 `cifX` 툴킷을 사용하여 STM32 호스트에서 netX 90의 MMIO7 핀을 제어하는 코드의 상세한 동작 원리를 설명합니다.

## 1. 제어 방식: 패킷 통신

netX 90의 MMIO(Memory-Mapped I/O)는 단순히 메모리 주소에 값을 쓰는 방식 외에도, 펌웨어에 정의된 **메일박스(Mailbox) 패킷 통신**을 통해 제어할 수 있습니다. 이 프로젝트에서는 후자의 방식을 사용합니다.

*   **장점**: 이 방식은 펌웨어가 제공하는 공식적인 인터페이스를 사용하므로 더 안정적이고 예측 가능합니다. 하드웨어 레지스터 주소가 변경되더라도 펌웨어 API(패킷 커맨드)가 동일하다면 코드를 수정할 필요가 없습니다.
*   **프로세스**: 호스트(STM32)는 특정 작업을 요청하는 패킷을 생성하여 netX 90으로 전송합니다. netX 90의 펌웨어는 이 패킷을 수신하여 해석하고, 요청된 작업을 수행합니다.

## 2. 코드 구조

MMIO 제어 로직은 재사용성과 모듈화를 위해 두 개의 파일로 분리되었습니다.

*   `mmio_control.h`: MMIO 제어에 필요한 구조체(`DIO_SET_LINE_CONFIG_REQ`, `DIO_SET_LINE_STATE_REQ`)와 함수 프로토타입(`SetMMIO7AsOutput`, `SetMMIO7State`)을 정의합니다.
*   `mmio_control.c`: 실제 패킷을 생성하고 전송하는 함수의 구현이 포함되어 있습니다.

--- 

## 3. 초기화 단계: MMIO7을 출력으로 설정

애플리케이션이 시작되면, 가장 먼저 MMIO7 핀을 **출력(Output) 모드**로 설정해야 합니다. 이 작업은 `SetMMIO7AsOutput` 함수에서 수행됩니다.

#### `SetMMIO7AsOutput` 함수 동작 분석

이 함수는 `DIO_SET_LINE_CONFIG_REQ` 타입의 패킷을 전송하여 MMIO의 동작 모드를 설정합니다.

```c
// mmio_control.c
int32_t SetMMIO7AsOutput(CIFXHANDLE hChannel)
{
    DIO_SET_LINE_CONFIG_REQ tCfg;
    memset(&tCfg, 0, sizeof(tCfg));

    // 1. 패킷 헤더 설정
    tCfg.tHeader.ulDest = 0x20;                // 대상: DIO 처리 장치
    tCfg.tHeader.ulCmd  = 0xB1;                // 커맨드: DIO_SET_LINE_CONFIG
    tCfg.tHeader.ulLen  = sizeof(tCfg) - sizeof(tCfg.tHeader);

    // 2. 패킷 데이터 설정
    tCfg.ulLine         = 7;                   // 라인: MMIO 7번
    tCfg.ulType         = DRV_DIO_LINE_MMIO;   // 타입: MMIO
    tCfg.ulFlags        = 0;                   // 플래그: 0은 출력 모드를 의미

    // 3. 패킷 전송
    int32_t lRet = xChannelPutPacket(hChannel, (CIFX_PACKET*)&tCfg, 1000);
    
    return lRet;
}
```

*   **`tCfg.tHeader` (패킷 헤더)**
    *   `ulDest` (0x20): 이 패킷을 처리할 netX 펌웨어 내의 목적지 주소입니다. `0x20`은 DIO 관련 기능을 처리하는 모듈을 가리킵니다.
    *   `ulCmd` (0xB1): 수행할 작업을 나타내는 커맨드입니다. `0xB1`은 `DIO_SET_LINE_CONFIG`로, 특정 라인의 모드를 설정하라는 의미입니다.
    *   `ulLen`: 헤더를 제외한 순수 데이터의 길이입니다.
*   **`tCfg` (패킷 데이터)**
    *   `ulLine` (7): 제어할 라인의 번호입니다. 여기서는 MMIO7을 의미합니다.
    *   `ulType` (`DRV_DIO_LINE_MMIO`): 제어할 라인의 종류가 MMIO임을 명시합니다.
    *   `ulFlags` (0): 라인의 세부 설정을 위한 플래그입니다. 이 경우 `0`은 **출력 모드**를 의미합니다. (입력으로 설정하려면 다른 값이 필요할 수 있습니다.)
*   **`xChannelPutPacket`**: 설정된 패킷 `tCfg`를 `cifX` 채널을 통해 netX 90으로 전송합니다.

--- 

## 4. 실행 단계: MMIO7 상태 변경 (HIGH/LOW)

핀이 출력으로 설정된 후, `SetMMIO7State` 함수를 호출하여 핀의 전압 상태를 HIGH 또는 LOW로 변경할 수 있습니다.

#### `SetMMIO7State` 함수 동작 분석

이 함수는 `DIO_SET_LINE_STATE_REQ` 타입의 패킷을 전송하여 핀의 상태를 변경합니다.

```c
// mmio_control.c
int32_t SetMMIO7State(CIFXHANDLE hChannel, bool fHigh)
{
    DIO_SET_LINE_STATE_REQ tReq;
    memset(&tReq, 0, sizeof(tReq));

    // 1. 패킷 헤더 설정
    tReq.tHeader.ulDest = 0x20;                // 대상: DIO 처리 장치
    tReq.tHeader.ulCmd  = 0xB2;                // 커맨드: DIO_SET_LINE_STATE
    tReq.tHeader.ulLen  = sizeof(tReq) - sizeof(tReq.tHeader);

    // 2. 패킷 데이터 설정
    tReq.ulLine         = 7;                   // 라인: MMIO 7번
    tReq.ulType         = DRV_DIO_LINE_MMIO;   // 타입: MMIO
    tReq.ulState        = fHigh ? 1 : 0;       // 상태: HIGH(1) 또는 LOW(0)

    // 3. 패킷 전송
    int32_t lRet = xChannelPutPacket(hChannel, (CIFX_PACKET*)&tReq, 1000);

    return lRet;
}
```

*   **`tReq.tHeader` (패킷 헤더)**
    *   `ulCmd` (0xB2): `DIO_SET_LINE_STATE` 커맨드로, 특정 라인의 상태를 변경하라는 의미입니다.
*   **`tReq` (패킷 데이터)**
    *   `ulState`: 변경할 상태를 지정합니다. `fHigh` 파라미터 값에 따라 `1`(HIGH) 또는 `0`(LOW)이 설정됩니다.

## 5. 애플리케이션 실행 흐름

`App_DemoApplication.c`의 `App_CifXApplicationDemo` 함수에서 전체적인 흐름이 조율됩니다.

1.  **초기화**: `cifX` 드라이버와 채널이 열리고, 모든 설정이 완료됩니다.
2.  **MMIO 출력 설정**: `SetMMIO7AsOutput()`이 **단 한 번** 호출되어 MMIO7 핀을 출력 모드로 영구 설정합니다.
3.  **무한 루프 진입**: `while` 루프에 진입하여 주기적인 작업을 수행합니다.
4.  **MMIO 토글**: 루프 내에서 `SetMMIO7State()` 함수가 `OS_Sleep(500)`과 함께 반복적으로 호출됩니다.
    *   `fMMIO7High` 변수가 `true`와 `false`를 번갈아 가며 `SetMMIO7State` 함수에 전달됩니다.
    *   이로 인해 MMIO7의 출력이 500ms 주기로 HIGH와 LOW 상태를 반복하게 됩니다.

```c
// App_DemoApplication.c 의 메인 루프

  bool fMMIO7High = false;

  /** now the bus is running */
  while(g_tAppData.fRunning && lRet == CIFX_NO_ERROR)
  {
    // ... 다른 핸들러들 ...

    // MMIO7 상태 변경 요청
    if (CIFX_NO_ERROR != (lRet = SetMMIO7State(g_tAppData.aptChannels[0]->hChannel, fMMIO7High)))
    {
        // 에러 처리
    }

    // 다음 상태를 위해 변수 토글
    fMMIO7High = !fMMIO7High;

    // 500ms 대기
    OS_Sleep(500);
  }
```
