# COM-flag 통신 유지 문제 분석

**작성일시**: 2025-10-29
**문제**: VAT 테스트 후 "COM-flag not set" 에러 발생
**원인**: 테스트 종료 시 통신 채널 및 드라이버 강제 종료

---

## 1. 문제 요약

### 🔴 현상
- VAT 테스트 완료 후 DeviceNet 통신 불가
- `CIFX_DEV_NO_COM_FLAG (0x80000003)` 에러 발생
- 기존 최초 코드에서는 계속 송수신 가능 상태 유지됨

### 🎯 핵심 원인
**테스트 종료 시 통신 리소스를 deinitialize하여 채널이 닫힘**

---

## 2. 코드 비교 분석

### ❌ 현재 코드 (문제 있는 구조)

**파일**: `Core/Src/main.c:635-739`

```c
if(g_bEnableVatTest)
{
    /* VAT 테스트 모드 */
    CIFXHANDLE hDriver = NULL;
    CIFXHANDLE hChannel = NULL;

    /* VAT 테스트 초기화 */
    VAT_InitializeTest();

    /* cifX 드라이버 열기 */
    lRet = xDriverOpen(&hDriver);
    if(CIFX_NO_ERROR == lRet)
    {
        /* 채널 0 열기 */
        lRet = xChannelOpen(hDriver, "cifX0", 0, &hChannel);
        if(CIFX_NO_ERROR == lRet)
        {
            /* 채널 준비 대기 */
            // ... (채널 준비 대기 로직)

            /* VAT 테스트 실행 */
            VAT_RunTest(hChannel);

            /* ⚠️ 문제 발생 지점 1: 채널 닫기 */
            xChannelClose(hChannel);        // 라인 713
        }

        /* ⚠️ 문제 발생 지점 2: 드라이버 닫기 */
        xDriverClose(hDriver);              // 라인 721
    }

    /* ⚠️ 문제 발생 지점 3: 테스트 컨텍스트 정리 */
    VAT_Test_Deinit(&g_tVatContext);        // 라인 729
}

/* 이후 무한 루프 */
while (1)
{
    MX_USB_HOST_Process();
    /* 통신 불가! 채널과 드라이버가 닫혀있음 */
}
```

### ✅ 기존 최초 코드 (정상 작동 구조)

**추정되는 구조**:

```c
/* cifX 드라이버 및 채널 열기 (전역 또는 main 시작 시) */
CIFXHANDLE g_hDriver = NULL;
CIFXHANDLE g_hChannel = NULL;

int main(void)
{
    /* ... 초기화 ... */

    /* cifX 드라이버 열기 */
    lRet = xDriverOpen(&g_hDriver);
    if(CIFX_NO_ERROR == lRet)
    {
        /* 채널 0 열기 */
        lRet = xChannelOpen(g_hDriver, "cifX0", 0, &g_hChannel);
        if(CIFX_NO_ERROR == lRet)
        {
            /* 채널 준비 대기 */
            // ...

            if(g_bEnableVatTest)
            {
                /* VAT 테스트 실행 */
                VAT_RunTest(g_hChannel);

                /* ✅ 차이점: 채널과 드라이버를 닫지 않음! */
                /* xChannelClose(g_hChannel);   ← 호출하지 않음 */
                /* xDriverClose(g_hDriver);     ← 호출하지 않음 */
            }
        }
    }

    /* 무한 루프 */
    while (1)
    {
        MX_USB_HOST_Process();

        /* ✅ 계속 통신 가능! 채널이 열린 상태 유지 */
        if (need_communication)
        {
            VAT_Test_ReadInput(&g_tVatContext, g_hChannel);
            VAT_Test_WriteOutput(&g_tVatContext, g_hChannel);
        }
    }
}
```

---

## 3. 차이점 상세 분석

### 📊 비교표

| 항목 | 현재 코드 (문제) | 기존 최초 코드 (정상) |
|------|------------------|----------------------|
| **채널 핸들 범위** | 로컬 변수 (if문 블록 내) | 전역 또는 main 함수 범위 |
| **채널 생명주기** | 테스트 실행 → 즉시 종료 | 프로그램 시작 → 프로그램 종료 |
| **xChannelClose 호출** | ✅ 호출함 (라인 713) | ❌ 호출 안 함 |
| **xDriverClose 호출** | ✅ 호출함 (라인 721) | ❌ 호출 안 함 |
| **VAT_Test_Deinit 호출** | ✅ 호출함 (라인 729) | ⚠️ 선택적 호출 |
| **무한 루프 내 통신** | ❌ 불가능 (채널 닫힘) | ✅ 가능 (채널 열림 유지) |
| **COM-flag 상태** | 🔴 Not Set (0x80000003) | 🟢 Ready (0x00000001) |

---

## 4. 문제 발생 메커니즘

### 🔄 현재 코드의 실행 흐름

```
1. main() 시작
   ↓
2. VAT 테스트 활성화 확인 (g_bEnableVatTest == true)
   ↓
3. xDriverOpen(&hDriver) ← 드라이버 오픈
   ↓
4. xChannelOpen(..., &hChannel) ← 채널 오픈
   ↓
5. 채널 준비 대기 (HIL_COMM_COS_READY)
   ↓
6. VAT_RunTest(hChannel) ← 테스트 실행
   ↓
7. ⚠️ xChannelClose(hChannel) ← 채널 닫기
   ↓
8. ⚠️ xDriverClose(hDriver) ← 드라이버 닫기
   ↓
9. ⚠️ VAT_Test_Deinit() ← 컨텍스트 정리
   ↓
10. while(1) 무한 루프 진입
    ↓
11. ❌ 통신 시도 → COM-flag not set 에러!
    └─ 이유: 채널과 드라이버가 이미 닫혀있음
```

### 📌 COM-flag가 설정되지 않는 이유

```c
/* xChannelIORead/Write 내부 동작 */
int32_t xChannelIORead(CIFXHANDLE hChannel, ...)
{
    /* 1. 채널 핸들 유효성 확인 */
    if (!IsValidChannel(hChannel))
        return CIFX_INVALID_HANDLE;

    /* 2. COM-flag 확인 */
    if (!IsCommunicationReady(hChannel))
        return CIFX_DEV_NO_COM_FLAG;  // ← 여기서 에러 발생!

    /* 3. 실제 데이터 읽기/쓰기 */
    // ...
}
```

**채널이 닫힌 후:**
- `hChannel` 핸들이 무효화됨
- 또는 채널 상태가 "CLOSED"로 변경됨
- → `IsCommunicationReady()` 검사 실패
- → `CIFX_DEV_NO_COM_FLAG (0x80000003)` 반환

---

## 5. 해결 방안

### ✅ 방안 1: 채널 및 드라이버 유지 (권장)

**수정 위치**: `Core/Src/main.c:635-739`

#### 5.1. 전역 핸들 선언

```c
/* USER CODE BEGIN PV */
/* Private variables ---------------------------------------------------------*/
static CIFXHANDLE g_hDriver = NULL;   /* cifX 드라이버 핸들 */
static CIFXHANDLE g_hChannel = NULL;  /* cifX 채널 핸들 */
/* USER CODE END PV */
```

#### 5.2. main() 함수 수정

```c
int main(void)
{
    /* ... 초기화 코드 ... */

    lRet = InitializeToolkit();

    if(CIFX_NO_ERROR == lRet)
    {
        /* cifX 드라이버 열기 */
        lRet = xDriverOpen(&g_hDriver);
        if(CIFX_NO_ERROR == lRet)
        {
            /* 채널 0 열기 */
            lRet = xChannelOpen(g_hDriver, "cifX0", 0, &g_hChannel);
            if(CIFX_NO_ERROR == lRet)
            {
                /* 채널 준비 대기 */
                CHANNEL_INFORMATION tChannelInfo;
                // ... (기존 채널 준비 대기 코드)

                if(lRet == CIFX_NO_ERROR)
                {
                    printf("\r\n*** Channel ready! ***\r\n");

                    /* 디바이스 정보 출력 */
                    PrintDeviceInformation(g_hDriver, g_hChannel);

                    if(g_bEnableVatTest)
                    {
                        /* VAT 테스트 초기화 */
                        VAT_InitializeTest();

                        /* VAT 테스트 실행 */
                        VAT_RunTest(g_hChannel);

                        /* ✅ 수정: 채널/드라이버 닫지 않음 */
                        // xChannelClose(g_hChannel);   ← 제거
                        // xDriverClose(g_hDriver);     ← 제거

                        /* ⚠️ 선택: Deinit도 제거하거나 수정 */
                        // VAT_Test_Deinit(&g_tVatContext);  ← 선택적 제거

                        printf("\r\n*** VAT Test completed - Channel remains open ***\r\n");
                    }
                    else
                    {
                        /* 기존 App 실행 */
                        lRet = App_CifXApplicationDemo("cifX0");
                    }
                }
            }
            else
            {
                printf("ERROR: xChannelOpen failed: 0x%08X\r\n", (unsigned int)lRet);
            }
        }
        else
        {
            printf("ERROR: xDriverOpen failed: 0x%08X\r\n", (unsigned int)lRet);
        }
    }

    /* 무한 루프 */
    while (1)
    {
        MX_USB_HOST_Process();

        /* ✅ 이제 여기서 통신 가능! */
        if (g_hChannel != NULL)
        {
            // 주기적인 통신 작업 수행 가능
        }
    }
}
```

### ✅ 방안 2: VAT_Test_Deinit 수정

**파일**: `Hil_DemoApp/Sources/vat_devicenet_test.c:112-121`

**현재 코드**:
```c
void VAT_Test_Deinit(VAT_TEST_CONTEXT_T* ptContext)
{
    if (ptContext == NULL)
        return;

    ptContext->test_running = false;

    LOG_PRINTF("[VAT Test] Deinitialized\n");
    VAT_Test_PrintStats(ptContext);
}
```

**수정 제안**:
```c
void VAT_Test_Deinit(VAT_TEST_CONTEXT_T* ptContext)
{
    if (ptContext == NULL)
        return;

    /* ⚠️ 중요: test_running 플래그만 false로 설정 */
    /* 통신 채널은 닫지 않음! */
    ptContext->test_running = false;

    /* 통계 출력 */
    LOG_PRINTF("[VAT Test] Test stopped - Communication remains active\n");
    VAT_Test_PrintStats(ptContext);

    /* 통계 초기화는 선택적 */
    // VAT_Test_ResetStats(ptContext);  // 필요시 활성화
}
```

---

## 6. 권장 수정 사항

### 🎯 최소 변경 수정안

**파일**: `Core/Src/main.c`

#### 수정 전 (라인 712-729)
```c
                  /* 채널 닫기 */
                  xChannelClose(hChannel);              // 라인 713
              }
              else
              {
                  printf("ERROR: xChannelOpen failed: 0x%08X\r\n", (unsigned int)lRet);
              }

              /* 드라이버 닫기 */
              xDriverClose(hDriver);                    // 라인 721
          }
          else
          {
              printf("ERROR: xDriverOpen failed: 0x%08X\r\n", (unsigned int)lRet);
          }

          /* 테스트 종료 */
          VAT_Test_Deinit(&g_tVatContext);              // 라인 729
```

#### 수정 후
```c
                  /* ✅ 수정: 채널은 닫지 않고 유지 */
                  printf("\r\n*** VAT Test completed - keeping channel open for continuous operation ***\r\n");
                  // xChannelClose(hChannel);  ← 주석 처리
              }
              else
              {
                  printf("ERROR: xChannelOpen failed: 0x%08X\r\n", (unsigned int)lRet);
              }

              /* ✅ 수정: 드라이버도 닫지 않고 유지 */
              // xDriverClose(hDriver);  ← 주석 처리
          }
          else
          {
              printf("ERROR: xDriverOpen failed: 0x%08X\r\n", (unsigned int)lRet);
          }

          /* ✅ 수정: 통계 출력만 수행하고 채널은 유지 */
          printf("\r\n========== VAT Test Statistics ==========\r\n");
          VAT_Test_PrintStats(&g_tVatContext);
          printf("Communication channel remains active.\r\n");
          printf("=========================================\r\n\r\n");
          // VAT_Test_Deinit(&g_tVatContext);  ← 주석 처리 또는 수정
```

---

## 7. 추가 권장 사항

### 💡 무한 루프 내 주기적 통신 추가

```c
/* USER CODE BEGIN 3 */

/* 선택적: 주기적으로 VAT 장치와 통신 */
static uint32_t last_vat_update = 0;

if (g_hChannel != NULL && g_bEnableVatTest)
{
    uint32_t current_time = HAL_GetTick();

    /* 100ms마다 VAT 통신 수행 */
    if ((current_time - last_vat_update) >= 100)
    {
        last_vat_update = current_time;

        /* VAT 데이터 읽기/쓰기 */
        VAT_Test_WriteOutput(&g_tVatContext, g_hChannel);
        VAT_Test_ReadInput(&g_tVatContext, g_hChannel);
    }
}

/* USER CODE END 3 */
```

### 🔧 전역 변수 추가

```c
/* USER CODE BEGIN PV */

/* cifX 통신 핸들 - 전역으로 선언하여 프로그램 전체에서 접근 가능 */
static CIFXHANDLE g_hDriver = NULL;
static CIFXHANDLE g_hChannel = NULL;

/* 통신 상태 플래그 */
volatile bool g_bCommunicationActive = false;

/* USER CODE END PV */
```

---

## 8. 테스트 체크리스트

### ✅ 수정 후 확인 사항

- [ ] 빌드 성공 (에러 없음)
- [ ] VAT 테스트 실행 성공
- [ ] 테스트 후 COM-flag 에러 없음
- [ ] 무한 루프 내에서 계속 통신 가능
- [ ] 채널 상태 유지 확인 (`g_hChannel != NULL`)
- [ ] 드라이버 상태 유지 확인 (`g_hDriver != NULL`)
- [ ] 주기적 읽기/쓰기 동작 확인

### 📊 예상 출력

```
========================================
 VAT DeviceNet Test Initialization
========================================
VAT Test Configuration:
  Mode: 1
  Node Address: 10
  Baud Rate: 250000 bps
========================================

Waiting for channel ready...
  [0 s] COS Flags: 0x00000001

*** Channel ready! ***
  COS Flags: 0x00000001
  Time taken: 0 seconds

========================================
 Running VAT Test Mode: 1
========================================
Test: Basic Pressure Control
Cycles: 10
Setpoint: 500

[VAT Output 0x07] Setpoint=500, Instance=0
[VAT Input 0x02] Exception=0x00, Pressure=498
...

========== VAT Test Statistics ==========
Total Read Operations:   10
Total Write Operations:  10
Read Errors:             0
Write Errors:            0
=========================================

*** VAT Test completed - keeping channel open for continuous operation ***
Communication channel remains active.

/* ✅ 이후 무한 루프에서도 계속 통신 가능 */
```

---

## 9. 요약

### 🎯 핵심 차이점

| 상황 | 기존 최초 코드 | 현재 문제 코드 |
|------|---------------|---------------|
| **통신 채널 관리** | 프로그램 시작 시 열고 종료 시까지 유지 | 테스트 시작 시 열고 테스트 종료 시 닫음 |
| **채널 생명주기** | 전체 프로그램 실행 기간 | VAT 테스트 실행 기간만 |
| **통신 가능 시점** | 채널 오픈 후 프로그램 종료까지 | VAT 테스트 중에만 |
| **COM-flag 상태** | 항상 Ready | 테스트 후 Not Set |
| **무한 루프 통신** | ✅ 가능 | ❌ 불가능 |

### ✅ 해결 방법

1. **`xChannelClose(hChannel)` 제거** (라인 713)
2. **`xDriverClose(hDriver)` 제거** (라인 721)
3. **`VAT_Test_Deinit()` 수정 또는 제거** (라인 729)
4. **전역 핸들 사용** (선택적, 더 깔끔한 구조)

### 💡 핵심 원칙

> **"통신 채널은 한 번 열면 프로그램이 끝날 때까지 열린 상태로 유지해야 한다"**

이 원칙을 지키면 COM-flag 에러 없이 계속해서 DeviceNet 통신이 가능합니다.

---

**문서 끝**
