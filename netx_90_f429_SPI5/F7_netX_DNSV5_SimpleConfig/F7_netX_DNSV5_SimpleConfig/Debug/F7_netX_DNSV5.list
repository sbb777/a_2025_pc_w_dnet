
F7_netX_DNSV5.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001f8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000a554  08000200  08000200  00010200  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00002724  0800a754  0800a754  0001a754  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800ce78  0800ce78  00020098  2**0
                  CONTENTS
  4 .ARM          00000008  0800ce78  0800ce78  0001ce78  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0800ce80  0800ce80  00020098  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800ce80  0800ce80  0001ce80  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0800ce84  0800ce84  0001ce84  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000098  20000000  0800ce88  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000002d4  20000098  0800cf20  00020098  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000036c  0800cf20  0002036c  2**0
                  ALLOC
 11 .ARM.attributes 0000002e  00000000  00000000  00020098  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  000200c6  2**0
                  CONTENTS, READONLY
 13 .debug_info   000309a5  00000000  00000000  00020109  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00005440  00000000  00000000  00050aae  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loclists 0000f1de  00000000  00000000  00055eee  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00001258  00000000  00000000  000650d0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 000012a9  00000000  00000000  00066328  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0002e9dd  00000000  00000000  000675d1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   0001f6f7  00000000  00000000  00095fae  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    00112d51  00000000  00000000  000b56a5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_frame  00004094  00000000  00000000  001c83f8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 0000007f  00000000  00000000  001cc48c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000200 <__do_global_dtors_aux>:
 8000200:	b510      	push	{r4, lr}
 8000202:	4c05      	ldr	r4, [pc, #20]	; (8000218 <__do_global_dtors_aux+0x18>)
 8000204:	7823      	ldrb	r3, [r4, #0]
 8000206:	b933      	cbnz	r3, 8000216 <__do_global_dtors_aux+0x16>
 8000208:	4b04      	ldr	r3, [pc, #16]	; (800021c <__do_global_dtors_aux+0x1c>)
 800020a:	b113      	cbz	r3, 8000212 <__do_global_dtors_aux+0x12>
 800020c:	4804      	ldr	r0, [pc, #16]	; (8000220 <__do_global_dtors_aux+0x20>)
 800020e:	f3af 8000 	nop.w
 8000212:	2301      	movs	r3, #1
 8000214:	7023      	strb	r3, [r4, #0]
 8000216:	bd10      	pop	{r4, pc}
 8000218:	20000098 	.word	0x20000098
 800021c:	00000000 	.word	0x00000000
 8000220:	0800a73c 	.word	0x0800a73c

08000224 <frame_dummy>:
 8000224:	b508      	push	{r3, lr}
 8000226:	4b03      	ldr	r3, [pc, #12]	; (8000234 <frame_dummy+0x10>)
 8000228:	b11b      	cbz	r3, 8000232 <frame_dummy+0xe>
 800022a:	4903      	ldr	r1, [pc, #12]	; (8000238 <frame_dummy+0x14>)
 800022c:	4803      	ldr	r0, [pc, #12]	; (800023c <frame_dummy+0x18>)
 800022e:	f3af 8000 	nop.w
 8000232:	bd08      	pop	{r3, pc}
 8000234:	00000000 	.word	0x00000000
 8000238:	2000009c 	.word	0x2000009c
 800023c:	0800a73c 	.word	0x0800a73c

08000240 <strcmp>:
 8000240:	f810 2b01 	ldrb.w	r2, [r0], #1
 8000244:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000248:	2a01      	cmp	r2, #1
 800024a:	bf28      	it	cs
 800024c:	429a      	cmpcs	r2, r3
 800024e:	d0f7      	beq.n	8000240 <strcmp>
 8000250:	1ad0      	subs	r0, r2, r3
 8000252:	4770      	bx	lr

08000254 <strlen>:
 8000254:	4603      	mov	r3, r0
 8000256:	f813 2b01 	ldrb.w	r2, [r3], #1
 800025a:	2a00      	cmp	r2, #0
 800025c:	d1fb      	bne.n	8000256 <strlen+0x2>
 800025e:	1a18      	subs	r0, r3, r0
 8000260:	3801      	subs	r0, #1
 8000262:	4770      	bx	lr
	...

08000270 <memchr>:
 8000270:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000274:	2a10      	cmp	r2, #16
 8000276:	db2b      	blt.n	80002d0 <memchr+0x60>
 8000278:	f010 0f07 	tst.w	r0, #7
 800027c:	d008      	beq.n	8000290 <memchr+0x20>
 800027e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000282:	3a01      	subs	r2, #1
 8000284:	428b      	cmp	r3, r1
 8000286:	d02d      	beq.n	80002e4 <memchr+0x74>
 8000288:	f010 0f07 	tst.w	r0, #7
 800028c:	b342      	cbz	r2, 80002e0 <memchr+0x70>
 800028e:	d1f6      	bne.n	800027e <memchr+0xe>
 8000290:	b4f0      	push	{r4, r5, r6, r7}
 8000292:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000296:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800029a:	f022 0407 	bic.w	r4, r2, #7
 800029e:	f07f 0700 	mvns.w	r7, #0
 80002a2:	2300      	movs	r3, #0
 80002a4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 80002a8:	3c08      	subs	r4, #8
 80002aa:	ea85 0501 	eor.w	r5, r5, r1
 80002ae:	ea86 0601 	eor.w	r6, r6, r1
 80002b2:	fa85 f547 	uadd8	r5, r5, r7
 80002b6:	faa3 f587 	sel	r5, r3, r7
 80002ba:	fa86 f647 	uadd8	r6, r6, r7
 80002be:	faa5 f687 	sel	r6, r5, r7
 80002c2:	b98e      	cbnz	r6, 80002e8 <memchr+0x78>
 80002c4:	d1ee      	bne.n	80002a4 <memchr+0x34>
 80002c6:	bcf0      	pop	{r4, r5, r6, r7}
 80002c8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80002cc:	f002 0207 	and.w	r2, r2, #7
 80002d0:	b132      	cbz	r2, 80002e0 <memchr+0x70>
 80002d2:	f810 3b01 	ldrb.w	r3, [r0], #1
 80002d6:	3a01      	subs	r2, #1
 80002d8:	ea83 0301 	eor.w	r3, r3, r1
 80002dc:	b113      	cbz	r3, 80002e4 <memchr+0x74>
 80002de:	d1f8      	bne.n	80002d2 <memchr+0x62>
 80002e0:	2000      	movs	r0, #0
 80002e2:	4770      	bx	lr
 80002e4:	3801      	subs	r0, #1
 80002e6:	4770      	bx	lr
 80002e8:	2d00      	cmp	r5, #0
 80002ea:	bf06      	itte	eq
 80002ec:	4635      	moveq	r5, r6
 80002ee:	3803      	subeq	r0, #3
 80002f0:	3807      	subne	r0, #7
 80002f2:	f015 0f01 	tst.w	r5, #1
 80002f6:	d107      	bne.n	8000308 <memchr+0x98>
 80002f8:	3001      	adds	r0, #1
 80002fa:	f415 7f80 	tst.w	r5, #256	; 0x100
 80002fe:	bf02      	ittt	eq
 8000300:	3001      	addeq	r0, #1
 8000302:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000306:	3001      	addeq	r0, #1
 8000308:	bcf0      	pop	{r4, r5, r6, r7}
 800030a:	3801      	subs	r0, #1
 800030c:	4770      	bx	lr
 800030e:	bf00      	nop

08000310 <__aeabi_uldivmod>:
 8000310:	b953      	cbnz	r3, 8000328 <__aeabi_uldivmod+0x18>
 8000312:	b94a      	cbnz	r2, 8000328 <__aeabi_uldivmod+0x18>
 8000314:	2900      	cmp	r1, #0
 8000316:	bf08      	it	eq
 8000318:	2800      	cmpeq	r0, #0
 800031a:	bf1c      	itt	ne
 800031c:	f04f 31ff 	movne.w	r1, #4294967295
 8000320:	f04f 30ff 	movne.w	r0, #4294967295
 8000324:	f000 b970 	b.w	8000608 <__aeabi_idiv0>
 8000328:	f1ad 0c08 	sub.w	ip, sp, #8
 800032c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000330:	f000 f806 	bl	8000340 <__udivmoddi4>
 8000334:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000338:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800033c:	b004      	add	sp, #16
 800033e:	4770      	bx	lr

08000340 <__udivmoddi4>:
 8000340:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000344:	9e08      	ldr	r6, [sp, #32]
 8000346:	460d      	mov	r5, r1
 8000348:	4604      	mov	r4, r0
 800034a:	460f      	mov	r7, r1
 800034c:	2b00      	cmp	r3, #0
 800034e:	d14a      	bne.n	80003e6 <__udivmoddi4+0xa6>
 8000350:	428a      	cmp	r2, r1
 8000352:	4694      	mov	ip, r2
 8000354:	d965      	bls.n	8000422 <__udivmoddi4+0xe2>
 8000356:	fab2 f382 	clz	r3, r2
 800035a:	b143      	cbz	r3, 800036e <__udivmoddi4+0x2e>
 800035c:	fa02 fc03 	lsl.w	ip, r2, r3
 8000360:	f1c3 0220 	rsb	r2, r3, #32
 8000364:	409f      	lsls	r7, r3
 8000366:	fa20 f202 	lsr.w	r2, r0, r2
 800036a:	4317      	orrs	r7, r2
 800036c:	409c      	lsls	r4, r3
 800036e:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 8000372:	fa1f f58c 	uxth.w	r5, ip
 8000376:	fbb7 f1fe 	udiv	r1, r7, lr
 800037a:	0c22      	lsrs	r2, r4, #16
 800037c:	fb0e 7711 	mls	r7, lr, r1, r7
 8000380:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 8000384:	fb01 f005 	mul.w	r0, r1, r5
 8000388:	4290      	cmp	r0, r2
 800038a:	d90a      	bls.n	80003a2 <__udivmoddi4+0x62>
 800038c:	eb1c 0202 	adds.w	r2, ip, r2
 8000390:	f101 37ff 	add.w	r7, r1, #4294967295
 8000394:	f080 811c 	bcs.w	80005d0 <__udivmoddi4+0x290>
 8000398:	4290      	cmp	r0, r2
 800039a:	f240 8119 	bls.w	80005d0 <__udivmoddi4+0x290>
 800039e:	3902      	subs	r1, #2
 80003a0:	4462      	add	r2, ip
 80003a2:	1a12      	subs	r2, r2, r0
 80003a4:	b2a4      	uxth	r4, r4
 80003a6:	fbb2 f0fe 	udiv	r0, r2, lr
 80003aa:	fb0e 2210 	mls	r2, lr, r0, r2
 80003ae:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80003b2:	fb00 f505 	mul.w	r5, r0, r5
 80003b6:	42a5      	cmp	r5, r4
 80003b8:	d90a      	bls.n	80003d0 <__udivmoddi4+0x90>
 80003ba:	eb1c 0404 	adds.w	r4, ip, r4
 80003be:	f100 32ff 	add.w	r2, r0, #4294967295
 80003c2:	f080 8107 	bcs.w	80005d4 <__udivmoddi4+0x294>
 80003c6:	42a5      	cmp	r5, r4
 80003c8:	f240 8104 	bls.w	80005d4 <__udivmoddi4+0x294>
 80003cc:	4464      	add	r4, ip
 80003ce:	3802      	subs	r0, #2
 80003d0:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 80003d4:	1b64      	subs	r4, r4, r5
 80003d6:	2100      	movs	r1, #0
 80003d8:	b11e      	cbz	r6, 80003e2 <__udivmoddi4+0xa2>
 80003da:	40dc      	lsrs	r4, r3
 80003dc:	2300      	movs	r3, #0
 80003de:	e9c6 4300 	strd	r4, r3, [r6]
 80003e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003e6:	428b      	cmp	r3, r1
 80003e8:	d908      	bls.n	80003fc <__udivmoddi4+0xbc>
 80003ea:	2e00      	cmp	r6, #0
 80003ec:	f000 80ed 	beq.w	80005ca <__udivmoddi4+0x28a>
 80003f0:	2100      	movs	r1, #0
 80003f2:	e9c6 0500 	strd	r0, r5, [r6]
 80003f6:	4608      	mov	r0, r1
 80003f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003fc:	fab3 f183 	clz	r1, r3
 8000400:	2900      	cmp	r1, #0
 8000402:	d149      	bne.n	8000498 <__udivmoddi4+0x158>
 8000404:	42ab      	cmp	r3, r5
 8000406:	d302      	bcc.n	800040e <__udivmoddi4+0xce>
 8000408:	4282      	cmp	r2, r0
 800040a:	f200 80f8 	bhi.w	80005fe <__udivmoddi4+0x2be>
 800040e:	1a84      	subs	r4, r0, r2
 8000410:	eb65 0203 	sbc.w	r2, r5, r3
 8000414:	2001      	movs	r0, #1
 8000416:	4617      	mov	r7, r2
 8000418:	2e00      	cmp	r6, #0
 800041a:	d0e2      	beq.n	80003e2 <__udivmoddi4+0xa2>
 800041c:	e9c6 4700 	strd	r4, r7, [r6]
 8000420:	e7df      	b.n	80003e2 <__udivmoddi4+0xa2>
 8000422:	b902      	cbnz	r2, 8000426 <__udivmoddi4+0xe6>
 8000424:	deff      	udf	#255	; 0xff
 8000426:	fab2 f382 	clz	r3, r2
 800042a:	2b00      	cmp	r3, #0
 800042c:	f040 8090 	bne.w	8000550 <__udivmoddi4+0x210>
 8000430:	1a8a      	subs	r2, r1, r2
 8000432:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000436:	fa1f fe8c 	uxth.w	lr, ip
 800043a:	2101      	movs	r1, #1
 800043c:	fbb2 f5f7 	udiv	r5, r2, r7
 8000440:	fb07 2015 	mls	r0, r7, r5, r2
 8000444:	0c22      	lsrs	r2, r4, #16
 8000446:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 800044a:	fb0e f005 	mul.w	r0, lr, r5
 800044e:	4290      	cmp	r0, r2
 8000450:	d908      	bls.n	8000464 <__udivmoddi4+0x124>
 8000452:	eb1c 0202 	adds.w	r2, ip, r2
 8000456:	f105 38ff 	add.w	r8, r5, #4294967295
 800045a:	d202      	bcs.n	8000462 <__udivmoddi4+0x122>
 800045c:	4290      	cmp	r0, r2
 800045e:	f200 80cb 	bhi.w	80005f8 <__udivmoddi4+0x2b8>
 8000462:	4645      	mov	r5, r8
 8000464:	1a12      	subs	r2, r2, r0
 8000466:	b2a4      	uxth	r4, r4
 8000468:	fbb2 f0f7 	udiv	r0, r2, r7
 800046c:	fb07 2210 	mls	r2, r7, r0, r2
 8000470:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8000474:	fb0e fe00 	mul.w	lr, lr, r0
 8000478:	45a6      	cmp	lr, r4
 800047a:	d908      	bls.n	800048e <__udivmoddi4+0x14e>
 800047c:	eb1c 0404 	adds.w	r4, ip, r4
 8000480:	f100 32ff 	add.w	r2, r0, #4294967295
 8000484:	d202      	bcs.n	800048c <__udivmoddi4+0x14c>
 8000486:	45a6      	cmp	lr, r4
 8000488:	f200 80bb 	bhi.w	8000602 <__udivmoddi4+0x2c2>
 800048c:	4610      	mov	r0, r2
 800048e:	eba4 040e 	sub.w	r4, r4, lr
 8000492:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 8000496:	e79f      	b.n	80003d8 <__udivmoddi4+0x98>
 8000498:	f1c1 0720 	rsb	r7, r1, #32
 800049c:	408b      	lsls	r3, r1
 800049e:	fa22 fc07 	lsr.w	ip, r2, r7
 80004a2:	ea4c 0c03 	orr.w	ip, ip, r3
 80004a6:	fa05 f401 	lsl.w	r4, r5, r1
 80004aa:	fa20 f307 	lsr.w	r3, r0, r7
 80004ae:	40fd      	lsrs	r5, r7
 80004b0:	ea4f 491c 	mov.w	r9, ip, lsr #16
 80004b4:	4323      	orrs	r3, r4
 80004b6:	fbb5 f8f9 	udiv	r8, r5, r9
 80004ba:	fa1f fe8c 	uxth.w	lr, ip
 80004be:	fb09 5518 	mls	r5, r9, r8, r5
 80004c2:	0c1c      	lsrs	r4, r3, #16
 80004c4:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 80004c8:	fb08 f50e 	mul.w	r5, r8, lr
 80004cc:	42a5      	cmp	r5, r4
 80004ce:	fa02 f201 	lsl.w	r2, r2, r1
 80004d2:	fa00 f001 	lsl.w	r0, r0, r1
 80004d6:	d90b      	bls.n	80004f0 <__udivmoddi4+0x1b0>
 80004d8:	eb1c 0404 	adds.w	r4, ip, r4
 80004dc:	f108 3aff 	add.w	sl, r8, #4294967295
 80004e0:	f080 8088 	bcs.w	80005f4 <__udivmoddi4+0x2b4>
 80004e4:	42a5      	cmp	r5, r4
 80004e6:	f240 8085 	bls.w	80005f4 <__udivmoddi4+0x2b4>
 80004ea:	f1a8 0802 	sub.w	r8, r8, #2
 80004ee:	4464      	add	r4, ip
 80004f0:	1b64      	subs	r4, r4, r5
 80004f2:	b29d      	uxth	r5, r3
 80004f4:	fbb4 f3f9 	udiv	r3, r4, r9
 80004f8:	fb09 4413 	mls	r4, r9, r3, r4
 80004fc:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 8000500:	fb03 fe0e 	mul.w	lr, r3, lr
 8000504:	45a6      	cmp	lr, r4
 8000506:	d908      	bls.n	800051a <__udivmoddi4+0x1da>
 8000508:	eb1c 0404 	adds.w	r4, ip, r4
 800050c:	f103 35ff 	add.w	r5, r3, #4294967295
 8000510:	d26c      	bcs.n	80005ec <__udivmoddi4+0x2ac>
 8000512:	45a6      	cmp	lr, r4
 8000514:	d96a      	bls.n	80005ec <__udivmoddi4+0x2ac>
 8000516:	3b02      	subs	r3, #2
 8000518:	4464      	add	r4, ip
 800051a:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800051e:	fba3 9502 	umull	r9, r5, r3, r2
 8000522:	eba4 040e 	sub.w	r4, r4, lr
 8000526:	42ac      	cmp	r4, r5
 8000528:	46c8      	mov	r8, r9
 800052a:	46ae      	mov	lr, r5
 800052c:	d356      	bcc.n	80005dc <__udivmoddi4+0x29c>
 800052e:	d053      	beq.n	80005d8 <__udivmoddi4+0x298>
 8000530:	b156      	cbz	r6, 8000548 <__udivmoddi4+0x208>
 8000532:	ebb0 0208 	subs.w	r2, r0, r8
 8000536:	eb64 040e 	sbc.w	r4, r4, lr
 800053a:	fa04 f707 	lsl.w	r7, r4, r7
 800053e:	40ca      	lsrs	r2, r1
 8000540:	40cc      	lsrs	r4, r1
 8000542:	4317      	orrs	r7, r2
 8000544:	e9c6 7400 	strd	r7, r4, [r6]
 8000548:	4618      	mov	r0, r3
 800054a:	2100      	movs	r1, #0
 800054c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000550:	f1c3 0120 	rsb	r1, r3, #32
 8000554:	fa02 fc03 	lsl.w	ip, r2, r3
 8000558:	fa20 f201 	lsr.w	r2, r0, r1
 800055c:	fa25 f101 	lsr.w	r1, r5, r1
 8000560:	409d      	lsls	r5, r3
 8000562:	432a      	orrs	r2, r5
 8000564:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000568:	fa1f fe8c 	uxth.w	lr, ip
 800056c:	fbb1 f0f7 	udiv	r0, r1, r7
 8000570:	fb07 1510 	mls	r5, r7, r0, r1
 8000574:	0c11      	lsrs	r1, r2, #16
 8000576:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 800057a:	fb00 f50e 	mul.w	r5, r0, lr
 800057e:	428d      	cmp	r5, r1
 8000580:	fa04 f403 	lsl.w	r4, r4, r3
 8000584:	d908      	bls.n	8000598 <__udivmoddi4+0x258>
 8000586:	eb1c 0101 	adds.w	r1, ip, r1
 800058a:	f100 38ff 	add.w	r8, r0, #4294967295
 800058e:	d22f      	bcs.n	80005f0 <__udivmoddi4+0x2b0>
 8000590:	428d      	cmp	r5, r1
 8000592:	d92d      	bls.n	80005f0 <__udivmoddi4+0x2b0>
 8000594:	3802      	subs	r0, #2
 8000596:	4461      	add	r1, ip
 8000598:	1b49      	subs	r1, r1, r5
 800059a:	b292      	uxth	r2, r2
 800059c:	fbb1 f5f7 	udiv	r5, r1, r7
 80005a0:	fb07 1115 	mls	r1, r7, r5, r1
 80005a4:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80005a8:	fb05 f10e 	mul.w	r1, r5, lr
 80005ac:	4291      	cmp	r1, r2
 80005ae:	d908      	bls.n	80005c2 <__udivmoddi4+0x282>
 80005b0:	eb1c 0202 	adds.w	r2, ip, r2
 80005b4:	f105 38ff 	add.w	r8, r5, #4294967295
 80005b8:	d216      	bcs.n	80005e8 <__udivmoddi4+0x2a8>
 80005ba:	4291      	cmp	r1, r2
 80005bc:	d914      	bls.n	80005e8 <__udivmoddi4+0x2a8>
 80005be:	3d02      	subs	r5, #2
 80005c0:	4462      	add	r2, ip
 80005c2:	1a52      	subs	r2, r2, r1
 80005c4:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
 80005c8:	e738      	b.n	800043c <__udivmoddi4+0xfc>
 80005ca:	4631      	mov	r1, r6
 80005cc:	4630      	mov	r0, r6
 80005ce:	e708      	b.n	80003e2 <__udivmoddi4+0xa2>
 80005d0:	4639      	mov	r1, r7
 80005d2:	e6e6      	b.n	80003a2 <__udivmoddi4+0x62>
 80005d4:	4610      	mov	r0, r2
 80005d6:	e6fb      	b.n	80003d0 <__udivmoddi4+0x90>
 80005d8:	4548      	cmp	r0, r9
 80005da:	d2a9      	bcs.n	8000530 <__udivmoddi4+0x1f0>
 80005dc:	ebb9 0802 	subs.w	r8, r9, r2
 80005e0:	eb65 0e0c 	sbc.w	lr, r5, ip
 80005e4:	3b01      	subs	r3, #1
 80005e6:	e7a3      	b.n	8000530 <__udivmoddi4+0x1f0>
 80005e8:	4645      	mov	r5, r8
 80005ea:	e7ea      	b.n	80005c2 <__udivmoddi4+0x282>
 80005ec:	462b      	mov	r3, r5
 80005ee:	e794      	b.n	800051a <__udivmoddi4+0x1da>
 80005f0:	4640      	mov	r0, r8
 80005f2:	e7d1      	b.n	8000598 <__udivmoddi4+0x258>
 80005f4:	46d0      	mov	r8, sl
 80005f6:	e77b      	b.n	80004f0 <__udivmoddi4+0x1b0>
 80005f8:	3d02      	subs	r5, #2
 80005fa:	4462      	add	r2, ip
 80005fc:	e732      	b.n	8000464 <__udivmoddi4+0x124>
 80005fe:	4608      	mov	r0, r1
 8000600:	e70a      	b.n	8000418 <__udivmoddi4+0xd8>
 8000602:	4464      	add	r4, ip
 8000604:	3802      	subs	r0, #2
 8000606:	e742      	b.n	800048e <__udivmoddi4+0x14e>

08000608 <__aeabi_idiv0>:
 8000608:	4770      	bx	lr
 800060a:	bf00      	nop

0800060c <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 800060c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800060e:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000610:	2400      	movs	r4, #0
 8000612:	9405      	str	r4, [sp, #20]
 8000614:	9406      	str	r4, [sp, #24]
 8000616:	9407      	str	r4, [sp, #28]
 8000618:	9408      	str	r4, [sp, #32]
 800061a:	9409      	str	r4, [sp, #36]	; 0x24

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800061c:	4b31      	ldr	r3, [pc, #196]	; (80006e4 <MX_GPIO_Init+0xd8>)
 800061e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000620:	f042 0204 	orr.w	r2, r2, #4
 8000624:	631a      	str	r2, [r3, #48]	; 0x30
 8000626:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000628:	f002 0204 	and.w	r2, r2, #4
 800062c:	9200      	str	r2, [sp, #0]
 800062e:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8000630:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000632:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000636:	631a      	str	r2, [r3, #48]	; 0x30
 8000638:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800063a:	f002 0280 	and.w	r2, r2, #128	; 0x80
 800063e:	9201      	str	r2, [sp, #4]
 8000640:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000642:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000644:	f042 0201 	orr.w	r2, r2, #1
 8000648:	631a      	str	r2, [r3, #48]	; 0x30
 800064a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800064c:	f002 0201 	and.w	r2, r2, #1
 8000650:	9202      	str	r2, [sp, #8]
 8000652:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000654:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000656:	f042 0202 	orr.w	r2, r2, #2
 800065a:	631a      	str	r2, [r3, #48]	; 0x30
 800065c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800065e:	f002 0202 	and.w	r2, r2, #2
 8000662:	9203      	str	r2, [sp, #12]
 8000664:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 8000666:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000668:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800066c:	631a      	str	r2, [r3, #48]	; 0x30
 800066e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000670:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000674:	9304      	str	r3, [sp, #16]
 8000676:	9b04      	ldr	r3, [sp, #16]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LD1_Pin|LD3_Pin|LD2_Pin, GPIO_PIN_RESET);
 8000678:	4f1b      	ldr	r7, [pc, #108]	; (80006e8 <MX_GPIO_Init+0xdc>)
 800067a:	4622      	mov	r2, r4
 800067c:	f244 0181 	movw	r1, #16513	; 0x4081
 8000680:	4638      	mov	r0, r7
 8000682:	f000 fc6f 	bl	8000f64 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(USB_PowerSwitchOn_GPIO_Port, USB_PowerSwitchOn_Pin, GPIO_PIN_RESET);
 8000686:	4d19      	ldr	r5, [pc, #100]	; (80006ec <MX_GPIO_Init+0xe0>)
 8000688:	4622      	mov	r2, r4
 800068a:	2140      	movs	r1, #64	; 0x40
 800068c:	4628      	mov	r0, r5
 800068e:	f000 fc69 	bl	8000f64 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : USER_Btn_Pin */
  GPIO_InitStruct.Pin = USER_Btn_Pin;
 8000692:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8000696:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8000698:	f44f 1388 	mov.w	r3, #1114112	; 0x110000
 800069c:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800069e:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(USER_Btn_GPIO_Port, &GPIO_InitStruct);
 80006a0:	a905      	add	r1, sp, #20
 80006a2:	4813      	ldr	r0, [pc, #76]	; (80006f0 <MX_GPIO_Init+0xe4>)
 80006a4:	f000 fb5c 	bl	8000d60 <HAL_GPIO_Init>

  /*Configure GPIO pins : LD1_Pin LD3_Pin LD2_Pin */
  GPIO_InitStruct.Pin = LD1_Pin|LD3_Pin|LD2_Pin;
 80006a8:	f244 0381 	movw	r3, #16513	; 0x4081
 80006ac:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80006ae:	2601      	movs	r6, #1
 80006b0:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80006b2:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80006b4:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80006b6:	a905      	add	r1, sp, #20
 80006b8:	4638      	mov	r0, r7
 80006ba:	f000 fb51 	bl	8000d60 <HAL_GPIO_Init>

  /*Configure GPIO pin : USB_PowerSwitchOn_Pin */
  GPIO_InitStruct.Pin = USB_PowerSwitchOn_Pin;
 80006be:	2340      	movs	r3, #64	; 0x40
 80006c0:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80006c2:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80006c4:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80006c6:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(USB_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 80006c8:	a905      	add	r1, sp, #20
 80006ca:	4628      	mov	r0, r5
 80006cc:	f000 fb48 	bl	8000d60 <HAL_GPIO_Init>

  /*Configure GPIO pin : USB_OverCurrent_Pin */
  GPIO_InitStruct.Pin = USB_OverCurrent_Pin;
 80006d0:	2380      	movs	r3, #128	; 0x80
 80006d2:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80006d4:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80006d6:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(USB_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 80006d8:	a905      	add	r1, sp, #20
 80006da:	4628      	mov	r0, r5
 80006dc:	f000 fb40 	bl	8000d60 <HAL_GPIO_Init>

}
 80006e0:	b00b      	add	sp, #44	; 0x2c
 80006e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80006e4:	40023800 	.word	0x40023800
 80006e8:	40020400 	.word	0x40020400
 80006ec:	40021800 	.word	0x40021800
 80006f0:	40020800 	.word	0x40020800

080006f4 <isCookieAvailable>:
{
 80006f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80006f8:	b085      	sub	sp, #20
 80006fa:	4605      	mov	r5, r0
 80006fc:	4689      	mov	r9, r1
	starttime = OS_GetMilliSecCounter();
 80006fe:	f002 fa28 	bl	8002b52 <OS_GetMilliSecCounter>
 8000702:	4680      	mov	r8, r0
	uint32_t difftime = 0;
 8000704:	2700      	movs	r7, #0
 8000706:	2400      	movs	r4, #0
	while(false == fCookieAvailable && difftime < ulTimeoutInMs)
 8000708:	f084 0301 	eor.w	r3, r4, #1
 800070c:	4620      	mov	r0, r4
 800070e:	454f      	cmp	r7, r9
 8000710:	bf2c      	ite	cs
 8000712:	2400      	movcs	r4, #0
 8000714:	f003 0401 	andcc.w	r4, r3, #1
 8000718:	b1f4      	cbz	r4, 8000758 <isCookieAvailable+0x64>
		OS_Memset(szCookie, 0, sizeof(szCookie));
 800071a:	2205      	movs	r2, #5
 800071c:	2100      	movs	r1, #0
 800071e:	a802      	add	r0, sp, #8
 8000720:	f002 f9fd 	bl	8002b1e <OS_Memset>
		HWIF_READN(ptDevInstance, szCookie, ptDevInstance->pbDPM, 4);
 8000724:	2304      	movs	r3, #4
 8000726:	9300      	str	r3, [sp, #0]
 8000728:	ab02      	add	r3, sp, #8
 800072a:	6a2a      	ldr	r2, [r5, #32]
 800072c:	4629      	mov	r1, r5
 800072e:	2000      	movs	r0, #0
 8000730:	f8d5 62c4 	ldr.w	r6, [r5, #708]	; 0x2c4
 8000734:	47b0      	blx	r6
		if( (0 == OS_Strcmp( szCookie, CIFX_DPMSIGNATURE_BSL_STR)) ||
 8000736:	490a      	ldr	r1, [pc, #40]	; (8000760 <isCookieAvailable+0x6c>)
 8000738:	a802      	add	r0, sp, #8
 800073a:	f002 fad1 	bl	8002ce0 <OS_Strcmp>
 800073e:	2800      	cmp	r0, #0
 8000740:	d0e2      	beq.n	8000708 <isCookieAvailable+0x14>
				(0 == OS_Strcmp( szCookie, CIFX_DPMSIGNATURE_FW_STR)) )
 8000742:	4908      	ldr	r1, [pc, #32]	; (8000764 <isCookieAvailable+0x70>)
 8000744:	a802      	add	r0, sp, #8
 8000746:	f002 facb 	bl	8002ce0 <OS_Strcmp>
		if( (0 == OS_Strcmp( szCookie, CIFX_DPMSIGNATURE_BSL_STR)) ||
 800074a:	2800      	cmp	r0, #0
 800074c:	d0dc      	beq.n	8000708 <isCookieAvailable+0x14>
			difftime = OS_GetMilliSecCounter() - starttime;
 800074e:	f002 fa00 	bl	8002b52 <OS_GetMilliSecCounter>
 8000752:	eba0 0708 	sub.w	r7, r0, r8
 8000756:	e7d6      	b.n	8000706 <isCookieAvailable+0x12>
}
 8000758:	b005      	add	sp, #20
 800075a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800075e:	bf00      	nop
 8000760:	0800a754 	.word	0x0800a754
 8000764:	0800a75c 	.word	0x0800a75c

08000768 <InitializeToolkit>:
static int32_t InitializeToolkit(){
 8000768:	b510      	push	{r4, lr}
	lRet = cifXTKitInit();
 800076a:	f008 f973 	bl	8008a54 <cifXTKitInit>
	if(CIFX_NO_ERROR == lRet)
 800076e:	b100      	cbz	r0, 8000772 <InitializeToolkit+0xa>
}
 8000770:	bd10      	pop	{r4, pc}
		DEVICEINSTANCE *ptDevInstance = (DEVICEINSTANCE*)OS_Memalloc(sizeof(*ptDevInstance));
 8000772:	f44f 7033 	mov.w	r0, #716	; 0x2cc
 8000776:	f002 f9c6 	bl	8002b06 <OS_Memalloc>
 800077a:	4604      	mov	r4, r0
		OS_Memset(ptDevInstance, 0, sizeof(*ptDevInstance));
 800077c:	f44f 7233 	mov.w	r2, #716	; 0x2cc
 8000780:	2100      	movs	r1, #0
 8000782:	f002 f9cc 	bl	8002b1e <OS_Memset>
		g_ulTraceLevel = TRACE_LEVEL_ERROR   |
 8000786:	4b13      	ldr	r3, [pc, #76]	; (80007d4 <InitializeToolkit+0x6c>)
 8000788:	220f      	movs	r2, #15
 800078a:	601a      	str	r2, [r3, #0]
		ptDevInstance->fPCICard          = 0;
 800078c:	2300      	movs	r3, #0
 800078e:	60e3      	str	r3, [r4, #12]
		ptDevInstance->pvOSDependent     = ptDevInstance;
 8000790:	61e4      	str	r4, [r4, #28]
		ptDevInstance->ulDPMSize         = 0x8000;//0x10000;
 8000792:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8000796:	6263      	str	r3, [r4, #36]	; 0x24
		OS_Strncpy(ptDevInstance->szName, "cifX0", sizeof(ptDevInstance->szName));
 8000798:	2210      	movs	r2, #16
 800079a:	490f      	ldr	r1, [pc, #60]	; (80007d8 <InitializeToolkit+0x70>)
 800079c:	f104 0029 	add.w	r0, r4, #41	; 0x29
 80007a0:	f002 faaa 	bl	8002cf8 <OS_Strncpy>
		OS_Sleep(500);
 80007a4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80007a8:	f002 f9d8 	bl	8002b5c <OS_Sleep>
		printf("netX type detection and SPM initialisation ...\n\r");
 80007ac:	480b      	ldr	r0, [pc, #44]	; (80007dc <InitializeToolkit+0x74>)
 80007ae:	f009 f93d 	bl	8009a2c <iprintf>
		lRet=SerialDPM_Init(ptDevInstance);
 80007b2:	4620      	mov	r0, r4
 80007b4:	f002 fd04 	bl	80031c0 <SerialDPM_Init>
		printf("netX type 0x%02x\n\r",(char)lRet);
 80007b8:	b2c1      	uxtb	r1, r0
 80007ba:	4809      	ldr	r0, [pc, #36]	; (80007e0 <InitializeToolkit+0x78>)
 80007bc:	f009 f936 	bl	8009a2c <iprintf>
		while( false == isCookieAvailable(ptDevInstance, 100) );
 80007c0:	2164      	movs	r1, #100	; 0x64
 80007c2:	4620      	mov	r0, r4
 80007c4:	f7ff ff96 	bl	80006f4 <isCookieAvailable>
 80007c8:	2800      	cmp	r0, #0
 80007ca:	d0f9      	beq.n	80007c0 <InitializeToolkit+0x58>
		lRet = cifXTKitAddDevice(ptDevInstance);
 80007cc:	4620      	mov	r0, r4
 80007ce:	f008 f8a5 	bl	800891c <cifXTKitAddDevice>
	return lRet;
 80007d2:	e7cd      	b.n	8000770 <InitializeToolkit+0x8>
 80007d4:	20000038 	.word	0x20000038
 80007d8:	0800a764 	.word	0x0800a764
 80007dc:	0800a76c 	.word	0x0800a76c
 80007e0:	0800a7a0 	.word	0x0800a7a0

080007e4 <Error_Handler>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007e4:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80007e6:	e7fe      	b.n	80007e6 <Error_Handler+0x2>

080007e8 <MX_SPI1_Init>:
{
 80007e8:	b570      	push	{r4, r5, r6, lr}
 80007ea:	b086      	sub	sp, #24
	SpiHandle.Instance               = SPIx;
 80007ec:	481d      	ldr	r0, [pc, #116]	; (8000864 <MX_SPI1_Init+0x7c>)
 80007ee:	4b1e      	ldr	r3, [pc, #120]	; (8000868 <MX_SPI1_Init+0x80>)
 80007f0:	6003      	str	r3, [r0, #0]
	SpiHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
 80007f2:	2318      	movs	r3, #24
 80007f4:	61c3      	str	r3, [r0, #28]
	SpiHandle.Init.Direction         = SPI_DIRECTION_2LINES;
 80007f6:	2300      	movs	r3, #0
 80007f8:	6083      	str	r3, [r0, #8]
	SpiHandle.Init.CLKPhase          = SPI_PHASE_2EDGE;
 80007fa:	2201      	movs	r2, #1
 80007fc:	6142      	str	r2, [r0, #20]
	SpiHandle.Init.CLKPolarity       = SPI_POLARITY_HIGH;
 80007fe:	2202      	movs	r2, #2
 8000800:	6102      	str	r2, [r0, #16]
	SpiHandle.Init.DataSize          = SPI_DATASIZE_8BIT;
 8000802:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 8000806:	60c2      	str	r2, [r0, #12]
	SpiHandle.Init.FirstBit          = SPI_FIRSTBIT_MSB;
 8000808:	6203      	str	r3, [r0, #32]
	SpiHandle.Init.TIMode            = SPI_TIMODE_DISABLE;
 800080a:	6243      	str	r3, [r0, #36]	; 0x24
	SpiHandle.Init.CRCCalculation    = SPI_CRCCALCULATION_DISABLE;
 800080c:	6283      	str	r3, [r0, #40]	; 0x28
	SpiHandle.Init.CRCPolynomial     = 7;
 800080e:	2307      	movs	r3, #7
 8000810:	62c3      	str	r3, [r0, #44]	; 0x2c
	SpiHandle.Init.NSS               = SPI_NSS_SOFT; //SPI_NSS_HARD_OUTPUT;  // original: SPI_NSS_SOFT
 8000812:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000816:	6183      	str	r3, [r0, #24]
	SpiHandle.Init.Mode              = SPI_MODE_MASTER;
 8000818:	f44f 7382 	mov.w	r3, #260	; 0x104
 800081c:	6043      	str	r3, [r0, #4]
	if(HAL_SPI_Init(&SpiHandle) != HAL_OK)
 800081e:	f001 f8c7 	bl	80019b0 <HAL_SPI_Init>
 8000822:	b9e8      	cbnz	r0, 8000860 <MX_SPI1_Init+0x78>
	GPIO_InitStruct.Pin = SPM_CS_PIN;
 8000824:	f44f 4580 	mov.w	r5, #16384	; 0x4000
 8000828:	9501      	str	r5, [sp, #4]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800082a:	2601      	movs	r6, #1
 800082c:	9602      	str	r6, [sp, #8]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 800082e:	2300      	movs	r3, #0
 8000830:	9303      	str	r3, [sp, #12]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000832:	9304      	str	r3, [sp, #16]
	__HAL_RCC_GPIOD_CLK_ENABLE();
 8000834:	4b0d      	ldr	r3, [pc, #52]	; (800086c <MX_SPI1_Init+0x84>)
 8000836:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000838:	f042 0208 	orr.w	r2, r2, #8
 800083c:	631a      	str	r2, [r3, #48]	; 0x30
 800083e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000840:	f003 0308 	and.w	r3, r3, #8
 8000844:	9300      	str	r3, [sp, #0]
 8000846:	9b00      	ldr	r3, [sp, #0]
	HAL_GPIO_Init(SPM_CS_GPIO_PORT, &GPIO_InitStruct);
 8000848:	4c09      	ldr	r4, [pc, #36]	; (8000870 <MX_SPI1_Init+0x88>)
 800084a:	a901      	add	r1, sp, #4
 800084c:	4620      	mov	r0, r4
 800084e:	f000 fa87 	bl	8000d60 <HAL_GPIO_Init>
	HAL_GPIO_WritePin(GPIOD, SPM_CS_PIN, GPIO_PIN_SET);
 8000852:	4632      	mov	r2, r6
 8000854:	4629      	mov	r1, r5
 8000856:	4620      	mov	r0, r4
 8000858:	f000 fb84 	bl	8000f64 <HAL_GPIO_WritePin>
}
 800085c:	b006      	add	sp, #24
 800085e:	bd70      	pop	{r4, r5, r6, pc}
		Error_Handler();
 8000860:	f7ff ffc0 	bl	80007e4 <Error_Handler>
 8000864:	200000b4 	.word	0x200000b4
 8000868:	40013000 	.word	0x40013000
 800086c:	40023800 	.word	0x40023800
 8000870:	40020c00 	.word	0x40020c00

08000874 <SystemClock_Config>:
{
 8000874:	b500      	push	{lr}
 8000876:	b095      	sub	sp, #84	; 0x54
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000878:	2234      	movs	r2, #52	; 0x34
 800087a:	2100      	movs	r1, #0
 800087c:	a807      	add	r0, sp, #28
 800087e:	f009 f954 	bl	8009b2a <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000882:	2300      	movs	r3, #0
 8000884:	9302      	str	r3, [sp, #8]
 8000886:	9303      	str	r3, [sp, #12]
 8000888:	9304      	str	r3, [sp, #16]
 800088a:	9305      	str	r3, [sp, #20]
 800088c:	9306      	str	r3, [sp, #24]
  HAL_PWR_EnableBkUpAccess();
 800088e:	f000 fb6f 	bl	8000f70 <HAL_PWR_EnableBkUpAccess>
  __HAL_RCC_PWR_CLK_ENABLE();
 8000892:	4b23      	ldr	r3, [pc, #140]	; (8000920 <SystemClock_Config+0xac>)
 8000894:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000896:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800089a:	641a      	str	r2, [r3, #64]	; 0x40
 800089c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800089e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80008a2:	9300      	str	r3, [sp, #0]
 80008a4:	9b00      	ldr	r3, [sp, #0]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80008a6:	4b1f      	ldr	r3, [pc, #124]	; (8000924 <SystemClock_Config+0xb0>)
 80008a8:	681a      	ldr	r2, [r3, #0]
 80008aa:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 80008ae:	601a      	str	r2, [r3, #0]
 80008b0:	681b      	ldr	r3, [r3, #0]
 80008b2:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 80008b6:	9301      	str	r3, [sp, #4]
 80008b8:	9b01      	ldr	r3, [sp, #4]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80008ba:	2301      	movs	r3, #1
 80008bc:	9307      	str	r3, [sp, #28]
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
 80008be:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
 80008c2:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80008c4:	2302      	movs	r3, #2
 80008c6:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80008c8:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 80008cc:	920e      	str	r2, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLM = 4;
 80008ce:	2204      	movs	r2, #4
 80008d0:	920f      	str	r2, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLN = 216;
 80008d2:	21d8      	movs	r1, #216	; 0xd8
 80008d4:	9110      	str	r1, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80008d6:	9311      	str	r3, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLQ = 4;
 80008d8:	9212      	str	r2, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLR = 2;
 80008da:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80008dc:	a807      	add	r0, sp, #28
 80008de:	f000 fb8d 	bl	8000ffc <HAL_RCC_OscConfig>
 80008e2:	b9b0      	cbnz	r0, 8000912 <SystemClock_Config+0x9e>
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 80008e4:	f000 fb4c 	bl	8000f80 <HAL_PWREx_EnableOverDrive>
 80008e8:	b9a8      	cbnz	r0, 8000916 <SystemClock_Config+0xa2>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80008ea:	230f      	movs	r3, #15
 80008ec:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80008ee:	2302      	movs	r3, #2
 80008f0:	9303      	str	r3, [sp, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80008f2:	2300      	movs	r3, #0
 80008f4:	9304      	str	r3, [sp, #16]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80008f6:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 80008fa:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80008fc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000900:	9306      	str	r3, [sp, #24]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
 8000902:	2107      	movs	r1, #7
 8000904:	a802      	add	r0, sp, #8
 8000906:	f000 fe09 	bl	800151c <HAL_RCC_ClockConfig>
 800090a:	b930      	cbnz	r0, 800091a <SystemClock_Config+0xa6>
}
 800090c:	b015      	add	sp, #84	; 0x54
 800090e:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8000912:	f7ff ff67 	bl	80007e4 <Error_Handler>
    Error_Handler();
 8000916:	f7ff ff65 	bl	80007e4 <Error_Handler>
    Error_Handler();
 800091a:	f7ff ff63 	bl	80007e4 <Error_Handler>
 800091e:	bf00      	nop
 8000920:	40023800 	.word	0x40023800
 8000924:	40007000 	.word	0x40007000

08000928 <main>:
{
 8000928:	b508      	push	{r3, lr}
  HAL_Init();
 800092a:	f000 f951 	bl	8000bd0 <HAL_Init>
  SystemClock_Config();
 800092e:	f7ff ffa1 	bl	8000874 <SystemClock_Config>
  MX_GPIO_Init();
 8000932:	f7ff fe6b 	bl	800060c <MX_GPIO_Init>
  MX_SPI1_Init();
 8000936:	f7ff ff57 	bl	80007e8 <MX_SPI1_Init>
  lRet = InitializeToolkit();
 800093a:	f7ff ff15 	bl	8000768 <InitializeToolkit>
  if(CIFX_NO_ERROR == lRet)
 800093e:	b100      	cbz	r0, 8000942 <main+0x1a>
  while (1)
 8000940:	e7fe      	b.n	8000940 <main+0x18>
    lRet = App_CifXApplicationDemo("cifX0");
 8000942:	4802      	ldr	r0, [pc, #8]	; (800094c <main+0x24>)
 8000944:	f001 fd0e 	bl	8002364 <App_CifXApplicationDemo>
 8000948:	e7fa      	b.n	8000940 <main+0x18>
 800094a:	bf00      	nop
 800094c:	0800a764 	.word	0x0800a764

08000950 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000950:	b082      	sub	sp, #8
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 8000952:	4b0a      	ldr	r3, [pc, #40]	; (800097c <HAL_MspInit+0x2c>)
 8000954:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000956:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800095a:	641a      	str	r2, [r3, #64]	; 0x40
 800095c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800095e:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8000962:	9200      	str	r2, [sp, #0]
 8000964:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000966:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000968:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800096c:	645a      	str	r2, [r3, #68]	; 0x44
 800096e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000970:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000974:	9301      	str	r3, [sp, #4]
 8000976:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000978:	b002      	add	sp, #8
 800097a:	4770      	bx	lr
 800097c:	40023800 	.word	0x40023800

08000980 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8000980:	b530      	push	{r4, r5, lr}
 8000982:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000984:	2300      	movs	r3, #0
 8000986:	9305      	str	r3, [sp, #20]
 8000988:	9306      	str	r3, [sp, #24]
 800098a:	9307      	str	r3, [sp, #28]
 800098c:	9308      	str	r3, [sp, #32]
 800098e:	9309      	str	r3, [sp, #36]	; 0x24
  if(hspi->Instance==SPI1)
 8000990:	6802      	ldr	r2, [r0, #0]
 8000992:	4b27      	ldr	r3, [pc, #156]	; (8000a30 <HAL_SPI_MspInit+0xb0>)
 8000994:	429a      	cmp	r2, r3
 8000996:	d001      	beq.n	800099c <HAL_SPI_MspInit+0x1c>
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 8000998:	b00b      	add	sp, #44	; 0x2c
 800099a:	bd30      	pop	{r4, r5, pc}
	SPIx_SCK_GPIO_CLK_ENABLE();
 800099c:	f503 3384 	add.w	r3, r3, #67584	; 0x10800
 80009a0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80009a2:	f042 0202 	orr.w	r2, r2, #2
 80009a6:	631a      	str	r2, [r3, #48]	; 0x30
 80009a8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80009aa:	f002 0202 	and.w	r2, r2, #2
 80009ae:	9201      	str	r2, [sp, #4]
 80009b0:	9a01      	ldr	r2, [sp, #4]
	SPIx_MISO_GPIO_CLK_ENABLE();
 80009b2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80009b4:	f042 0201 	orr.w	r2, r2, #1
 80009b8:	631a      	str	r2, [r3, #48]	; 0x30
 80009ba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80009bc:	f002 0201 	and.w	r2, r2, #1
 80009c0:	9202      	str	r2, [sp, #8]
 80009c2:	9a02      	ldr	r2, [sp, #8]
	SPIx_MOSI_GPIO_CLK_ENABLE();
 80009c4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80009c6:	f042 0201 	orr.w	r2, r2, #1
 80009ca:	631a      	str	r2, [r3, #48]	; 0x30
 80009cc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80009ce:	f002 0201 	and.w	r2, r2, #1
 80009d2:	9203      	str	r2, [sp, #12]
 80009d4:	9a03      	ldr	r2, [sp, #12]
	SPIx_CLK_ENABLE();
 80009d6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80009d8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80009dc:	645a      	str	r2, [r3, #68]	; 0x44
 80009de:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80009e0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80009e4:	9304      	str	r3, [sp, #16]
 80009e6:	9b04      	ldr	r3, [sp, #16]
	GPIO_InitStruct.Pin       = SPIx_SCK_PIN;
 80009e8:	2320      	movs	r3, #32
 80009ea:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 80009ec:	2302      	movs	r3, #2
 80009ee:	9306      	str	r3, [sp, #24]
	GPIO_InitStruct.Pull      = GPIO_PULLDOWN;
 80009f0:	9307      	str	r3, [sp, #28]
	GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_HIGH;
 80009f2:	9308      	str	r3, [sp, #32]
	GPIO_InitStruct.Alternate = SPIx_SCK_AF;
 80009f4:	2505      	movs	r5, #5
 80009f6:	9509      	str	r5, [sp, #36]	; 0x24
	HAL_GPIO_Init(SPIx_SCK_GPIO_PORT, &GPIO_InitStruct);
 80009f8:	4c0e      	ldr	r4, [pc, #56]	; (8000a34 <HAL_SPI_MspInit+0xb4>)
 80009fa:	a905      	add	r1, sp, #20
 80009fc:	4620      	mov	r0, r4
 80009fe:	f000 f9af 	bl	8000d60 <HAL_GPIO_Init>
	GPIO_InitStruct.Pin = SPIx_MISO_PIN;
 8000a02:	2340      	movs	r3, #64	; 0x40
 8000a04:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Alternate = SPIx_MISO_AF;
 8000a06:	9509      	str	r5, [sp, #36]	; 0x24
	HAL_GPIO_Init(SPIx_MISO_GPIO_PORT, &GPIO_InitStruct);
 8000a08:	a905      	add	r1, sp, #20
 8000a0a:	4620      	mov	r0, r4
 8000a0c:	f000 f9a8 	bl	8000d60 <HAL_GPIO_Init>
	GPIO_InitStruct.Pin = SPIx_MOSI_PIN;
 8000a10:	2380      	movs	r3, #128	; 0x80
 8000a12:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Alternate = SPIx_MOSI_AF;
 8000a14:	9509      	str	r5, [sp, #36]	; 0x24
	HAL_GPIO_Init(SPIx_MOSI_GPIO_PORT, &GPIO_InitStruct);
 8000a16:	a905      	add	r1, sp, #20
 8000a18:	4620      	mov	r0, r4
 8000a1a:	f000 f9a1 	bl	8000d60 <HAL_GPIO_Init>
	HAL_NVIC_SetPriority(SPIx_IRQn, 1, 0);
 8000a1e:	2200      	movs	r2, #0
 8000a20:	2101      	movs	r1, #1
 8000a22:	2023      	movs	r0, #35	; 0x23
 8000a24:	f000 f91e 	bl	8000c64 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(SPIx_IRQn);
 8000a28:	2023      	movs	r0, #35	; 0x23
 8000a2a:	f000 f951 	bl	8000cd0 <HAL_NVIC_EnableIRQ>
}
 8000a2e:	e7b3      	b.n	8000998 <HAL_SPI_MspInit+0x18>
 8000a30:	40013000 	.word	0x40013000
 8000a34:	40020000 	.word	0x40020000

08000a38 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8000a38:	e7fe      	b.n	8000a38 <NMI_Handler>

08000a3a <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8000a3a:	e7fe      	b.n	8000a3a <HardFault_Handler>

08000a3c <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8000a3c:	e7fe      	b.n	8000a3c <MemManage_Handler>

08000a3e <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8000a3e:	e7fe      	b.n	8000a3e <BusFault_Handler>

08000a40 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000a40:	e7fe      	b.n	8000a40 <UsageFault_Handler>

08000a42 <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8000a42:	4770      	bx	lr

08000a44 <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8000a44:	4770      	bx	lr

08000a46 <PendSV_Handler>:

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8000a46:	4770      	bx	lr

08000a48 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8000a48:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8000a4a:	f000 f8d3 	bl	8000bf4 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8000a4e:	bd08      	pop	{r3, pc}

08000a50 <SPI1_IRQHandler>:
  * @brief  This function handles SPI interrupt request.
  * @param  None
  * @retval None
  */
void SPIx_IRQHandler(void)
{
 8000a50:	b508      	push	{r3, lr}
	HAL_SPI_IRQHandler(&SpiHandle);
 8000a52:	4802      	ldr	r0, [pc, #8]	; (8000a5c <SPI1_IRQHandler+0xc>)
 8000a54:	f001 faf8 	bl	8002048 <HAL_SPI_IRQHandler>
}
 8000a58:	bd08      	pop	{r3, pc}
 8000a5a:	bf00      	nop
 8000a5c:	200000b4 	.word	0x200000b4

08000a60 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 8000a60:	2001      	movs	r0, #1
 8000a62:	4770      	bx	lr

08000a64 <_kill>:

int _kill(int pid, int sig)
{
 8000a64:	b508      	push	{r3, lr}
	errno = EINVAL;
 8000a66:	f009 f8f3 	bl	8009c50 <__errno>
 8000a6a:	2316      	movs	r3, #22
 8000a6c:	6003      	str	r3, [r0, #0]
	return -1;
}
 8000a6e:	f04f 30ff 	mov.w	r0, #4294967295
 8000a72:	bd08      	pop	{r3, pc}

08000a74 <_exit>:

void _exit (int status)
{
 8000a74:	b508      	push	{r3, lr}
	_kill(status, -1);
 8000a76:	f04f 31ff 	mov.w	r1, #4294967295
 8000a7a:	f7ff fff3 	bl	8000a64 <_kill>
	while (1) {}		/* Make sure we hang here */
 8000a7e:	e7fe      	b.n	8000a7e <_exit+0xa>

08000a80 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8000a80:	b570      	push	{r4, r5, r6, lr}
 8000a82:	460c      	mov	r4, r1
 8000a84:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000a86:	2500      	movs	r5, #0
 8000a88:	e006      	b.n	8000a98 <_read+0x18>
	{
		*ptr++ = __io_getchar();
 8000a8a:	f3af 8000 	nop.w
 8000a8e:	4621      	mov	r1, r4
 8000a90:	f801 0b01 	strb.w	r0, [r1], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000a94:	3501      	adds	r5, #1
		*ptr++ = __io_getchar();
 8000a96:	460c      	mov	r4, r1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000a98:	42b5      	cmp	r5, r6
 8000a9a:	dbf6      	blt.n	8000a8a <_read+0xa>
	}

return len;
}
 8000a9c:	4630      	mov	r0, r6
 8000a9e:	bd70      	pop	{r4, r5, r6, pc}

08000aa0 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8000aa0:	b570      	push	{r4, r5, r6, lr}
 8000aa2:	460c      	mov	r4, r1
 8000aa4:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000aa6:	2500      	movs	r5, #0
 8000aa8:	e004      	b.n	8000ab4 <_write+0x14>
	{
		__io_putchar(*ptr++);
 8000aaa:	f814 0b01 	ldrb.w	r0, [r4], #1
 8000aae:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000ab2:	3501      	adds	r5, #1
 8000ab4:	42b5      	cmp	r5, r6
 8000ab6:	dbf8      	blt.n	8000aaa <_write+0xa>
	}
	return len;
}
 8000ab8:	4630      	mov	r0, r6
 8000aba:	bd70      	pop	{r4, r5, r6, pc}

08000abc <_close>:

int _close(int file)
{
	return -1;
}
 8000abc:	f04f 30ff 	mov.w	r0, #4294967295
 8000ac0:	4770      	bx	lr

08000ac2 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8000ac2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8000ac6:	604b      	str	r3, [r1, #4]
	return 0;
}
 8000ac8:	2000      	movs	r0, #0
 8000aca:	4770      	bx	lr

08000acc <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8000acc:	2001      	movs	r0, #1
 8000ace:	4770      	bx	lr

08000ad0 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8000ad0:	2000      	movs	r0, #0
 8000ad2:	4770      	bx	lr

08000ad4 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8000ad4:	b510      	push	{r4, lr}
 8000ad6:	4603      	mov	r3, r0
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8000ad8:	4a0c      	ldr	r2, [pc, #48]	; (8000b0c <_sbrk+0x38>)
 8000ada:	490d      	ldr	r1, [pc, #52]	; (8000b10 <_sbrk+0x3c>)
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8000adc:	480d      	ldr	r0, [pc, #52]	; (8000b14 <_sbrk+0x40>)
 8000ade:	6800      	ldr	r0, [r0, #0]
 8000ae0:	b140      	cbz	r0, 8000af4 <_sbrk+0x20>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8000ae2:	480c      	ldr	r0, [pc, #48]	; (8000b14 <_sbrk+0x40>)
 8000ae4:	6800      	ldr	r0, [r0, #0]
 8000ae6:	4403      	add	r3, r0
 8000ae8:	1a52      	subs	r2, r2, r1
 8000aea:	4293      	cmp	r3, r2
 8000aec:	d806      	bhi.n	8000afc <_sbrk+0x28>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 8000aee:	4a09      	ldr	r2, [pc, #36]	; (8000b14 <_sbrk+0x40>)
 8000af0:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
}
 8000af2:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 8000af4:	4807      	ldr	r0, [pc, #28]	; (8000b14 <_sbrk+0x40>)
 8000af6:	4c08      	ldr	r4, [pc, #32]	; (8000b18 <_sbrk+0x44>)
 8000af8:	6004      	str	r4, [r0, #0]
 8000afa:	e7f2      	b.n	8000ae2 <_sbrk+0xe>
    errno = ENOMEM;
 8000afc:	f009 f8a8 	bl	8009c50 <__errno>
 8000b00:	230c      	movs	r3, #12
 8000b02:	6003      	str	r3, [r0, #0]
    return (void *)-1;
 8000b04:	f04f 30ff 	mov.w	r0, #4294967295
 8000b08:	e7f3      	b.n	8000af2 <_sbrk+0x1e>
 8000b0a:	bf00      	nop
 8000b0c:	20080000 	.word	0x20080000
 8000b10:	00000400 	.word	0x00000400
 8000b14:	20000118 	.word	0x20000118
 8000b18:	20000370 	.word	0x20000370

08000b1c <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000b1c:	4a03      	ldr	r2, [pc, #12]	; (8000b2c <SystemInit+0x10>)
 8000b1e:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8000b22:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000b26:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8000b2a:	4770      	bx	lr
 8000b2c:	e000ed00 	.word	0xe000ed00

08000b30 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8000b30:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000b68 <LoopFillZerobss+0x12>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8000b34:	480d      	ldr	r0, [pc, #52]	; (8000b6c <LoopFillZerobss+0x16>)
  ldr r1, =_edata
 8000b36:	490e      	ldr	r1, [pc, #56]	; (8000b70 <LoopFillZerobss+0x1a>)
  ldr r2, =_sidata
 8000b38:	4a0e      	ldr	r2, [pc, #56]	; (8000b74 <LoopFillZerobss+0x1e>)
  movs r3, #0
 8000b3a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8000b3c:	e002      	b.n	8000b44 <LoopCopyDataInit>

08000b3e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000b3e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000b40:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000b42:	3304      	adds	r3, #4

08000b44 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000b44:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000b46:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000b48:	d3f9      	bcc.n	8000b3e <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8000b4a:	4a0b      	ldr	r2, [pc, #44]	; (8000b78 <LoopFillZerobss+0x22>)
  ldr r4, =_ebss
 8000b4c:	4c0b      	ldr	r4, [pc, #44]	; (8000b7c <LoopFillZerobss+0x26>)
  movs r3, #0
 8000b4e:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000b50:	e001      	b.n	8000b56 <LoopFillZerobss>

08000b52 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000b52:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000b54:	3204      	adds	r2, #4

08000b56 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8000b56:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8000b58:	d3fb      	bcc.n	8000b52 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 8000b5a:	f7ff ffdf 	bl	8000b1c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8000b5e:	f009 f87d 	bl	8009c5c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8000b62:	f7ff fee1 	bl	8000928 <main>
  bx  lr    
 8000b66:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8000b68:	20080000 	.word	0x20080000
  ldr r0, =_sdata
 8000b6c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000b70:	20000098 	.word	0x20000098
  ldr r2, =_sidata
 8000b74:	0800ce88 	.word	0x0800ce88
  ldr r2, =_sbss
 8000b78:	20000098 	.word	0x20000098
  ldr r4, =_ebss
 8000b7c:	2000036c 	.word	0x2000036c

08000b80 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000b80:	e7fe      	b.n	8000b80 <ADC_IRQHandler>
	...

08000b84 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000b84:	b510      	push	{r4, lr}
 8000b86:	4604      	mov	r4, r0
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000b88:	4b0e      	ldr	r3, [pc, #56]	; (8000bc4 <HAL_InitTick+0x40>)
 8000b8a:	781a      	ldrb	r2, [r3, #0]
 8000b8c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000b90:	fbb3 f3f2 	udiv	r3, r3, r2
 8000b94:	4a0c      	ldr	r2, [pc, #48]	; (8000bc8 <HAL_InitTick+0x44>)
 8000b96:	6810      	ldr	r0, [r2, #0]
 8000b98:	fbb0 f0f3 	udiv	r0, r0, r3
 8000b9c:	f000 f8b8 	bl	8000d10 <HAL_SYSTICK_Config>
 8000ba0:	b968      	cbnz	r0, 8000bbe <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000ba2:	2c0f      	cmp	r4, #15
 8000ba4:	d901      	bls.n	8000baa <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 8000ba6:	2001      	movs	r0, #1
 8000ba8:	e00a      	b.n	8000bc0 <HAL_InitTick+0x3c>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8000baa:	2200      	movs	r2, #0
 8000bac:	4621      	mov	r1, r4
 8000bae:	f04f 30ff 	mov.w	r0, #4294967295
 8000bb2:	f000 f857 	bl	8000c64 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8000bb6:	4b05      	ldr	r3, [pc, #20]	; (8000bcc <HAL_InitTick+0x48>)
 8000bb8:	601c      	str	r4, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 8000bba:	2000      	movs	r0, #0
 8000bbc:	e000      	b.n	8000bc0 <HAL_InitTick+0x3c>
    return HAL_ERROR;
 8000bbe:	2001      	movs	r0, #1
}
 8000bc0:	bd10      	pop	{r4, pc}
 8000bc2:	bf00      	nop
 8000bc4:	20000004 	.word	0x20000004
 8000bc8:	20000000 	.word	0x20000000
 8000bcc:	20000008 	.word	0x20000008

08000bd0 <HAL_Init>:
{
 8000bd0:	b508      	push	{r3, lr}
  __HAL_FLASH_ART_ENABLE();
 8000bd2:	4a07      	ldr	r2, [pc, #28]	; (8000bf0 <HAL_Init+0x20>)
 8000bd4:	6813      	ldr	r3, [r2, #0]
 8000bd6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000bda:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000bdc:	2003      	movs	r0, #3
 8000bde:	f000 f82f 	bl	8000c40 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8000be2:	2000      	movs	r0, #0
 8000be4:	f7ff ffce 	bl	8000b84 <HAL_InitTick>
  HAL_MspInit();
 8000be8:	f7ff feb2 	bl	8000950 <HAL_MspInit>
}
 8000bec:	2000      	movs	r0, #0
 8000bee:	bd08      	pop	{r3, pc}
 8000bf0:	40023c00 	.word	0x40023c00

08000bf4 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8000bf4:	4a03      	ldr	r2, [pc, #12]	; (8000c04 <HAL_IncTick+0x10>)
 8000bf6:	6811      	ldr	r1, [r2, #0]
 8000bf8:	4b03      	ldr	r3, [pc, #12]	; (8000c08 <HAL_IncTick+0x14>)
 8000bfa:	781b      	ldrb	r3, [r3, #0]
 8000bfc:	440b      	add	r3, r1
 8000bfe:	6013      	str	r3, [r2, #0]
}
 8000c00:	4770      	bx	lr
 8000c02:	bf00      	nop
 8000c04:	2000011c 	.word	0x2000011c
 8000c08:	20000004 	.word	0x20000004

08000c0c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000c0c:	4b01      	ldr	r3, [pc, #4]	; (8000c14 <HAL_GetTick+0x8>)
 8000c0e:	6818      	ldr	r0, [r3, #0]
}
 8000c10:	4770      	bx	lr
 8000c12:	bf00      	nop
 8000c14:	2000011c 	.word	0x2000011c

08000c18 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000c18:	b538      	push	{r3, r4, r5, lr}
 8000c1a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000c1c:	f7ff fff6 	bl	8000c0c <HAL_GetTick>
 8000c20:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000c22:	f1b4 3fff 	cmp.w	r4, #4294967295
 8000c26:	d002      	beq.n	8000c2e <HAL_Delay+0x16>
  {
    wait += (uint32_t)(uwTickFreq);
 8000c28:	4b04      	ldr	r3, [pc, #16]	; (8000c3c <HAL_Delay+0x24>)
 8000c2a:	781b      	ldrb	r3, [r3, #0]
 8000c2c:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8000c2e:	f7ff ffed 	bl	8000c0c <HAL_GetTick>
 8000c32:	1b40      	subs	r0, r0, r5
 8000c34:	42a0      	cmp	r0, r4
 8000c36:	d3fa      	bcc.n	8000c2e <HAL_Delay+0x16>
  {
  }
}
 8000c38:	bd38      	pop	{r3, r4, r5, pc}
 8000c3a:	bf00      	nop
 8000c3c:	20000004 	.word	0x20000004

08000c40 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000c40:	4906      	ldr	r1, [pc, #24]	; (8000c5c <HAL_NVIC_SetPriorityGrouping+0x1c>)
 8000c42:	68cb      	ldr	r3, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000c44:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000c48:	041b      	lsls	r3, r3, #16
 8000c4a:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000c4c:	0200      	lsls	r0, r0, #8
 8000c4e:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000c52:	4303      	orrs	r3, r0
  reg_value  =  (reg_value                                   |
 8000c54:	4a02      	ldr	r2, [pc, #8]	; (8000c60 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8000c56:	431a      	orrs	r2, r3
  SCB->AIRCR =  reg_value;
 8000c58:	60ca      	str	r2, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8000c5a:	4770      	bx	lr
 8000c5c:	e000ed00 	.word	0xe000ed00
 8000c60:	05fa0000 	.word	0x05fa0000

08000c64 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000c64:	b500      	push	{lr}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000c66:	4b17      	ldr	r3, [pc, #92]	; (8000cc4 <HAL_NVIC_SetPriority+0x60>)
 8000c68:	68db      	ldr	r3, [r3, #12]
 8000c6a:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000c6e:	f1c3 0c07 	rsb	ip, r3, #7
 8000c72:	f1bc 0f04 	cmp.w	ip, #4
 8000c76:	bf28      	it	cs
 8000c78:	f04f 0c04 	movcs.w	ip, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000c7c:	f103 0e04 	add.w	lr, r3, #4
 8000c80:	f1be 0f06 	cmp.w	lr, #6
 8000c84:	d914      	bls.n	8000cb0 <HAL_NVIC_SetPriority+0x4c>
 8000c86:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000c88:	f04f 3eff 	mov.w	lr, #4294967295
 8000c8c:	fa0e fc0c 	lsl.w	ip, lr, ip
 8000c90:	ea21 010c 	bic.w	r1, r1, ip
 8000c94:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000c96:	fa0e fe03 	lsl.w	lr, lr, r3
 8000c9a:	ea22 020e 	bic.w	r2, r2, lr
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000c9e:	430a      	orrs	r2, r1
  if ((int32_t)(IRQn) >= 0)
 8000ca0:	2800      	cmp	r0, #0
 8000ca2:	db07      	blt.n	8000cb4 <HAL_NVIC_SetPriority+0x50>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ca4:	0112      	lsls	r2, r2, #4
 8000ca6:	b2d2      	uxtb	r2, r2
 8000ca8:	4b07      	ldr	r3, [pc, #28]	; (8000cc8 <HAL_NVIC_SetPriority+0x64>)
 8000caa:	541a      	strb	r2, [r3, r0]
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8000cac:	f85d fb04 	ldr.w	pc, [sp], #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000cb0:	2300      	movs	r3, #0
 8000cb2:	e7e9      	b.n	8000c88 <HAL_NVIC_SetPriority+0x24>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000cb4:	f000 000f 	and.w	r0, r0, #15
 8000cb8:	0112      	lsls	r2, r2, #4
 8000cba:	b2d2      	uxtb	r2, r2
 8000cbc:	4b03      	ldr	r3, [pc, #12]	; (8000ccc <HAL_NVIC_SetPriority+0x68>)
 8000cbe:	541a      	strb	r2, [r3, r0]
 8000cc0:	e7f4      	b.n	8000cac <HAL_NVIC_SetPriority+0x48>
 8000cc2:	bf00      	nop
 8000cc4:	e000ed00 	.word	0xe000ed00
 8000cc8:	e000e400 	.word	0xe000e400
 8000ccc:	e000ed14 	.word	0xe000ed14

08000cd0 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8000cd0:	2800      	cmp	r0, #0
 8000cd2:	db07      	blt.n	8000ce4 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8000cd4:	f000 021f 	and.w	r2, r0, #31
 8000cd8:	0940      	lsrs	r0, r0, #5
 8000cda:	2301      	movs	r3, #1
 8000cdc:	4093      	lsls	r3, r2
 8000cde:	4a02      	ldr	r2, [pc, #8]	; (8000ce8 <HAL_NVIC_EnableIRQ+0x18>)
 8000ce0:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8000ce4:	4770      	bx	lr
 8000ce6:	bf00      	nop
 8000ce8:	e000e100 	.word	0xe000e100

08000cec <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8000cec:	2800      	cmp	r0, #0
 8000cee:	db0c      	blt.n	8000d0a <HAL_NVIC_DisableIRQ+0x1e>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8000cf0:	f000 021f 	and.w	r2, r0, #31
 8000cf4:	0940      	lsrs	r0, r0, #5
 8000cf6:	2301      	movs	r3, #1
 8000cf8:	4093      	lsls	r3, r2
 8000cfa:	3020      	adds	r0, #32
 8000cfc:	4a03      	ldr	r2, [pc, #12]	; (8000d0c <HAL_NVIC_DisableIRQ+0x20>)
 8000cfe:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000d02:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000d06:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 8000d0a:	4770      	bx	lr
 8000d0c:	e000e100 	.word	0xe000e100

08000d10 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000d10:	3801      	subs	r0, #1
 8000d12:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000d16:	d20b      	bcs.n	8000d30 <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000d18:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8000d1c:	6158      	str	r0, [r3, #20]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d1e:	4a05      	ldr	r2, [pc, #20]	; (8000d34 <HAL_SYSTICK_Config+0x24>)
 8000d20:	21f0      	movs	r1, #240	; 0xf0
 8000d22:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000d26:	2000      	movs	r0, #0
 8000d28:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000d2a:	2207      	movs	r2, #7
 8000d2c:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8000d2e:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000d30:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000d32:	4770      	bx	lr
 8000d34:	e000ed00 	.word	0xe000ed00

08000d38 <HAL_DMA_Abort_IT>:
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8000d38:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8000d3c:	b2db      	uxtb	r3, r3
 8000d3e:	2b02      	cmp	r3, #2
 8000d40:	d003      	beq.n	8000d4a <HAL_DMA_Abort_IT+0x12>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000d42:	2380      	movs	r3, #128	; 0x80
 8000d44:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 8000d46:	2001      	movs	r0, #1
 8000d48:	4770      	bx	lr
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 8000d4a:	2305      	movs	r3, #5
 8000d4c:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8000d50:	6802      	ldr	r2, [r0, #0]
 8000d52:	6813      	ldr	r3, [r2, #0]
 8000d54:	f023 0301 	bic.w	r3, r3, #1
 8000d58:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8000d5a:	2000      	movs	r0, #0
}
 8000d5c:	4770      	bx	lr
	...

08000d60 <HAL_GPIO_Init>:
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 8000d60:	2300      	movs	r3, #0
 8000d62:	2b0f      	cmp	r3, #15
 8000d64:	f200 80f4 	bhi.w	8000f50 <HAL_GPIO_Init+0x1f0>
{
 8000d68:	b570      	push	{r4, r5, r6, lr}
 8000d6a:	b082      	sub	sp, #8
 8000d6c:	e066      	b.n	8000e3c <HAL_GPIO_Init+0xdc>
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8000d6e:	6885      	ldr	r5, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8000d70:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 8000d74:	2403      	movs	r4, #3
 8000d76:	fa04 f40e 	lsl.w	r4, r4, lr
 8000d7a:	ea25 0504 	bic.w	r5, r5, r4
        temp |= (GPIO_Init->Speed << (position * 2));
 8000d7e:	68cc      	ldr	r4, [r1, #12]
 8000d80:	fa04 f40e 	lsl.w	r4, r4, lr
 8000d84:	432c      	orrs	r4, r5
        GPIOx->OSPEEDR = temp;
 8000d86:	6084      	str	r4, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8000d88:	6844      	ldr	r4, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000d8a:	ea24 0402 	bic.w	r4, r4, r2
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8000d8e:	684a      	ldr	r2, [r1, #4]
 8000d90:	f3c2 1200 	ubfx	r2, r2, #4, #1
 8000d94:	409a      	lsls	r2, r3
 8000d96:	4322      	orrs	r2, r4
        GPIOx->OTYPER = temp;
 8000d98:	6042      	str	r2, [r0, #4]
 8000d9a:	e05d      	b.n	8000e58 <HAL_GPIO_Init+0xf8>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8000d9c:	08dc      	lsrs	r4, r3, #3
 8000d9e:	3408      	adds	r4, #8
 8000da0:	f850 2024 	ldr.w	r2, [r0, r4, lsl #2]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000da4:	f003 0507 	and.w	r5, r3, #7
 8000da8:	00ad      	lsls	r5, r5, #2
 8000daa:	f04f 0e0f 	mov.w	lr, #15
 8000dae:	fa0e fe05 	lsl.w	lr, lr, r5
 8000db2:	ea22 0e0e 	bic.w	lr, r2, lr
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8000db6:	690a      	ldr	r2, [r1, #16]
 8000db8:	40aa      	lsls	r2, r5
 8000dba:	ea42 020e 	orr.w	r2, r2, lr
        GPIOx->AFR[position >> 3] = temp;
 8000dbe:	f840 2024 	str.w	r2, [r0, r4, lsl #2]
 8000dc2:	e05d      	b.n	8000e80 <HAL_GPIO_Init+0x120>
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000dc4:	2209      	movs	r2, #9
 8000dc6:	e000      	b.n	8000dca <HAL_GPIO_Init+0x6a>
 8000dc8:	2200      	movs	r2, #0
 8000dca:	fa02 f20e 	lsl.w	r2, r2, lr
 8000dce:	432a      	orrs	r2, r5
        SYSCFG->EXTICR[position >> 2] = temp;
 8000dd0:	3402      	adds	r4, #2
 8000dd2:	4d60      	ldr	r5, [pc, #384]	; (8000f54 <HAL_GPIO_Init+0x1f4>)
 8000dd4:	f845 2024 	str.w	r2, [r5, r4, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8000dd8:	4a5f      	ldr	r2, [pc, #380]	; (8000f58 <HAL_GPIO_Init+0x1f8>)
 8000dda:	6894      	ldr	r4, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
 8000ddc:	ea6f 020c 	mvn.w	r2, ip
 8000de0:	ea24 050c 	bic.w	r5, r4, ip
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8000de4:	684e      	ldr	r6, [r1, #4]
 8000de6:	f416 1f80 	tst.w	r6, #1048576	; 0x100000
 8000dea:	d001      	beq.n	8000df0 <HAL_GPIO_Init+0x90>
        {
          temp |= iocurrent;
 8000dec:	ea4c 0504 	orr.w	r5, ip, r4
        }
        EXTI->RTSR = temp;
 8000df0:	4c59      	ldr	r4, [pc, #356]	; (8000f58 <HAL_GPIO_Init+0x1f8>)
 8000df2:	60a5      	str	r5, [r4, #8]

        temp = EXTI->FTSR;
 8000df4:	68e4      	ldr	r4, [r4, #12]
        temp &= ~((uint32_t)iocurrent);
 8000df6:	ea02 0504 	and.w	r5, r2, r4
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 8000dfa:	684e      	ldr	r6, [r1, #4]
 8000dfc:	f416 1f00 	tst.w	r6, #2097152	; 0x200000
 8000e00:	d001      	beq.n	8000e06 <HAL_GPIO_Init+0xa6>
        {
          temp |= iocurrent;
 8000e02:	ea4c 0504 	orr.w	r5, ip, r4
        }
        EXTI->FTSR = temp;
 8000e06:	4c54      	ldr	r4, [pc, #336]	; (8000f58 <HAL_GPIO_Init+0x1f8>)
 8000e08:	60e5      	str	r5, [r4, #12]

        temp = EXTI->EMR;
 8000e0a:	6864      	ldr	r4, [r4, #4]
        temp &= ~((uint32_t)iocurrent);
 8000e0c:	ea02 0504 	and.w	r5, r2, r4
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8000e10:	684e      	ldr	r6, [r1, #4]
 8000e12:	f416 3f00 	tst.w	r6, #131072	; 0x20000
 8000e16:	d001      	beq.n	8000e1c <HAL_GPIO_Init+0xbc>
        {
          temp |= iocurrent;
 8000e18:	ea4c 0504 	orr.w	r5, ip, r4
        }
        EXTI->EMR = temp;
 8000e1c:	4c4e      	ldr	r4, [pc, #312]	; (8000f58 <HAL_GPIO_Init+0x1f8>)
 8000e1e:	6065      	str	r5, [r4, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000e20:	6824      	ldr	r4, [r4, #0]
        temp &= ~((uint32_t)iocurrent);
 8000e22:	4022      	ands	r2, r4
        if((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 8000e24:	684d      	ldr	r5, [r1, #4]
 8000e26:	f415 3f80 	tst.w	r5, #65536	; 0x10000
 8000e2a:	d001      	beq.n	8000e30 <HAL_GPIO_Init+0xd0>
        {
          temp |= iocurrent;
 8000e2c:	ea4c 0204 	orr.w	r2, ip, r4
        }
        EXTI->IMR = temp;
 8000e30:	4c49      	ldr	r4, [pc, #292]	; (8000f58 <HAL_GPIO_Init+0x1f8>)
 8000e32:	6022      	str	r2, [r4, #0]
  for(position = 0; position < GPIO_NUMBER; position++)
 8000e34:	3301      	adds	r3, #1
 8000e36:	2b0f      	cmp	r3, #15
 8000e38:	f200 8088 	bhi.w	8000f4c <HAL_GPIO_Init+0x1ec>
    ioposition = ((uint32_t)0x01) << position;
 8000e3c:	2201      	movs	r2, #1
 8000e3e:	409a      	lsls	r2, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000e40:	680c      	ldr	r4, [r1, #0]
 8000e42:	ea04 0c02 	and.w	ip, r4, r2
    if(iocurrent == ioposition)
 8000e46:	ea32 0404 	bics.w	r4, r2, r4
 8000e4a:	d1f3      	bne.n	8000e34 <HAL_GPIO_Init+0xd4>
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8000e4c:	684c      	ldr	r4, [r1, #4]
 8000e4e:	f004 0403 	and.w	r4, r4, #3
 8000e52:	3c01      	subs	r4, #1
 8000e54:	2c01      	cmp	r4, #1
 8000e56:	d98a      	bls.n	8000d6e <HAL_GPIO_Init+0xe>
      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8000e58:	684a      	ldr	r2, [r1, #4]
 8000e5a:	f002 0203 	and.w	r2, r2, #3
 8000e5e:	2a03      	cmp	r2, #3
 8000e60:	d009      	beq.n	8000e76 <HAL_GPIO_Init+0x116>
        temp = GPIOx->PUPDR;
 8000e62:	68c4      	ldr	r4, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8000e64:	005d      	lsls	r5, r3, #1
 8000e66:	2203      	movs	r2, #3
 8000e68:	40aa      	lsls	r2, r5
 8000e6a:	ea24 0402 	bic.w	r4, r4, r2
        temp |= ((GPIO_Init->Pull) << (position * 2));
 8000e6e:	688a      	ldr	r2, [r1, #8]
 8000e70:	40aa      	lsls	r2, r5
 8000e72:	4322      	orrs	r2, r4
        GPIOx->PUPDR = temp;
 8000e74:	60c2      	str	r2, [r0, #12]
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8000e76:	684a      	ldr	r2, [r1, #4]
 8000e78:	f002 0203 	and.w	r2, r2, #3
 8000e7c:	2a02      	cmp	r2, #2
 8000e7e:	d08d      	beq.n	8000d9c <HAL_GPIO_Init+0x3c>
      temp = GPIOx->MODER;
 8000e80:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000e82:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 8000e86:	2203      	movs	r2, #3
 8000e88:	fa02 f20e 	lsl.w	r2, r2, lr
 8000e8c:	ea24 0402 	bic.w	r4, r4, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000e90:	684a      	ldr	r2, [r1, #4]
 8000e92:	f002 0203 	and.w	r2, r2, #3
 8000e96:	fa02 f20e 	lsl.w	r2, r2, lr
 8000e9a:	4322      	orrs	r2, r4
      GPIOx->MODER = temp;
 8000e9c:	6002      	str	r2, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8000e9e:	684a      	ldr	r2, [r1, #4]
 8000ea0:	f412 3f40 	tst.w	r2, #196608	; 0x30000
 8000ea4:	d0c6      	beq.n	8000e34 <HAL_GPIO_Init+0xd4>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000ea6:	4a2d      	ldr	r2, [pc, #180]	; (8000f5c <HAL_GPIO_Init+0x1fc>)
 8000ea8:	6c54      	ldr	r4, [r2, #68]	; 0x44
 8000eaa:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
 8000eae:	6454      	str	r4, [r2, #68]	; 0x44
 8000eb0:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8000eb2:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8000eb6:	9201      	str	r2, [sp, #4]
 8000eb8:	9a01      	ldr	r2, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2];
 8000eba:	089c      	lsrs	r4, r3, #2
 8000ebc:	1ca5      	adds	r5, r4, #2
 8000ebe:	4a25      	ldr	r2, [pc, #148]	; (8000f54 <HAL_GPIO_Init+0x1f4>)
 8000ec0:	f852 5025 	ldr.w	r5, [r2, r5, lsl #2]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000ec4:	f003 0e03 	and.w	lr, r3, #3
 8000ec8:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8000ecc:	220f      	movs	r2, #15
 8000ece:	fa02 f20e 	lsl.w	r2, r2, lr
 8000ed2:	ea25 0502 	bic.w	r5, r5, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000ed6:	4a22      	ldr	r2, [pc, #136]	; (8000f60 <HAL_GPIO_Init+0x200>)
 8000ed8:	4290      	cmp	r0, r2
 8000eda:	f43f af75 	beq.w	8000dc8 <HAL_GPIO_Init+0x68>
 8000ede:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000ee2:	4290      	cmp	r0, r2
 8000ee4:	d022      	beq.n	8000f2c <HAL_GPIO_Init+0x1cc>
 8000ee6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000eea:	4290      	cmp	r0, r2
 8000eec:	d020      	beq.n	8000f30 <HAL_GPIO_Init+0x1d0>
 8000eee:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000ef2:	4290      	cmp	r0, r2
 8000ef4:	d01e      	beq.n	8000f34 <HAL_GPIO_Init+0x1d4>
 8000ef6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000efa:	4290      	cmp	r0, r2
 8000efc:	d01c      	beq.n	8000f38 <HAL_GPIO_Init+0x1d8>
 8000efe:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000f02:	4290      	cmp	r0, r2
 8000f04:	d01a      	beq.n	8000f3c <HAL_GPIO_Init+0x1dc>
 8000f06:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000f0a:	4290      	cmp	r0, r2
 8000f0c:	d018      	beq.n	8000f40 <HAL_GPIO_Init+0x1e0>
 8000f0e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000f12:	4290      	cmp	r0, r2
 8000f14:	d016      	beq.n	8000f44 <HAL_GPIO_Init+0x1e4>
 8000f16:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000f1a:	4290      	cmp	r0, r2
 8000f1c:	d014      	beq.n	8000f48 <HAL_GPIO_Init+0x1e8>
 8000f1e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000f22:	4290      	cmp	r0, r2
 8000f24:	f43f af4e 	beq.w	8000dc4 <HAL_GPIO_Init+0x64>
 8000f28:	220a      	movs	r2, #10
 8000f2a:	e74e      	b.n	8000dca <HAL_GPIO_Init+0x6a>
 8000f2c:	2201      	movs	r2, #1
 8000f2e:	e74c      	b.n	8000dca <HAL_GPIO_Init+0x6a>
 8000f30:	2202      	movs	r2, #2
 8000f32:	e74a      	b.n	8000dca <HAL_GPIO_Init+0x6a>
 8000f34:	2203      	movs	r2, #3
 8000f36:	e748      	b.n	8000dca <HAL_GPIO_Init+0x6a>
 8000f38:	2204      	movs	r2, #4
 8000f3a:	e746      	b.n	8000dca <HAL_GPIO_Init+0x6a>
 8000f3c:	2205      	movs	r2, #5
 8000f3e:	e744      	b.n	8000dca <HAL_GPIO_Init+0x6a>
 8000f40:	2206      	movs	r2, #6
 8000f42:	e742      	b.n	8000dca <HAL_GPIO_Init+0x6a>
 8000f44:	2207      	movs	r2, #7
 8000f46:	e740      	b.n	8000dca <HAL_GPIO_Init+0x6a>
 8000f48:	2208      	movs	r2, #8
 8000f4a:	e73e      	b.n	8000dca <HAL_GPIO_Init+0x6a>
      }
    }
  }
}
 8000f4c:	b002      	add	sp, #8
 8000f4e:	bd70      	pop	{r4, r5, r6, pc}
 8000f50:	4770      	bx	lr
 8000f52:	bf00      	nop
 8000f54:	40013800 	.word	0x40013800
 8000f58:	40013c00 	.word	0x40013c00
 8000f5c:	40023800 	.word	0x40023800
 8000f60:	40020000 	.word	0x40020000

08000f64 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8000f64:	b10a      	cbz	r2, 8000f6a <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
 8000f66:	6181      	str	r1, [r0, #24]
 8000f68:	4770      	bx	lr
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 8000f6a:	0409      	lsls	r1, r1, #16
 8000f6c:	6181      	str	r1, [r0, #24]
  }
}
 8000f6e:	4770      	bx	lr

08000f70 <HAL_PWR_EnableBkUpAccess>:
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  /* Enable access to RTC and backup registers */
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8000f70:	4a02      	ldr	r2, [pc, #8]	; (8000f7c <HAL_PWR_EnableBkUpAccess+0xc>)
 8000f72:	6813      	ldr	r3, [r2, #0]
 8000f74:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000f78:	6013      	str	r3, [r2, #0]
}
 8000f7a:	4770      	bx	lr
 8000f7c:	40007000 	.word	0x40007000

08000f80 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 8000f80:	b510      	push	{r4, lr}
 8000f82:	b082      	sub	sp, #8
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 8000f84:	4b1b      	ldr	r3, [pc, #108]	; (8000ff4 <HAL_PWREx_EnableOverDrive+0x74>)
 8000f86:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000f88:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000f8c:	641a      	str	r2, [r3, #64]	; 0x40
 8000f8e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000f90:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000f94:	9301      	str	r3, [sp, #4]
 8000f96:	9b01      	ldr	r3, [sp, #4]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8000f98:	4a17      	ldr	r2, [pc, #92]	; (8000ff8 <HAL_PWREx_EnableOverDrive+0x78>)
 8000f9a:	6813      	ldr	r3, [r2, #0]
 8000f9c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000fa0:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8000fa2:	f7ff fe33 	bl	8000c0c <HAL_GetTick>
 8000fa6:	4604      	mov	r4, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8000fa8:	4b13      	ldr	r3, [pc, #76]	; (8000ff8 <HAL_PWREx_EnableOverDrive+0x78>)
 8000faa:	685b      	ldr	r3, [r3, #4]
 8000fac:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8000fb0:	d108      	bne.n	8000fc4 <HAL_PWREx_EnableOverDrive+0x44>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8000fb2:	f7ff fe2b 	bl	8000c0c <HAL_GetTick>
 8000fb6:	1b00      	subs	r0, r0, r4
 8000fb8:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8000fbc:	d9f4      	bls.n	8000fa8 <HAL_PWREx_EnableOverDrive+0x28>
    {
      return HAL_TIMEOUT;
 8000fbe:	2003      	movs	r0, #3
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
}
 8000fc0:	b002      	add	sp, #8
 8000fc2:	bd10      	pop	{r4, pc}
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8000fc4:	4a0c      	ldr	r2, [pc, #48]	; (8000ff8 <HAL_PWREx_EnableOverDrive+0x78>)
 8000fc6:	6813      	ldr	r3, [r2, #0]
 8000fc8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000fcc:	6013      	str	r3, [r2, #0]
  tickstart = HAL_GetTick();
 8000fce:	f7ff fe1d 	bl	8000c0c <HAL_GetTick>
 8000fd2:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8000fd4:	4b08      	ldr	r3, [pc, #32]	; (8000ff8 <HAL_PWREx_EnableOverDrive+0x78>)
 8000fd6:	685b      	ldr	r3, [r3, #4]
 8000fd8:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8000fdc:	d107      	bne.n	8000fee <HAL_PWREx_EnableOverDrive+0x6e>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8000fde:	f7ff fe15 	bl	8000c0c <HAL_GetTick>
 8000fe2:	1b00      	subs	r0, r0, r4
 8000fe4:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8000fe8:	d9f4      	bls.n	8000fd4 <HAL_PWREx_EnableOverDrive+0x54>
      return HAL_TIMEOUT;
 8000fea:	2003      	movs	r0, #3
 8000fec:	e7e8      	b.n	8000fc0 <HAL_PWREx_EnableOverDrive+0x40>
  return HAL_OK;
 8000fee:	2000      	movs	r0, #0
 8000ff0:	e7e6      	b.n	8000fc0 <HAL_PWREx_EnableOverDrive+0x40>
 8000ff2:	bf00      	nop
 8000ff4:	40023800 	.word	0x40023800
 8000ff8:	40007000 	.word	0x40007000

08000ffc <HAL_RCC_OscConfig>:
  uint32_t tickstart;
  uint32_t pll_config;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8000ffc:	2800      	cmp	r0, #0
 8000ffe:	f000 8206 	beq.w	800140e <HAL_RCC_OscConfig+0x412>
{
 8001002:	b570      	push	{r4, r5, r6, lr}
 8001004:	b082      	sub	sp, #8
 8001006:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001008:	6803      	ldr	r3, [r0, #0]
 800100a:	f013 0f01 	tst.w	r3, #1
 800100e:	d029      	beq.n	8001064 <HAL_RCC_OscConfig+0x68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 8001010:	4b95      	ldr	r3, [pc, #596]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 8001012:	689b      	ldr	r3, [r3, #8]
 8001014:	f003 030c 	and.w	r3, r3, #12
 8001018:	2b04      	cmp	r3, #4
 800101a:	d01a      	beq.n	8001052 <HAL_RCC_OscConfig+0x56>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800101c:	4b92      	ldr	r3, [pc, #584]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 800101e:	689b      	ldr	r3, [r3, #8]
 8001020:	f003 030c 	and.w	r3, r3, #12
 8001024:	2b08      	cmp	r3, #8
 8001026:	d00f      	beq.n	8001048 <HAL_RCC_OscConfig+0x4c>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001028:	6863      	ldr	r3, [r4, #4]
 800102a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800102e:	d040      	beq.n	80010b2 <HAL_RCC_OscConfig+0xb6>
 8001030:	2b00      	cmp	r3, #0
 8001032:	d154      	bne.n	80010de <HAL_RCC_OscConfig+0xe2>
 8001034:	4b8c      	ldr	r3, [pc, #560]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 8001036:	681a      	ldr	r2, [r3, #0]
 8001038:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800103c:	601a      	str	r2, [r3, #0]
 800103e:	681a      	ldr	r2, [r3, #0]
 8001040:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001044:	601a      	str	r2, [r3, #0]
 8001046:	e039      	b.n	80010bc <HAL_RCC_OscConfig+0xc0>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001048:	4b87      	ldr	r3, [pc, #540]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 800104a:	685b      	ldr	r3, [r3, #4]
 800104c:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8001050:	d0ea      	beq.n	8001028 <HAL_RCC_OscConfig+0x2c>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001052:	4b85      	ldr	r3, [pc, #532]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 8001054:	681b      	ldr	r3, [r3, #0]
 8001056:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800105a:	d003      	beq.n	8001064 <HAL_RCC_OscConfig+0x68>
 800105c:	6863      	ldr	r3, [r4, #4]
 800105e:	2b00      	cmp	r3, #0
 8001060:	f000 81d7 	beq.w	8001412 <HAL_RCC_OscConfig+0x416>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001064:	6823      	ldr	r3, [r4, #0]
 8001066:	f013 0f02 	tst.w	r3, #2
 800106a:	d074      	beq.n	8001156 <HAL_RCC_OscConfig+0x15a>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 800106c:	4b7e      	ldr	r3, [pc, #504]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 800106e:	689b      	ldr	r3, [r3, #8]
 8001070:	f013 0f0c 	tst.w	r3, #12
 8001074:	d05e      	beq.n	8001134 <HAL_RCC_OscConfig+0x138>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001076:	4b7c      	ldr	r3, [pc, #496]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 8001078:	689b      	ldr	r3, [r3, #8]
 800107a:	f003 030c 	and.w	r3, r3, #12
 800107e:	2b08      	cmp	r3, #8
 8001080:	d053      	beq.n	800112a <HAL_RCC_OscConfig+0x12e>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 8001082:	68e3      	ldr	r3, [r4, #12]
 8001084:	2b00      	cmp	r3, #0
 8001086:	f000 8089 	beq.w	800119c <HAL_RCC_OscConfig+0x1a0>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800108a:	4a77      	ldr	r2, [pc, #476]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 800108c:	6813      	ldr	r3, [r2, #0]
 800108e:	f043 0301 	orr.w	r3, r3, #1
 8001092:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001094:	f7ff fdba 	bl	8000c0c <HAL_GetTick>
 8001098:	4605      	mov	r5, r0

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800109a:	4b73      	ldr	r3, [pc, #460]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 800109c:	681b      	ldr	r3, [r3, #0]
 800109e:	f013 0f02 	tst.w	r3, #2
 80010a2:	d172      	bne.n	800118a <HAL_RCC_OscConfig+0x18e>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80010a4:	f7ff fdb2 	bl	8000c0c <HAL_GetTick>
 80010a8:	1b40      	subs	r0, r0, r5
 80010aa:	2802      	cmp	r0, #2
 80010ac:	d9f5      	bls.n	800109a <HAL_RCC_OscConfig+0x9e>
          {
            return HAL_TIMEOUT;
 80010ae:	2003      	movs	r0, #3
 80010b0:	e1b4      	b.n	800141c <HAL_RCC_OscConfig+0x420>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80010b2:	4a6d      	ldr	r2, [pc, #436]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 80010b4:	6813      	ldr	r3, [r2, #0]
 80010b6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80010ba:	6013      	str	r3, [r2, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80010bc:	6863      	ldr	r3, [r4, #4]
 80010be:	b32b      	cbz	r3, 800110c <HAL_RCC_OscConfig+0x110>
        tickstart = HAL_GetTick();
 80010c0:	f7ff fda4 	bl	8000c0c <HAL_GetTick>
 80010c4:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80010c6:	4b68      	ldr	r3, [pc, #416]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 80010c8:	681b      	ldr	r3, [r3, #0]
 80010ca:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80010ce:	d1c9      	bne.n	8001064 <HAL_RCC_OscConfig+0x68>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80010d0:	f7ff fd9c 	bl	8000c0c <HAL_GetTick>
 80010d4:	1b40      	subs	r0, r0, r5
 80010d6:	2864      	cmp	r0, #100	; 0x64
 80010d8:	d9f5      	bls.n	80010c6 <HAL_RCC_OscConfig+0xca>
            return HAL_TIMEOUT;
 80010da:	2003      	movs	r0, #3
 80010dc:	e19e      	b.n	800141c <HAL_RCC_OscConfig+0x420>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80010de:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80010e2:	d009      	beq.n	80010f8 <HAL_RCC_OscConfig+0xfc>
 80010e4:	4b60      	ldr	r3, [pc, #384]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 80010e6:	681a      	ldr	r2, [r3, #0]
 80010e8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80010ec:	601a      	str	r2, [r3, #0]
 80010ee:	681a      	ldr	r2, [r3, #0]
 80010f0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80010f4:	601a      	str	r2, [r3, #0]
 80010f6:	e7e1      	b.n	80010bc <HAL_RCC_OscConfig+0xc0>
 80010f8:	4b5b      	ldr	r3, [pc, #364]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 80010fa:	681a      	ldr	r2, [r3, #0]
 80010fc:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8001100:	601a      	str	r2, [r3, #0]
 8001102:	681a      	ldr	r2, [r3, #0]
 8001104:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001108:	601a      	str	r2, [r3, #0]
 800110a:	e7d7      	b.n	80010bc <HAL_RCC_OscConfig+0xc0>
        tickstart = HAL_GetTick();
 800110c:	f7ff fd7e 	bl	8000c0c <HAL_GetTick>
 8001110:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001112:	4b55      	ldr	r3, [pc, #340]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 8001114:	681b      	ldr	r3, [r3, #0]
 8001116:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800111a:	d0a3      	beq.n	8001064 <HAL_RCC_OscConfig+0x68>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800111c:	f7ff fd76 	bl	8000c0c <HAL_GetTick>
 8001120:	1b40      	subs	r0, r0, r5
 8001122:	2864      	cmp	r0, #100	; 0x64
 8001124:	d9f5      	bls.n	8001112 <HAL_RCC_OscConfig+0x116>
            return HAL_TIMEOUT;
 8001126:	2003      	movs	r0, #3
 8001128:	e178      	b.n	800141c <HAL_RCC_OscConfig+0x420>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800112a:	4b4f      	ldr	r3, [pc, #316]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 800112c:	685b      	ldr	r3, [r3, #4]
 800112e:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8001132:	d1a6      	bne.n	8001082 <HAL_RCC_OscConfig+0x86>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001134:	4b4c      	ldr	r3, [pc, #304]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 8001136:	681b      	ldr	r3, [r3, #0]
 8001138:	f013 0f02 	tst.w	r3, #2
 800113c:	d003      	beq.n	8001146 <HAL_RCC_OscConfig+0x14a>
 800113e:	68e3      	ldr	r3, [r4, #12]
 8001140:	2b01      	cmp	r3, #1
 8001142:	f040 8168 	bne.w	8001416 <HAL_RCC_OscConfig+0x41a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001146:	4a48      	ldr	r2, [pc, #288]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 8001148:	6813      	ldr	r3, [r2, #0]
 800114a:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800114e:	6921      	ldr	r1, [r4, #16]
 8001150:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001154:	6013      	str	r3, [r2, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001156:	6823      	ldr	r3, [r4, #0]
 8001158:	f013 0f08 	tst.w	r3, #8
 800115c:	d046      	beq.n	80011ec <HAL_RCC_OscConfig+0x1f0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 800115e:	6963      	ldr	r3, [r4, #20]
 8001160:	b383      	cbz	r3, 80011c4 <HAL_RCC_OscConfig+0x1c8>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001162:	4a41      	ldr	r2, [pc, #260]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 8001164:	6f53      	ldr	r3, [r2, #116]	; 0x74
 8001166:	f043 0301 	orr.w	r3, r3, #1
 800116a:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800116c:	f7ff fd4e 	bl	8000c0c <HAL_GetTick>
 8001170:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001172:	4b3d      	ldr	r3, [pc, #244]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 8001174:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001176:	f013 0f02 	tst.w	r3, #2
 800117a:	d137      	bne.n	80011ec <HAL_RCC_OscConfig+0x1f0>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800117c:	f7ff fd46 	bl	8000c0c <HAL_GetTick>
 8001180:	1b40      	subs	r0, r0, r5
 8001182:	2802      	cmp	r0, #2
 8001184:	d9f5      	bls.n	8001172 <HAL_RCC_OscConfig+0x176>
        {
          return HAL_TIMEOUT;
 8001186:	2003      	movs	r0, #3
 8001188:	e148      	b.n	800141c <HAL_RCC_OscConfig+0x420>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800118a:	4a37      	ldr	r2, [pc, #220]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 800118c:	6813      	ldr	r3, [r2, #0]
 800118e:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001192:	6921      	ldr	r1, [r4, #16]
 8001194:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001198:	6013      	str	r3, [r2, #0]
 800119a:	e7dc      	b.n	8001156 <HAL_RCC_OscConfig+0x15a>
        __HAL_RCC_HSI_DISABLE();
 800119c:	4a32      	ldr	r2, [pc, #200]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 800119e:	6813      	ldr	r3, [r2, #0]
 80011a0:	f023 0301 	bic.w	r3, r3, #1
 80011a4:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80011a6:	f7ff fd31 	bl	8000c0c <HAL_GetTick>
 80011aa:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80011ac:	4b2e      	ldr	r3, [pc, #184]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 80011ae:	681b      	ldr	r3, [r3, #0]
 80011b0:	f013 0f02 	tst.w	r3, #2
 80011b4:	d0cf      	beq.n	8001156 <HAL_RCC_OscConfig+0x15a>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80011b6:	f7ff fd29 	bl	8000c0c <HAL_GetTick>
 80011ba:	1b40      	subs	r0, r0, r5
 80011bc:	2802      	cmp	r0, #2
 80011be:	d9f5      	bls.n	80011ac <HAL_RCC_OscConfig+0x1b0>
            return HAL_TIMEOUT;
 80011c0:	2003      	movs	r0, #3
 80011c2:	e12b      	b.n	800141c <HAL_RCC_OscConfig+0x420>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80011c4:	4a28      	ldr	r2, [pc, #160]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 80011c6:	6f53      	ldr	r3, [r2, #116]	; 0x74
 80011c8:	f023 0301 	bic.w	r3, r3, #1
 80011cc:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80011ce:	f7ff fd1d 	bl	8000c0c <HAL_GetTick>
 80011d2:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80011d4:	4b24      	ldr	r3, [pc, #144]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 80011d6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80011d8:	f013 0f02 	tst.w	r3, #2
 80011dc:	d006      	beq.n	80011ec <HAL_RCC_OscConfig+0x1f0>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80011de:	f7ff fd15 	bl	8000c0c <HAL_GetTick>
 80011e2:	1b40      	subs	r0, r0, r5
 80011e4:	2802      	cmp	r0, #2
 80011e6:	d9f5      	bls.n	80011d4 <HAL_RCC_OscConfig+0x1d8>
        {
          return HAL_TIMEOUT;
 80011e8:	2003      	movs	r0, #3
 80011ea:	e117      	b.n	800141c <HAL_RCC_OscConfig+0x420>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80011ec:	6823      	ldr	r3, [r4, #0]
 80011ee:	f013 0f04 	tst.w	r3, #4
 80011f2:	d07d      	beq.n	80012f0 <HAL_RCC_OscConfig+0x2f4>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 80011f4:	4b1c      	ldr	r3, [pc, #112]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 80011f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80011f8:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 80011fc:	d11e      	bne.n	800123c <HAL_RCC_OscConfig+0x240>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 80011fe:	4b1a      	ldr	r3, [pc, #104]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 8001200:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001202:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001206:	641a      	str	r2, [r3, #64]	; 0x40
 8001208:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800120a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800120e:	9301      	str	r3, [sp, #4]
 8001210:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8001212:	2501      	movs	r5, #1
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8001214:	4b15      	ldr	r3, [pc, #84]	; (800126c <HAL_RCC_OscConfig+0x270>)
 8001216:	681b      	ldr	r3, [r3, #0]
 8001218:	f413 7f80 	tst.w	r3, #256	; 0x100
 800121c:	d010      	beq.n	8001240 <HAL_RCC_OscConfig+0x244>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800121e:	68a3      	ldr	r3, [r4, #8]
 8001220:	2b01      	cmp	r3, #1
 8001222:	d025      	beq.n	8001270 <HAL_RCC_OscConfig+0x274>
 8001224:	2b00      	cmp	r3, #0
 8001226:	d13b      	bne.n	80012a0 <HAL_RCC_OscConfig+0x2a4>
 8001228:	4b0f      	ldr	r3, [pc, #60]	; (8001268 <HAL_RCC_OscConfig+0x26c>)
 800122a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800122c:	f022 0201 	bic.w	r2, r2, #1
 8001230:	671a      	str	r2, [r3, #112]	; 0x70
 8001232:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001234:	f022 0204 	bic.w	r2, r2, #4
 8001238:	671a      	str	r2, [r3, #112]	; 0x70
 800123a:	e01e      	b.n	800127a <HAL_RCC_OscConfig+0x27e>
  FlagStatus pwrclkchanged = RESET;
 800123c:	2500      	movs	r5, #0
 800123e:	e7e9      	b.n	8001214 <HAL_RCC_OscConfig+0x218>
      PWR->CR1 |= PWR_CR1_DBP;
 8001240:	4a0a      	ldr	r2, [pc, #40]	; (800126c <HAL_RCC_OscConfig+0x270>)
 8001242:	6813      	ldr	r3, [r2, #0]
 8001244:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001248:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 800124a:	f7ff fcdf 	bl	8000c0c <HAL_GetTick>
 800124e:	4606      	mov	r6, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8001250:	4b06      	ldr	r3, [pc, #24]	; (800126c <HAL_RCC_OscConfig+0x270>)
 8001252:	681b      	ldr	r3, [r3, #0]
 8001254:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001258:	d1e1      	bne.n	800121e <HAL_RCC_OscConfig+0x222>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800125a:	f7ff fcd7 	bl	8000c0c <HAL_GetTick>
 800125e:	1b80      	subs	r0, r0, r6
 8001260:	2864      	cmp	r0, #100	; 0x64
 8001262:	d9f5      	bls.n	8001250 <HAL_RCC_OscConfig+0x254>
          return HAL_TIMEOUT;
 8001264:	2003      	movs	r0, #3
 8001266:	e0d9      	b.n	800141c <HAL_RCC_OscConfig+0x420>
 8001268:	40023800 	.word	0x40023800
 800126c:	40007000 	.word	0x40007000
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001270:	4a72      	ldr	r2, [pc, #456]	; (800143c <HAL_RCC_OscConfig+0x440>)
 8001272:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8001274:	f043 0301 	orr.w	r3, r3, #1
 8001278:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800127a:	68a3      	ldr	r3, [r4, #8]
 800127c:	b333      	cbz	r3, 80012cc <HAL_RCC_OscConfig+0x2d0>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800127e:	f7ff fcc5 	bl	8000c0c <HAL_GetTick>
 8001282:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001284:	4b6d      	ldr	r3, [pc, #436]	; (800143c <HAL_RCC_OscConfig+0x440>)
 8001286:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001288:	f013 0f02 	tst.w	r3, #2
 800128c:	d12f      	bne.n	80012ee <HAL_RCC_OscConfig+0x2f2>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800128e:	f7ff fcbd 	bl	8000c0c <HAL_GetTick>
 8001292:	1b80      	subs	r0, r0, r6
 8001294:	f241 3388 	movw	r3, #5000	; 0x1388
 8001298:	4298      	cmp	r0, r3
 800129a:	d9f3      	bls.n	8001284 <HAL_RCC_OscConfig+0x288>
        {
          return HAL_TIMEOUT;
 800129c:	2003      	movs	r0, #3
 800129e:	e0bd      	b.n	800141c <HAL_RCC_OscConfig+0x420>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80012a0:	2b05      	cmp	r3, #5
 80012a2:	d009      	beq.n	80012b8 <HAL_RCC_OscConfig+0x2bc>
 80012a4:	4b65      	ldr	r3, [pc, #404]	; (800143c <HAL_RCC_OscConfig+0x440>)
 80012a6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80012a8:	f022 0201 	bic.w	r2, r2, #1
 80012ac:	671a      	str	r2, [r3, #112]	; 0x70
 80012ae:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80012b0:	f022 0204 	bic.w	r2, r2, #4
 80012b4:	671a      	str	r2, [r3, #112]	; 0x70
 80012b6:	e7e0      	b.n	800127a <HAL_RCC_OscConfig+0x27e>
 80012b8:	4b60      	ldr	r3, [pc, #384]	; (800143c <HAL_RCC_OscConfig+0x440>)
 80012ba:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80012bc:	f042 0204 	orr.w	r2, r2, #4
 80012c0:	671a      	str	r2, [r3, #112]	; 0x70
 80012c2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80012c4:	f042 0201 	orr.w	r2, r2, #1
 80012c8:	671a      	str	r2, [r3, #112]	; 0x70
 80012ca:	e7d6      	b.n	800127a <HAL_RCC_OscConfig+0x27e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80012cc:	f7ff fc9e 	bl	8000c0c <HAL_GetTick>
 80012d0:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80012d2:	4b5a      	ldr	r3, [pc, #360]	; (800143c <HAL_RCC_OscConfig+0x440>)
 80012d4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80012d6:	f013 0f02 	tst.w	r3, #2
 80012da:	d008      	beq.n	80012ee <HAL_RCC_OscConfig+0x2f2>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80012dc:	f7ff fc96 	bl	8000c0c <HAL_GetTick>
 80012e0:	1b80      	subs	r0, r0, r6
 80012e2:	f241 3388 	movw	r3, #5000	; 0x1388
 80012e6:	4298      	cmp	r0, r3
 80012e8:	d9f3      	bls.n	80012d2 <HAL_RCC_OscConfig+0x2d6>
        {
          return HAL_TIMEOUT;
 80012ea:	2003      	movs	r0, #3
 80012ec:	e096      	b.n	800141c <HAL_RCC_OscConfig+0x420>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 80012ee:	b9fd      	cbnz	r5, 8001330 <HAL_RCC_OscConfig+0x334>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80012f0:	69a3      	ldr	r3, [r4, #24]
 80012f2:	2b00      	cmp	r3, #0
 80012f4:	f000 8091 	beq.w	800141a <HAL_RCC_OscConfig+0x41e>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80012f8:	4a50      	ldr	r2, [pc, #320]	; (800143c <HAL_RCC_OscConfig+0x440>)
 80012fa:	6892      	ldr	r2, [r2, #8]
 80012fc:	f002 020c 	and.w	r2, r2, #12
 8001300:	2a08      	cmp	r2, #8
 8001302:	d059      	beq.n	80013b8 <HAL_RCC_OscConfig+0x3bc>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001304:	2b02      	cmp	r3, #2
 8001306:	d019      	beq.n	800133c <HAL_RCC_OscConfig+0x340>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001308:	4a4c      	ldr	r2, [pc, #304]	; (800143c <HAL_RCC_OscConfig+0x440>)
 800130a:	6813      	ldr	r3, [r2, #0]
 800130c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8001310:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001312:	f7ff fc7b 	bl	8000c0c <HAL_GetTick>
 8001316:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001318:	4b48      	ldr	r3, [pc, #288]	; (800143c <HAL_RCC_OscConfig+0x440>)
 800131a:	681b      	ldr	r3, [r3, #0]
 800131c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001320:	d048      	beq.n	80013b4 <HAL_RCC_OscConfig+0x3b8>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001322:	f7ff fc73 	bl	8000c0c <HAL_GetTick>
 8001326:	1b00      	subs	r0, r0, r4
 8001328:	2802      	cmp	r0, #2
 800132a:	d9f5      	bls.n	8001318 <HAL_RCC_OscConfig+0x31c>
          {
            return HAL_TIMEOUT;
 800132c:	2003      	movs	r0, #3
 800132e:	e075      	b.n	800141c <HAL_RCC_OscConfig+0x420>
      __HAL_RCC_PWR_CLK_DISABLE();
 8001330:	4a42      	ldr	r2, [pc, #264]	; (800143c <HAL_RCC_OscConfig+0x440>)
 8001332:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8001334:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001338:	6413      	str	r3, [r2, #64]	; 0x40
 800133a:	e7d9      	b.n	80012f0 <HAL_RCC_OscConfig+0x2f4>
        __HAL_RCC_PLL_DISABLE();
 800133c:	4a3f      	ldr	r2, [pc, #252]	; (800143c <HAL_RCC_OscConfig+0x440>)
 800133e:	6813      	ldr	r3, [r2, #0]
 8001340:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8001344:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8001346:	f7ff fc61 	bl	8000c0c <HAL_GetTick>
 800134a:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800134c:	4b3b      	ldr	r3, [pc, #236]	; (800143c <HAL_RCC_OscConfig+0x440>)
 800134e:	681b      	ldr	r3, [r3, #0]
 8001350:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001354:	d006      	beq.n	8001364 <HAL_RCC_OscConfig+0x368>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001356:	f7ff fc59 	bl	8000c0c <HAL_GetTick>
 800135a:	1b40      	subs	r0, r0, r5
 800135c:	2802      	cmp	r0, #2
 800135e:	d9f5      	bls.n	800134c <HAL_RCC_OscConfig+0x350>
            return HAL_TIMEOUT;
 8001360:	2003      	movs	r0, #3
 8001362:	e05b      	b.n	800141c <HAL_RCC_OscConfig+0x420>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001364:	69e3      	ldr	r3, [r4, #28]
 8001366:	6a22      	ldr	r2, [r4, #32]
 8001368:	4313      	orrs	r3, r2
 800136a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800136c:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8001370:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001372:	0852      	lsrs	r2, r2, #1
 8001374:	3a01      	subs	r2, #1
 8001376:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800137a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800137c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001380:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8001382:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 8001386:	4a2d      	ldr	r2, [pc, #180]	; (800143c <HAL_RCC_OscConfig+0x440>)
 8001388:	6053      	str	r3, [r2, #4]
        __HAL_RCC_PLL_ENABLE();
 800138a:	6813      	ldr	r3, [r2, #0]
 800138c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001390:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8001392:	f7ff fc3b 	bl	8000c0c <HAL_GetTick>
 8001396:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001398:	4b28      	ldr	r3, [pc, #160]	; (800143c <HAL_RCC_OscConfig+0x440>)
 800139a:	681b      	ldr	r3, [r3, #0]
 800139c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80013a0:	d106      	bne.n	80013b0 <HAL_RCC_OscConfig+0x3b4>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80013a2:	f7ff fc33 	bl	8000c0c <HAL_GetTick>
 80013a6:	1b00      	subs	r0, r0, r4
 80013a8:	2802      	cmp	r0, #2
 80013aa:	d9f5      	bls.n	8001398 <HAL_RCC_OscConfig+0x39c>
            return HAL_TIMEOUT;
 80013ac:	2003      	movs	r0, #3
 80013ae:	e035      	b.n	800141c <HAL_RCC_OscConfig+0x420>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 80013b0:	2000      	movs	r0, #0
 80013b2:	e033      	b.n	800141c <HAL_RCC_OscConfig+0x420>
 80013b4:	2000      	movs	r0, #0
 80013b6:	e031      	b.n	800141c <HAL_RCC_OscConfig+0x420>
      pll_config = RCC->PLLCFGR;
 80013b8:	4a20      	ldr	r2, [pc, #128]	; (800143c <HAL_RCC_OscConfig+0x440>)
 80013ba:	6852      	ldr	r2, [r2, #4]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80013bc:	2b01      	cmp	r3, #1
 80013be:	d02f      	beq.n	8001420 <HAL_RCC_OscConfig+0x424>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80013c0:	f402 0380 	and.w	r3, r2, #4194304	; 0x400000
 80013c4:	69e1      	ldr	r1, [r4, #28]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80013c6:	428b      	cmp	r3, r1
 80013c8:	d12c      	bne.n	8001424 <HAL_RCC_OscConfig+0x428>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 80013ca:	f002 033f 	and.w	r3, r2, #63	; 0x3f
 80013ce:	6a21      	ldr	r1, [r4, #32]
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80013d0:	428b      	cmp	r3, r1
 80013d2:	d129      	bne.n	8001428 <HAL_RCC_OscConfig+0x42c>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 80013d4:	6a61      	ldr	r1, [r4, #36]	; 0x24
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 80013d6:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80013da:	4013      	ands	r3, r2
 80013dc:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
 80013e0:	d124      	bne.n	800142c <HAL_RCC_OscConfig+0x430>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 80013e2:	f402 3140 	and.w	r1, r2, #196608	; 0x30000
 80013e6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80013e8:	085b      	lsrs	r3, r3, #1
 80013ea:	3b01      	subs	r3, #1
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 80013ec:	ebb1 4f03 	cmp.w	r1, r3, lsl #16
 80013f0:	d11e      	bne.n	8001430 <HAL_RCC_OscConfig+0x434>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
 80013f2:	f002 6370 	and.w	r3, r2, #251658240	; 0xf000000
 80013f6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 80013f8:	ebb3 6f01 	cmp.w	r3, r1, lsl #24
 80013fc:	d11a      	bne.n	8001434 <HAL_RCC_OscConfig+0x438>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
 80013fe:	f002 42e0 	and.w	r2, r2, #1879048192	; 0x70000000
 8001402:	6b23      	ldr	r3, [r4, #48]	; 0x30
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
 8001404:	ebb2 7f03 	cmp.w	r2, r3, lsl #28
 8001408:	d116      	bne.n	8001438 <HAL_RCC_OscConfig+0x43c>
  return HAL_OK;
 800140a:	2000      	movs	r0, #0
 800140c:	e006      	b.n	800141c <HAL_RCC_OscConfig+0x420>
    return HAL_ERROR;
 800140e:	2001      	movs	r0, #1
}
 8001410:	4770      	bx	lr
        return HAL_ERROR;
 8001412:	2001      	movs	r0, #1
 8001414:	e002      	b.n	800141c <HAL_RCC_OscConfig+0x420>
        return HAL_ERROR;
 8001416:	2001      	movs	r0, #1
 8001418:	e000      	b.n	800141c <HAL_RCC_OscConfig+0x420>
  return HAL_OK;
 800141a:	2000      	movs	r0, #0
}
 800141c:	b002      	add	sp, #8
 800141e:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 8001420:	2001      	movs	r0, #1
 8001422:	e7fb      	b.n	800141c <HAL_RCC_OscConfig+0x420>
 8001424:	2001      	movs	r0, #1
 8001426:	e7f9      	b.n	800141c <HAL_RCC_OscConfig+0x420>
 8001428:	2001      	movs	r0, #1
 800142a:	e7f7      	b.n	800141c <HAL_RCC_OscConfig+0x420>
 800142c:	2001      	movs	r0, #1
 800142e:	e7f5      	b.n	800141c <HAL_RCC_OscConfig+0x420>
 8001430:	2001      	movs	r0, #1
 8001432:	e7f3      	b.n	800141c <HAL_RCC_OscConfig+0x420>
 8001434:	2001      	movs	r0, #1
 8001436:	e7f1      	b.n	800141c <HAL_RCC_OscConfig+0x420>
 8001438:	2001      	movs	r0, #1
 800143a:	e7ef      	b.n	800141c <HAL_RCC_OscConfig+0x420>
 800143c:	40023800 	.word	0x40023800

08001440 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8001440:	b508      	push	{r3, lr}
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001442:	4b33      	ldr	r3, [pc, #204]	; (8001510 <HAL_RCC_GetSysClockFreq+0xd0>)
 8001444:	689b      	ldr	r3, [r3, #8]
 8001446:	f003 030c 	and.w	r3, r3, #12
 800144a:	2b04      	cmp	r3, #4
 800144c:	d05b      	beq.n	8001506 <HAL_RCC_GetSysClockFreq+0xc6>
 800144e:	2b08      	cmp	r3, #8
 8001450:	d15b      	bne.n	800150a <HAL_RCC_GetSysClockFreq+0xca>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001452:	4b2f      	ldr	r3, [pc, #188]	; (8001510 <HAL_RCC_GetSysClockFreq+0xd0>)
 8001454:	685a      	ldr	r2, [r3, #4]
 8001456:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800145a:	685b      	ldr	r3, [r3, #4]
 800145c:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8001460:	d02c      	beq.n	80014bc <HAL_RCC_GetSysClockFreq+0x7c>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8001462:	4b2b      	ldr	r3, [pc, #172]	; (8001510 <HAL_RCC_GetSysClockFreq+0xd0>)
 8001464:	6858      	ldr	r0, [r3, #4]
 8001466:	f3c0 1088 	ubfx	r0, r0, #6, #9
 800146a:	ea4f 1c40 	mov.w	ip, r0, lsl #5
 800146e:	ebbc 0c00 	subs.w	ip, ip, r0
 8001472:	eb6e 0e0e 	sbc.w	lr, lr, lr
 8001476:	ea4f 138e 	mov.w	r3, lr, lsl #6
 800147a:	ea43 639c 	orr.w	r3, r3, ip, lsr #26
 800147e:	ea4f 118c 	mov.w	r1, ip, lsl #6
 8001482:	ebb1 010c 	subs.w	r1, r1, ip
 8001486:	eb63 030e 	sbc.w	r3, r3, lr
 800148a:	00db      	lsls	r3, r3, #3
 800148c:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 8001490:	00c9      	lsls	r1, r1, #3
 8001492:	eb11 0c00 	adds.w	ip, r1, r0
 8001496:	f143 0300 	adc.w	r3, r3, #0
 800149a:	0259      	lsls	r1, r3, #9
 800149c:	2300      	movs	r3, #0
 800149e:	ea4f 204c 	mov.w	r0, ip, lsl #9
 80014a2:	ea41 51dc 	orr.w	r1, r1, ip, lsr #23
 80014a6:	f7fe ff33 	bl	8000310 <__aeabi_uldivmod>
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 80014aa:	4b19      	ldr	r3, [pc, #100]	; (8001510 <HAL_RCC_GetSysClockFreq+0xd0>)
 80014ac:	685b      	ldr	r3, [r3, #4]
 80014ae:	f3c3 4301 	ubfx	r3, r3, #16, #2
 80014b2:	3301      	adds	r3, #1
 80014b4:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco / pllp;
 80014b6:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
 80014ba:	e027      	b.n	800150c <HAL_RCC_GetSysClockFreq+0xcc>
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80014bc:	4b14      	ldr	r3, [pc, #80]	; (8001510 <HAL_RCC_GetSysClockFreq+0xd0>)
 80014be:	6858      	ldr	r0, [r3, #4]
 80014c0:	f3c0 1088 	ubfx	r0, r0, #6, #9
 80014c4:	ea4f 1c40 	mov.w	ip, r0, lsl #5
 80014c8:	ebbc 0c00 	subs.w	ip, ip, r0
 80014cc:	eb6e 0e0e 	sbc.w	lr, lr, lr
 80014d0:	ea4f 138e 	mov.w	r3, lr, lsl #6
 80014d4:	ea43 639c 	orr.w	r3, r3, ip, lsr #26
 80014d8:	ea4f 118c 	mov.w	r1, ip, lsl #6
 80014dc:	ebb1 010c 	subs.w	r1, r1, ip
 80014e0:	eb63 030e 	sbc.w	r3, r3, lr
 80014e4:	00db      	lsls	r3, r3, #3
 80014e6:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 80014ea:	00c9      	lsls	r1, r1, #3
 80014ec:	eb11 0c00 	adds.w	ip, r1, r0
 80014f0:	f143 0300 	adc.w	r3, r3, #0
 80014f4:	0299      	lsls	r1, r3, #10
 80014f6:	2300      	movs	r3, #0
 80014f8:	ea4f 208c 	mov.w	r0, ip, lsl #10
 80014fc:	ea41 519c 	orr.w	r1, r1, ip, lsr #22
 8001500:	f7fe ff06 	bl	8000310 <__aeabi_uldivmod>
 8001504:	e7d1      	b.n	80014aa <HAL_RCC_GetSysClockFreq+0x6a>
      sysclockfreq = HSE_VALUE;
 8001506:	4803      	ldr	r0, [pc, #12]	; (8001514 <HAL_RCC_GetSysClockFreq+0xd4>)
 8001508:	e000      	b.n	800150c <HAL_RCC_GetSysClockFreq+0xcc>
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800150a:	4803      	ldr	r0, [pc, #12]	; (8001518 <HAL_RCC_GetSysClockFreq+0xd8>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 800150c:	bd08      	pop	{r3, pc}
 800150e:	bf00      	nop
 8001510:	40023800 	.word	0x40023800
 8001514:	007a1200 	.word	0x007a1200
 8001518:	00f42400 	.word	0x00f42400

0800151c <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 800151c:	2800      	cmp	r0, #0
 800151e:	f000 80a0 	beq.w	8001662 <HAL_RCC_ClockConfig+0x146>
{
 8001522:	b570      	push	{r4, r5, r6, lr}
 8001524:	460d      	mov	r5, r1
 8001526:	4604      	mov	r4, r0
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8001528:	4b52      	ldr	r3, [pc, #328]	; (8001674 <HAL_RCC_ClockConfig+0x158>)
 800152a:	681b      	ldr	r3, [r3, #0]
 800152c:	f003 030f 	and.w	r3, r3, #15
 8001530:	428b      	cmp	r3, r1
 8001532:	d20b      	bcs.n	800154c <HAL_RCC_ClockConfig+0x30>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001534:	4a4f      	ldr	r2, [pc, #316]	; (8001674 <HAL_RCC_ClockConfig+0x158>)
 8001536:	6813      	ldr	r3, [r2, #0]
 8001538:	f023 030f 	bic.w	r3, r3, #15
 800153c:	430b      	orrs	r3, r1
 800153e:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8001540:	6813      	ldr	r3, [r2, #0]
 8001542:	f003 030f 	and.w	r3, r3, #15
 8001546:	428b      	cmp	r3, r1
 8001548:	f040 808d 	bne.w	8001666 <HAL_RCC_ClockConfig+0x14a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800154c:	6823      	ldr	r3, [r4, #0]
 800154e:	f013 0f02 	tst.w	r3, #2
 8001552:	d017      	beq.n	8001584 <HAL_RCC_ClockConfig+0x68>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001554:	f013 0f04 	tst.w	r3, #4
 8001558:	d004      	beq.n	8001564 <HAL_RCC_ClockConfig+0x48>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800155a:	4a47      	ldr	r2, [pc, #284]	; (8001678 <HAL_RCC_ClockConfig+0x15c>)
 800155c:	6893      	ldr	r3, [r2, #8]
 800155e:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 8001562:	6093      	str	r3, [r2, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001564:	6823      	ldr	r3, [r4, #0]
 8001566:	f013 0f08 	tst.w	r3, #8
 800156a:	d004      	beq.n	8001576 <HAL_RCC_ClockConfig+0x5a>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800156c:	4a42      	ldr	r2, [pc, #264]	; (8001678 <HAL_RCC_ClockConfig+0x15c>)
 800156e:	6893      	ldr	r3, [r2, #8]
 8001570:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 8001574:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001576:	4a40      	ldr	r2, [pc, #256]	; (8001678 <HAL_RCC_ClockConfig+0x15c>)
 8001578:	6893      	ldr	r3, [r2, #8]
 800157a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800157e:	68a1      	ldr	r1, [r4, #8]
 8001580:	430b      	orrs	r3, r1
 8001582:	6093      	str	r3, [r2, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001584:	6823      	ldr	r3, [r4, #0]
 8001586:	f013 0f01 	tst.w	r3, #1
 800158a:	d031      	beq.n	80015f0 <HAL_RCC_ClockConfig+0xd4>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800158c:	6863      	ldr	r3, [r4, #4]
 800158e:	2b01      	cmp	r3, #1
 8001590:	d020      	beq.n	80015d4 <HAL_RCC_ClockConfig+0xb8>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001592:	2b02      	cmp	r3, #2
 8001594:	d025      	beq.n	80015e2 <HAL_RCC_ClockConfig+0xc6>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001596:	4a38      	ldr	r2, [pc, #224]	; (8001678 <HAL_RCC_ClockConfig+0x15c>)
 8001598:	6812      	ldr	r2, [r2, #0]
 800159a:	f012 0f02 	tst.w	r2, #2
 800159e:	d064      	beq.n	800166a <HAL_RCC_ClockConfig+0x14e>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80015a0:	4935      	ldr	r1, [pc, #212]	; (8001678 <HAL_RCC_ClockConfig+0x15c>)
 80015a2:	688a      	ldr	r2, [r1, #8]
 80015a4:	f022 0203 	bic.w	r2, r2, #3
 80015a8:	4313      	orrs	r3, r2
 80015aa:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 80015ac:	f7ff fb2e 	bl	8000c0c <HAL_GetTick>
 80015b0:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80015b2:	4b31      	ldr	r3, [pc, #196]	; (8001678 <HAL_RCC_ClockConfig+0x15c>)
 80015b4:	689b      	ldr	r3, [r3, #8]
 80015b6:	f003 030c 	and.w	r3, r3, #12
 80015ba:	6862      	ldr	r2, [r4, #4]
 80015bc:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80015c0:	d016      	beq.n	80015f0 <HAL_RCC_ClockConfig+0xd4>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80015c2:	f7ff fb23 	bl	8000c0c <HAL_GetTick>
 80015c6:	1b80      	subs	r0, r0, r6
 80015c8:	f241 3388 	movw	r3, #5000	; 0x1388
 80015cc:	4298      	cmp	r0, r3
 80015ce:	d9f0      	bls.n	80015b2 <HAL_RCC_ClockConfig+0x96>
        return HAL_TIMEOUT;
 80015d0:	2003      	movs	r0, #3
 80015d2:	e045      	b.n	8001660 <HAL_RCC_ClockConfig+0x144>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80015d4:	4a28      	ldr	r2, [pc, #160]	; (8001678 <HAL_RCC_ClockConfig+0x15c>)
 80015d6:	6812      	ldr	r2, [r2, #0]
 80015d8:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 80015dc:	d1e0      	bne.n	80015a0 <HAL_RCC_ClockConfig+0x84>
        return HAL_ERROR;
 80015de:	2001      	movs	r0, #1
 80015e0:	e03e      	b.n	8001660 <HAL_RCC_ClockConfig+0x144>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80015e2:	4a25      	ldr	r2, [pc, #148]	; (8001678 <HAL_RCC_ClockConfig+0x15c>)
 80015e4:	6812      	ldr	r2, [r2, #0]
 80015e6:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 80015ea:	d1d9      	bne.n	80015a0 <HAL_RCC_ClockConfig+0x84>
        return HAL_ERROR;
 80015ec:	2001      	movs	r0, #1
 80015ee:	e037      	b.n	8001660 <HAL_RCC_ClockConfig+0x144>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 80015f0:	4b20      	ldr	r3, [pc, #128]	; (8001674 <HAL_RCC_ClockConfig+0x158>)
 80015f2:	681b      	ldr	r3, [r3, #0]
 80015f4:	f003 030f 	and.w	r3, r3, #15
 80015f8:	42ab      	cmp	r3, r5
 80015fa:	d90a      	bls.n	8001612 <HAL_RCC_ClockConfig+0xf6>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80015fc:	4a1d      	ldr	r2, [pc, #116]	; (8001674 <HAL_RCC_ClockConfig+0x158>)
 80015fe:	6813      	ldr	r3, [r2, #0]
 8001600:	f023 030f 	bic.w	r3, r3, #15
 8001604:	432b      	orrs	r3, r5
 8001606:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8001608:	6813      	ldr	r3, [r2, #0]
 800160a:	f003 030f 	and.w	r3, r3, #15
 800160e:	42ab      	cmp	r3, r5
 8001610:	d12d      	bne.n	800166e <HAL_RCC_ClockConfig+0x152>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001612:	6823      	ldr	r3, [r4, #0]
 8001614:	f013 0f04 	tst.w	r3, #4
 8001618:	d006      	beq.n	8001628 <HAL_RCC_ClockConfig+0x10c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800161a:	4a17      	ldr	r2, [pc, #92]	; (8001678 <HAL_RCC_ClockConfig+0x15c>)
 800161c:	6893      	ldr	r3, [r2, #8]
 800161e:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8001622:	68e1      	ldr	r1, [r4, #12]
 8001624:	430b      	orrs	r3, r1
 8001626:	6093      	str	r3, [r2, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001628:	6823      	ldr	r3, [r4, #0]
 800162a:	f013 0f08 	tst.w	r3, #8
 800162e:	d007      	beq.n	8001640 <HAL_RCC_ClockConfig+0x124>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8001630:	4a11      	ldr	r2, [pc, #68]	; (8001678 <HAL_RCC_ClockConfig+0x15c>)
 8001632:	6893      	ldr	r3, [r2, #8]
 8001634:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001638:	6921      	ldr	r1, [r4, #16]
 800163a:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800163e:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8001640:	f7ff fefe 	bl	8001440 <HAL_RCC_GetSysClockFreq>
 8001644:	4b0c      	ldr	r3, [pc, #48]	; (8001678 <HAL_RCC_ClockConfig+0x15c>)
 8001646:	689b      	ldr	r3, [r3, #8]
 8001648:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800164c:	4a0b      	ldr	r2, [pc, #44]	; (800167c <HAL_RCC_ClockConfig+0x160>)
 800164e:	5cd3      	ldrb	r3, [r2, r3]
 8001650:	40d8      	lsrs	r0, r3
 8001652:	4b0b      	ldr	r3, [pc, #44]	; (8001680 <HAL_RCC_ClockConfig+0x164>)
 8001654:	6018      	str	r0, [r3, #0]
  HAL_InitTick(uwTickPrio);
 8001656:	4b0b      	ldr	r3, [pc, #44]	; (8001684 <HAL_RCC_ClockConfig+0x168>)
 8001658:	6818      	ldr	r0, [r3, #0]
 800165a:	f7ff fa93 	bl	8000b84 <HAL_InitTick>
  return HAL_OK;
 800165e:	2000      	movs	r0, #0
}
 8001660:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8001662:	2001      	movs	r0, #1
}
 8001664:	4770      	bx	lr
      return HAL_ERROR;
 8001666:	2001      	movs	r0, #1
 8001668:	e7fa      	b.n	8001660 <HAL_RCC_ClockConfig+0x144>
        return HAL_ERROR;
 800166a:	2001      	movs	r0, #1
 800166c:	e7f8      	b.n	8001660 <HAL_RCC_ClockConfig+0x144>
      return HAL_ERROR;
 800166e:	2001      	movs	r0, #1
 8001670:	e7f6      	b.n	8001660 <HAL_RCC_ClockConfig+0x144>
 8001672:	bf00      	nop
 8001674:	40023c00 	.word	0x40023c00
 8001678:	40023800 	.word	0x40023800
 800167c:	0800a7b4 	.word	0x0800a7b4
 8001680:	20000000 	.word	0x20000000
 8001684:	20000008 	.word	0x20000008

08001688 <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8001688:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800168c:	b082      	sub	sp, #8
 800168e:	4605      	mov	r5, r0
 8001690:	4688      	mov	r8, r1
 8001692:	4617      	mov	r7, r2
 8001694:	461e      	mov	r6, r3
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 8001696:	f7ff fab9 	bl	8000c0c <HAL_GetTick>
 800169a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800169c:	1a1b      	subs	r3, r3, r0
 800169e:	eb03 0906 	add.w	r9, r3, r6
  tmp_tickstart = HAL_GetTick();
 80016a2:	f7ff fab3 	bl	8000c0c <HAL_GetTick>
 80016a6:	4682      	mov	sl, r0

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 80016a8:	4b2a      	ldr	r3, [pc, #168]	; (8001754 <SPI_WaitFlagStateUntilTimeout+0xcc>)
 80016aa:	681b      	ldr	r3, [r3, #0]
 80016ac:	f3c3 33cb 	ubfx	r3, r3, #15, #12
 80016b0:	fb09 f303 	mul.w	r3, r9, r3
 80016b4:	9301      	str	r3, [sp, #4]

  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80016b6:	682b      	ldr	r3, [r5, #0]
 80016b8:	689c      	ldr	r4, [r3, #8]
 80016ba:	ea38 0404 	bics.w	r4, r8, r4
 80016be:	bf0c      	ite	eq
 80016c0:	2301      	moveq	r3, #1
 80016c2:	2300      	movne	r3, #0
 80016c4:	42bb      	cmp	r3, r7
 80016c6:	d040      	beq.n	800174a <SPI_WaitFlagStateUntilTimeout+0xc2>
  {
    if (Timeout != HAL_MAX_DELAY)
 80016c8:	f1b6 3fff 	cmp.w	r6, #4294967295
 80016cc:	d0f3      	beq.n	80016b6 <SPI_WaitFlagStateUntilTimeout+0x2e>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 80016ce:	f7ff fa9d 	bl	8000c0c <HAL_GetTick>
 80016d2:	eba0 000a 	sub.w	r0, r0, sl
 80016d6:	4548      	cmp	r0, r9
 80016d8:	d20a      	bcs.n	80016f0 <SPI_WaitFlagStateUntilTimeout+0x68>
 80016da:	f1b9 0f00 	cmp.w	r9, #0
 80016de:	d007      	beq.n	80016f0 <SPI_WaitFlagStateUntilTimeout+0x68>
        __HAL_UNLOCK(hspi);

        return HAL_TIMEOUT;
      }
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if (count == 0U)
 80016e0:	9a01      	ldr	r2, [sp, #4]
 80016e2:	b102      	cbz	r2, 80016e6 <SPI_WaitFlagStateUntilTimeout+0x5e>
 80016e4:	464a      	mov	r2, r9
      {
        tmp_timeout = 0U;
      }
      count--;
 80016e6:	9b01      	ldr	r3, [sp, #4]
 80016e8:	3b01      	subs	r3, #1
 80016ea:	9301      	str	r3, [sp, #4]
 80016ec:	4691      	mov	r9, r2
 80016ee:	e7e2      	b.n	80016b6 <SPI_WaitFlagStateUntilTimeout+0x2e>
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80016f0:	682a      	ldr	r2, [r5, #0]
 80016f2:	6853      	ldr	r3, [r2, #4]
 80016f4:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 80016f8:	6053      	str	r3, [r2, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80016fa:	686b      	ldr	r3, [r5, #4]
 80016fc:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8001700:	d00b      	beq.n	800171a <SPI_WaitFlagStateUntilTimeout+0x92>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8001702:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8001704:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8001708:	d014      	beq.n	8001734 <SPI_WaitFlagStateUntilTimeout+0xac>
        hspi->State = HAL_SPI_STATE_READY;
 800170a:	2301      	movs	r3, #1
 800170c:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
        __HAL_UNLOCK(hspi);
 8001710:	2300      	movs	r3, #0
 8001712:	f885 305c 	strb.w	r3, [r5, #92]	; 0x5c
        return HAL_TIMEOUT;
 8001716:	2003      	movs	r0, #3
 8001718:	e018      	b.n	800174c <SPI_WaitFlagStateUntilTimeout+0xc4>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800171a:	68ab      	ldr	r3, [r5, #8]
 800171c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8001720:	bf18      	it	ne
 8001722:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 8001726:	d1ec      	bne.n	8001702 <SPI_WaitFlagStateUntilTimeout+0x7a>
          __HAL_SPI_DISABLE(hspi);
 8001728:	682a      	ldr	r2, [r5, #0]
 800172a:	6813      	ldr	r3, [r2, #0]
 800172c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001730:	6013      	str	r3, [r2, #0]
 8001732:	e7e6      	b.n	8001702 <SPI_WaitFlagStateUntilTimeout+0x7a>
          SPI_RESET_CRC(hspi);
 8001734:	682a      	ldr	r2, [r5, #0]
 8001736:	6813      	ldr	r3, [r2, #0]
 8001738:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800173c:	6013      	str	r3, [r2, #0]
 800173e:	682a      	ldr	r2, [r5, #0]
 8001740:	6813      	ldr	r3, [r2, #0]
 8001742:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001746:	6013      	str	r3, [r2, #0]
 8001748:	e7df      	b.n	800170a <SPI_WaitFlagStateUntilTimeout+0x82>
    }
  }

  return HAL_OK;
 800174a:	2000      	movs	r0, #0
}
 800174c:	b002      	add	sp, #8
 800174e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001752:	bf00      	nop
 8001754:	20000000 	.word	0x20000000

08001758 <SPI_WaitFifoStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8001758:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800175c:	b082      	sub	sp, #8
 800175e:	4606      	mov	r6, r0
 8001760:	460d      	mov	r5, r1
 8001762:	4614      	mov	r4, r2
 8001764:	461f      	mov	r7, r3
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;
  __IO uint8_t  *ptmpreg8;
  __IO uint8_t  tmpreg8 = 0;
 8001766:	2300      	movs	r3, #0
 8001768:	f88d 3003 	strb.w	r3, [sp, #3]

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout = Timeout - (HAL_GetTick() - Tickstart);
 800176c:	f7ff fa4e 	bl	8000c0c <HAL_GetTick>
 8001770:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001772:	1a1b      	subs	r3, r3, r0
 8001774:	eb03 0907 	add.w	r9, r3, r7
  tmp_tickstart = HAL_GetTick();
 8001778:	f7ff fa48 	bl	8000c0c <HAL_GetTick>
 800177c:	4682      	mov	sl, r0

  /* Initialize the 8bit temporary pointer */
  ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
 800177e:	f8d6 8000 	ldr.w	r8, [r6]

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
 8001782:	4b31      	ldr	r3, [pc, #196]	; (8001848 <SPI_WaitFifoStateUntilTimeout+0xf0>)
 8001784:	681b      	ldr	r3, [r3, #0]
 8001786:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800178a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 800178e:	0d1b      	lsrs	r3, r3, #20
 8001790:	fb09 f303 	mul.w	r3, r9, r3
 8001794:	9301      	str	r3, [sp, #4]

  while ((hspi->Instance->SR & Fifo) != State)
 8001796:	e002      	b.n	800179e <SPI_WaitFifoStateUntilTimeout+0x46>
      tmpreg8 = *ptmpreg8;
      /* To avoid GCC warning */
      UNUSED(tmpreg8);
    }

    if (Timeout != HAL_MAX_DELAY)
 8001798:	f1b7 3fff 	cmp.w	r7, #4294967295
 800179c:	d112      	bne.n	80017c4 <SPI_WaitFifoStateUntilTimeout+0x6c>
  while ((hspi->Instance->SR & Fifo) != State)
 800179e:	6833      	ldr	r3, [r6, #0]
 80017a0:	689b      	ldr	r3, [r3, #8]
 80017a2:	ea03 0c05 	and.w	ip, r3, r5
 80017a6:	45a4      	cmp	ip, r4
 80017a8:	d04a      	beq.n	8001840 <SPI_WaitFifoStateUntilTimeout+0xe8>
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 80017aa:	f5b5 6fc0 	cmp.w	r5, #1536	; 0x600
 80017ae:	bf08      	it	eq
 80017b0:	2c00      	cmpeq	r4, #0
 80017b2:	d1f1      	bne.n	8001798 <SPI_WaitFifoStateUntilTimeout+0x40>
      tmpreg8 = *ptmpreg8;
 80017b4:	f898 300c 	ldrb.w	r3, [r8, #12]
 80017b8:	b2db      	uxtb	r3, r3
 80017ba:	f88d 3003 	strb.w	r3, [sp, #3]
      UNUSED(tmpreg8);
 80017be:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80017c2:	e7e9      	b.n	8001798 <SPI_WaitFifoStateUntilTimeout+0x40>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 80017c4:	f7ff fa22 	bl	8000c0c <HAL_GetTick>
 80017c8:	eba0 000a 	sub.w	r0, r0, sl
 80017cc:	4548      	cmp	r0, r9
 80017ce:	d20a      	bcs.n	80017e6 <SPI_WaitFifoStateUntilTimeout+0x8e>
 80017d0:	f1b9 0f00 	cmp.w	r9, #0
 80017d4:	d007      	beq.n	80017e6 <SPI_WaitFifoStateUntilTimeout+0x8e>
        __HAL_UNLOCK(hspi);

        return HAL_TIMEOUT;
      }
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if (count == 0U)
 80017d6:	9a01      	ldr	r2, [sp, #4]
 80017d8:	b102      	cbz	r2, 80017dc <SPI_WaitFifoStateUntilTimeout+0x84>
 80017da:	464a      	mov	r2, r9
      {
        tmp_timeout = 0U;
      }
      count--;
 80017dc:	9b01      	ldr	r3, [sp, #4]
 80017de:	3b01      	subs	r3, #1
 80017e0:	9301      	str	r3, [sp, #4]
 80017e2:	4691      	mov	r9, r2
 80017e4:	e7db      	b.n	800179e <SPI_WaitFifoStateUntilTimeout+0x46>
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80017e6:	6832      	ldr	r2, [r6, #0]
 80017e8:	6853      	ldr	r3, [r2, #4]
 80017ea:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 80017ee:	6053      	str	r3, [r2, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80017f0:	6873      	ldr	r3, [r6, #4]
 80017f2:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80017f6:	d00b      	beq.n	8001810 <SPI_WaitFifoStateUntilTimeout+0xb8>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80017f8:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80017fa:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80017fe:	d014      	beq.n	800182a <SPI_WaitFifoStateUntilTimeout+0xd2>
        hspi->State = HAL_SPI_STATE_READY;
 8001800:	2301      	movs	r3, #1
 8001802:	f886 305d 	strb.w	r3, [r6, #93]	; 0x5d
        __HAL_UNLOCK(hspi);
 8001806:	2300      	movs	r3, #0
 8001808:	f886 305c 	strb.w	r3, [r6, #92]	; 0x5c
        return HAL_TIMEOUT;
 800180c:	2003      	movs	r0, #3
 800180e:	e018      	b.n	8001842 <SPI_WaitFifoStateUntilTimeout+0xea>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001810:	68b3      	ldr	r3, [r6, #8]
 8001812:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8001816:	bf18      	it	ne
 8001818:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 800181c:	d1ec      	bne.n	80017f8 <SPI_WaitFifoStateUntilTimeout+0xa0>
          __HAL_SPI_DISABLE(hspi);
 800181e:	6832      	ldr	r2, [r6, #0]
 8001820:	6813      	ldr	r3, [r2, #0]
 8001822:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001826:	6013      	str	r3, [r2, #0]
 8001828:	e7e6      	b.n	80017f8 <SPI_WaitFifoStateUntilTimeout+0xa0>
          SPI_RESET_CRC(hspi);
 800182a:	6832      	ldr	r2, [r6, #0]
 800182c:	6813      	ldr	r3, [r2, #0]
 800182e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001832:	6013      	str	r3, [r2, #0]
 8001834:	6832      	ldr	r2, [r6, #0]
 8001836:	6813      	ldr	r3, [r2, #0]
 8001838:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800183c:	6013      	str	r3, [r2, #0]
 800183e:	e7df      	b.n	8001800 <SPI_WaitFifoStateUntilTimeout+0xa8>
    }
  }

  return HAL_OK;
 8001840:	2000      	movs	r0, #0
}
 8001842:	b002      	add	sp, #8
 8001844:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001848:	20000000 	.word	0x20000000

0800184c <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 800184c:	b570      	push	{r4, r5, r6, lr}
 800184e:	b084      	sub	sp, #16
 8001850:	4604      	mov	r4, r0
 8001852:	460d      	mov	r5, r1
 8001854:	4616      	mov	r6, r2
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001856:	9200      	str	r2, [sp, #0]
 8001858:	460b      	mov	r3, r1
 800185a:	2200      	movs	r2, #0
 800185c:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
 8001860:	f7ff ff7a 	bl	8001758 <SPI_WaitFifoStateUntilTimeout>
 8001864:	bb18      	cbnz	r0, 80018ae <SPI_EndRxTxTransaction+0x62>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  /* Timeout in s */
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 8001866:	4b1f      	ldr	r3, [pc, #124]	; (80018e4 <SPI_EndRxTxTransaction+0x98>)
 8001868:	681b      	ldr	r3, [r3, #0]
 800186a:	4a1f      	ldr	r2, [pc, #124]	; (80018e8 <SPI_EndRxTxTransaction+0x9c>)
 800186c:	fba2 2303 	umull	r2, r3, r2, r3
 8001870:	0d5b      	lsrs	r3, r3, #21
 8001872:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8001876:	fb02 f303 	mul.w	r3, r2, r3
 800187a:	9303      	str	r3, [sp, #12]
  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 800187c:	6863      	ldr	r3, [r4, #4]
 800187e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8001882:	d01a      	beq.n	80018ba <SPI_EndRxTxTransaction+0x6e>
    * User have to calculate the timeout value to fit with the time of 1 byte transfer.
    * This time is directly link with the SPI clock from Master device.
    */
    do
    {
      if (count == 0U)
 8001884:	9b03      	ldr	r3, [sp, #12]
 8001886:	b13b      	cbz	r3, 8001898 <SPI_EndRxTxTransaction+0x4c>
      {
        break;
      }
      count--;
 8001888:	9b03      	ldr	r3, [sp, #12]
 800188a:	3b01      	subs	r3, #1
 800188c:	9303      	str	r3, [sp, #12]
    } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
 800188e:	6823      	ldr	r3, [r4, #0]
 8001890:	689b      	ldr	r3, [r3, #8]
 8001892:	f013 0f80 	tst.w	r3, #128	; 0x80
 8001896:	d1f5      	bne.n	8001884 <SPI_EndRxTxTransaction+0x38>
  }


  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001898:	9600      	str	r6, [sp, #0]
 800189a:	462b      	mov	r3, r5
 800189c:	2200      	movs	r2, #0
 800189e:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 80018a2:	4620      	mov	r0, r4
 80018a4:	f7ff ff58 	bl	8001758 <SPI_WaitFifoStateUntilTimeout>
 80018a8:	b9b0      	cbnz	r0, 80018d8 <SPI_EndRxTxTransaction+0x8c>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  return HAL_OK;
}
 80018aa:	b004      	add	sp, #16
 80018ac:	bd70      	pop	{r4, r5, r6, pc}
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80018ae:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80018b0:	f043 0320 	orr.w	r3, r3, #32
 80018b4:	6623      	str	r3, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 80018b6:	2003      	movs	r0, #3
 80018b8:	e7f7      	b.n	80018aa <SPI_EndRxTxTransaction+0x5e>
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 80018ba:	9600      	str	r6, [sp, #0]
 80018bc:	462b      	mov	r3, r5
 80018be:	2200      	movs	r2, #0
 80018c0:	2180      	movs	r1, #128	; 0x80
 80018c2:	4620      	mov	r0, r4
 80018c4:	f7ff fee0 	bl	8001688 <SPI_WaitFlagStateUntilTimeout>
 80018c8:	2800      	cmp	r0, #0
 80018ca:	d0e5      	beq.n	8001898 <SPI_EndRxTxTransaction+0x4c>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80018cc:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80018ce:	f043 0320 	orr.w	r3, r3, #32
 80018d2:	6623      	str	r3, [r4, #96]	; 0x60
      return HAL_TIMEOUT;
 80018d4:	2003      	movs	r0, #3
 80018d6:	e7e8      	b.n	80018aa <SPI_EndRxTxTransaction+0x5e>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80018d8:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80018da:	f043 0320 	orr.w	r3, r3, #32
 80018de:	6623      	str	r3, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 80018e0:	2003      	movs	r0, #3
 80018e2:	e7e2      	b.n	80018aa <SPI_EndRxTxTransaction+0x5e>
 80018e4:	20000000 	.word	0x20000000
 80018e8:	165e9f81 	.word	0x165e9f81

080018ec <SPI_EndRxTransaction>:
{
 80018ec:	b570      	push	{r4, r5, r6, lr}
 80018ee:	b084      	sub	sp, #16
 80018f0:	4604      	mov	r4, r0
 80018f2:	460d      	mov	r5, r1
 80018f4:	4616      	mov	r6, r2
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80018f6:	6843      	ldr	r3, [r0, #4]
 80018f8:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80018fc:	d01f      	beq.n	800193e <SPI_EndRxTransaction+0x52>
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 80018fe:	6863      	ldr	r3, [r4, #4]
 8001900:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8001904:	d028      	beq.n	8001958 <SPI_EndRxTransaction+0x6c>
    __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 8001906:	4b28      	ldr	r3, [pc, #160]	; (80019a8 <SPI_EndRxTransaction+0xbc>)
 8001908:	681b      	ldr	r3, [r3, #0]
 800190a:	4a28      	ldr	r2, [pc, #160]	; (80019ac <SPI_EndRxTransaction+0xc0>)
 800190c:	fba2 2303 	umull	r2, r3, r2, r3
 8001910:	0d5b      	lsrs	r3, r3, #21
 8001912:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8001916:	fb02 f303 	mul.w	r3, r2, r3
 800191a:	9303      	str	r3, [sp, #12]
      if (count == 0U)
 800191c:	9b03      	ldr	r3, [sp, #12]
 800191e:	b13b      	cbz	r3, 8001930 <SPI_EndRxTransaction+0x44>
      count--;
 8001920:	9b03      	ldr	r3, [sp, #12]
 8001922:	3b01      	subs	r3, #1
 8001924:	9303      	str	r3, [sp, #12]
    } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
 8001926:	6820      	ldr	r0, [r4, #0]
 8001928:	6880      	ldr	r0, [r0, #8]
 800192a:	f010 0f80 	tst.w	r0, #128	; 0x80
 800192e:	d1f5      	bne.n	800191c <SPI_EndRxTransaction+0x30>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001930:	6863      	ldr	r3, [r4, #4]
 8001932:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8001936:	d01e      	beq.n	8001976 <SPI_EndRxTransaction+0x8a>
  return HAL_OK;
 8001938:	2000      	movs	r0, #0
}
 800193a:	b004      	add	sp, #16
 800193c:	bd70      	pop	{r4, r5, r6, pc}
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800193e:	6883      	ldr	r3, [r0, #8]
 8001940:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8001944:	bf18      	it	ne
 8001946:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 800194a:	d1d8      	bne.n	80018fe <SPI_EndRxTransaction+0x12>
    __HAL_SPI_DISABLE(hspi);
 800194c:	6802      	ldr	r2, [r0, #0]
 800194e:	6813      	ldr	r3, [r2, #0]
 8001950:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001954:	6013      	str	r3, [r2, #0]
 8001956:	e7d2      	b.n	80018fe <SPI_EndRxTransaction+0x12>
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8001958:	9600      	str	r6, [sp, #0]
 800195a:	462b      	mov	r3, r5
 800195c:	2200      	movs	r2, #0
 800195e:	2180      	movs	r1, #128	; 0x80
 8001960:	4620      	mov	r0, r4
 8001962:	f7ff fe91 	bl	8001688 <SPI_WaitFlagStateUntilTimeout>
 8001966:	2800      	cmp	r0, #0
 8001968:	d0e2      	beq.n	8001930 <SPI_EndRxTransaction+0x44>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800196a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800196c:	f043 0320 	orr.w	r3, r3, #32
 8001970:	6623      	str	r3, [r4, #96]	; 0x60
      return HAL_TIMEOUT;
 8001972:	2003      	movs	r0, #3
 8001974:	e7e1      	b.n	800193a <SPI_EndRxTransaction+0x4e>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001976:	68a3      	ldr	r3, [r4, #8]
 8001978:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800197c:	bf18      	it	ne
 800197e:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 8001982:	d001      	beq.n	8001988 <SPI_EndRxTransaction+0x9c>
  return HAL_OK;
 8001984:	2000      	movs	r0, #0
 8001986:	e7d8      	b.n	800193a <SPI_EndRxTransaction+0x4e>
    if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001988:	9600      	str	r6, [sp, #0]
 800198a:	462b      	mov	r3, r5
 800198c:	2200      	movs	r2, #0
 800198e:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8001992:	4620      	mov	r0, r4
 8001994:	f7ff fee0 	bl	8001758 <SPI_WaitFifoStateUntilTimeout>
 8001998:	2800      	cmp	r0, #0
 800199a:	d0ce      	beq.n	800193a <SPI_EndRxTransaction+0x4e>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800199c:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800199e:	f043 0320 	orr.w	r3, r3, #32
 80019a2:	6623      	str	r3, [r4, #96]	; 0x60
      return HAL_TIMEOUT;
 80019a4:	2003      	movs	r0, #3
 80019a6:	e7c8      	b.n	800193a <SPI_EndRxTransaction+0x4e>
 80019a8:	20000000 	.word	0x20000000
 80019ac:	165e9f81 	.word	0x165e9f81

080019b0 <HAL_SPI_Init>:
  if (hspi == NULL)
 80019b0:	2800      	cmp	r0, #0
 80019b2:	d06f      	beq.n	8001a94 <HAL_SPI_Init+0xe4>
{
 80019b4:	b510      	push	{r4, lr}
 80019b6:	4604      	mov	r4, r0
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 80019b8:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80019ba:	b933      	cbnz	r3, 80019ca <HAL_SPI_Init+0x1a>
    if (hspi->Init.Mode == SPI_MODE_MASTER)
 80019bc:	6843      	ldr	r3, [r0, #4]
 80019be:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80019c2:	d005      	beq.n	80019d0 <HAL_SPI_Init+0x20>
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80019c4:	2300      	movs	r3, #0
 80019c6:	61c3      	str	r3, [r0, #28]
 80019c8:	e002      	b.n	80019d0 <HAL_SPI_Init+0x20>
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 80019ca:	2300      	movs	r3, #0
 80019cc:	6103      	str	r3, [r0, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 80019ce:	6143      	str	r3, [r0, #20]
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80019d0:	2300      	movs	r3, #0
 80019d2:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 80019d4:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
 80019d8:	2b00      	cmp	r3, #0
 80019da:	d052      	beq.n	8001a82 <HAL_SPI_Init+0xd2>
  hspi->State = HAL_SPI_STATE_BUSY;
 80019dc:	2302      	movs	r3, #2
 80019de:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_SPI_DISABLE(hspi);
 80019e2:	6822      	ldr	r2, [r4, #0]
 80019e4:	6813      	ldr	r3, [r2, #0]
 80019e6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80019ea:	6013      	str	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80019ec:	68e3      	ldr	r3, [r4, #12]
 80019ee:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 80019f2:	d94c      	bls.n	8001a8e <HAL_SPI_Init+0xde>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 80019f4:	2200      	movs	r2, #0
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 80019f6:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 80019fa:	bf18      	it	ne
 80019fc:	f5b3 6fe0 	cmpne.w	r3, #1792	; 0x700
 8001a00:	d001      	beq.n	8001a06 <HAL_SPI_Init+0x56>
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001a02:	2300      	movs	r3, #0
 8001a04:	62a3      	str	r3, [r4, #40]	; 0x28
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8001a06:	6863      	ldr	r3, [r4, #4]
 8001a08:	f403 7382 	and.w	r3, r3, #260	; 0x104
 8001a0c:	68a1      	ldr	r1, [r4, #8]
 8001a0e:	f401 4104 	and.w	r1, r1, #33792	; 0x8400
 8001a12:	430b      	orrs	r3, r1
 8001a14:	6921      	ldr	r1, [r4, #16]
 8001a16:	f001 0102 	and.w	r1, r1, #2
 8001a1a:	430b      	orrs	r3, r1
 8001a1c:	6961      	ldr	r1, [r4, #20]
 8001a1e:	f001 0101 	and.w	r1, r1, #1
 8001a22:	430b      	orrs	r3, r1
 8001a24:	69a1      	ldr	r1, [r4, #24]
 8001a26:	f401 7100 	and.w	r1, r1, #512	; 0x200
 8001a2a:	430b      	orrs	r3, r1
 8001a2c:	69e1      	ldr	r1, [r4, #28]
 8001a2e:	f001 0138 	and.w	r1, r1, #56	; 0x38
 8001a32:	430b      	orrs	r3, r1
 8001a34:	6a21      	ldr	r1, [r4, #32]
 8001a36:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8001a3a:	430b      	orrs	r3, r1
 8001a3c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001a3e:	f401 5100 	and.w	r1, r1, #8192	; 0x2000
 8001a42:	6820      	ldr	r0, [r4, #0]
 8001a44:	430b      	orrs	r3, r1
 8001a46:	6003      	str	r3, [r0, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8001a48:	8b63      	ldrh	r3, [r4, #26]
 8001a4a:	f003 0304 	and.w	r3, r3, #4
 8001a4e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8001a50:	f001 0110 	and.w	r1, r1, #16
 8001a54:	430b      	orrs	r3, r1
 8001a56:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8001a58:	f001 0108 	and.w	r1, r1, #8
 8001a5c:	430b      	orrs	r3, r1
 8001a5e:	68e1      	ldr	r1, [r4, #12]
 8001a60:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
 8001a64:	430b      	orrs	r3, r1
 8001a66:	6821      	ldr	r1, [r4, #0]
 8001a68:	431a      	orrs	r2, r3
 8001a6a:	604a      	str	r2, [r1, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8001a6c:	6822      	ldr	r2, [r4, #0]
 8001a6e:	69d3      	ldr	r3, [r2, #28]
 8001a70:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8001a74:	61d3      	str	r3, [r2, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8001a76:	2000      	movs	r0, #0
 8001a78:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8001a7a:	2301      	movs	r3, #1
 8001a7c:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
}
 8001a80:	bd10      	pop	{r4, pc}
    hspi->Lock = HAL_UNLOCKED;
 8001a82:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
    HAL_SPI_MspInit(hspi);
 8001a86:	4620      	mov	r0, r4
 8001a88:	f7fe ff7a 	bl	8000980 <HAL_SPI_MspInit>
 8001a8c:	e7a6      	b.n	80019dc <HAL_SPI_Init+0x2c>
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8001a8e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001a92:	e7b0      	b.n	80019f6 <HAL_SPI_Init+0x46>
    return HAL_ERROR;
 8001a94:	2001      	movs	r0, #1
}
 8001a96:	4770      	bx	lr

08001a98 <HAL_SPI_Transmit_IT>:
{
 8001a98:	4603      	mov	r3, r0
  __HAL_LOCK(hspi);
 8001a9a:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
 8001a9e:	2801      	cmp	r0, #1
 8001aa0:	d04a      	beq.n	8001b38 <HAL_SPI_Transmit_IT+0xa0>
 8001aa2:	2001      	movs	r0, #1
 8001aa4:	f883 005c 	strb.w	r0, [r3, #92]	; 0x5c
  if ((pData == NULL) || (Size == 0U))
 8001aa8:	2a00      	cmp	r2, #0
 8001aaa:	bf18      	it	ne
 8001aac:	2900      	cmpne	r1, #0
 8001aae:	d03a      	beq.n	8001b26 <HAL_SPI_Transmit_IT+0x8e>
  if (hspi->State != HAL_SPI_STATE_READY)
 8001ab0:	f893 005d 	ldrb.w	r0, [r3, #93]	; 0x5d
 8001ab4:	b2c0      	uxtb	r0, r0
 8001ab6:	2801      	cmp	r0, #1
 8001ab8:	d13a      	bne.n	8001b30 <HAL_SPI_Transmit_IT+0x98>
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8001aba:	2003      	movs	r0, #3
 8001abc:	f883 005d 	strb.w	r0, [r3, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001ac0:	2000      	movs	r0, #0
 8001ac2:	6618      	str	r0, [r3, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8001ac4:	6399      	str	r1, [r3, #56]	; 0x38
  hspi->TxXferSize  = Size;
 8001ac6:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->TxXferCount = Size;
 8001ac8:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8001aca:	6418      	str	r0, [r3, #64]	; 0x40
  hspi->RxXferSize  = 0U;
 8001acc:	f8a3 0044 	strh.w	r0, [r3, #68]	; 0x44
  hspi->RxXferCount = 0U;
 8001ad0:	f8a3 0046 	strh.w	r0, [r3, #70]	; 0x46
  hspi->RxISR       = NULL;
 8001ad4:	64d8      	str	r0, [r3, #76]	; 0x4c
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001ad6:	68da      	ldr	r2, [r3, #12]
 8001ad8:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
 8001adc:	d915      	bls.n	8001b0a <HAL_SPI_Transmit_IT+0x72>
    hspi->TxISR = SPI_TxISR_16BIT;
 8001ade:	4a17      	ldr	r2, [pc, #92]	; (8001b3c <HAL_SPI_Transmit_IT+0xa4>)
 8001ae0:	651a      	str	r2, [r3, #80]	; 0x50
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001ae2:	689a      	ldr	r2, [r3, #8]
 8001ae4:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8001ae8:	d012      	beq.n	8001b10 <HAL_SPI_Transmit_IT+0x78>
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
 8001aea:	6819      	ldr	r1, [r3, #0]
 8001aec:	684a      	ldr	r2, [r1, #4]
 8001aee:	f042 02a0 	orr.w	r2, r2, #160	; 0xa0
 8001af2:	604a      	str	r2, [r1, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8001af4:	681a      	ldr	r2, [r3, #0]
 8001af6:	6811      	ldr	r1, [r2, #0]
 8001af8:	f011 0f40 	tst.w	r1, #64	; 0x40
 8001afc:	d11a      	bne.n	8001b34 <HAL_SPI_Transmit_IT+0x9c>
    __HAL_SPI_ENABLE(hspi);
 8001afe:	6811      	ldr	r1, [r2, #0]
 8001b00:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 8001b04:	6011      	str	r1, [r2, #0]
  HAL_StatusTypeDef errorcode = HAL_OK;
 8001b06:	2000      	movs	r0, #0
 8001b08:	e00e      	b.n	8001b28 <HAL_SPI_Transmit_IT+0x90>
    hspi->TxISR = SPI_TxISR_8BIT;
 8001b0a:	4a0d      	ldr	r2, [pc, #52]	; (8001b40 <HAL_SPI_Transmit_IT+0xa8>)
 8001b0c:	651a      	str	r2, [r3, #80]	; 0x50
 8001b0e:	e7e8      	b.n	8001ae2 <HAL_SPI_Transmit_IT+0x4a>
    __HAL_SPI_DISABLE(hspi);
 8001b10:	6819      	ldr	r1, [r3, #0]
 8001b12:	680a      	ldr	r2, [r1, #0]
 8001b14:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001b18:	600a      	str	r2, [r1, #0]
    SPI_1LINE_TX(hspi);
 8001b1a:	6819      	ldr	r1, [r3, #0]
 8001b1c:	680a      	ldr	r2, [r1, #0]
 8001b1e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001b22:	600a      	str	r2, [r1, #0]
 8001b24:	e7e1      	b.n	8001aea <HAL_SPI_Transmit_IT+0x52>
    errorcode = HAL_ERROR;
 8001b26:	2001      	movs	r0, #1
  __HAL_UNLOCK(hspi);
 8001b28:	2200      	movs	r2, #0
 8001b2a:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  return errorcode;
 8001b2e:	4770      	bx	lr
    errorcode = HAL_BUSY;
 8001b30:	2002      	movs	r0, #2
 8001b32:	e7f9      	b.n	8001b28 <HAL_SPI_Transmit_IT+0x90>
  HAL_StatusTypeDef errorcode = HAL_OK;
 8001b34:	2000      	movs	r0, #0
 8001b36:	e7f7      	b.n	8001b28 <HAL_SPI_Transmit_IT+0x90>
  __HAL_LOCK(hspi);
 8001b38:	2002      	movs	r0, #2
}
 8001b3a:	4770      	bx	lr
 8001b3c:	08001dd7 	.word	0x08001dd7
 8001b40:	08001daf 	.word	0x08001daf

08001b44 <HAL_SPI_TransmitReceive_IT>:
{
 8001b44:	4684      	mov	ip, r0
  __HAL_LOCK(hspi);
 8001b46:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
 8001b4a:	2801      	cmp	r0, #1
 8001b4c:	d077      	beq.n	8001c3e <HAL_SPI_TransmitReceive_IT+0xfa>
{
 8001b4e:	b410      	push	{r4}
  __HAL_LOCK(hspi);
 8001b50:	2001      	movs	r0, #1
 8001b52:	f88c 005c 	strb.w	r0, [ip, #92]	; 0x5c
  tmp_state           = hspi->State;
 8001b56:	f89c 005d 	ldrb.w	r0, [ip, #93]	; 0x5d
 8001b5a:	b2c0      	uxtb	r0, r0
  tmp_mode            = hspi->Init.Mode;
 8001b5c:	f8dc 4004 	ldr.w	r4, [ip, #4]
  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 8001b60:	2801      	cmp	r0, #1
 8001b62:	d008      	beq.n	8001b76 <HAL_SPI_TransmitReceive_IT+0x32>
 8001b64:	f5b4 7f82 	cmp.w	r4, #260	; 0x104
 8001b68:	d158      	bne.n	8001c1c <HAL_SPI_TransmitReceive_IT+0xd8>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 8001b6a:	f8dc 4008 	ldr.w	r4, [ip, #8]
 8001b6e:	2c00      	cmp	r4, #0
 8001b70:	d15b      	bne.n	8001c2a <HAL_SPI_TransmitReceive_IT+0xe6>
 8001b72:	2804      	cmp	r0, #4
 8001b74:	d15b      	bne.n	8001c2e <HAL_SPI_TransmitReceive_IT+0xea>
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 8001b76:	2a00      	cmp	r2, #0
 8001b78:	bf18      	it	ne
 8001b7a:	2900      	cmpne	r1, #0
 8001b7c:	d059      	beq.n	8001c32 <HAL_SPI_TransmitReceive_IT+0xee>
 8001b7e:	2b00      	cmp	r3, #0
 8001b80:	d059      	beq.n	8001c36 <HAL_SPI_TransmitReceive_IT+0xf2>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8001b82:	f89c 005d 	ldrb.w	r0, [ip, #93]	; 0x5d
 8001b86:	b2c0      	uxtb	r0, r0
 8001b88:	2804      	cmp	r0, #4
 8001b8a:	d002      	beq.n	8001b92 <HAL_SPI_TransmitReceive_IT+0x4e>
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8001b8c:	2005      	movs	r0, #5
 8001b8e:	f88c 005d 	strb.w	r0, [ip, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001b92:	2000      	movs	r0, #0
 8001b94:	f8cc 0060 	str.w	r0, [ip, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8001b98:	f8cc 1038 	str.w	r1, [ip, #56]	; 0x38
  hspi->TxXferSize  = Size;
 8001b9c:	f8ac 303c 	strh.w	r3, [ip, #60]	; 0x3c
  hspi->TxXferCount = Size;
 8001ba0:	f8ac 303e 	strh.w	r3, [ip, #62]	; 0x3e
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8001ba4:	f8cc 2040 	str.w	r2, [ip, #64]	; 0x40
  hspi->RxXferSize  = Size;
 8001ba8:	f8ac 3044 	strh.w	r3, [ip, #68]	; 0x44
  hspi->RxXferCount = Size;
 8001bac:	f8ac 3046 	strh.w	r3, [ip, #70]	; 0x46
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001bb0:	f8dc 200c 	ldr.w	r2, [ip, #12]
 8001bb4:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
 8001bb8:	d922      	bls.n	8001c00 <HAL_SPI_TransmitReceive_IT+0xbc>
    hspi->RxISR     = SPI_2linesRxISR_16BIT;
 8001bba:	4922      	ldr	r1, [pc, #136]	; (8001c44 <HAL_SPI_TransmitReceive_IT+0x100>)
 8001bbc:	f8cc 104c 	str.w	r1, [ip, #76]	; 0x4c
    hspi->TxISR     = SPI_2linesTxISR_16BIT;
 8001bc0:	4921      	ldr	r1, [pc, #132]	; (8001c48 <HAL_SPI_TransmitReceive_IT+0x104>)
 8001bc2:	f8cc 1050 	str.w	r1, [ip, #80]	; 0x50
  if ((hspi->Init.DataSize > SPI_DATASIZE_8BIT) || (Size >= 2U))
 8001bc6:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
 8001bca:	d801      	bhi.n	8001bd0 <HAL_SPI_TransmitReceive_IT+0x8c>
 8001bcc:	2b01      	cmp	r3, #1
 8001bce:	d91e      	bls.n	8001c0e <HAL_SPI_TransmitReceive_IT+0xca>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8001bd0:	f8dc 2000 	ldr.w	r2, [ip]
 8001bd4:	6853      	ldr	r3, [r2, #4]
 8001bd6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8001bda:	6053      	str	r3, [r2, #4]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8001bdc:	f8dc 2000 	ldr.w	r2, [ip]
 8001be0:	6853      	ldr	r3, [r2, #4]
 8001be2:	f043 03e0 	orr.w	r3, r3, #224	; 0xe0
 8001be6:	6053      	str	r3, [r2, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8001be8:	f8dc 3000 	ldr.w	r3, [ip]
 8001bec:	681a      	ldr	r2, [r3, #0]
 8001bee:	f012 0f40 	tst.w	r2, #64	; 0x40
 8001bf2:	d122      	bne.n	8001c3a <HAL_SPI_TransmitReceive_IT+0xf6>
    __HAL_SPI_ENABLE(hspi);
 8001bf4:	681a      	ldr	r2, [r3, #0]
 8001bf6:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001bfa:	601a      	str	r2, [r3, #0]
  HAL_StatusTypeDef    errorcode = HAL_OK;
 8001bfc:	2000      	movs	r0, #0
 8001bfe:	e00e      	b.n	8001c1e <HAL_SPI_TransmitReceive_IT+0xda>
    hspi->RxISR     = SPI_2linesRxISR_8BIT;
 8001c00:	4912      	ldr	r1, [pc, #72]	; (8001c4c <HAL_SPI_TransmitReceive_IT+0x108>)
 8001c02:	f8cc 104c 	str.w	r1, [ip, #76]	; 0x4c
    hspi->TxISR     = SPI_2linesTxISR_8BIT;
 8001c06:	4912      	ldr	r1, [pc, #72]	; (8001c50 <HAL_SPI_TransmitReceive_IT+0x10c>)
 8001c08:	f8cc 1050 	str.w	r1, [ip, #80]	; 0x50
 8001c0c:	e7db      	b.n	8001bc6 <HAL_SPI_TransmitReceive_IT+0x82>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8001c0e:	f8dc 2000 	ldr.w	r2, [ip]
 8001c12:	6853      	ldr	r3, [r2, #4]
 8001c14:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001c18:	6053      	str	r3, [r2, #4]
 8001c1a:	e7df      	b.n	8001bdc <HAL_SPI_TransmitReceive_IT+0x98>
    errorcode = HAL_BUSY;
 8001c1c:	2002      	movs	r0, #2
  __HAL_UNLOCK(hspi);
 8001c1e:	2300      	movs	r3, #0
 8001c20:	f88c 305c 	strb.w	r3, [ip, #92]	; 0x5c
}
 8001c24:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001c28:	4770      	bx	lr
    errorcode = HAL_BUSY;
 8001c2a:	2002      	movs	r0, #2
 8001c2c:	e7f7      	b.n	8001c1e <HAL_SPI_TransmitReceive_IT+0xda>
 8001c2e:	2002      	movs	r0, #2
 8001c30:	e7f5      	b.n	8001c1e <HAL_SPI_TransmitReceive_IT+0xda>
    errorcode = HAL_ERROR;
 8001c32:	2001      	movs	r0, #1
 8001c34:	e7f3      	b.n	8001c1e <HAL_SPI_TransmitReceive_IT+0xda>
 8001c36:	2001      	movs	r0, #1
 8001c38:	e7f1      	b.n	8001c1e <HAL_SPI_TransmitReceive_IT+0xda>
  HAL_StatusTypeDef    errorcode = HAL_OK;
 8001c3a:	2000      	movs	r0, #0
 8001c3c:	e7ef      	b.n	8001c1e <HAL_SPI_TransmitReceive_IT+0xda>
  __HAL_LOCK(hspi);
 8001c3e:	2002      	movs	r0, #2
}
 8001c40:	4770      	bx	lr
 8001c42:	bf00      	nop
 8001c44:	08002009 	.word	0x08002009
 8001c48:	08001fcf 	.word	0x08001fcf
 8001c4c:	08001f55 	.word	0x08001f55
 8001c50:	08001ef9 	.word	0x08001ef9

08001c54 <HAL_SPI_Receive_IT>:
{
 8001c54:	b508      	push	{r3, lr}
 8001c56:	4684      	mov	ip, r0
  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 8001c58:	6883      	ldr	r3, [r0, #8]
 8001c5a:	b91b      	cbnz	r3, 8001c64 <HAL_SPI_Receive_IT+0x10>
 8001c5c:	6843      	ldr	r3, [r0, #4]
 8001c5e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8001c62:	d048      	beq.n	8001cf6 <HAL_SPI_Receive_IT+0xa2>
  __HAL_LOCK(hspi);
 8001c64:	f89c 305c 	ldrb.w	r3, [ip, #92]	; 0x5c
 8001c68:	2b01      	cmp	r3, #1
 8001c6a:	d06a      	beq.n	8001d42 <HAL_SPI_Receive_IT+0xee>
 8001c6c:	2301      	movs	r3, #1
 8001c6e:	f88c 305c 	strb.w	r3, [ip, #92]	; 0x5c
  if (hspi->State != HAL_SPI_STATE_READY)
 8001c72:	f89c 005d 	ldrb.w	r0, [ip, #93]	; 0x5d
 8001c76:	b2c0      	uxtb	r0, r0
 8001c78:	4298      	cmp	r0, r3
 8001c7a:	d15b      	bne.n	8001d34 <HAL_SPI_Receive_IT+0xe0>
  if ((pData == NULL) || (Size == 0U))
 8001c7c:	2a00      	cmp	r2, #0
 8001c7e:	bf18      	it	ne
 8001c80:	2900      	cmpne	r1, #0
 8001c82:	d058      	beq.n	8001d36 <HAL_SPI_Receive_IT+0xe2>
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8001c84:	2304      	movs	r3, #4
 8001c86:	f88c 305d 	strb.w	r3, [ip, #93]	; 0x5d
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001c8a:	2300      	movs	r3, #0
 8001c8c:	f8cc 3060 	str.w	r3, [ip, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 8001c90:	f8cc 1040 	str.w	r1, [ip, #64]	; 0x40
  hspi->RxXferSize  = Size;
 8001c94:	f8ac 2044 	strh.w	r2, [ip, #68]	; 0x44
  hspi->RxXferCount = Size;
 8001c98:	f8ac 2046 	strh.w	r2, [ip, #70]	; 0x46
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 8001c9c:	f8cc 3038 	str.w	r3, [ip, #56]	; 0x38
  hspi->TxXferSize  = 0U;
 8001ca0:	f8ac 303c 	strh.w	r3, [ip, #60]	; 0x3c
  hspi->TxXferCount = 0U;
 8001ca4:	f8ac 303e 	strh.w	r3, [ip, #62]	; 0x3e
  hspi->TxISR       = NULL;
 8001ca8:	f8cc 3050 	str.w	r3, [ip, #80]	; 0x50
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001cac:	f8dc 300c 	ldr.w	r3, [ip, #12]
 8001cb0:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8001cb4:	d927      	bls.n	8001d06 <HAL_SPI_Receive_IT+0xb2>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8001cb6:	f8dc 2000 	ldr.w	r2, [ip]
 8001cba:	6853      	ldr	r3, [r2, #4]
 8001cbc:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8001cc0:	6053      	str	r3, [r2, #4]
    hspi->RxISR = SPI_RxISR_16BIT;
 8001cc2:	4b21      	ldr	r3, [pc, #132]	; (8001d48 <HAL_SPI_Receive_IT+0xf4>)
 8001cc4:	f8cc 304c 	str.w	r3, [ip, #76]	; 0x4c
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001cc8:	f8dc 3008 	ldr.w	r3, [ip, #8]
 8001ccc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8001cd0:	d023      	beq.n	8001d1a <HAL_SPI_Receive_IT+0xc6>
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
 8001cd2:	f8dc 2000 	ldr.w	r2, [ip]
 8001cd6:	6853      	ldr	r3, [r2, #4]
 8001cd8:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 8001cdc:	6053      	str	r3, [r2, #4]
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8001cde:	f8dc 3000 	ldr.w	r3, [ip]
 8001ce2:	681a      	ldr	r2, [r3, #0]
 8001ce4:	f012 0f40 	tst.w	r2, #64	; 0x40
 8001ce8:	d129      	bne.n	8001d3e <HAL_SPI_Receive_IT+0xea>
    __HAL_SPI_ENABLE(hspi);
 8001cea:	681a      	ldr	r2, [r3, #0]
 8001cec:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001cf0:	601a      	str	r2, [r3, #0]
  HAL_StatusTypeDef errorcode = HAL_OK;
 8001cf2:	2000      	movs	r0, #0
 8001cf4:	e01f      	b.n	8001d36 <HAL_SPI_Receive_IT+0xe2>
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 8001cf6:	2304      	movs	r3, #4
 8001cf8:	f880 305d 	strb.w	r3, [r0, #93]	; 0x5d
    return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
 8001cfc:	4613      	mov	r3, r2
 8001cfe:	460a      	mov	r2, r1
 8001d00:	f7ff ff20 	bl	8001b44 <HAL_SPI_TransmitReceive_IT>
 8001d04:	e01a      	b.n	8001d3c <HAL_SPI_Receive_IT+0xe8>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8001d06:	f8dc 2000 	ldr.w	r2, [ip]
 8001d0a:	6853      	ldr	r3, [r2, #4]
 8001d0c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001d10:	6053      	str	r3, [r2, #4]
    hspi->RxISR = SPI_RxISR_8BIT;
 8001d12:	4b0e      	ldr	r3, [pc, #56]	; (8001d4c <HAL_SPI_Receive_IT+0xf8>)
 8001d14:	f8cc 304c 	str.w	r3, [ip, #76]	; 0x4c
 8001d18:	e7d6      	b.n	8001cc8 <HAL_SPI_Receive_IT+0x74>
    __HAL_SPI_DISABLE(hspi);
 8001d1a:	f8dc 2000 	ldr.w	r2, [ip]
 8001d1e:	6813      	ldr	r3, [r2, #0]
 8001d20:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001d24:	6013      	str	r3, [r2, #0]
    SPI_1LINE_RX(hspi);
 8001d26:	f8dc 2000 	ldr.w	r2, [ip]
 8001d2a:	6813      	ldr	r3, [r2, #0]
 8001d2c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001d30:	6013      	str	r3, [r2, #0]
 8001d32:	e7ce      	b.n	8001cd2 <HAL_SPI_Receive_IT+0x7e>
    errorcode = HAL_BUSY;
 8001d34:	2002      	movs	r0, #2
  __HAL_UNLOCK(hspi);
 8001d36:	2300      	movs	r3, #0
 8001d38:	f88c 305c 	strb.w	r3, [ip, #92]	; 0x5c
}
 8001d3c:	bd08      	pop	{r3, pc}
  HAL_StatusTypeDef errorcode = HAL_OK;
 8001d3e:	2000      	movs	r0, #0
 8001d40:	e7f9      	b.n	8001d36 <HAL_SPI_Receive_IT+0xe2>
  __HAL_LOCK(hspi);
 8001d42:	2002      	movs	r0, #2
 8001d44:	e7fa      	b.n	8001d3c <HAL_SPI_Receive_IT+0xe8>
 8001d46:	bf00      	nop
 8001d48:	08001e6d 	.word	0x08001e6d
 8001d4c:	08001e3f 	.word	0x08001e3f

08001d50 <HAL_SPI_TxCpltCallback>:
}
 8001d50:	4770      	bx	lr

08001d52 <HAL_SPI_RxCpltCallback>:
}
 8001d52:	4770      	bx	lr

08001d54 <HAL_SPI_TxRxCpltCallback>:
}
 8001d54:	4770      	bx	lr

08001d56 <HAL_SPI_ErrorCallback>:
}
 8001d56:	4770      	bx	lr

08001d58 <SPI_CloseTx_ISR>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
{
 8001d58:	b510      	push	{r4, lr}
 8001d5a:	b082      	sub	sp, #8
 8001d5c:	4604      	mov	r4, r0
  uint32_t tickstart;

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8001d5e:	f7fe ff55 	bl	8000c0c <HAL_GetTick>
 8001d62:	4602      	mov	r2, r0

  /* Disable TXE and ERR interrupt */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
 8001d64:	6821      	ldr	r1, [r4, #0]
 8001d66:	684b      	ldr	r3, [r1, #4]
 8001d68:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8001d6c:	604b      	str	r3, [r1, #4]

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8001d6e:	2164      	movs	r1, #100	; 0x64
 8001d70:	4620      	mov	r0, r4
 8001d72:	f7ff fd6b 	bl	800184c <SPI_EndRxTxTransaction>
 8001d76:	b118      	cbz	r0, 8001d80 <SPI_CloseTx_ISR+0x28>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001d78:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001d7a:	f043 0320 	orr.w	r3, r3, #32
 8001d7e:	6623      	str	r3, [r4, #96]	; 0x60
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8001d80:	68a3      	ldr	r3, [r4, #8]
 8001d82:	b933      	cbnz	r3, 8001d92 <SPI_CloseTx_ISR+0x3a>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8001d84:	9301      	str	r3, [sp, #4]
 8001d86:	6823      	ldr	r3, [r4, #0]
 8001d88:	68da      	ldr	r2, [r3, #12]
 8001d8a:	9201      	str	r2, [sp, #4]
 8001d8c:	689b      	ldr	r3, [r3, #8]
 8001d8e:	9301      	str	r3, [sp, #4]
 8001d90:	9b01      	ldr	r3, [sp, #4]
  }

  hspi->State = HAL_SPI_STATE_READY;
 8001d92:	2301      	movs	r3, #1
 8001d94:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8001d98:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001d9a:	b123      	cbz	r3, 8001da6 <SPI_CloseTx_ISR+0x4e>
  {
    /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
    hspi->ErrorCallback(hspi);
#else
    HAL_SPI_ErrorCallback(hspi);
 8001d9c:	4620      	mov	r0, r4
 8001d9e:	f7ff ffda 	bl	8001d56 <HAL_SPI_ErrorCallback>
    hspi->TxCpltCallback(hspi);
#else
    HAL_SPI_TxCpltCallback(hspi);
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }
}
 8001da2:	b002      	add	sp, #8
 8001da4:	bd10      	pop	{r4, pc}
    HAL_SPI_TxCpltCallback(hspi);
 8001da6:	4620      	mov	r0, r4
 8001da8:	f7ff ffd2 	bl	8001d50 <HAL_SPI_TxCpltCallback>
}
 8001dac:	e7f9      	b.n	8001da2 <SPI_CloseTx_ISR+0x4a>

08001dae <SPI_TxISR_8BIT>:
{
 8001dae:	b508      	push	{r3, lr}
  *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8001db0:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8001db2:	6803      	ldr	r3, [r0, #0]
 8001db4:	7812      	ldrb	r2, [r2, #0]
 8001db6:	731a      	strb	r2, [r3, #12]
  hspi->pTxBuffPtr++;
 8001db8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001dba:	3301      	adds	r3, #1
 8001dbc:	6383      	str	r3, [r0, #56]	; 0x38
  hspi->TxXferCount--;
 8001dbe:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001dc0:	b29b      	uxth	r3, r3
 8001dc2:	3b01      	subs	r3, #1
 8001dc4:	b29b      	uxth	r3, r3
 8001dc6:	87c3      	strh	r3, [r0, #62]	; 0x3e
  if (hspi->TxXferCount == 0U)
 8001dc8:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001dca:	b29b      	uxth	r3, r3
 8001dcc:	b103      	cbz	r3, 8001dd0 <SPI_TxISR_8BIT+0x22>
}
 8001dce:	bd08      	pop	{r3, pc}
    SPI_CloseTx_ISR(hspi);
 8001dd0:	f7ff ffc2 	bl	8001d58 <SPI_CloseTx_ISR>
}
 8001dd4:	e7fb      	b.n	8001dce <SPI_TxISR_8BIT+0x20>

08001dd6 <SPI_TxISR_16BIT>:
{
 8001dd6:	b508      	push	{r3, lr}
  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8001dd8:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8001dda:	6803      	ldr	r3, [r0, #0]
 8001ddc:	8812      	ldrh	r2, [r2, #0]
 8001dde:	60da      	str	r2, [r3, #12]
  hspi->pTxBuffPtr += sizeof(uint16_t);
 8001de0:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001de2:	3302      	adds	r3, #2
 8001de4:	6383      	str	r3, [r0, #56]	; 0x38
  hspi->TxXferCount--;
 8001de6:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001de8:	b29b      	uxth	r3, r3
 8001dea:	3b01      	subs	r3, #1
 8001dec:	b29b      	uxth	r3, r3
 8001dee:	87c3      	strh	r3, [r0, #62]	; 0x3e
  if (hspi->TxXferCount == 0U)
 8001df0:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001df2:	b29b      	uxth	r3, r3
 8001df4:	b103      	cbz	r3, 8001df8 <SPI_TxISR_16BIT+0x22>
}
 8001df6:	bd08      	pop	{r3, pc}
    SPI_CloseTx_ISR(hspi);
 8001df8:	f7ff ffae 	bl	8001d58 <SPI_CloseTx_ISR>
}
 8001dfc:	e7fb      	b.n	8001df6 <SPI_TxISR_16BIT+0x20>

08001dfe <SPI_CloseRx_ISR>:
{
 8001dfe:	b510      	push	{r4, lr}
 8001e00:	4604      	mov	r4, r0
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
 8001e02:	6802      	ldr	r2, [r0, #0]
 8001e04:	6853      	ldr	r3, [r2, #4]
 8001e06:	f023 0360 	bic.w	r3, r3, #96	; 0x60
 8001e0a:	6053      	str	r3, [r2, #4]
  if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
 8001e0c:	f7fe fefe 	bl	8000c0c <HAL_GetTick>
 8001e10:	4602      	mov	r2, r0
 8001e12:	2164      	movs	r1, #100	; 0x64
 8001e14:	4620      	mov	r0, r4
 8001e16:	f7ff fd69 	bl	80018ec <SPI_EndRxTransaction>
 8001e1a:	b118      	cbz	r0, 8001e24 <SPI_CloseRx_ISR+0x26>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001e1c:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001e1e:	f043 0320 	orr.w	r3, r3, #32
 8001e22:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 8001e24:	2301      	movs	r3, #1
 8001e26:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
    if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
 8001e2a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001e2c:	b91b      	cbnz	r3, 8001e36 <SPI_CloseRx_ISR+0x38>
      HAL_SPI_RxCpltCallback(hspi);
 8001e2e:	4620      	mov	r0, r4
 8001e30:	f7ff ff8f 	bl	8001d52 <HAL_SPI_RxCpltCallback>
}
 8001e34:	bd10      	pop	{r4, pc}
      HAL_SPI_ErrorCallback(hspi);
 8001e36:	4620      	mov	r0, r4
 8001e38:	f7ff ff8d 	bl	8001d56 <HAL_SPI_ErrorCallback>
}
 8001e3c:	e7fa      	b.n	8001e34 <SPI_CloseRx_ISR+0x36>

08001e3e <SPI_RxISR_8BIT>:
{
 8001e3e:	b508      	push	{r3, lr}
  *hspi->pRxBuffPtr = (*(__IO uint8_t *)&hspi->Instance->DR);
 8001e40:	6802      	ldr	r2, [r0, #0]
 8001e42:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001e44:	7b12      	ldrb	r2, [r2, #12]
 8001e46:	701a      	strb	r2, [r3, #0]
  hspi->pRxBuffPtr++;
 8001e48:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001e4a:	3301      	adds	r3, #1
 8001e4c:	6403      	str	r3, [r0, #64]	; 0x40
  hspi->RxXferCount--;
 8001e4e:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8001e52:	b29b      	uxth	r3, r3
 8001e54:	3b01      	subs	r3, #1
 8001e56:	b29b      	uxth	r3, r3
 8001e58:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
  if (hspi->RxXferCount == 0U)
 8001e5c:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8001e60:	b29b      	uxth	r3, r3
 8001e62:	b103      	cbz	r3, 8001e66 <SPI_RxISR_8BIT+0x28>
}
 8001e64:	bd08      	pop	{r3, pc}
    SPI_CloseRx_ISR(hspi);
 8001e66:	f7ff ffca 	bl	8001dfe <SPI_CloseRx_ISR>
}
 8001e6a:	e7fb      	b.n	8001e64 <SPI_RxISR_8BIT+0x26>

08001e6c <SPI_RxISR_16BIT>:
{
 8001e6c:	b508      	push	{r3, lr}
  *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
 8001e6e:	6803      	ldr	r3, [r0, #0]
 8001e70:	68da      	ldr	r2, [r3, #12]
 8001e72:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001e74:	801a      	strh	r2, [r3, #0]
  hspi->pRxBuffPtr += sizeof(uint16_t);
 8001e76:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001e78:	3302      	adds	r3, #2
 8001e7a:	6403      	str	r3, [r0, #64]	; 0x40
  hspi->RxXferCount--;
 8001e7c:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8001e80:	b29b      	uxth	r3, r3
 8001e82:	3b01      	subs	r3, #1
 8001e84:	b29b      	uxth	r3, r3
 8001e86:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
  if (hspi->RxXferCount == 0U)
 8001e8a:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8001e8e:	b29b      	uxth	r3, r3
 8001e90:	b103      	cbz	r3, 8001e94 <SPI_RxISR_16BIT+0x28>
}
 8001e92:	bd08      	pop	{r3, pc}
    SPI_CloseRx_ISR(hspi);
 8001e94:	f7ff ffb3 	bl	8001dfe <SPI_CloseRx_ISR>
}
 8001e98:	e7fb      	b.n	8001e92 <SPI_RxISR_16BIT+0x26>

08001e9a <SPI_CloseRxTx_ISR>:
{
 8001e9a:	b510      	push	{r4, lr}
 8001e9c:	4604      	mov	r4, r0
  tickstart = HAL_GetTick();
 8001e9e:	f7fe feb5 	bl	8000c0c <HAL_GetTick>
 8001ea2:	4602      	mov	r2, r0
  __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8001ea4:	6821      	ldr	r1, [r4, #0]
 8001ea6:	684b      	ldr	r3, [r1, #4]
 8001ea8:	f023 0320 	bic.w	r3, r3, #32
 8001eac:	604b      	str	r3, [r1, #4]
  if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8001eae:	2164      	movs	r1, #100	; 0x64
 8001eb0:	4620      	mov	r0, r4
 8001eb2:	f7ff fccb 	bl	800184c <SPI_EndRxTxTransaction>
 8001eb6:	b118      	cbz	r0, 8001ec0 <SPI_CloseRxTx_ISR+0x26>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001eb8:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001eba:	f043 0320 	orr.w	r3, r3, #32
 8001ebe:	6623      	str	r3, [r4, #96]	; 0x60
    if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
 8001ec0:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001ec2:	b993      	cbnz	r3, 8001eea <SPI_CloseRxTx_ISR+0x50>
      if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 8001ec4:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
 8001ec8:	b2db      	uxtb	r3, r3
 8001eca:	2b04      	cmp	r3, #4
 8001ecc:	d006      	beq.n	8001edc <SPI_CloseRxTx_ISR+0x42>
        hspi->State = HAL_SPI_STATE_READY;
 8001ece:	2301      	movs	r3, #1
 8001ed0:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
        HAL_SPI_TxRxCpltCallback(hspi);
 8001ed4:	4620      	mov	r0, r4
 8001ed6:	f7ff ff3d 	bl	8001d54 <HAL_SPI_TxRxCpltCallback>
}
 8001eda:	bd10      	pop	{r4, pc}
        hspi->State = HAL_SPI_STATE_READY;
 8001edc:	2301      	movs	r3, #1
 8001ede:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
        HAL_SPI_RxCpltCallback(hspi);
 8001ee2:	4620      	mov	r0, r4
 8001ee4:	f7ff ff35 	bl	8001d52 <HAL_SPI_RxCpltCallback>
 8001ee8:	e7f7      	b.n	8001eda <SPI_CloseRxTx_ISR+0x40>
      hspi->State = HAL_SPI_STATE_READY;
 8001eea:	2301      	movs	r3, #1
 8001eec:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
      HAL_SPI_ErrorCallback(hspi);
 8001ef0:	4620      	mov	r0, r4
 8001ef2:	f7ff ff30 	bl	8001d56 <HAL_SPI_ErrorCallback>
}
 8001ef6:	e7f0      	b.n	8001eda <SPI_CloseRxTx_ISR+0x40>

08001ef8 <SPI_2linesTxISR_8BIT>:
{
 8001ef8:	b508      	push	{r3, lr}
  if (hspi->TxXferCount >= 2U)
 8001efa:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001efc:	b29b      	uxth	r3, r3
 8001efe:	2b01      	cmp	r3, #1
 8001f00:	d918      	bls.n	8001f34 <SPI_2linesTxISR_8BIT+0x3c>
    hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8001f02:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8001f04:	6803      	ldr	r3, [r0, #0]
 8001f06:	8812      	ldrh	r2, [r2, #0]
 8001f08:	60da      	str	r2, [r3, #12]
    hspi->pTxBuffPtr += sizeof(uint16_t);
 8001f0a:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001f0c:	3302      	adds	r3, #2
 8001f0e:	6383      	str	r3, [r0, #56]	; 0x38
    hspi->TxXferCount -= 2U;
 8001f10:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001f12:	b29b      	uxth	r3, r3
 8001f14:	3b02      	subs	r3, #2
 8001f16:	b29b      	uxth	r3, r3
 8001f18:	87c3      	strh	r3, [r0, #62]	; 0x3e
  if (hspi->TxXferCount == 0U)
 8001f1a:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001f1c:	b29b      	uxth	r3, r3
 8001f1e:	b943      	cbnz	r3, 8001f32 <SPI_2linesTxISR_8BIT+0x3a>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
 8001f20:	6802      	ldr	r2, [r0, #0]
 8001f22:	6853      	ldr	r3, [r2, #4]
 8001f24:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001f28:	6053      	str	r3, [r2, #4]
    if (hspi->RxXferCount == 0U)
 8001f2a:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8001f2e:	b29b      	uxth	r3, r3
 8001f30:	b16b      	cbz	r3, 8001f4e <SPI_2linesTxISR_8BIT+0x56>
}
 8001f32:	bd08      	pop	{r3, pc}
    *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8001f34:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8001f36:	6803      	ldr	r3, [r0, #0]
 8001f38:	7812      	ldrb	r2, [r2, #0]
 8001f3a:	731a      	strb	r2, [r3, #12]
    hspi->pTxBuffPtr++;
 8001f3c:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001f3e:	3301      	adds	r3, #1
 8001f40:	6383      	str	r3, [r0, #56]	; 0x38
    hspi->TxXferCount--;
 8001f42:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001f44:	b29b      	uxth	r3, r3
 8001f46:	3b01      	subs	r3, #1
 8001f48:	b29b      	uxth	r3, r3
 8001f4a:	87c3      	strh	r3, [r0, #62]	; 0x3e
 8001f4c:	e7e5      	b.n	8001f1a <SPI_2linesTxISR_8BIT+0x22>
      SPI_CloseRxTx_ISR(hspi);
 8001f4e:	f7ff ffa4 	bl	8001e9a <SPI_CloseRxTx_ISR>
}
 8001f52:	e7ee      	b.n	8001f32 <SPI_2linesTxISR_8BIT+0x3a>

08001f54 <SPI_2linesRxISR_8BIT>:
{
 8001f54:	b508      	push	{r3, lr}
  if (hspi->RxXferCount > 1U)
 8001f56:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8001f5a:	b29b      	uxth	r3, r3
 8001f5c:	2b01      	cmp	r3, #1
 8001f5e:	d918      	bls.n	8001f92 <SPI_2linesRxISR_8BIT+0x3e>
    *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
 8001f60:	6803      	ldr	r3, [r0, #0]
 8001f62:	68da      	ldr	r2, [r3, #12]
 8001f64:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001f66:	801a      	strh	r2, [r3, #0]
    hspi->pRxBuffPtr += sizeof(uint16_t);
 8001f68:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001f6a:	3302      	adds	r3, #2
 8001f6c:	6403      	str	r3, [r0, #64]	; 0x40
    hspi->RxXferCount -= 2U;
 8001f6e:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8001f72:	b29b      	uxth	r3, r3
 8001f74:	3b02      	subs	r3, #2
 8001f76:	b29b      	uxth	r3, r3
 8001f78:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
    if (hspi->RxXferCount == 1U)
 8001f7c:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8001f80:	b29b      	uxth	r3, r3
 8001f82:	2b01      	cmp	r3, #1
 8001f84:	d113      	bne.n	8001fae <SPI_2linesRxISR_8BIT+0x5a>
      SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8001f86:	6802      	ldr	r2, [r0, #0]
 8001f88:	6853      	ldr	r3, [r2, #4]
 8001f8a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001f8e:	6053      	str	r3, [r2, #4]
 8001f90:	e00d      	b.n	8001fae <SPI_2linesRxISR_8BIT+0x5a>
    *hspi->pRxBuffPtr = *((__IO uint8_t *)&hspi->Instance->DR);
 8001f92:	6802      	ldr	r2, [r0, #0]
 8001f94:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001f96:	7b12      	ldrb	r2, [r2, #12]
 8001f98:	701a      	strb	r2, [r3, #0]
    hspi->pRxBuffPtr++;
 8001f9a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001f9c:	3301      	adds	r3, #1
 8001f9e:	6403      	str	r3, [r0, #64]	; 0x40
    hspi->RxXferCount--;
 8001fa0:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8001fa4:	b29b      	uxth	r3, r3
 8001fa6:	3b01      	subs	r3, #1
 8001fa8:	b29b      	uxth	r3, r3
 8001faa:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
  if (hspi->RxXferCount == 0U)
 8001fae:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8001fb2:	b29b      	uxth	r3, r3
 8001fb4:	b93b      	cbnz	r3, 8001fc6 <SPI_2linesRxISR_8BIT+0x72>
    __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
 8001fb6:	6802      	ldr	r2, [r0, #0]
 8001fb8:	6853      	ldr	r3, [r2, #4]
 8001fba:	f023 0360 	bic.w	r3, r3, #96	; 0x60
 8001fbe:	6053      	str	r3, [r2, #4]
    if (hspi->TxXferCount == 0U)
 8001fc0:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001fc2:	b29b      	uxth	r3, r3
 8001fc4:	b103      	cbz	r3, 8001fc8 <SPI_2linesRxISR_8BIT+0x74>
}
 8001fc6:	bd08      	pop	{r3, pc}
      SPI_CloseRxTx_ISR(hspi);
 8001fc8:	f7ff ff67 	bl	8001e9a <SPI_CloseRxTx_ISR>
}
 8001fcc:	e7fb      	b.n	8001fc6 <SPI_2linesRxISR_8BIT+0x72>

08001fce <SPI_2linesTxISR_16BIT>:
{
 8001fce:	b508      	push	{r3, lr}
  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8001fd0:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8001fd2:	6803      	ldr	r3, [r0, #0]
 8001fd4:	8812      	ldrh	r2, [r2, #0]
 8001fd6:	60da      	str	r2, [r3, #12]
  hspi->pTxBuffPtr += sizeof(uint16_t);
 8001fd8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001fda:	3302      	adds	r3, #2
 8001fdc:	6383      	str	r3, [r0, #56]	; 0x38
  hspi->TxXferCount--;
 8001fde:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001fe0:	b29b      	uxth	r3, r3
 8001fe2:	3b01      	subs	r3, #1
 8001fe4:	b29b      	uxth	r3, r3
 8001fe6:	87c3      	strh	r3, [r0, #62]	; 0x3e
  if (hspi->TxXferCount == 0U)
 8001fe8:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 8001fea:	b29b      	uxth	r3, r3
 8001fec:	b943      	cbnz	r3, 8002000 <SPI_2linesTxISR_16BIT+0x32>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
 8001fee:	6802      	ldr	r2, [r0, #0]
 8001ff0:	6853      	ldr	r3, [r2, #4]
 8001ff2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001ff6:	6053      	str	r3, [r2, #4]
    if (hspi->RxXferCount == 0U)
 8001ff8:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 8001ffc:	b29b      	uxth	r3, r3
 8001ffe:	b103      	cbz	r3, 8002002 <SPI_2linesTxISR_16BIT+0x34>
}
 8002000:	bd08      	pop	{r3, pc}
      SPI_CloseRxTx_ISR(hspi);
 8002002:	f7ff ff4a 	bl	8001e9a <SPI_CloseRxTx_ISR>
}
 8002006:	e7fb      	b.n	8002000 <SPI_2linesTxISR_16BIT+0x32>

08002008 <SPI_2linesRxISR_16BIT>:
{
 8002008:	b508      	push	{r3, lr}
  *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
 800200a:	6803      	ldr	r3, [r0, #0]
 800200c:	68da      	ldr	r2, [r3, #12]
 800200e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8002010:	801a      	strh	r2, [r3, #0]
  hspi->pRxBuffPtr += sizeof(uint16_t);
 8002012:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8002014:	3302      	adds	r3, #2
 8002016:	6403      	str	r3, [r0, #64]	; 0x40
  hspi->RxXferCount--;
 8002018:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 800201c:	b29b      	uxth	r3, r3
 800201e:	3b01      	subs	r3, #1
 8002020:	b29b      	uxth	r3, r3
 8002022:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
  if (hspi->RxXferCount == 0U)
 8002026:	f8b0 3046 	ldrh.w	r3, [r0, #70]	; 0x46
 800202a:	b29b      	uxth	r3, r3
 800202c:	b93b      	cbnz	r3, 800203e <SPI_2linesRxISR_16BIT+0x36>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
 800202e:	6802      	ldr	r2, [r0, #0]
 8002030:	6853      	ldr	r3, [r2, #4]
 8002032:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002036:	6053      	str	r3, [r2, #4]
    if (hspi->TxXferCount == 0U)
 8002038:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 800203a:	b29b      	uxth	r3, r3
 800203c:	b103      	cbz	r3, 8002040 <SPI_2linesRxISR_16BIT+0x38>
}
 800203e:	bd08      	pop	{r3, pc}
      SPI_CloseRxTx_ISR(hspi);
 8002040:	f7ff ff2b 	bl	8001e9a <SPI_CloseRxTx_ISR>
}
 8002044:	e7fb      	b.n	800203e <SPI_2linesRxISR_16BIT+0x36>
	...

08002048 <HAL_SPI_IRQHandler>:
{
 8002048:	b510      	push	{r4, lr}
 800204a:	b084      	sub	sp, #16
 800204c:	4604      	mov	r4, r0
  uint32_t itsource = hspi->Instance->CR2;
 800204e:	6802      	ldr	r2, [r0, #0]
 8002050:	6851      	ldr	r1, [r2, #4]
  uint32_t itflag   = hspi->Instance->SR;
 8002052:	6893      	ldr	r3, [r2, #8]
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
 8002054:	f003 0041 	and.w	r0, r3, #65	; 0x41
 8002058:	2801      	cmp	r0, #1
 800205a:	d067      	beq.n	800212c <HAL_SPI_IRQHandler+0xe4>
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
 800205c:	f013 0f02 	tst.w	r3, #2
 8002060:	d002      	beq.n	8002068 <HAL_SPI_IRQHandler+0x20>
 8002062:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002066:	d168      	bne.n	800213a <HAL_SPI_IRQHandler+0xf2>
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
 8002068:	f413 7fb0 	tst.w	r3, #352	; 0x160
 800206c:	d068      	beq.n	8002140 <HAL_SPI_IRQHandler+0xf8>
       || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 800206e:	f011 0f20 	tst.w	r1, #32
 8002072:	d065      	beq.n	8002140 <HAL_SPI_IRQHandler+0xf8>
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
 8002074:	f013 0f40 	tst.w	r3, #64	; 0x40
 8002078:	d00f      	beq.n	800209a <HAL_SPI_IRQHandler+0x52>
      if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 800207a:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 800207e:	b2c0      	uxtb	r0, r0
 8002080:	2803      	cmp	r0, #3
 8002082:	d05f      	beq.n	8002144 <HAL_SPI_IRQHandler+0xfc>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 8002084:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8002086:	f040 0004 	orr.w	r0, r0, #4
 800208a:	6620      	str	r0, [r4, #96]	; 0x60
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800208c:	2000      	movs	r0, #0
 800208e:	9000      	str	r0, [sp, #0]
 8002090:	68d0      	ldr	r0, [r2, #12]
 8002092:	9000      	str	r0, [sp, #0]
 8002094:	6890      	ldr	r0, [r2, #8]
 8002096:	9000      	str	r0, [sp, #0]
 8002098:	9800      	ldr	r0, [sp, #0]
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
 800209a:	f013 0f20 	tst.w	r3, #32
 800209e:	d00c      	beq.n	80020ba <HAL_SPI_IRQHandler+0x72>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 80020a0:	6e20      	ldr	r0, [r4, #96]	; 0x60
 80020a2:	f040 0001 	orr.w	r0, r0, #1
 80020a6:	6620      	str	r0, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 80020a8:	2000      	movs	r0, #0
 80020aa:	9002      	str	r0, [sp, #8]
 80020ac:	6890      	ldr	r0, [r2, #8]
 80020ae:	9002      	str	r0, [sp, #8]
 80020b0:	6810      	ldr	r0, [r2, #0]
 80020b2:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 80020b6:	6010      	str	r0, [r2, #0]
 80020b8:	9a02      	ldr	r2, [sp, #8]
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
 80020ba:	f413 7f80 	tst.w	r3, #256	; 0x100
 80020be:	d009      	beq.n	80020d4 <HAL_SPI_IRQHandler+0x8c>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 80020c0:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80020c2:	f043 0308 	orr.w	r3, r3, #8
 80020c6:	6623      	str	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 80020c8:	2300      	movs	r3, #0
 80020ca:	9303      	str	r3, [sp, #12]
 80020cc:	6823      	ldr	r3, [r4, #0]
 80020ce:	689b      	ldr	r3, [r3, #8]
 80020d0:	9303      	str	r3, [sp, #12]
 80020d2:	9b03      	ldr	r3, [sp, #12]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80020d4:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80020d6:	2b00      	cmp	r3, #0
 80020d8:	d032      	beq.n	8002140 <HAL_SPI_IRQHandler+0xf8>
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 80020da:	6822      	ldr	r2, [r4, #0]
 80020dc:	6853      	ldr	r3, [r2, #4]
 80020de:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 80020e2:	6053      	str	r3, [r2, #4]
      hspi->State = HAL_SPI_STATE_READY;
 80020e4:	2301      	movs	r3, #1
 80020e6:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 80020ea:	f011 0f03 	tst.w	r1, #3
 80020ee:	d031      	beq.n	8002154 <HAL_SPI_IRQHandler+0x10c>
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 80020f0:	6822      	ldr	r2, [r4, #0]
 80020f2:	6853      	ldr	r3, [r2, #4]
 80020f4:	f023 0303 	bic.w	r3, r3, #3
 80020f8:	6053      	str	r3, [r2, #4]
        if (hspi->hdmarx != NULL)
 80020fa:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80020fc:	b14b      	cbz	r3, 8002112 <HAL_SPI_IRQHandler+0xca>
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 80020fe:	4a17      	ldr	r2, [pc, #92]	; (800215c <HAL_SPI_IRQHandler+0x114>)
 8002100:	651a      	str	r2, [r3, #80]	; 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
 8002102:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8002104:	f7fe fe18 	bl	8000d38 <HAL_DMA_Abort_IT>
 8002108:	b118      	cbz	r0, 8002112 <HAL_SPI_IRQHandler+0xca>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 800210a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800210c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002110:	6623      	str	r3, [r4, #96]	; 0x60
        if (hspi->hdmatx != NULL)
 8002112:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002114:	b1a3      	cbz	r3, 8002140 <HAL_SPI_IRQHandler+0xf8>
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 8002116:	4a11      	ldr	r2, [pc, #68]	; (800215c <HAL_SPI_IRQHandler+0x114>)
 8002118:	651a      	str	r2, [r3, #80]	; 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
 800211a:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800211c:	f7fe fe0c 	bl	8000d38 <HAL_DMA_Abort_IT>
 8002120:	b170      	cbz	r0, 8002140 <HAL_SPI_IRQHandler+0xf8>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 8002122:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8002124:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002128:	6623      	str	r3, [r4, #96]	; 0x60
 800212a:	e009      	b.n	8002140 <HAL_SPI_IRQHandler+0xf8>
      (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
 800212c:	f011 0f40 	tst.w	r1, #64	; 0x40
 8002130:	d094      	beq.n	800205c <HAL_SPI_IRQHandler+0x14>
    hspi->RxISR(hspi);
 8002132:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8002134:	4620      	mov	r0, r4
 8002136:	4798      	blx	r3
    return;
 8002138:	e002      	b.n	8002140 <HAL_SPI_IRQHandler+0xf8>
    hspi->TxISR(hspi);
 800213a:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800213c:	4620      	mov	r0, r4
 800213e:	4798      	blx	r3
}
 8002140:	b004      	add	sp, #16
 8002142:	bd10      	pop	{r4, pc}
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8002144:	2300      	movs	r3, #0
 8002146:	9301      	str	r3, [sp, #4]
 8002148:	68d3      	ldr	r3, [r2, #12]
 800214a:	9301      	str	r3, [sp, #4]
 800214c:	6893      	ldr	r3, [r2, #8]
 800214e:	9301      	str	r3, [sp, #4]
 8002150:	9b01      	ldr	r3, [sp, #4]
        return;
 8002152:	e7f5      	b.n	8002140 <HAL_SPI_IRQHandler+0xf8>
        HAL_SPI_ErrorCallback(hspi);
 8002154:	4620      	mov	r0, r4
 8002156:	f7ff fdfe 	bl	8001d56 <HAL_SPI_ErrorCallback>
    return;
 800215a:	e7f1      	b.n	8002140 <HAL_SPI_IRQHandler+0xf8>
 800215c:	08002161 	.word	0x08002161

08002160 <SPI_DMAAbortOnError>:
{
 8002160:	b508      	push	{r3, lr}
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8002162:	6b80      	ldr	r0, [r0, #56]	; 0x38
  hspi->RxXferCount = 0U;
 8002164:	2300      	movs	r3, #0
 8002166:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
  hspi->TxXferCount = 0U;
 800216a:	87c3      	strh	r3, [r0, #62]	; 0x3e
  HAL_SPI_ErrorCallback(hspi);
 800216c:	f7ff fdf3 	bl	8001d56 <HAL_SPI_ErrorCallback>
}
 8002170:	bd08      	pop	{r3, pc}

08002172 <HAL_SPI_GetState>:
  return hspi->State;
 8002172:	f890 005d 	ldrb.w	r0, [r0, #93]	; 0x5d
}
 8002176:	4770      	bx	lr

08002178 <App_ReadBoardInfo>:
* \param ptBoardInfo [out]  Board information
*/
/**************************************************************************************/
void App_ReadBoardInfo( const CIFXHANDLE         hDriver,
                        BOARD_INFORMATION* const ptBoardInfo )
{
 8002178:	b5f0      	push	{r4, r5, r6, r7, lr}
 800217a:	b08f      	sub	sp, #60	; 0x3c
 800217c:	4605      	mov	r5, r0
 800217e:	460c      	mov	r4, r1
  CIFXHANDLE                       hSys     = NULL;
 8002180:	2300      	movs	r3, #0
 8002182:	930d      	str	r3, [sp, #52]	; 0x34
  SYSTEM_CHANNEL_SYSTEM_INFO_BLOCK tSysInfo = ptBoardInfo->tSystemInfo;
 8002184:	f101 0c3d 	add.w	ip, r1, #61	; 0x3d
 8002188:	ae01      	add	r6, sp, #4
 800218a:	f101 076d 	add.w	r7, r1, #109	; 0x6d
 800218e:	46b6      	mov	lr, r6
 8002190:	f8dc 0000 	ldr.w	r0, [ip]
 8002194:	f8dc 1004 	ldr.w	r1, [ip, #4]
 8002198:	f8dc 2008 	ldr.w	r2, [ip, #8]
 800219c:	f8dc 300c 	ldr.w	r3, [ip, #12]
 80021a0:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 80021a4:	f10c 0c10 	add.w	ip, ip, #16
 80021a8:	4676      	mov	r6, lr
 80021aa:	45bc      	cmp	ip, r7
 80021ac:	d1ef      	bne.n	800218e <App_ReadBoardInfo+0x16>
  long                             lRet     = 0;      /** Return value for common error codes  */

  /** Retrieve board 0 information */
  if(CIFX_NO_ERROR != (lRet = xDriverEnumBoards(hDriver, 0, sizeof(BOARD_INFORMATION), ptBoardInfo)))
 80021ae:	4623      	mov	r3, r4
 80021b0:	226d      	movs	r2, #109	; 0x6d
 80021b2:	2100      	movs	r1, #0
 80021b4:	4628      	mov	r0, r5
 80021b6:	f002 fde1 	bl	8004d7c <xDriverEnumBoards>
 80021ba:	b108      	cbz	r0, 80021c0 <App_ReadBoardInfo+0x48>
    PRINTF("HW Revision      : %u" NEWLINE, (unsigned int)tSysInfo.bHwRevision);
    PRINTF("HW Compatibility : %u" NEWLINE, (unsigned int)tSysInfo.bHwCompatibility);

    xSysdeviceClose(hSys);
  }
}
 80021bc:	b00f      	add	sp, #60	; 0x3c
 80021be:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(CIFX_NO_ERROR != (lRet = xSysdeviceOpen(hDriver, "cifX0", &hSys)))
 80021c0:	aa0d      	add	r2, sp, #52	; 0x34
 80021c2:	4909      	ldr	r1, [pc, #36]	; (80021e8 <App_ReadBoardInfo+0x70>)
 80021c4:	4628      	mov	r0, r5
 80021c6:	f002 fa5f 	bl	8004688 <xSysdeviceOpen>
 80021ca:	2800      	cmp	r0, #0
 80021cc:	d1f6      	bne.n	80021bc <App_ReadBoardInfo+0x44>
  else if(CIFX_NO_ERROR != (lRet = xSysdeviceInfo(hSys, CIFX_INFO_CMD_SYSTEM_INFO_BLOCK, sizeof(tSysInfo), &tSysInfo)))
 80021ce:	ab01      	add	r3, sp, #4
 80021d0:	2230      	movs	r2, #48	; 0x30
 80021d2:	2102      	movs	r1, #2
 80021d4:	980d      	ldr	r0, [sp, #52]	; 0x34
 80021d6:	f002 fb4d 	bl	8004874 <xSysdeviceInfo>
 80021da:	2800      	cmp	r0, #0
 80021dc:	d1ee      	bne.n	80021bc <App_ReadBoardInfo+0x44>
    xSysdeviceClose(hSys);
 80021de:	980d      	ldr	r0, [sp, #52]	; 0x34
 80021e0:	f002 fa8e 	bl	8004700 <xSysdeviceClose>
}
 80021e4:	e7ea      	b.n	80021bc <App_ReadBoardInfo+0x44>
 80021e6:	bf00      	nop
 80021e8:	0800a764 	.word	0x0800a764

080021ec <App_AllChannels_Open>:
*/
/**************************************************************************************/
int32_t App_AllChannels_Open( APP_DATA_T* ptAppData,
                              CIFXHANDLE  hDriver,
                              char*       szDeviceName )
{
 80021ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80021ee:	4605      	mov	r5, r0
 80021f0:	460f      	mov	r7, r1
 80021f2:	4616      	mov	r6, r2
  int i;
  int32_t lRet;

  for (i = 0; i < MAX_COMMUNICATION_CHANNEL_COUNT; i++)
 80021f4:	2400      	movs	r4, #0
 80021f6:	e000      	b.n	80021fa <App_AllChannels_Open+0xe>
 80021f8:	3401      	adds	r4, #1
 80021fa:	2c02      	cmp	r4, #2
 80021fc:	dc12      	bgt.n	8002224 <App_AllChannels_Open+0x38>
  {
    if ((ptAppData->aptChannels[i] != NULL) &&
 80021fe:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 8002202:	2b00      	cmp	r3, #0
 8002204:	d0f8      	beq.n	80021f8 <App_AllChannels_Open+0xc>
        (ptAppData->aptChannels[i]->tProtocol.pfStartChannelConfiguration != NULL))
 8002206:	f8d3 26e4 	ldr.w	r2, [r3, #1764]	; 0x6e4
    if ((ptAppData->aptChannels[i] != NULL) &&
 800220a:	2a00      	cmp	r2, #0
 800220c:	d0f4      	beq.n	80021f8 <App_AllChannels_Open+0xc>
    {
      if (CIFX_NO_ERROR != (lRet = xChannelOpen(hDriver, szDeviceName, i, &ptAppData->aptChannels[i]->hChannel)))
 800220e:	f203 633c 	addw	r3, r3, #1596	; 0x63c
 8002212:	4622      	mov	r2, r4
 8002214:	4631      	mov	r1, r6
 8002216:	4638      	mov	r0, r7
 8002218:	f002 fc16 	bl	8004a48 <xChannelOpen>
 800221c:	4603      	mov	r3, r0
 800221e:	2800      	cmp	r0, #0
 8002220:	d0ea      	beq.n	80021f8 <App_AllChannels_Open+0xc>
 8002222:	e000      	b.n	8002226 <App_AllChannels_Open+0x3a>
        PRINTF("ERROR: xChannelOpen for %s, channel %d failed: 0x%08X" NEWLINE, szDeviceName, i, (unsigned int)lRet);
        return lRet;
      }
    }
  }
  return CIFX_NO_ERROR;
 8002224:	2300      	movs	r3, #0
}
 8002226:	4618      	mov	r0, r3
 8002228:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800222c <App_AllChannels_GetChannelInfo_WaitReady>:
*
*   \return 0 on success.
*/
/**************************************************************************************/
void App_AllChannels_GetChannelInfo_WaitReady( APP_DATA_T* ptAppData )
{
 800222c:	b538      	push	{r3, r4, r5, lr}
 800222e:	4605      	mov	r5, r0
  int i;

  for (i = 0; i < MAX_COMMUNICATION_CHANNEL_COUNT; i++)
 8002230:	2400      	movs	r4, #0
 8002232:	e000      	b.n	8002236 <App_AllChannels_GetChannelInfo_WaitReady+0xa>
 8002234:	3401      	adds	r4, #1
 8002236:	2c02      	cmp	r4, #2
 8002238:	dc1b      	bgt.n	8002272 <App_AllChannels_GetChannelInfo_WaitReady+0x46>
  {
    if ((ptAppData->aptChannels[i] != NULL) &&
 800223a:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 800223e:	2b00      	cmp	r3, #0
 8002240:	d0f8      	beq.n	8002234 <App_AllChannels_GetChannelInfo_WaitReady+0x8>
        (ptAppData->aptChannels[i]->hChannel != NULL))
 8002242:	f8d3 363c 	ldr.w	r3, [r3, #1596]	; 0x63c
    if ((ptAppData->aptChannels[i] != NULL) &&
 8002246:	2b00      	cmp	r3, #0
 8002248:	d0f4      	beq.n	8002234 <App_AllChannels_GetChannelInfo_WaitReady+0x8>
    {
      do
      {
        xChannelInfo(ptAppData->aptChannels[i]->hChannel, sizeof(CHANNEL_INFORMATION), &ptAppData->aptChannels[i]->tChannelInfo);
 800224a:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 800224e:	f503 62c8 	add.w	r2, r3, #1600	; 0x640
 8002252:	21a4      	movs	r1, #164	; 0xa4
 8002254:	f8d3 063c 	ldr.w	r0, [r3, #1596]	; 0x63c
 8002258:	f002 fdf4 	bl	8004e44 <xChannelInfo>
      }
      while (!(ptAppData->aptChannels[i]->tChannelInfo.ulDeviceCOSFlags & HIL_COMM_COS_READY) ||
 800225c:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 8002260:	f8d3 36e0 	ldr.w	r3, [r3, #1760]	; 0x6e0
 8002264:	f013 0f01 	tst.w	r3, #1
 8002268:	d0ef      	beq.n	800224a <App_AllChannels_GetChannelInfo_WaitReady+0x1e>
 800226a:	4a02      	ldr	r2, [pc, #8]	; (8002274 <App_AllChannels_GetChannelInfo_WaitReady+0x48>)
 800226c:	4293      	cmp	r3, r2
 800226e:	d0ec      	beq.n	800224a <App_AllChannels_GetChannelInfo_WaitReady+0x1e>
 8002270:	e7e0      	b.n	8002234 <App_AllChannels_GetChannelInfo_WaitReady+0x8>
              (ptAppData->aptChannels[i]->tChannelInfo.ulDeviceCOSFlags == CIFX_DPM_NO_MEMORY_ASSIGNED));
    }
  }
}
 8002272:	bd38      	pop	{r3, r4, r5, pc}
 8002274:	0bad0bad 	.word	0x0bad0bad

08002278 <App_AllChannels_Configure>:
*
*   \return 0 on success.
*/
/**************************************************************************************/
uint32_t App_AllChannels_Configure( APP_DATA_T* ptAppData )
{
 8002278:	b538      	push	{r3, r4, r5, lr}
 800227a:	4605      	mov	r5, r0
  int     i;
  int32_t ulRet = 0;

  //Protocol_StartConfiguration

  for (i = 0; i < MAX_COMMUNICATION_CHANNEL_COUNT; i++)
 800227c:	2400      	movs	r4, #0
 800227e:	e000      	b.n	8002282 <App_AllChannels_Configure+0xa>
 8002280:	3401      	adds	r4, #1
 8002282:	2c02      	cmp	r4, #2
 8002284:	dc10      	bgt.n	80022a8 <App_AllChannels_Configure+0x30>
  {
    if ((ptAppData->aptChannels[i] != NULL) &&
 8002286:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 800228a:	2b00      	cmp	r3, #0
 800228c:	d0f8      	beq.n	8002280 <App_AllChannels_Configure+0x8>
        (ptAppData->aptChannels[i]->hChannel != NULL) &&
 800228e:	f8d3 263c 	ldr.w	r2, [r3, #1596]	; 0x63c
    if ((ptAppData->aptChannels[i] != NULL) &&
 8002292:	2a00      	cmp	r2, #0
 8002294:	d0f4      	beq.n	8002280 <App_AllChannels_Configure+0x8>
        (ptAppData->aptChannels[i]->tProtocol.pfStartChannelConfiguration != NULL))
 8002296:	f8d3 36e4 	ldr.w	r3, [r3, #1764]	; 0x6e4
        (ptAppData->aptChannels[i]->hChannel != NULL) &&
 800229a:	2b00      	cmp	r3, #0
 800229c:	d0f0      	beq.n	8002280 <App_AllChannels_Configure+0x8>
    {
      if (CIFX_NO_ERROR != (ulRet = ptAppData->aptChannels[i]->tProtocol.pfStartChannelConfiguration(ptAppData)))
 800229e:	4628      	mov	r0, r5
 80022a0:	4798      	blx	r3
 80022a2:	2800      	cmp	r0, #0
 80022a4:	d0ec      	beq.n	8002280 <App_AllChannels_Configure+0x8>
 80022a6:	e000      	b.n	80022aa <App_AllChannels_Configure+0x32>
        PRINTF("Error: Protocol_StartConfiguration failed: 0x%08X" NEWLINE, (unsigned int)ulRet);
        return ulRet;
      }
    }
  }
  return 0;
 80022a8:	2000      	movs	r0, #0
}
 80022aa:	bd38      	pop	{r3, r4, r5, pc}

080022ac <App_AllChannels_PacketHandler>:
*
*   \return 0 on success.
*/
/**************************************************************************************/
uint32_t App_AllChannels_PacketHandler( APP_DATA_T* ptAppData )
{
 80022ac:	b538      	push	{r3, r4, r5, lr}
 80022ae:	4605      	mov	r5, r0
  int     i;
  int32_t ulRet = 0;

  for (i = 0; i < MAX_COMMUNICATION_CHANNEL_COUNT; i++)
 80022b0:	2400      	movs	r4, #0
 80022b2:	e000      	b.n	80022b6 <App_AllChannels_PacketHandler+0xa>
 80022b4:	3401      	adds	r4, #1
 80022b6:	2c02      	cmp	r4, #2
 80022b8:	dc10      	bgt.n	80022dc <App_AllChannels_PacketHandler+0x30>
  {
    if ((ptAppData->aptChannels[i] != NULL) &&
 80022ba:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 80022be:	2b00      	cmp	r3, #0
 80022c0:	d0f8      	beq.n	80022b4 <App_AllChannels_PacketHandler+0x8>
        (ptAppData->aptChannels[i]->hChannel != NULL) &&
 80022c2:	f8d3 263c 	ldr.w	r2, [r3, #1596]	; 0x63c
    if ((ptAppData->aptChannels[i] != NULL) &&
 80022c6:	2a00      	cmp	r2, #0
 80022c8:	d0f4      	beq.n	80022b4 <App_AllChannels_PacketHandler+0x8>
        (ptAppData->aptChannels[i]->tProtocol.pfPacketHandler != NULL))
 80022ca:	f8d3 36e8 	ldr.w	r3, [r3, #1768]	; 0x6e8
        (ptAppData->aptChannels[i]->hChannel != NULL) &&
 80022ce:	2b00      	cmp	r3, #0
 80022d0:	d0f0      	beq.n	80022b4 <App_AllChannels_PacketHandler+0x8>
    {
      if (0 != (ulRet = ptAppData->aptChannels[i]->tProtocol.pfPacketHandler(ptAppData)))
 80022d2:	4628      	mov	r0, r5
 80022d4:	4798      	blx	r3
 80022d6:	2800      	cmp	r0, #0
 80022d8:	d0ec      	beq.n	80022b4 <App_AllChannels_PacketHandler+0x8>
 80022da:	e000      	b.n	80022de <App_AllChannels_PacketHandler+0x32>
        PRINTF("Error: Protocol_PacketHandler failed: 0x%08X" NEWLINE, (unsigned int)ulRet);
        return ulRet;
      }
    }
  }
  return 0;
 80022dc:	2000      	movs	r0, #0
}
 80022de:	bd38      	pop	{r3, r4, r5, pc}

080022e0 <App_AllChannels_Close>:
*
*   \return 0 on success.
*/
/**************************************************************************************/
void App_AllChannels_Close( APP_DATA_T* ptAppData )
{
 80022e0:	b538      	push	{r3, r4, r5, lr}
 80022e2:	4605      	mov	r5, r0
  int i;

  for (i = 0; i < MAX_COMMUNICATION_CHANNEL_COUNT; i++)
 80022e4:	2400      	movs	r4, #0
 80022e6:	e000      	b.n	80022ea <App_AllChannels_Close+0xa>
 80022e8:	3401      	adds	r4, #1
 80022ea:	2c02      	cmp	r4, #2
 80022ec:	dc0f      	bgt.n	800230e <App_AllChannels_Close+0x2e>
  {
    if ((ptAppData->aptChannels[i] != NULL) &&
 80022ee:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 80022f2:	2b00      	cmp	r3, #0
 80022f4:	d0f8      	beq.n	80022e8 <App_AllChannels_Close+0x8>
        (ptAppData->aptChannels[i]->hChannel != NULL))
 80022f6:	f8d3 063c 	ldr.w	r0, [r3, #1596]	; 0x63c
    if ((ptAppData->aptChannels[i] != NULL) &&
 80022fa:	2800      	cmp	r0, #0
 80022fc:	d0f4      	beq.n	80022e8 <App_AllChannels_Close+0x8>
    {
      xChannelClose( ptAppData->aptChannels[i]->hChannel );
 80022fe:	f002 fbeb 	bl	8004ad8 <xChannelClose>
      ptAppData->aptChannels[i]->hChannel = NULL;
 8002302:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 8002306:	2200      	movs	r2, #0
 8002308:	f8c3 263c 	str.w	r2, [r3, #1596]	; 0x63c
 800230c:	e7ec      	b.n	80022e8 <App_AllChannels_Close+0x8>
    }
  }
}
 800230e:	bd38      	pop	{r3, r4, r5, pc}

08002310 <App_IODataHandler>:
 *
 * \param ptAppData  [in]  Pointer to application data
 */
/**************************************************************************************/
void App_IODataHandler(void* ptAppResources)
{
 8002310:	b510      	push	{r4, lr}
 8002312:	b082      	sub	sp, #8
 8002314:	4604      	mov	r4, r0
  long            lRet      = CIFX_NO_ERROR; /** Return value for common error codes  */
  APP_DATA_T*     ptAppData = (APP_DATA_T*)ptAppResources;

  if(ptAppData->aptChannels[0]->hChannel != NULL)
 8002316:	6803      	ldr	r3, [r0, #0]
 8002318:	f8d3 063c 	ldr.w	r0, [r3, #1596]	; 0x63c
 800231c:	b1e0      	cbz	r0, 8002358 <App_IODataHandler+0x48>
  {
    /** INPUT DATA *********************************************************************/
    lRet = xChannelIORead(ptAppData->aptChannels[0]->hChannel, 0, 0, sizeof(ptAppData->tInputData), &ptAppData->tInputData, 0);
 800231e:	f104 037b 	add.w	r3, r4, #123	; 0x7b
 8002322:	2100      	movs	r1, #0
 8002324:	9101      	str	r1, [sp, #4]
 8002326:	9300      	str	r3, [sp, #0]
 8002328:	2306      	movs	r3, #6
 800232a:	460a      	mov	r2, r1
 800232c:	f002 fc14 	bl	8004b58 <xChannelIORead>
    if(lRet != CIFX_NO_ERROR)
 8002330:	b1a0      	cbz	r0, 800235c <App_IODataHandler+0x4c>
       * Reason for error could be:
       * 1) netX is not "ready" yet. May happen during startup.
       * 2) netX is not "running" yet. May happen during startup in case the netX is not fully configured yet.
       * 3) netX has not yet established an IO connection. */

      ptAppData->fInputDataValid = false;
 8002332:	2300      	movs	r3, #0
 8002334:	f884 307a 	strb.w	r3, [r4, #122]	; 0x7a

    }

    /** OUTPUT DATA ***************************************/
    /** update output data image to be sent in this cycle */
    ptAppData->tOutputData.output[0]++;
 8002338:	f894 3081 	ldrb.w	r3, [r4, #129]	; 0x81
 800233c:	3301      	adds	r3, #1
 800233e:	f884 3081 	strb.w	r3, [r4, #129]	; 0x81
    lRet = xChannelIOWrite(ptAppData->aptChannels[0]->hChannel, 0, 0, sizeof(ptAppData->tOutputData), &ptAppData->tOutputData, 0);
 8002342:	f854 3b81 	ldr.w	r3, [r4], #129
 8002346:	f8d3 063c 	ldr.w	r0, [r3, #1596]	; 0x63c
 800234a:	2100      	movs	r1, #0
 800234c:	9101      	str	r1, [sp, #4]
 800234e:	9400      	str	r4, [sp, #0]
 8002350:	230a      	movs	r3, #10
 8002352:	460a      	mov	r2, r1
 8002354:	f002 fc76 	bl	8004c44 <xChannelIOWrite>
       * 1) netX is not "ready" yet. May happen during startup.
       * 2) netX is not "running" yet. May happen during startup in case the netX is not fully configured yet.
       * 3) netX has not yet established an IO connection. */
    }
  }
}
 8002358:	b002      	add	sp, #8
 800235a:	bd10      	pop	{r4, pc}
      ptAppData->fInputDataValid = true;
 800235c:	2301      	movs	r3, #1
 800235e:	f884 307a 	strb.w	r3, [r4, #122]	; 0x7a
 8002362:	e7e9      	b.n	8002338 <App_IODataHandler+0x28>

08002364 <App_CifXApplicationDemo>:
{
 8002364:	b570      	push	{r4, r5, r6, lr}
 8002366:	b082      	sub	sp, #8
 8002368:	4605      	mov	r5, r0
  CIFXHANDLE hDriver  = NULL;  /** Handle of cifX driver               */
 800236a:	2300      	movs	r3, #0
 800236c:	9301      	str	r3, [sp, #4]
  uint32_t  ulState   = 0;     /** Actual state returned               */
 800236e:	9300      	str	r3, [sp, #0]
  g_tAppData.fRunning = true;
 8002370:	4c3f      	ldr	r4, [pc, #252]	; (8002470 <App_CifXApplicationDemo+0x10c>)
 8002372:	2001      	movs	r0, #1
 8002374:	f884 0079 	strb.w	r0, [r4, #121]	; 0x79
  g_tAppData.aptChannels[0] = (APP_COMM_CHANNEL_T*)calloc(1, sizeof(APP_COMM_CHANNEL_T));
 8002378:	f240 61ec 	movw	r1, #1772	; 0x6ec
 800237c:	f007 f982 	bl	8009684 <calloc>
 8002380:	6020      	str	r0, [r4, #0]
  g_tAppData.aptChannels[0]->tProtocol = g_tRealtimeProtocolHandlers;
 8002382:	4a3c      	ldr	r2, [pc, #240]	; (8002474 <App_CifXApplicationDemo+0x110>)
 8002384:	f200 63e4 	addw	r3, r0, #1764	; 0x6e4
 8002388:	e892 0003 	ldmia.w	r2, {r0, r1}
 800238c:	e883 0003 	stmia.w	r3, {r0, r1}
  if (CIFX_NO_ERROR != (lRet = xDriverOpen(&hDriver)))
 8002390:	a801      	add	r0, sp, #4
 8002392:	f002 fccd 	bl	8004d30 <xDriverOpen>
 8002396:	4604      	mov	r4, r0
 8002398:	b110      	cbz	r0, 80023a0 <App_CifXApplicationDemo+0x3c>
}
 800239a:	4620      	mov	r0, r4
 800239c:	b002      	add	sp, #8
 800239e:	bd70      	pop	{r4, r5, r6, pc}
  App_ReadBoardInfo(hDriver, &g_tAppData.tBoardInfo);
 80023a0:	4e35      	ldr	r6, [pc, #212]	; (8002478 <App_CifXApplicationDemo+0x114>)
 80023a2:	4631      	mov	r1, r6
 80023a4:	9801      	ldr	r0, [sp, #4]
 80023a6:	f7ff fee7 	bl	8002178 <App_ReadBoardInfo>
  if (CIFX_NO_ERROR != App_AllChannels_Open(&g_tAppData, hDriver, szDeviceName))
 80023aa:	462a      	mov	r2, r5
 80023ac:	9901      	ldr	r1, [sp, #4]
 80023ae:	f1a6 000c 	sub.w	r0, r6, #12
 80023b2:	f7ff ff1b 	bl	80021ec <App_AllChannels_Open>
 80023b6:	b1c8      	cbz	r0, 80023ec <App_CifXApplicationDemo+0x88>
  if (CIFX_NO_ERROR != (lRet = xDriverOpen(&hDriver)))
 80023b8:	4625      	mov	r5, r4
  if ((g_tAppData.aptChannels[0] != NULL) &&
 80023ba:	4b2d      	ldr	r3, [pc, #180]	; (8002470 <App_CifXApplicationDemo+0x10c>)
 80023bc:	681b      	ldr	r3, [r3, #0]
 80023be:	b18b      	cbz	r3, 80023e4 <App_CifXApplicationDemo+0x80>
      (g_tAppData.aptChannels[0]->hChannel != NULL))
 80023c0:	f8d3 063c 	ldr.w	r0, [r3, #1596]	; 0x63c
  if ((g_tAppData.aptChannels[0] != NULL) &&
 80023c4:	b170      	cbz	r0, 80023e4 <App_CifXApplicationDemo+0x80>
    xChannelBusState(g_tAppData.aptChannels[0]->hChannel, CIFX_BUS_STATE_OFF, &ulState, 10);
 80023c6:	230a      	movs	r3, #10
 80023c8:	466a      	mov	r2, sp
 80023ca:	2100      	movs	r1, #0
 80023cc:	f002 fbc0 	bl	8004b50 <xChannelBusState>
    xChannelHostState(g_tAppData.aptChannels[0]->hChannel, CIFX_HOST_STATE_NOT_READY, &ulState, ulTimeout);
 80023d0:	4b27      	ldr	r3, [pc, #156]	; (8002470 <App_CifXApplicationDemo+0x10c>)
 80023d2:	6818      	ldr	r0, [r3, #0]
 80023d4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80023d8:	466a      	mov	r2, sp
 80023da:	2100      	movs	r1, #0
 80023dc:	f8d0 063c 	ldr.w	r0, [r0, #1596]	; 0x63c
 80023e0:	f002 fdae 	bl	8004f40 <xChannelHostState>
  App_AllChannels_Close(&g_tAppData);
 80023e4:	4822      	ldr	r0, [pc, #136]	; (8002470 <App_CifXApplicationDemo+0x10c>)
 80023e6:	f7ff ff7b 	bl	80022e0 <App_AllChannels_Close>
    for (iChannelIdx = 0; iChannelIdx < MAX_COMMUNICATION_CHANNEL_COUNT; iChannelIdx++)
 80023ea:	e02b      	b.n	8002444 <App_CifXApplicationDemo+0xe0>
  App_AllChannels_GetChannelInfo_WaitReady(&g_tAppData);
 80023ec:	f1a6 050c 	sub.w	r5, r6, #12
 80023f0:	4628      	mov	r0, r5
 80023f2:	f7ff ff1b 	bl	800222c <App_AllChannels_GetChannelInfo_WaitReady>
  if (CIFX_NO_ERROR != (lRet = xChannelHostState(g_tAppData.aptChannels[0]->hChannel, CIFX_HOST_STATE_READY, &ulState, ulTimeout)))
 80023f6:	6828      	ldr	r0, [r5, #0]
 80023f8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80023fc:	466a      	mov	r2, sp
 80023fe:	2101      	movs	r1, #1
 8002400:	f8d0 063c 	ldr.w	r0, [r0, #1596]	; 0x63c
 8002404:	f002 fd9c 	bl	8004f40 <xChannelHostState>
 8002408:	4605      	mov	r5, r0
 800240a:	2800      	cmp	r0, #0
 800240c:	d1d5      	bne.n	80023ba <App_CifXApplicationDemo+0x56>
  if (CIFX_NO_ERROR != (lRet = App_AllChannels_Configure(&g_tAppData)))	//Protocol_StartConfiguration
 800240e:	f1a6 000c 	sub.w	r0, r6, #12
 8002412:	f7ff ff31 	bl	8002278 <App_AllChannels_Configure>
 8002416:	4605      	mov	r5, r0
 8002418:	b158      	cbz	r0, 8002432 <App_CifXApplicationDemo+0xce>
 800241a:	e7ce      	b.n	80023ba <App_CifXApplicationDemo+0x56>
	App_IODataHandler(&g_tAppData);
 800241c:	4d14      	ldr	r5, [pc, #80]	; (8002470 <App_CifXApplicationDemo+0x10c>)
 800241e:	4628      	mov	r0, r5
 8002420:	f7ff ff76 	bl	8002310 <App_IODataHandler>
	lRet = App_AllChannels_PacketHandler(&g_tAppData);
 8002424:	4628      	mov	r0, r5
 8002426:	f7ff ff41 	bl	80022ac <App_AllChannels_PacketHandler>
 800242a:	4605      	mov	r5, r0
    OS_Sleep(1);
 800242c:	2001      	movs	r0, #1
 800242e:	f000 fb95 	bl	8002b5c <OS_Sleep>
  while(g_tAppData.fRunning && lRet == CIFX_NO_ERROR)
 8002432:	4b0f      	ldr	r3, [pc, #60]	; (8002470 <App_CifXApplicationDemo+0x10c>)
 8002434:	f893 3079 	ldrb.w	r3, [r3, #121]	; 0x79
 8002438:	2b00      	cmp	r3, #0
 800243a:	d0be      	beq.n	80023ba <App_CifXApplicationDemo+0x56>
 800243c:	2d00      	cmp	r5, #0
 800243e:	d0ed      	beq.n	800241c <App_CifXApplicationDemo+0xb8>
 8002440:	e7bb      	b.n	80023ba <App_CifXApplicationDemo+0x56>
    for (iChannelIdx = 0; iChannelIdx < MAX_COMMUNICATION_CHANNEL_COUNT; iChannelIdx++)
 8002442:	3401      	adds	r4, #1
 8002444:	2c02      	cmp	r4, #2
 8002446:	dc07      	bgt.n	8002458 <App_CifXApplicationDemo+0xf4>
      if (g_tAppData.aptChannels[iChannelIdx] != NULL)
 8002448:	4b09      	ldr	r3, [pc, #36]	; (8002470 <App_CifXApplicationDemo+0x10c>)
 800244a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800244e:	2800      	cmp	r0, #0
 8002450:	d0f7      	beq.n	8002442 <App_CifXApplicationDemo+0xde>
        free(g_tAppData.aptChannels[iChannelIdx]);
 8002452:	f007 f93d 	bl	80096d0 <free>
 8002456:	e7f4      	b.n	8002442 <App_CifXApplicationDemo+0xde>
  Pkt_Deinit();
 8002458:	f000 f8de 	bl	8002618 <Pkt_Deinit>
  g_tAppData.fRunning = false;
 800245c:	2400      	movs	r4, #0
 800245e:	4b04      	ldr	r3, [pc, #16]	; (8002470 <App_CifXApplicationDemo+0x10c>)
 8002460:	f883 4079 	strb.w	r4, [r3, #121]	; 0x79
  xDriverClose(hDriver);
 8002464:	9801      	ldr	r0, [sp, #4]
 8002466:	f002 fc73 	bl	8004d50 <xDriverClose>
  hDriver = NULL;
 800246a:	9401      	str	r4, [sp, #4]
  return lRet;
 800246c:	462c      	mov	r4, r5
 800246e:	e794      	b.n	800239a <App_CifXApplicationDemo+0x36>
 8002470:	2000015c 	.word	0x2000015c
 8002474:	20000010 	.word	0x20000010
 8002478:	20000168 	.word	0x20000168

0800247c <Pkt_QueueConfirmation>:
/**************************************************************************************/
static bool
Pkt_QueueConfirmation( int iChannelIdx, CIFX_PACKET* ptPacket )
{
  int i;
  for(i = 0; i < s_aiReceiveQueueDepths[iChannelIdx]; i++)
 800247c:	2300      	movs	r3, #0
 800247e:	4a13      	ldr	r2, [pc, #76]	; (80024cc <Pkt_QueueConfirmation+0x50>)
 8002480:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 8002484:	429a      	cmp	r2, r3
 8002486:	dd1f      	ble.n	80024c8 <Pkt_QueueConfirmation+0x4c>
{
 8002488:	b510      	push	{r4, lr}
  {
    if(s_aaptReceiveQueue[iChannelIdx][i]->fUsed == false)
 800248a:	4a11      	ldr	r2, [pc, #68]	; (80024d0 <Pkt_QueueConfirmation+0x54>)
 800248c:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 8002490:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 8002494:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8002498:	7814      	ldrb	r4, [r2, #0]
 800249a:	b13c      	cbz	r4, 80024ac <Pkt_QueueConfirmation+0x30>
  for(i = 0; i < s_aiReceiveQueueDepths[iChannelIdx]; i++)
 800249c:	3301      	adds	r3, #1
 800249e:	4a0b      	ldr	r2, [pc, #44]	; (80024cc <Pkt_QueueConfirmation+0x50>)
 80024a0:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 80024a4:	429a      	cmp	r2, r3
 80024a6:	dcf0      	bgt.n	800248a <Pkt_QueueConfirmation+0xe>
      s_aaptReceiveQueue[iChannelIdx][i]->tPacket = *ptPacket;
      return true;
    }
  }

  return false;
 80024a8:	2000      	movs	r0, #0
 80024aa:	e00c      	b.n	80024c6 <Pkt_QueueConfirmation+0x4a>
      s_aaptReceiveQueue[iChannelIdx][i]->fUsed = true;
 80024ac:	2401      	movs	r4, #1
 80024ae:	7014      	strb	r4, [r2, #0]
      s_aaptReceiveQueue[iChannelIdx][i]->tPacket = *ptPacket;
 80024b0:	4b07      	ldr	r3, [pc, #28]	; (80024d0 <Pkt_QueueConfirmation+0x54>)
 80024b2:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80024b6:	f853 000c 	ldr.w	r0, [r3, ip]
 80024ba:	f240 623c 	movw	r2, #1596	; 0x63c
 80024be:	4420      	add	r0, r4
 80024c0:	f007 fbf2 	bl	8009ca8 <memcpy>
      return true;
 80024c4:	4620      	mov	r0, r4
}
 80024c6:	bd10      	pop	{r4, pc}
  return false;
 80024c8:	2000      	movs	r0, #0
}
 80024ca:	4770      	bx	lr
 80024cc:	2000012c 	.word	0x2000012c
 80024d0:	20000120 	.word	0x20000120

080024d4 <Pkt_GetPacketFromQueue>:
 *   \return true:  Packet could be queued
 *           false: Packet could not be queued
 */
/**************************************************************************************/
static bool Pkt_GetPacketFromQueue(int iChannelIdx, CIFX_PACKET* ptPacket)
{
 80024d4:	b5b0      	push	{r4, r5, r7, lr}
 80024d6:	4604      	mov	r4, r0
 80024d8:	4608      	mov	r0, r1
  int i;
  for(i = 0; i < s_aiReceiveQueueDepths[iChannelIdx]; i++)
 80024da:	2300      	movs	r3, #0
 80024dc:	e000      	b.n	80024e0 <Pkt_GetPacketFromQueue+0xc>
 80024de:	3301      	adds	r3, #1
 80024e0:	4a0e      	ldr	r2, [pc, #56]	; (800251c <Pkt_GetPacketFromQueue+0x48>)
 80024e2:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
 80024e6:	429a      	cmp	r2, r3
 80024e8:	dd14      	ble.n	8002514 <Pkt_GetPacketFromQueue+0x40>
  {
    if(s_aaptReceiveQueue[iChannelIdx][i]->fUsed == true)
 80024ea:	4a0d      	ldr	r2, [pc, #52]	; (8002520 <Pkt_GetPacketFromQueue+0x4c>)
 80024ec:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
 80024f0:	009f      	lsls	r7, r3, #2
 80024f2:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 80024f6:	780d      	ldrb	r5, [r1, #0]
 80024f8:	2d00      	cmp	r5, #0
 80024fa:	d0f0      	beq.n	80024de <Pkt_GetPacketFromQueue+0xa>
    {
      *ptPacket = s_aaptReceiveQueue[iChannelIdx][i]->tPacket;
 80024fc:	f240 623c 	movw	r2, #1596	; 0x63c
 8002500:	3101      	adds	r1, #1
 8002502:	f007 fbd1 	bl	8009ca8 <memcpy>
      s_aaptReceiveQueue[iChannelIdx][i]->fUsed = false;
 8002506:	4b06      	ldr	r3, [pc, #24]	; (8002520 <Pkt_GetPacketFromQueue+0x4c>)
 8002508:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800250c:	59db      	ldr	r3, [r3, r7]
 800250e:	2200      	movs	r2, #0
 8002510:	701a      	strb	r2, [r3, #0]
      return true;
 8002512:	e000      	b.n	8002516 <Pkt_GetPacketFromQueue+0x42>
    }
  }
  return false;
 8002514:	2500      	movs	r5, #0
}
 8002516:	4628      	mov	r0, r5
 8002518:	bdb0      	pop	{r4, r5, r7, pc}
 800251a:	bf00      	nop
 800251c:	2000012c 	.word	0x2000012c
 8002520:	20000120 	.word	0x20000120

08002524 <Pkt_TryDequeConfirmation>:
/**************************************************************************************/
static bool Pkt_TryDequeConfirmation( int iChannelIdx,
                                      uint32_t     ulCmd,
                                      uint32_t     ulId,
                                      CIFX_PACKET* ptPacket )
{
 8002524:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002526:	4605      	mov	r5, r0
 8002528:	4618      	mov	r0, r3
  int i;
  for(i = 0; i < s_aiReceiveQueueDepths[iChannelIdx]; i++)
 800252a:	f04f 0c00 	mov.w	ip, #0
 800252e:	e001      	b.n	8002534 <Pkt_TryDequeConfirmation+0x10>
 8002530:	f10c 0c01 	add.w	ip, ip, #1
 8002534:	4c12      	ldr	r4, [pc, #72]	; (8002580 <Pkt_TryDequeConfirmation+0x5c>)
 8002536:	f854 4025 	ldr.w	r4, [r4, r5, lsl #2]
 800253a:	4564      	cmp	r4, ip
 800253c:	dd1d      	ble.n	800257a <Pkt_TryDequeConfirmation+0x56>
  {
    if( (s_aaptReceiveQueue[iChannelIdx][i]->fUsed == true)                  &&
 800253e:	4c11      	ldr	r4, [pc, #68]	; (8002584 <Pkt_TryDequeConfirmation+0x60>)
 8002540:	f854 4025 	ldr.w	r4, [r4, r5, lsl #2]
 8002544:	ea4f 078c 	mov.w	r7, ip, lsl #2
 8002548:	f854 402c 	ldr.w	r4, [r4, ip, lsl #2]
 800254c:	7826      	ldrb	r6, [r4, #0]
 800254e:	2e00      	cmp	r6, #0
 8002550:	d0ee      	beq.n	8002530 <Pkt_TryDequeConfirmation+0xc>
        (s_aaptReceiveQueue[iChannelIdx][i]->tPacket.tHeader.ulCmd == ulCmd) &&
 8002552:	f8d4 e01d 	ldr.w	lr, [r4, #29]
    if( (s_aaptReceiveQueue[iChannelIdx][i]->fUsed == true)                  &&
 8002556:	458e      	cmp	lr, r1
 8002558:	d1ea      	bne.n	8002530 <Pkt_TryDequeConfirmation+0xc>
        (s_aaptReceiveQueue[iChannelIdx][i]->tPacket.tHeader.ulId == ulId)
 800255a:	f8d4 3015 	ldr.w	r3, [r4, #21]
        (s_aaptReceiveQueue[iChannelIdx][i]->tPacket.tHeader.ulCmd == ulCmd) &&
 800255e:	4293      	cmp	r3, r2
 8002560:	d1e6      	bne.n	8002530 <Pkt_TryDequeConfirmation+0xc>
       )
    {
      *ptPacket = s_aaptReceiveQueue[iChannelIdx][i]->tPacket;
 8002562:	f240 623c 	movw	r2, #1596	; 0x63c
 8002566:	1c61      	adds	r1, r4, #1
 8002568:	f007 fb9e 	bl	8009ca8 <memcpy>
      s_aaptReceiveQueue[iChannelIdx][i]->fUsed = false;
 800256c:	4b05      	ldr	r3, [pc, #20]	; (8002584 <Pkt_TryDequeConfirmation+0x60>)
 800256e:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8002572:	59db      	ldr	r3, [r3, r7]
 8002574:	2200      	movs	r2, #0
 8002576:	701a      	strb	r2, [r3, #0]
      return true;
 8002578:	e000      	b.n	800257c <Pkt_TryDequeConfirmation+0x58>
    }
  }
  return false;
 800257a:	2600      	movs	r6, #0
}
 800257c:	4630      	mov	r0, r6
 800257e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002580:	2000012c 	.word	0x2000012c
 8002584:	20000120 	.word	0x20000120

08002588 <Pkt_DispatchIndication>:
 */
/**************************************************************************************/

static bool
Pkt_DispatchIndication( int iChannelIdx, CIFX_PACKET* ptPacket )
{
 8002588:	b510      	push	{r4, lr}
 800258a:	4603      	mov	r3, r0
  /* Dispatch this indication */
  if(s_atIndicationHandler[iChannelIdx].fnHandler)
 800258c:	4a05      	ldr	r2, [pc, #20]	; (80025a4 <Pkt_DispatchIndication+0x1c>)
 800258e:	f852 4030 	ldr.w	r4, [r2, r0, lsl #3]
 8002592:	b12c      	cbz	r4, 80025a0 <Pkt_DispatchIndication+0x18>
 8002594:	4608      	mov	r0, r1
  {
    return s_atIndicationHandler[iChannelIdx].fnHandler(ptPacket, s_atIndicationHandler[iChannelIdx].pvUserData);
 8002596:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800259a:	6859      	ldr	r1, [r3, #4]
 800259c:	47a0      	blx	r4
  }
  else
  {
    return false;
  }
}
 800259e:	bd10      	pop	{r4, pc}
    return false;
 80025a0:	2000      	movs	r0, #0
 80025a2:	e7fc      	b.n	800259e <Pkt_DispatchIndication+0x16>
 80025a4:	20000138 	.word	0x20000138

080025a8 <Pkt_Init>:
  if (iChannelIdx >= MAX_COMMUNICATION_CHANNEL_COUNT)
 80025a8:	2802      	cmp	r0, #2
 80025aa:	dc2b      	bgt.n	8002604 <Pkt_Init+0x5c>
{
 80025ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80025b0:	4605      	mov	r5, r0
 80025b2:	460f      	mov	r7, r1
  if (s_aaptReceiveQueue[iChannelIdx] != NULL)
 80025b4:	4b16      	ldr	r3, [pc, #88]	; (8002610 <Pkt_Init+0x68>)
 80025b6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80025ba:	b113      	cbz	r3, 80025c2 <Pkt_Init+0x1a>
    return false;
 80025bc:	2000      	movs	r0, #0
}
 80025be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  s_aaptReceiveQueue[iChannelIdx] = (SYNC_PACKET_INTERFACE_QUEUED_PACKET_T**)calloc( iReceiveQueueDepth, sizeof(SYNC_PACKET_INTERFACE_QUEUED_PACKET_T*));
 80025c2:	2104      	movs	r1, #4
 80025c4:	4638      	mov	r0, r7
 80025c6:	f007 f85d 	bl	8009684 <calloc>
 80025ca:	4b11      	ldr	r3, [pc, #68]	; (8002610 <Pkt_Init+0x68>)
 80025cc:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
  if (NULL == s_aaptReceiveQueue[iChannelIdx])
 80025d0:	b1d0      	cbz	r0, 8002608 <Pkt_Init+0x60>
  for (i = 0; i < iReceiveQueueDepth; i++)
 80025d2:	2400      	movs	r4, #0
 80025d4:	42bc      	cmp	r4, r7
 80025d6:	da10      	bge.n	80025fa <Pkt_Init+0x52>
    s_aaptReceiveQueue[iChannelIdx][i] = (SYNC_PACKET_INTERFACE_QUEUED_PACKET_T*)calloc( 1, sizeof(SYNC_PACKET_INTERFACE_QUEUED_PACKET_T) );
 80025d8:	4e0d      	ldr	r6, [pc, #52]	; (8002610 <Pkt_Init+0x68>)
 80025da:	f856 8025 	ldr.w	r8, [r6, r5, lsl #2]
 80025de:	f240 613d 	movw	r1, #1597	; 0x63d
 80025e2:	2001      	movs	r0, #1
 80025e4:	f007 f84e 	bl	8009684 <calloc>
 80025e8:	f848 0024 	str.w	r0, [r8, r4, lsl #2]
    if (NULL == s_aaptReceiveQueue[iChannelIdx][i])
 80025ec:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80025f0:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80025f4:	b153      	cbz	r3, 800260c <Pkt_Init+0x64>
  for (i = 0; i < iReceiveQueueDepth; i++)
 80025f6:	3401      	adds	r4, #1
 80025f8:	e7ec      	b.n	80025d4 <Pkt_Init+0x2c>
  s_aiReceiveQueueDepths[iChannelIdx] = iReceiveQueueDepth;
 80025fa:	4b06      	ldr	r3, [pc, #24]	; (8002614 <Pkt_Init+0x6c>)
 80025fc:	f843 7025 	str.w	r7, [r3, r5, lsl #2]
  return true;
 8002600:	2001      	movs	r0, #1
 8002602:	e7dc      	b.n	80025be <Pkt_Init+0x16>
    return false;
 8002604:	2000      	movs	r0, #0
}
 8002606:	4770      	bx	lr
    return false;
 8002608:	2000      	movs	r0, #0
 800260a:	e7d8      	b.n	80025be <Pkt_Init+0x16>
      return false;
 800260c:	2000      	movs	r0, #0
 800260e:	e7d6      	b.n	80025be <Pkt_Init+0x16>
 8002610:	20000120 	.word	0x20000120
 8002614:	2000012c 	.word	0x2000012c

08002618 <Pkt_Deinit>:
{
 8002618:	b538      	push	{r3, r4, r5, lr}
  for( iChannelIdx = 0; iChannelIdx < MAX_COMMUNICATION_CHANNEL_COUNT; iChannelIdx++ )
 800261a:	2500      	movs	r5, #0
 800261c:	e015      	b.n	800264a <Pkt_Deinit+0x32>
      for (iCnfQueueIdx = 0; iCnfQueueIdx < s_aiReceiveQueueDepths[iChannelIdx]; iCnfQueueIdx++)
 800261e:	3401      	adds	r4, #1
 8002620:	4b13      	ldr	r3, [pc, #76]	; (8002670 <Pkt_Deinit+0x58>)
 8002622:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8002626:	42a3      	cmp	r3, r4
 8002628:	dd09      	ble.n	800263e <Pkt_Deinit+0x26>
        if (s_aaptReceiveQueue[iChannelIdx][iCnfQueueIdx] != NULL)
 800262a:	4b12      	ldr	r3, [pc, #72]	; (8002674 <Pkt_Deinit+0x5c>)
 800262c:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8002630:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8002634:	2800      	cmp	r0, #0
 8002636:	d0f2      	beq.n	800261e <Pkt_Deinit+0x6>
          free( s_aaptReceiveQueue[iChannelIdx][iCnfQueueIdx] );
 8002638:	f007 f84a 	bl	80096d0 <free>
 800263c:	e7ef      	b.n	800261e <Pkt_Deinit+0x6>
      free( s_aaptReceiveQueue[iChannelIdx] );
 800263e:	4b0d      	ldr	r3, [pc, #52]	; (8002674 <Pkt_Deinit+0x5c>)
 8002640:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8002644:	f007 f844 	bl	80096d0 <free>
  for( iChannelIdx = 0; iChannelIdx < MAX_COMMUNICATION_CHANNEL_COUNT; iChannelIdx++ )
 8002648:	3501      	adds	r5, #1
 800264a:	2d02      	cmp	r5, #2
 800264c:	dc06      	bgt.n	800265c <Pkt_Deinit+0x44>
    if( s_aaptReceiveQueue[iChannelIdx] != NULL)
 800264e:	4b09      	ldr	r3, [pc, #36]	; (8002674 <Pkt_Deinit+0x5c>)
 8002650:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8002654:	2b00      	cmp	r3, #0
 8002656:	d0f7      	beq.n	8002648 <Pkt_Deinit+0x30>
      for (iCnfQueueIdx = 0; iCnfQueueIdx < s_aiReceiveQueueDepths[iChannelIdx]; iCnfQueueIdx++)
 8002658:	2400      	movs	r4, #0
 800265a:	e7e1      	b.n	8002620 <Pkt_Deinit+0x8>
  memset( s_aiReceiveQueueDepths, 0, sizeof(s_aiReceiveQueueDepths) );
 800265c:	4a04      	ldr	r2, [pc, #16]	; (8002670 <Pkt_Deinit+0x58>)
 800265e:	2300      	movs	r3, #0
 8002660:	6013      	str	r3, [r2, #0]
 8002662:	6053      	str	r3, [r2, #4]
 8002664:	6093      	str	r3, [r2, #8]
  memset( s_aaptReceiveQueue,     0, sizeof(s_aaptReceiveQueue) );
 8002666:	4a03      	ldr	r2, [pc, #12]	; (8002674 <Pkt_Deinit+0x5c>)
 8002668:	6013      	str	r3, [r2, #0]
 800266a:	6053      	str	r3, [r2, #4]
 800266c:	6093      	str	r3, [r2, #8]
}
 800266e:	bd38      	pop	{r3, r4, r5, pc}
 8002670:	2000012c 	.word	0x2000012c
 8002674:	20000120 	.word	0x20000120

08002678 <Pkt_SendPacket>:
{
 8002678:	b508      	push	{r3, lr}
 800267a:	468c      	mov	ip, r1
 800267c:	4611      	mov	r1, r2
  lRet = xChannelPutPacket(ptAppData->aptChannels[iChannelIdx]->hChannel, ptPacket, ulTimeout);
 800267e:	f850 002c 	ldr.w	r0, [r0, ip, lsl #2]
 8002682:	461a      	mov	r2, r3
 8002684:	f8d0 063c 	ldr.w	r0, [r0, #1596]	; 0x63c
 8002688:	f002 fa2c 	bl	8004ae4 <xChannelPutPacket>
  if(CIFX_NO_ERROR == lRet)
 800268c:	b920      	cbnz	r0, 8002698 <Pkt_SendPacket+0x20>
    s_tPacketCounter.ulPacketSendCountSuccess++;
 800268e:	4a05      	ldr	r2, [pc, #20]	; (80026a4 <Pkt_SendPacket+0x2c>)
 8002690:	6813      	ldr	r3, [r2, #0]
 8002692:	3301      	adds	r3, #1
 8002694:	6013      	str	r3, [r2, #0]
}
 8002696:	bd08      	pop	{r3, pc}
    s_tPacketCounter.ulPacketSendCountError++;
 8002698:	4a02      	ldr	r2, [pc, #8]	; (80026a4 <Pkt_SendPacket+0x2c>)
 800269a:	6853      	ldr	r3, [r2, #4]
 800269c:	3301      	adds	r3, #1
 800269e:	6053      	str	r3, [r2, #4]
  return lRet;
 80026a0:	e7f9      	b.n	8002696 <Pkt_SendPacket+0x1e>
 80026a2:	bf00      	nop
 80026a4:	20000150 	.word	0x20000150

080026a8 <Pkt_ReceivePacket>:
{
 80026a8:	b508      	push	{r3, lr}
  lRet = xChannelGetPacket(ptAppData->aptChannels[iChannelIdx]->hChannel, sizeof(*ptPacket), ptPacket, ulTimeout);
 80026aa:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
 80026ae:	f240 613c 	movw	r1, #1596	; 0x63c
 80026b2:	f8d0 063c 	ldr.w	r0, [r0, #1596]	; 0x63c
 80026b6:	f002 fa2f 	bl	8004b18 <xChannelGetPacket>
}
 80026ba:	bd08      	pop	{r3, pc}

080026bc <Pkt_RegisterIndicationHandler>:
  if( NULL == s_atIndicationHandler[iChannelIdx].fnHandler)
 80026bc:	4b06      	ldr	r3, [pc, #24]	; (80026d8 <Pkt_RegisterIndicationHandler+0x1c>)
 80026be:	f853 3030 	ldr.w	r3, [r3, r0, lsl #3]
 80026c2:	b10b      	cbz	r3, 80026c8 <Pkt_RegisterIndicationHandler+0xc>
    return false;
 80026c4:	2000      	movs	r0, #0
}
 80026c6:	4770      	bx	lr
    s_atIndicationHandler[iChannelIdx].fnHandler = fnHandler;
 80026c8:	4b03      	ldr	r3, [pc, #12]	; (80026d8 <Pkt_RegisterIndicationHandler+0x1c>)
 80026ca:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
    s_atIndicationHandler[iChannelIdx].pvUserData = pvUserData;
 80026ce:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 80026d2:	605a      	str	r2, [r3, #4]
    return true;
 80026d4:	2001      	movs	r0, #1
 80026d6:	4770      	bx	lr
 80026d8:	20000138 	.word	0x20000138

080026dc <Pkt_CheckReceiveMailbox>:

uint32_t
Pkt_CheckReceiveMailbox( APP_DATA_T *ptAppData,
                         int iChannelIdx,
                         CIFX_PACKET* ptPacket )
{
 80026dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80026de:	4607      	mov	r7, r0
 80026e0:	460e      	mov	r6, r1
 80026e2:	4614      	mov	r4, r2
  uint32_t ulRet = CIFX_NO_ERROR;

  /* First, let's see if there are some unprocessed confirmations in our queue. */
  if( false == Pkt_GetPacketFromQueue(iChannelIdx, ptPacket))
 80026e4:	4611      	mov	r1, r2
 80026e6:	4630      	mov	r0, r6
 80026e8:	f7ff fef4 	bl	80024d4 <Pkt_GetPacketFromQueue>
 80026ec:	b940      	cbnz	r0, 8002700 <Pkt_CheckReceiveMailbox+0x24>
  {
    /* No packets in the confirmation queue --> check the receive mailbox. */
    ulRet = Pkt_ReceivePacket(ptAppData, iChannelIdx, ptPacket, RX_TIMEOUT);
 80026ee:	230a      	movs	r3, #10
 80026f0:	4622      	mov	r2, r4
 80026f2:	4631      	mov	r1, r6
 80026f4:	4638      	mov	r0, r7
 80026f6:	f7ff ffd7 	bl	80026a8 <Pkt_ReceivePacket>
  }

  if( CIFX_NO_ERROR == ulRet)
 80026fa:	4605      	mov	r5, r0
 80026fc:	b930      	cbnz	r0, 800270c <Pkt_CheckReceiveMailbox+0x30>
 80026fe:	e000      	b.n	8002702 <Pkt_CheckReceiveMailbox+0x26>
  uint32_t ulRet = CIFX_NO_ERROR;
 8002700:	2500      	movs	r5, #0
    PRINTF( "[ok] IND:           Packet ulCmd 0x%08x (%s)" NEWLINE NEWLINE,
            (unsigned int)ptPacket->tHeader.ulCmd,
      LookupCommandCode(ptPacket->tHeader.ulCmd));
#endif

    if(!Pkt_DispatchIndication(iChannelIdx, ptPacket))
 8002702:	4621      	mov	r1, r4
 8002704:	4630      	mov	r0, r6
 8002706:	f7ff ff3f 	bl	8002588 <Pkt_DispatchIndication>
 800270a:	b108      	cbz	r0, 8002710 <Pkt_CheckReceiveMailbox+0x34>
      Pkt_SendPacket(ptAppData, iChannelIdx, ptPacket, TX_TIMEOUT);
    }
  }

  return ulRet;
}
 800270c:	4628      	mov	r0, r5
 800270e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ptPacket->tHeader.ulCmd |= 0x01; /* Make it a response */
 8002710:	69e3      	ldr	r3, [r4, #28]
 8002712:	f043 0301 	orr.w	r3, r3, #1
 8002716:	61e3      	str	r3, [r4, #28]
      ptPacket->tHeader.ulLen = 0;
 8002718:	2300      	movs	r3, #0
 800271a:	7423      	strb	r3, [r4, #16]
 800271c:	7463      	strb	r3, [r4, #17]
 800271e:	74a3      	strb	r3, [r4, #18]
 8002720:	74e3      	strb	r3, [r4, #19]
      ptPacket->tHeader.ulState = CIFX_INVALID_COMMAND;
 8002722:	2206      	movs	r2, #6
 8002724:	7622      	strb	r2, [r4, #24]
 8002726:	7663      	strb	r3, [r4, #25]
 8002728:	230a      	movs	r3, #10
 800272a:	76a3      	strb	r3, [r4, #26]
 800272c:	f06f 037f 	mvn.w	r3, #127	; 0x7f
 8002730:	76e3      	strb	r3, [r4, #27]
      Pkt_SendPacket(ptAppData, iChannelIdx, ptPacket, TX_TIMEOUT);
 8002732:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8002736:	4622      	mov	r2, r4
 8002738:	4631      	mov	r1, r6
 800273a:	4638      	mov	r0, r7
 800273c:	f7ff ff9c 	bl	8002678 <Pkt_SendPacket>
  return ulRet;
 8002740:	e7e4      	b.n	800270c <Pkt_CheckReceiveMailbox+0x30>
	...

08002744 <Pkt_SendReceivePacket>:
uint32_t
Pkt_SendReceivePacket( APP_DATA_T  *ptAppData,
                       int          iChannelIdx,
                       CIFX_PACKET* ptPacket,
                       uint32_t     ulTimeout )
{
 8002744:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002748:	4607      	mov	r7, r0
 800274a:	460d      	mov	r5, r1
 800274c:	4614      	mov	r4, r2
 800274e:	4698      	mov	r8, r3
  uint32_t ulRet = CIFX_NO_ERROR;
  uint32_t ulCmd = ptPacket->tHeader.ulCmd;
 8002750:	f8d2 901c 	ldr.w	r9, [r2, #28]
  uint32_t ulPacketId;

  if(!(ptPacket->tHeader.ulExt & (HIL_PACKET_SEQ_MIDDLE | HIL_PACKET_SEQ_LAST)))
 8002754:	6a13      	ldr	r3, [r2, #32]
 8002756:	f013 0fc0 	tst.w	r3, #192	; 0xc0
 800275a:	d103      	bne.n	8002764 <Pkt_SendReceivePacket+0x20>
  {
    s_ulNextPacketId++;
 800275c:	4a2f      	ldr	r2, [pc, #188]	; (800281c <Pkt_SendReceivePacket+0xd8>)
 800275e:	6813      	ldr	r3, [r2, #0]
 8002760:	3301      	adds	r3, #1
 8002762:	6013      	str	r3, [r2, #0]
  }

  ulPacketId             = s_ulNextPacketId;
 8002764:	4b2d      	ldr	r3, [pc, #180]	; (800281c <Pkt_SendReceivePacket+0xd8>)
 8002766:	f8d3 a000 	ldr.w	sl, [r3]
  ptPacket->tHeader.ulId = ulPacketId;
 800276a:	f8c4 a014 	str.w	sl, [r4, #20]

  /* issue the request */
  ulRet = Pkt_SendPacket(ptAppData, iChannelIdx, ptPacket, ulTimeout);
 800276e:	4643      	mov	r3, r8
 8002770:	4622      	mov	r2, r4
 8002772:	4629      	mov	r1, r5
 8002774:	4638      	mov	r0, r7
 8002776:	f7ff ff7f 	bl	8002678 <Pkt_SendPacket>

  if( CIFX_NO_ERROR != ulRet)
 800277a:	4606      	mov	r6, r0
 800277c:	b378      	cbz	r0, 80027de <Pkt_SendReceivePacket+0x9a>
      PRINTF("[!!] SEND/RECV of packet failed with Status: 0x%08x" NEWLINE NEWLINE, (unsigned int) ulRet);
    }
  }

  return ulRet;
}
 800277e:	4630      	mov	r0, r6
 8002780:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if((ptPacket->tHeader.ulCmd == (ulCmd | 0x1)) && (ptPacket->tHeader.ulId == ulPacketId))
 8002784:	6962      	ldr	r2, [r4, #20]
 8002786:	4552      	cmp	r2, sl
 8002788:	d137      	bne.n	80027fa <Pkt_SendReceivePacket+0xb6>
 800278a:	e7f8      	b.n	800277e <Pkt_SendReceivePacket+0x3a>
          if(!Pkt_DispatchIndication(iChannelIdx, ptPacket))
 800278c:	4621      	mov	r1, r4
 800278e:	4628      	mov	r0, r5
 8002790:	f7ff fefa 	bl	8002588 <Pkt_DispatchIndication>
 8002794:	b138      	cbz	r0, 80027a6 <Pkt_SendReceivePacket+0x62>
          if(Pkt_TryDequeConfirmation(iChannelIdx, (ulCmd | 0x1), ulPacketId, ptPacket))
 8002796:	4623      	mov	r3, r4
 8002798:	4652      	mov	r2, sl
 800279a:	4659      	mov	r1, fp
 800279c:	4628      	mov	r0, r5
 800279e:	f7ff fec1 	bl	8002524 <Pkt_TryDequeConfirmation>
 80027a2:	b1e0      	cbz	r0, 80027de <Pkt_SendReceivePacket+0x9a>
 80027a4:	e7eb      	b.n	800277e <Pkt_SendReceivePacket+0x3a>
            ptPacket->tHeader.ulCmd |= 0x01; /* Make it a response */
 80027a6:	69e3      	ldr	r3, [r4, #28]
 80027a8:	f043 0301 	orr.w	r3, r3, #1
 80027ac:	61e3      	str	r3, [r4, #28]
            ptPacket->tHeader.ulLen = 0;
 80027ae:	2300      	movs	r3, #0
 80027b0:	7423      	strb	r3, [r4, #16]
 80027b2:	7463      	strb	r3, [r4, #17]
 80027b4:	74a3      	strb	r3, [r4, #18]
 80027b6:	74e3      	strb	r3, [r4, #19]
            ptPacket->tHeader.ulState = CIFX_INVALID_COMMAND;
 80027b8:	2206      	movs	r2, #6
 80027ba:	7622      	strb	r2, [r4, #24]
 80027bc:	7663      	strb	r3, [r4, #25]
 80027be:	230a      	movs	r3, #10
 80027c0:	76a3      	strb	r3, [r4, #26]
 80027c2:	f06f 037f 	mvn.w	r3, #127	; 0x7f
 80027c6:	76e3      	strb	r3, [r4, #27]
            Pkt_SendPacket(ptAppData, iChannelIdx, ptPacket, TX_TIMEOUT);
 80027c8:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 80027cc:	4622      	mov	r2, r4
 80027ce:	4629      	mov	r1, r5
 80027d0:	4638      	mov	r0, r7
 80027d2:	f7ff ff51 	bl	8002678 <Pkt_SendPacket>
 80027d6:	e7de      	b.n	8002796 <Pkt_SendReceivePacket+0x52>
      else if( CIFX_DEV_GET_NO_PACKET == ulRet)
 80027d8:	4b11      	ldr	r3, [pc, #68]	; (8002820 <Pkt_SendReceivePacket+0xdc>)
 80027da:	4298      	cmp	r0, r3
 80027dc:	d0cf      	beq.n	800277e <Pkt_SendReceivePacket+0x3a>
      ulRet = Pkt_ReceivePacket(ptAppData, iChannelIdx , ptPacket, ulTimeout);
 80027de:	4643      	mov	r3, r8
 80027e0:	4622      	mov	r2, r4
 80027e2:	4629      	mov	r1, r5
 80027e4:	4638      	mov	r0, r7
 80027e6:	f7ff ff5f 	bl	80026a8 <Pkt_ReceivePacket>
      if(CIFX_NO_ERROR == ulRet)
 80027ea:	4606      	mov	r6, r0
 80027ec:	2800      	cmp	r0, #0
 80027ee:	d1f3      	bne.n	80027d8 <Pkt_SendReceivePacket+0x94>
        if((ptPacket->tHeader.ulCmd == (ulCmd | 0x1)) && (ptPacket->tHeader.ulId == ulPacketId))
 80027f0:	69e3      	ldr	r3, [r4, #28]
 80027f2:	f049 0b01 	orr.w	fp, r9, #1
 80027f6:	455b      	cmp	r3, fp
 80027f8:	d0c4      	beq.n	8002784 <Pkt_SendReceivePacket+0x40>
        else if(ptPacket->tHeader.ulCmd & 0x1)
 80027fa:	f013 0f01 	tst.w	r3, #1
 80027fe:	d0c5      	beq.n	800278c <Pkt_SendReceivePacket+0x48>
          if (!Pkt_QueueConfirmation(iChannelIdx, ptPacket))
 8002800:	4621      	mov	r1, r4
 8002802:	4628      	mov	r0, r5
 8002804:	f7ff fe3a 	bl	800247c <Pkt_QueueConfirmation>
 8002808:	2800      	cmp	r0, #0
 800280a:	d1e8      	bne.n	80027de <Pkt_SendReceivePacket+0x9a>
            assert(0);
 800280c:	4b05      	ldr	r3, [pc, #20]	; (8002824 <Pkt_SendReceivePacket+0xe0>)
 800280e:	4a06      	ldr	r2, [pc, #24]	; (8002828 <Pkt_SendReceivePacket+0xe4>)
 8002810:	f240 11ef 	movw	r1, #495	; 0x1ef
 8002814:	4805      	ldr	r0, [pc, #20]	; (800282c <Pkt_SendReceivePacket+0xe8>)
 8002816:	f006 ff17 	bl	8009648 <__assert_func>
 800281a:	bf00      	nop
 800281c:	2000000c 	.word	0x2000000c
 8002820:	800c0019 	.word	0x800c0019
 8002824:	0800a768 	.word	0x0800a768
 8002828:	0800a7f8 	.word	0x0800a7f8
 800282c:	0800a7c4 	.word	0x0800a7c4

08002830 <App_SysPkt_AssembleChannelInitReq>:
 *
 * \param ptPkt  [out] Packet resource used for assembling.
 */
/*****************************************************************************/
void App_SysPkt_AssembleChannelInitReq( CIFX_PACKET* ptPkt )
{
 8002830:	b510      	push	{r4, lr}
 8002832:	4604      	mov	r4, r0
  memset( &ptPkt->tHeader, 0, sizeof(ptPkt->tHeader) );
 8002834:	2228      	movs	r2, #40	; 0x28
 8002836:	2100      	movs	r1, #0
 8002838:	f007 f977 	bl	8009b2a <memset>

  ptPkt->tHeader.ulDest = HIL_PACKET_DEST_DEFAULT_CHANNEL;
 800283c:	2300      	movs	r3, #0
 800283e:	2220      	movs	r2, #32
 8002840:	7022      	strb	r2, [r4, #0]
 8002842:	7063      	strb	r3, [r4, #1]
 8002844:	70a3      	strb	r3, [r4, #2]
 8002846:	70e3      	strb	r3, [r4, #3]
  ptPkt->tHeader.ulCmd  = HIL_CHANNEL_INIT_REQ;
 8002848:	f06f 027f 	mvn.w	r2, #127	; 0x7f
 800284c:	7722      	strb	r2, [r4, #28]
 800284e:	222f      	movs	r2, #47	; 0x2f
 8002850:	7762      	strb	r2, [r4, #29]
 8002852:	77a3      	strb	r3, [r4, #30]
 8002854:	77e3      	strb	r3, [r4, #31]
  ptPkt->tHeader.ulLen  = 0;
}
 8002856:	bd10      	pop	{r4, pc}

08002858 <App_SysPkt_AssembleStartStopCommReq>:
 *                        false: stop communication  (BUS_OFF)
 */
/*****************************************************************************/
void App_SysPkt_AssembleStartStopCommReq( CIFX_PACKET* ptPkt,
                                          bool         fStart )
{
 8002858:	b538      	push	{r3, r4, r5, lr}
 800285a:	4604      	mov	r4, r0
 800285c:	460d      	mov	r5, r1
  HIL_START_STOP_COMM_REQ_T* ptReq = (HIL_START_STOP_COMM_REQ_T*)ptPkt;

  memset( ptReq, 0, sizeof(*ptReq) );
 800285e:	222c      	movs	r2, #44	; 0x2c
 8002860:	2100      	movs	r1, #0
 8002862:	f007 f962 	bl	8009b2a <memset>

  ptReq->tHead.ulDest = HIL_PACKET_DEST_DEFAULT_CHANNEL;
 8002866:	2300      	movs	r3, #0
 8002868:	2220      	movs	r2, #32
 800286a:	7022      	strb	r2, [r4, #0]
 800286c:	7063      	strb	r3, [r4, #1]
 800286e:	70a3      	strb	r3, [r4, #2]
 8002870:	70e3      	strb	r3, [r4, #3]
  ptReq->tHead.ulCmd  = HIL_START_STOP_COMM_REQ;
 8002872:	2230      	movs	r2, #48	; 0x30
 8002874:	7722      	strb	r2, [r4, #28]
 8002876:	222f      	movs	r2, #47	; 0x2f
 8002878:	7762      	strb	r2, [r4, #29]
 800287a:	77a3      	strb	r3, [r4, #30]
 800287c:	77e3      	strb	r3, [r4, #31]
  ptReq->tHead.ulLen  = sizeof(ptReq->tData);
 800287e:	2204      	movs	r2, #4
 8002880:	7422      	strb	r2, [r4, #16]
 8002882:	7463      	strb	r3, [r4, #17]
 8002884:	74a3      	strb	r3, [r4, #18]
 8002886:	74e3      	strb	r3, [r4, #19]

  ptReq->tData.ulParam = fStart ? HIL_START_STOP_COMM_PARAM_START : HIL_START_STOP_COMM_PARAM_STOP;
 8002888:	b115      	cbz	r5, 8002890 <App_SysPkt_AssembleStartStopCommReq+0x38>
 800288a:	2301      	movs	r3, #1
 800288c:	62a3      	str	r3, [r4, #40]	; 0x28
}
 800288e:	bd38      	pop	{r3, r4, r5, pc}
  ptReq->tData.ulParam = fStart ? HIL_START_STOP_COMM_PARAM_START : HIL_START_STOP_COMM_PARAM_STOP;
 8002890:	2302      	movs	r3, #2
 8002892:	e7fb      	b.n	800288c <App_SysPkt_AssembleStartStopCommReq+0x34>

08002894 <Protocol_PacketHandler_callback>:
/***************************************************************************************
*! Protocol specific packet handler.
*   \param ptAppData   pointer to APP_DATA_T structure
****************************************************************************************/
static uint32_t Protocol_PacketHandler_callback( APP_DATA_T* ptAppData )
{
 8002894:	b508      	push	{r3, lr}
  uint32_t ulRet = CIFX_NO_ERROR;

  ulRet = Pkt_CheckReceiveMailbox( ptAppData, DNS_DEMO_CHANNEL_INDEX, &ptAppData->aptChannels[DNS_DEMO_CHANNEL_INDEX]->tPacket );
 8002896:	6802      	ldr	r2, [r0, #0]
 8002898:	2100      	movs	r1, #0
 800289a:	f7ff ff1f 	bl	80026dc <Pkt_CheckReceiveMailbox>

  if( CIFX_DEV_GET_NO_PACKET == ulRet || CIFX_DEV_NOT_READY == ulRet )
 800289e:	4a04      	ldr	r2, [pc, #16]	; (80028b0 <Protocol_PacketHandler_callback+0x1c>)
 80028a0:	4b04      	ldr	r3, [pc, #16]	; (80028b4 <Protocol_PacketHandler_callback+0x20>)
 80028a2:	4298      	cmp	r0, r3
 80028a4:	bf18      	it	ne
 80028a6:	4290      	cmpne	r0, r2
 80028a8:	d100      	bne.n	80028ac <Protocol_PacketHandler_callback+0x18>
  {
    /* Handle "no packet" and "stack not ready" as success. */
    ulRet = CIFX_NO_ERROR;
 80028aa:	2000      	movs	r0, #0
  }

  return ulRet;
}
 80028ac:	bd08      	pop	{r3, pc}
 80028ae:	bf00      	nop
 80028b0:	800c0019 	.word	0x800c0019
 80028b4:	800c0011 	.word	0x800c0011

080028b8 <Protocol_StartConfiguration_callback>:
{
 80028b8:	b510      	push	{r4, lr}
 80028ba:	4604      	mov	r4, r0
  if (!Pkt_Init(DNS_DEMO_CHANNEL_INDEX, 1))
 80028bc:	2101      	movs	r1, #1
 80028be:	2000      	movs	r0, #0
 80028c0:	f7ff fe72 	bl	80025a8 <Pkt_Init>
 80028c4:	b160      	cbz	r0, 80028e0 <Protocol_StartConfiguration_callback+0x28>
  if( Pkt_RegisterIndicationHandler( DNS_DEMO_CHANNEL_INDEX, AppDNS_PacketHandler_callback, (void*)ptAppData ) )
 80028c6:	4622      	mov	r2, r4
 80028c8:	4906      	ldr	r1, [pc, #24]	; (80028e4 <Protocol_StartConfiguration_callback+0x2c>)
 80028ca:	2000      	movs	r0, #0
 80028cc:	f7ff fef6 	bl	80026bc <Pkt_RegisterIndicationHandler>
 80028d0:	b908      	cbnz	r0, 80028d6 <Protocol_StartConfiguration_callback+0x1e>
    ulRet = CIFX_DRV_INIT_ERROR;
 80028d2:	4805      	ldr	r0, [pc, #20]	; (80028e8 <Protocol_StartConfiguration_callback+0x30>)
 80028d4:	e005      	b.n	80028e2 <Protocol_StartConfiguration_callback+0x2a>
    ulRet = AppDNS_ConfigureStack( ptAppData, 0 );
 80028d6:	2100      	movs	r1, #0
 80028d8:	4620      	mov	r0, r4
 80028da:	f000 f8f8 	bl	8002ace <AppDNS_ConfigureStack>
 80028de:	e000      	b.n	80028e2 <Protocol_StartConfiguration_callback+0x2a>
    return CIFX_DRV_INIT_ERROR;
 80028e0:	4801      	ldr	r0, [pc, #4]	; (80028e8 <Protocol_StartConfiguration_callback+0x30>)
}
 80028e2:	bd10      	pop	{r4, pc}
 80028e4:	08002921 	.word	0x08002921
 80028e8:	800b0031 	.word	0x800b0031

080028ec <AppDNS_GlobalPacket_SendReceive>:
*  funktion must prepare the command to be send in global packet buffer. The confirmation will be
*  also received in the global packet buffer.
*   \param ptAppData   pointer to APP_DATA_T structure
***************************************************************************************************/
uint32_t AppDNS_GlobalPacket_SendReceive(APP_DATA_T* ptAppData)
{
 80028ec:	b510      	push	{r4, lr}
 80028ee:	4604      	mov	r4, r0
  uint32_t ulRet = 0;
  ptAppData->aptChannels[DNS_DEMO_CHANNEL_INDEX]->tPacket.tHeader.ulDest = HIL_PACKET_DEST_DEFAULT_CHANNEL;
 80028f0:	6803      	ldr	r3, [r0, #0]
 80028f2:	2220      	movs	r2, #32
 80028f4:	601a      	str	r2, [r3, #0]

  ulRet = Pkt_SendReceivePacket(ptAppData,
 80028f6:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 80028fa:	6802      	ldr	r2, [r0, #0]
 80028fc:	2100      	movs	r1, #0
 80028fe:	f7ff ff21 	bl	8002744 <Pkt_SendReceivePacket>
                                DNS_DEMO_CHANNEL_INDEX,
                                &ptAppData->aptChannels[DNS_DEMO_CHANNEL_INDEX]->tPacket,
                                TXRX_TIMEOUT);
  if (ulRet != CIFX_NO_ERROR)
 8002902:	b908      	cbnz	r0, 8002908 <AppDNS_GlobalPacket_SendReceive+0x1c>
  {
    return ulRet;
  }

  ulRet = ptAppData->aptChannels[DNS_DEMO_CHANNEL_INDEX]->tPacket.tHeader.ulState;
 8002904:	6823      	ldr	r3, [r4, #0]
 8002906:	6998      	ldr	r0, [r3, #24]
  return ulRet;
}
 8002908:	bd10      	pop	{r4, pc}

0800290a <AppDNS_GlobalPacket_Send>:
*   buffer. The calling funktion must prepare the command to be send in global packet buffer.
*   Usally it can be used to send confirmation packet to previosly received indication packets.
*   \param ptAppData   pointer to APP_DATA_T structure
***************************************************************************************************/
uint32_t AppDNS_GlobalPacket_Send(APP_DATA_T* ptAppData)
{
 800290a:	b508      	push	{r3, lr}
  uint32_t ulRet = 0;
  ptAppData->aptChannels[DNS_DEMO_CHANNEL_INDEX]->tPacket.tHeader.ulDest = HIL_PACKET_DEST_DEFAULT_CHANNEL;
 800290c:	6803      	ldr	r3, [r0, #0]
 800290e:	2120      	movs	r1, #32
 8002910:	6019      	str	r1, [r3, #0]

  ulRet = Pkt_SendPacket(ptAppData,
 8002912:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8002916:	6802      	ldr	r2, [r0, #0]
 8002918:	2100      	movs	r1, #0
 800291a:	f7ff fead 	bl	8002678 <Pkt_SendPacket>
  if (ulRet != CIFX_NO_ERROR)
  {
    PRINTF("Sending DNS_RESET_RES failed with error code 0x%08x" NEWLINE, (unsigned int)ulRet);
  }
  return ulRet;
}
 800291e:	bd08      	pop	{r3, pc}

08002920 <AppDNS_PacketHandler_callback>:
  if( ptPacket != &ptAppData->aptChannels[DNS_DEMO_CHANNEL_INDEX]->tPacket )
 8002920:	680a      	ldr	r2, [r1, #0]
 8002922:	4282      	cmp	r2, r0
 8002924:	d001      	beq.n	800292a <AppDNS_PacketHandler_callback+0xa>
    return false;
 8002926:	2000      	movs	r0, #0
}
 8002928:	4770      	bx	lr
{
 800292a:	b508      	push	{r3, lr}
 800292c:	4603      	mov	r3, r0
  switch( ptPacket->tHeader.ulCmd )
 800292e:	69c2      	ldr	r2, [r0, #28]
      if ((ptPacket->tHeader.ulCmd & 0x1) == 0)
 8002930:	f012 0f01 	tst.w	r2, #1
 8002934:	d001      	beq.n	800293a <AppDNS_PacketHandler_callback+0x1a>
  return fPacketHandled;
 8002936:	2001      	movs	r0, #1
}
 8002938:	bd08      	pop	{r3, pc}
        ptPacket->tHeader.ulState = ERR_HIL_NO_APPLICATION_REGISTERED;
 800293a:	2002      	movs	r0, #2
 800293c:	7618      	strb	r0, [r3, #24]
 800293e:	7658      	strb	r0, [r3, #25]
 8002940:	2000      	movs	r0, #0
 8002942:	7698      	strb	r0, [r3, #26]
 8002944:	f06f 003f 	mvn.w	r0, #63	; 0x3f
 8002948:	76d8      	strb	r0, [r3, #27]
        ptPacket->tHeader.ulCmd |= 0x01; /* Make it a response */
 800294a:	f042 0201 	orr.w	r2, r2, #1
 800294e:	61da      	str	r2, [r3, #28]
        AppDNS_GlobalPacket_Send(ptAppData);
 8002950:	4608      	mov	r0, r1
 8002952:	f7ff ffda 	bl	800290a <AppDNS_GlobalPacket_Send>
  return fPacketHandled;
 8002956:	2001      	movs	r0, #1
 8002958:	e7ee      	b.n	8002938 <AppDNS_PacketHandler_callback+0x18>

0800295a <AppDNS_GlobalPacket_Init>:
/***************************************************************************************************
*! Helpfunktion to preset the header of the global packet buffer with zero, befor using it.
*   \param ptAppData   pointer to APP_DATA_T structure
***************************************************************************************************/
void* AppDNS_GlobalPacket_Init(APP_DATA_T* ptAppData)
{
 800295a:	b510      	push	{r4, lr}
  void* pvPkt = (void*)&ptAppData->aptChannels[DNS_DEMO_CHANNEL_INDEX]->tPacket;
 800295c:	6804      	ldr	r4, [r0, #0]
  memset(pvPkt, 0x00, sizeof(ptAppData->aptChannels[DNS_DEMO_CHANNEL_INDEX]->tPacket.tHeader));
 800295e:	2228      	movs	r2, #40	; 0x28
 8002960:	2100      	movs	r1, #0
 8002962:	4620      	mov	r0, r4
 8002964:	f007 f8e1 	bl	8009b2a <memset>
  return pvPkt;
}
 8002968:	4620      	mov	r0, r4
 800296a:	bd10      	pop	{r4, pc}

0800296c <AppDNS_SetConfiguration>:
{
 800296c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002970:	4607      	mov	r7, r0
  DNS_PACKET_SET_CONFIGURATION_REQ_T* ptReq = AppDNS_GlobalPacket_Init(ptAppData);
 8002972:	f7ff fff2 	bl	800295a <AppDNS_GlobalPacket_Init>
 8002976:	4604      	mov	r4, r0
  ptReq->tHead.ulCmd        = DNS_CMD_SET_CONFIGURATION_REQ;
 8002978:	2500      	movs	r5, #0
 800297a:	7705      	strb	r5, [r0, #28]
 800297c:	f06f 034e 	mvn.w	r3, #78	; 0x4e
 8002980:	7743      	strb	r3, [r0, #29]
 8002982:	7785      	strb	r5, [r0, #30]
 8002984:	77c5      	strb	r5, [r0, #31]
  ptReq->tHead.ulLen        = DNS_SET_CONFIGURATION_V1_REQ_SIZE;
 8002986:	f04f 0864 	mov.w	r8, #100	; 0x64
 800298a:	f880 8010 	strb.w	r8, [r0, #16]
 800298e:	7445      	strb	r5, [r0, #17]
 8002990:	7485      	strb	r5, [r0, #18]
 8002992:	74c5      	strb	r5, [r0, #19]
  ptReq->tHead.ulSta        = 0;
 8002994:	7605      	strb	r5, [r0, #24]
 8002996:	7645      	strb	r5, [r0, #25]
 8002998:	7685      	strb	r5, [r0, #26]
 800299a:	76c5      	strb	r5, [r0, #27]
  ptReq->tData.ulVersion    = DNS_CONFIGURATION_V1;
 800299c:	2601      	movs	r6, #1
 800299e:	f880 6028 	strb.w	r6, [r0, #40]	; 0x28
 80029a2:	f880 5029 	strb.w	r5, [r0, #41]	; 0x29
 80029a6:	f880 502a 	strb.w	r5, [r0, #42]	; 0x2a
 80029aa:	f880 502b 	strb.w	r5, [r0, #43]	; 0x2b
  memset(ptCfg, 0x00, sizeof(DNS_CONFIGURATION_V1_T));
 80029ae:	2260      	movs	r2, #96	; 0x60
 80029b0:	4629      	mov	r1, r5
 80029b2:	302c      	adds	r0, #44	; 0x2c
 80029b4:	f007 f8b9 	bl	8009b2a <memset>
  ptCfg->ulSystemFlags      = DNS_SYS_FLG_MANUAL_START;
 80029b8:	f884 602c 	strb.w	r6, [r4, #44]	; 0x2c
 80029bc:	f884 502d 	strb.w	r5, [r4, #45]	; 0x2d
 80029c0:	f884 502e 	strb.w	r5, [r4, #46]	; 0x2e
 80029c4:	f884 502f 	strb.w	r5, [r4, #47]	; 0x2f
  ptCfg->ulWdgTime          = 0;
 80029c8:	f884 5030 	strb.w	r5, [r4, #48]	; 0x30
 80029cc:	f884 5031 	strb.w	r5, [r4, #49]	; 0x31
 80029d0:	f884 5032 	strb.w	r5, [r4, #50]	; 0x32
 80029d4:	f884 5033 	strb.w	r5, [r4, #51]	; 0x33
  ptCfg->ulNodeId = g_tAppDnsData.bNodeIdValue;
 80029d8:	4b30      	ldr	r3, [pc, #192]	; (8002a9c <AppDNS_SetConfiguration+0x130>)
 80029da:	781a      	ldrb	r2, [r3, #0]
 80029dc:	6362      	str	r2, [r4, #52]	; 0x34
  ptCfg->ulBaudrate = g_tAppDnsData.bBaudRateValue;
 80029de:	785b      	ldrb	r3, [r3, #1]
 80029e0:	63a3      	str	r3, [r4, #56]	; 0x38
  ptCfg->ulConfigFlags      = 0;
 80029e2:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
 80029e6:	f884 503d 	strb.w	r5, [r4, #61]	; 0x3d
 80029ea:	f884 503e 	strb.w	r5, [r4, #62]	; 0x3e
 80029ee:	f884 503f 	strb.w	r5, [r4, #63]	; 0x3f
  ptCfg->ulObjectFlags      = 0;
 80029f2:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
 80029f6:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
 80029fa:	f884 5042 	strb.w	r5, [r4, #66]	; 0x42
 80029fe:	f884 5043 	strb.w	r5, [r4, #67]	; 0x43
  ptCfg->usVendorId         = VENDOR_ID;
 8002a02:	231b      	movs	r3, #27
 8002a04:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8002a08:	f884 6045 	strb.w	r6, [r4, #69]	; 0x45
  ptCfg->usDeviceType       = DEVICE_TYPE_COMMUNICATION_ADAPTER;
 8002a0c:	230c      	movs	r3, #12
 8002a0e:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 8002a12:	f884 5047 	strb.w	r5, [r4, #71]	; 0x47
  ptCfg->usProductCode      = PRODUCT_CODE;
 8002a16:	2322      	movs	r3, #34	; 0x22
 8002a18:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
 8002a1c:	f884 5049 	strb.w	r5, [r4, #73]	; 0x49
  ptCfg->bMajorRev          = MAJOR_REVISION;
 8002a20:	2305      	movs	r3, #5
 8002a22:	f884 304b 	strb.w	r3, [r4, #75]	; 0x4b
  ptCfg->bMinorRev          = MINOR_REVISION;
 8002a26:	2302      	movs	r3, #2
 8002a28:	f884 304a 	strb.w	r3, [r4, #74]	; 0x4a
  ptCfg->bProductNameLen    = sizeof(abProductName)-1;
 8002a2c:	2319      	movs	r3, #25
 8002a2e:	f884 3053 	strb.w	r3, [r4, #83]	; 0x53
  memcpy(&ptCfg->abProductName[0], &abProductName[0], ptCfg->bProductNameLen);
 8002a32:	4e1b      	ldr	r6, [pc, #108]	; (8002aa0 <AppDNS_SetConfiguration+0x134>)
 8002a34:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8002a36:	6560      	str	r0, [r4, #84]	; 0x54
 8002a38:	65a1      	str	r1, [r4, #88]	; 0x58
 8002a3a:	65e2      	str	r2, [r4, #92]	; 0x5c
 8002a3c:	6623      	str	r3, [r4, #96]	; 0x60
 8002a3e:	ce03      	ldmia	r6!, {r0, r1}
 8002a40:	6660      	str	r0, [r4, #100]	; 0x64
 8002a42:	66a1      	str	r1, [r4, #104]	; 0x68
 8002a44:	7833      	ldrb	r3, [r6, #0]
 8002a46:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
  ptCfg->ulProduceAsInstance  = DNS_DEMO_PRODUCING_ASSEMBLY_INSTANCE;
 8002a4a:	2365      	movs	r3, #101	; 0x65
 8002a4c:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
 8002a50:	f884 5075 	strb.w	r5, [r4, #117]	; 0x75
 8002a54:	f884 5076 	strb.w	r5, [r4, #118]	; 0x76
 8002a58:	f884 5077 	strb.w	r5, [r4, #119]	; 0x77
  ptCfg->ulProduceAsSize      = DNS_DEMO_PRODUCING_ASSEMBLY_INSTANCE_SIZE;
 8002a5c:	230a      	movs	r3, #10
 8002a5e:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
 8002a62:	f884 507d 	strb.w	r5, [r4, #125]	; 0x7d
 8002a66:	f884 507e 	strb.w	r5, [r4, #126]	; 0x7e
 8002a6a:	f884 507f 	strb.w	r5, [r4, #127]	; 0x7f
  ptCfg->ulConsumeAsInstance  = DNS_DEMO_CONSUMING_ASSEMBLY_INSTANCE;
 8002a6e:	f884 8080 	strb.w	r8, [r4, #128]	; 0x80
 8002a72:	f884 5081 	strb.w	r5, [r4, #129]	; 0x81
 8002a76:	f884 5082 	strb.w	r5, [r4, #130]	; 0x82
 8002a7a:	f884 5083 	strb.w	r5, [r4, #131]	; 0x83
  ptCfg->ulConsumeAsSize      = DNS_DEMO_CONSUMING_ASSEMBLY_INSTANCE_SIZE;
 8002a7e:	2306      	movs	r3, #6
 8002a80:	f884 3088 	strb.w	r3, [r4, #136]	; 0x88
 8002a84:	f884 5089 	strb.w	r5, [r4, #137]	; 0x89
 8002a88:	f884 508a 	strb.w	r5, [r4, #138]	; 0x8a
 8002a8c:	f884 508b 	strb.w	r5, [r4, #139]	; 0x8b
  ulRet = AppDNS_GlobalPacket_SendReceive(ptAppData);
 8002a90:	4638      	mov	r0, r7
 8002a92:	f7ff ff2b 	bl	80028ec <AppDNS_GlobalPacket_SendReceive>
}
 8002a96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002a9a:	bf00      	nop
 8002a9c:	20000034 	.word	0x20000034
 8002aa0:	20000018 	.word	0x20000018

08002aa4 <AppDNS_ChannelInit>:
{
 8002aa4:	b510      	push	{r4, lr}
 8002aa6:	4604      	mov	r4, r0
  CIFX_PACKET* ptReq = AppDNS_GlobalPacket_Init(ptAppData);
 8002aa8:	f7ff ff57 	bl	800295a <AppDNS_GlobalPacket_Init>
  App_SysPkt_AssembleChannelInitReq(ptReq);
 8002aac:	f7ff fec0 	bl	8002830 <App_SysPkt_AssembleChannelInitReq>
  ulRet = AppDNS_GlobalPacket_SendReceive(ptAppData);
 8002ab0:	4620      	mov	r0, r4
 8002ab2:	f7ff ff1b 	bl	80028ec <AppDNS_GlobalPacket_SendReceive>
}
 8002ab6:	bd10      	pop	{r4, pc}

08002ab8 <AppDNS_StartCommunication>:
{
 8002ab8:	b510      	push	{r4, lr}
 8002aba:	4604      	mov	r4, r0
  CIFX_PACKET* ptReq = AppDNS_GlobalPacket_Init(ptAppData);
 8002abc:	f7ff ff4d 	bl	800295a <AppDNS_GlobalPacket_Init>
  App_SysPkt_AssembleStartStopCommReq(ptReq, true);
 8002ac0:	2101      	movs	r1, #1
 8002ac2:	f7ff fec9 	bl	8002858 <App_SysPkt_AssembleStartStopCommReq>
  ulRet = AppDNS_GlobalPacket_SendReceive(ptAppData);
 8002ac6:	4620      	mov	r0, r4
 8002ac8:	f7ff ff10 	bl	80028ec <AppDNS_GlobalPacket_SendReceive>
}
 8002acc:	bd10      	pop	{r4, pc}

08002ace <AppDNS_ConfigureStack>:
{
 8002ace:	b510      	push	{r4, lr}
 8002ad0:	4604      	mov	r4, r0
  ulRet = AppDNS_SetConfiguration(ptAppData);
 8002ad2:	f7ff ff4b 	bl	800296c <AppDNS_SetConfiguration>
  if (ulRet != 0)
 8002ad6:	4603      	mov	r3, r0
 8002ad8:	b108      	cbz	r0, 8002ade <AppDNS_ConfigureStack+0x10>
}
 8002ada:	4618      	mov	r0, r3
 8002adc:	bd10      	pop	{r4, pc}
  ulRet = AppDNS_ChannelInit(ptAppData);
 8002ade:	4620      	mov	r0, r4
 8002ae0:	f7ff ffe0 	bl	8002aa4 <AppDNS_ChannelInit>
  if (ulRet != 0)
 8002ae4:	4603      	mov	r3, r0
 8002ae6:	2800      	cmp	r0, #0
 8002ae8:	d1f7      	bne.n	8002ada <AppDNS_ConfigureStack+0xc>
  ulRet = AppDNS_StartCommunication(ptAppData);
 8002aea:	4620      	mov	r0, r4
 8002aec:	f7ff ffe4 	bl	8002ab8 <AppDNS_StartCommunication>
 8002af0:	4603      	mov	r3, r0
  return ulRet;
 8002af2:	e7f2      	b.n	8002ada <AppDNS_ConfigureStack+0xc>

08002af4 <OS_Init>:
/*! O/S Specific initialization (initializes libpciaccess)
*     \return CIFX_NO_ERROR on success                                       */
/*****************************************************************************/
int32_t OS_Init(void)
{
  s_fOSInitDone = 1;
 8002af4:	4b02      	ldr	r3, [pc, #8]	; (8002b00 <OS_Init+0xc>)
 8002af6:	2201      	movs	r2, #1
 8002af8:	601a      	str	r2, [r3, #0]
  
  return CIFX_NO_ERROR;
}
 8002afa:	2000      	movs	r0, #0
 8002afc:	4770      	bx	lr
 8002afe:	bf00      	nop
 8002b00:	20000200 	.word	0x20000200

08002b04 <OS_Deinit>:
/*****************************************************************************/
/*! O/S Specific de-initialization (de-initializes libpciaccess)             */
/*****************************************************************************/
void OS_Deinit(void)
{
}
 8002b04:	4770      	bx	lr

08002b06 <OS_Memalloc>:
/*! Memory allocation wrapper (standard malloc)
*     \param ulSize Size of block to allocate
*     \return NULL on failure                                                */
/*****************************************************************************/
void* OS_Memalloc(uint32_t ulSize)
{
 8002b06:	b508      	push	{r3, lr}
  return malloc(ulSize);
 8002b08:	f006 fdda 	bl	80096c0 <malloc>
}
 8002b0c:	bd08      	pop	{r3, pc}

08002b0e <OS_Memfree>:
/*****************************************************************************/
/*! Memory de-allocation wrapper (standard free)
*     \param pvMem  Block to free                                            */
/*****************************************************************************/
void OS_Memfree(void* pvMem)
{
 8002b0e:	b508      	push	{r3, lr}
  free(pvMem);
 8002b10:	f006 fdde 	bl	80096d0 <free>
}
 8002b14:	bd08      	pop	{r3, pc}

08002b16 <OS_Memrealloc>:
*     \param pvMem      Block to resize
*     \param ulNewSize  New size of the block
*     \return NULL on error                                                  */
/*****************************************************************************/
void* OS_Memrealloc(void* pvMem, uint32_t ulNewSize)
{
 8002b16:	b508      	push	{r3, lr}
  return realloc(pvMem, ulNewSize);
 8002b18:	f006 fe8e 	bl	8009838 <realloc>
}
 8002b1c:	bd08      	pop	{r3, pc}

08002b1e <OS_Memset>:
*     \param pvMem   Memory to set
*     \param bFill   Fill byte
*     \param ulSize  Size of the fill block                                  */
/*****************************************************************************/
void OS_Memset(void* pvMem, uint8_t bFill, uint32_t ulSize)
{
 8002b1e:	b508      	push	{r3, lr}
  memset(pvMem, bFill, ulSize);
 8002b20:	f007 f803 	bl	8009b2a <memset>
}
 8002b24:	bd08      	pop	{r3, pc}

08002b26 <OS_Memcpy>:
*     \param pvDest  Destination pointer
*     \param pvSrc   Source pointer
*     \param ulSize  Size to copy                                            */
/*****************************************************************************/
void OS_Memcpy(void* pvDest, void* pvSrc, uint32_t ulSize)
{
 8002b26:	b508      	push	{r3, lr}
  memcpy(pvDest, pvSrc, ulSize);
 8002b28:	f007 f8be 	bl	8009ca8 <memcpy>
}
 8002b2c:	bd08      	pop	{r3, pc}

08002b2e <OS_Memcmp>:
*     \param pvBuf2  Second compare buffer
*     \param ulSize  Size to compare
*     \return 0 if blocks are equal                                          */
/*****************************************************************************/
int OS_Memcmp(void* pvBuf1, void* pvBuf2, uint32_t ulSize)
{
 8002b2e:	b508      	push	{r3, lr}
  return memcmp(pvBuf1, pvBuf2, ulSize);
 8002b30:	f006 ffd1 	bl	8009ad6 <memcmp>
}
 8002b34:	bd08      	pop	{r3, pc}

08002b36 <OS_Memmove>:
*     \param pvDest  Destination buffer
*     \param pvSrc   Source buffer
*     \param ulSize  Size to move                                            */
/*****************************************************************************/
void OS_Memmove(void* pvDest, void* pvSrc, uint32_t ulSize)
{
 8002b36:	b508      	push	{r3, lr}
  memmove(pvDest, pvSrc, ulSize);
 8002b38:	f006 ffdd 	bl	8009af6 <memmove>
}
 8002b3c:	bd08      	pop	{r3, pc}

08002b3e <OS_ReadPCIConfig>:
/*****************************************************************************/
void* OS_ReadPCIConfig(void* pvOSDependent)
{
  UNREFERENCED_PARAMETER(pvOSDependent);
  return NULL;
}
 8002b3e:	2000      	movs	r0, #0
 8002b40:	4770      	bx	lr

08002b42 <OS_WritePCIConfig>:
/*****************************************************************************/
void OS_WritePCIConfig(void* pvOSDependent, void* pvPCIConfig)
{
  UNREFERENCED_PARAMETER(pvOSDependent);
  UNREFERENCED_PARAMETER(pvPCIConfig);
}
 8002b42:	4770      	bx	lr

08002b44 <OS_EnableInterrupts>:
  __ASM volatile ("cpsie i" : : : "memory");
 8002b44:	b662      	cpsie	i
*     \param pvOSDependent Pointer to internal device structure              */
/*****************************************************************************/
void OS_EnableInterrupts(void* pvOSDependent)
{
	__enable_irq();
}
 8002b46:	4770      	bx	lr

08002b48 <OS_FileOpen>:
void* OS_FileOpen(char* szFile, uint32_t* pulFileLen)
{
  UNREFERENCED_PARAMETER(szFile);
  UNREFERENCED_PARAMETER(pulFileLen);
  return NULL;
}
 8002b48:	2000      	movs	r0, #0
 8002b4a:	4770      	bx	lr

08002b4c <OS_FileRead>:
  UNREFERENCED_PARAMETER(pvFile);
  UNREFERENCED_PARAMETER(ulOffset);  
  UNREFERENCED_PARAMETER(ulSize);
  UNREFERENCED_PARAMETER(pvBuffer);
  return 0;
}
 8002b4c:	2000      	movs	r0, #0
 8002b4e:	4770      	bx	lr

08002b50 <OS_FileClose>:
*     \param pvFile    Handle to the file (acquired by OS_FileOpen)          */
/*****************************************************************************/
void OS_FileClose(void* pvFile)
{
  UNREFERENCED_PARAMETER(pvFile);
}
 8002b50:	4770      	bx	lr

08002b52 <OS_GetMilliSecCounter>:
/*****************************************************************************/
/*! Get Millisecond counter value (used for timeout handling)
*     \return Counter value with a resolution of 1ms                         */
/*****************************************************************************/
uint32_t OS_GetMilliSecCounter(void)
{
 8002b52:	b508      	push	{r3, lr}
  return HAL_GetTick();
 8002b54:	f7fe f85a 	bl	8000c0c <HAL_GetTick>
}
 8002b58:	bd08      	pop	{r3, pc}
	...

08002b5c <OS_Sleep>:
/*****************************************************************************/
/*! Sleep for the given time
*     \param ulSleepTimeMs Time in ms to sleep (0 will sleep for 50us)       */
/*****************************************************************************/
void OS_Sleep(uint32_t ulSleepTimeMs)
{
 8002b5c:	b538      	push	{r3, r4, r5, lr}
	uint32_t ulStartTime   = 0;
	uint32_t ulCurrentTime = 0;

	if (!s_fOSInitDone)
 8002b5e:	4b0e      	ldr	r3, [pc, #56]	; (8002b98 <OS_Sleep+0x3c>)
 8002b60:	681b      	ldr	r3, [r3, #0]
 8002b62:	b12b      	cbz	r3, 8002b70 <OS_Sleep+0x14>
 8002b64:	4604      	mov	r4, r0
		return;

	if (ulSleepTimeMs == 0)
 8002b66:	b920      	cbnz	r0, 8002b72 <OS_Sleep+0x16>
	{
		if (g_pfnOSAL_Idle != NULL)
 8002b68:	4b0c      	ldr	r3, [pc, #48]	; (8002b9c <OS_Sleep+0x40>)
 8002b6a:	681b      	ldr	r3, [r3, #0]
 8002b6c:	b103      	cbz	r3, 8002b70 <OS_Sleep+0x14>
			g_pfnOSAL_Idle(); /* call idle time function, can be used by application*/
 8002b6e:	4798      	blx	r3
		}
		while ((ulCurrentTime - ulStartTime) < ulSleepTimeMs);
	}


}
 8002b70:	bd38      	pop	{r3, r4, r5, pc}
		ulStartTime = OS_GetMilliSecCounter();
 8002b72:	f7ff ffee 	bl	8002b52 <OS_GetMilliSecCounter>
 8002b76:	4605      	mov	r5, r0
 8002b78:	e007      	b.n	8002b8a <OS_Sleep+0x2e>
			HAL_Delay(1);
 8002b7a:	2001      	movs	r0, #1
 8002b7c:	f7fe f84c 	bl	8000c18 <HAL_Delay>
			ulCurrentTime = OS_GetMilliSecCounter();
 8002b80:	f7ff ffe7 	bl	8002b52 <OS_GetMilliSecCounter>
		while ((ulCurrentTime - ulStartTime) < ulSleepTimeMs);
 8002b84:	1b43      	subs	r3, r0, r5
 8002b86:	42a3      	cmp	r3, r4
 8002b88:	d2f2      	bcs.n	8002b70 <OS_Sleep+0x14>
			if (g_pfnOSAL_Idle != NULL)
 8002b8a:	4b04      	ldr	r3, [pc, #16]	; (8002b9c <OS_Sleep+0x40>)
 8002b8c:	681b      	ldr	r3, [r3, #0]
 8002b8e:	2b00      	cmp	r3, #0
 8002b90:	d0f3      	beq.n	8002b7a <OS_Sleep+0x1e>
				g_pfnOSAL_Idle();
 8002b92:	4798      	blx	r3
 8002b94:	e7f1      	b.n	8002b7a <OS_Sleep+0x1e>
 8002b96:	bf00      	nop
 8002b98:	20000200 	.word	0x20000200
 8002b9c:	200001e8 	.word	0x200001e8

08002ba0 <OS_EnterLock>:
/*****************************************************************************/
/*! Acquire a lock
*     \param pvLock Handle to lock                                           */
/*****************************************************************************/
void OS_EnterLock(void* pvLock)
{
 8002ba0:	b508      	push	{r3, lr}
	HAL_NVIC_DisableIRQ(TIMx_IRQn); // disable IRQ at NVIC
 8002ba2:	201d      	movs	r0, #29
 8002ba4:	f7fe f8a2 	bl	8000cec <HAL_NVIC_DisableIRQ>
	s_ulIrqSemaphore++;
 8002ba8:	4a02      	ldr	r2, [pc, #8]	; (8002bb4 <OS_EnterLock+0x14>)
 8002baa:	6813      	ldr	r3, [r2, #0]
 8002bac:	3301      	adds	r3, #1
 8002bae:	6013      	str	r3, [r2, #0]
}
 8002bb0:	bd08      	pop	{r3, pc}
 8002bb2:	bf00      	nop
 8002bb4:	20000204 	.word	0x20000204

08002bb8 <OS_LeaveLock>:
/*****************************************************************************/
/*! Release a lock
*     \param pvLock Handle to lock                                           */
/*****************************************************************************/
void OS_LeaveLock(void* pvLock)
{
 8002bb8:	b508      	push	{r3, lr}
	  // Because the interupt should be disabled this is atomic
	  s_ulIrqSemaphore-=1;
 8002bba:	4a05      	ldr	r2, [pc, #20]	; (8002bd0 <OS_LeaveLock+0x18>)
 8002bbc:	6813      	ldr	r3, [r2, #0]
 8002bbe:	3b01      	subs	r3, #1
 8002bc0:	6013      	str	r3, [r2, #0]
	  if(s_ulIrqSemaphore == 0)
 8002bc2:	b103      	cbz	r3, 8002bc6 <OS_LeaveLock+0xe>
	  {
			HAL_NVIC_EnableIRQ(TIMx_IRQn); // enable IRQ at NVIC
	  }
}
 8002bc4:	bd08      	pop	{r3, pc}
			HAL_NVIC_EnableIRQ(TIMx_IRQn); // enable IRQ at NVIC
 8002bc6:	201d      	movs	r0, #29
 8002bc8:	f7fe f882 	bl	8000cd0 <HAL_NVIC_EnableIRQ>
}
 8002bcc:	e7fa      	b.n	8002bc4 <OS_LeaveLock+0xc>
 8002bce:	bf00      	nop
 8002bd0:	20000204 	.word	0x20000204

08002bd4 <OS_DeleteLock>:
*     \param pvLock Handle to lock                                           */
/*****************************************************************************/
void OS_DeleteLock(void* pvLock)
{
  OS_DeleteMutex(pvLock);
}
 8002bd4:	4770      	bx	lr

08002bd6 <OS_CreateMutex>:
*     \return Handle to new created mutex                                    */
/*****************************************************************************/
void* OS_CreateMutex(void)
{
  return (void*)1;
}
 8002bd6:	2001      	movs	r0, #1
 8002bd8:	4770      	bx	lr

08002bda <OS_CreateLock>:
{
 8002bda:	b508      	push	{r3, lr}
  return OS_CreateMutex();
 8002bdc:	f7ff fffb 	bl	8002bd6 <OS_CreateMutex>
}
 8002be0:	bd08      	pop	{r3, pc}
	...

08002be4 <OS_WaitMutex>:
*     \param pvMutex   Handle to mutex
*     \param ulTimeout Timeout in ms to wait for mutex
*     \return !=0 if mutex was acquired                                      */
/*****************************************************************************/
int OS_WaitMutex(void* pvMutex, uint32_t ulTimeout)
{ 
 8002be4:	b508      	push	{r3, lr}
	HAL_NVIC_DisableIRQ(TIMx_IRQn); // disable IRQ at NVIC
 8002be6:	201d      	movs	r0, #29
 8002be8:	f7fe f880 	bl	8000cec <HAL_NVIC_DisableIRQ>
	s_ulIrqSemaphore++;
 8002bec:	4a02      	ldr	r2, [pc, #8]	; (8002bf8 <OS_WaitMutex+0x14>)
 8002bee:	6813      	ldr	r3, [r2, #0]
 8002bf0:	3301      	adds	r3, #1
 8002bf2:	6013      	str	r3, [r2, #0]

    UNREFERENCED_PARAMETER(pvMutex);
    UNREFERENCED_PARAMETER(ulTimeout);
  
  return 1;  
}
 8002bf4:	2001      	movs	r0, #1
 8002bf6:	bd08      	pop	{r3, pc}
 8002bf8:	20000204 	.word	0x20000204

08002bfc <OS_ReleaseMutex>:
/*****************************************************************************/
/*! Release previously acquired mutex
*     \param pvMutex   Handle to mutex                                       */
/*****************************************************************************/
void OS_ReleaseMutex(void* pvMutex)
{
 8002bfc:	b508      	push	{r3, lr}
	  s_ulIrqSemaphore-=1;
 8002bfe:	4a05      	ldr	r2, [pc, #20]	; (8002c14 <OS_ReleaseMutex+0x18>)
 8002c00:	6813      	ldr	r3, [r2, #0]
 8002c02:	3b01      	subs	r3, #1
 8002c04:	6013      	str	r3, [r2, #0]
	  if(s_ulIrqSemaphore == 0)
 8002c06:	b103      	cbz	r3, 8002c0a <OS_ReleaseMutex+0xe>
	  {
			HAL_NVIC_EnableIRQ(TIMx_IRQn); // enable IRQ at NVIC
	  }
}
 8002c08:	bd08      	pop	{r3, pc}
			HAL_NVIC_EnableIRQ(TIMx_IRQn); // enable IRQ at NVIC
 8002c0a:	201d      	movs	r0, #29
 8002c0c:	f7fe f860 	bl	8000cd0 <HAL_NVIC_EnableIRQ>
}
 8002c10:	e7fa      	b.n	8002c08 <OS_ReleaseMutex+0xc>
 8002c12:	bf00      	nop
 8002c14:	20000204 	.word	0x20000204

08002c18 <OS_DeleteMutex>:
*     \param pvMutex   Handle to mutex                                       */
/*****************************************************************************/
void OS_DeleteMutex(void* pvMutex)
{
  UNREFERENCED_PARAMETER(pvMutex);
}
 8002c18:	4770      	bx	lr
	...

08002c1c <OS_CreateEvent>:
void* OS_CreateEvent(void)
{
	  uint32_t ulIndex;

	  /* first pass: search for an event entry that has never been used */
	  for (ulIndex = OSAL_MAX_EVENTS; ulIndex > 0; ulIndex--)
 8002c1c:	2010      	movs	r0, #16
 8002c1e:	b138      	cbz	r0, 8002c30 <OS_CreateEvent+0x14>
	  {
	    if (s_eOsalEvents[ulIndex] == EVENT_STATE_UNUSED)
 8002c20:	4b0b      	ldr	r3, [pc, #44]	; (8002c50 <OS_CreateEvent+0x34>)
 8002c22:	5c1b      	ldrb	r3, [r3, r0]
 8002c24:	b10b      	cbz	r3, 8002c2a <OS_CreateEvent+0xe>
	  for (ulIndex = OSAL_MAX_EVENTS; ulIndex > 0; ulIndex--)
 8002c26:	3801      	subs	r0, #1
 8002c28:	e7f9      	b.n	8002c1e <OS_CreateEvent+0x2>
	    {
	      s_eOsalEvents[ulIndex] = EVENT_STATE_CLEAR;
 8002c2a:	4b09      	ldr	r3, [pc, #36]	; (8002c50 <OS_CreateEvent+0x34>)
 8002c2c:	2201      	movs	r2, #1
 8002c2e:	541a      	strb	r2, [r3, r0]
	      break;
	    }
	  }
	  if (ulIndex == 0)
 8002c30:	b158      	cbz	r0, 8002c4a <OS_CreateEvent+0x2e>
 8002c32:	4770      	bx	lr
	  { /* second pass: search for an event entry that has been used and released before */
	    for (ulIndex = OSAL_MAX_EVENTS; ulIndex > 0; ulIndex--)
 8002c34:	3801      	subs	r0, #1
 8002c36:	b150      	cbz	r0, 8002c4e <OS_CreateEvent+0x32>
	    {
	      if (s_eOsalEvents[ulIndex] == EVENT_STATE_DELETED)
 8002c38:	4b05      	ldr	r3, [pc, #20]	; (8002c50 <OS_CreateEvent+0x34>)
 8002c3a:	5c1b      	ldrb	r3, [r3, r0]
 8002c3c:	b2db      	uxtb	r3, r3
 8002c3e:	2b03      	cmp	r3, #3
 8002c40:	d1f8      	bne.n	8002c34 <OS_CreateEvent+0x18>
	      {
	        s_eOsalEvents[ulIndex] = EVENT_STATE_CLEAR;
 8002c42:	4b03      	ldr	r3, [pc, #12]	; (8002c50 <OS_CreateEvent+0x34>)
 8002c44:	2201      	movs	r2, #1
 8002c46:	541a      	strb	r2, [r3, r0]
	        break;
 8002c48:	4770      	bx	lr
	    for (ulIndex = OSAL_MAX_EVENTS; ulIndex > 0; ulIndex--)
 8002c4a:	2010      	movs	r0, #16
 8002c4c:	e7f3      	b.n	8002c36 <OS_CreateEvent+0x1a>
	      }
	    }
	  }
	  return (void*)(ulIndex);
}
 8002c4e:	4770      	bx	lr
 8002c50:	200001ec 	.word	0x200001ec

08002c54 <OS_SetEvent>:
/*****************************************************************************/
void OS_SetEvent(void* pvEvent)
{
	  uint32_t ulIndex = (uint32_t) pvEvent;

	  if (ulIndex <= OSAL_MAX_EVENTS)
 8002c54:	2810      	cmp	r0, #16
 8002c56:	d804      	bhi.n	8002c62 <OS_SetEvent+0xe>
	  {
	    if (s_eOsalEvents[ulIndex] == EVENT_STATE_CLEAR)
 8002c58:	4b04      	ldr	r3, [pc, #16]	; (8002c6c <OS_SetEvent+0x18>)
 8002c5a:	5c1b      	ldrb	r3, [r3, r0]
 8002c5c:	b2db      	uxtb	r3, r3
 8002c5e:	2b01      	cmp	r3, #1
 8002c60:	d000      	beq.n	8002c64 <OS_SetEvent+0x10>
	      s_eOsalEvents[ulIndex] = EVENT_STATE_SET;
	  }
}
 8002c62:	4770      	bx	lr
	      s_eOsalEvents[ulIndex] = EVENT_STATE_SET;
 8002c64:	4b01      	ldr	r3, [pc, #4]	; (8002c6c <OS_SetEvent+0x18>)
 8002c66:	2202      	movs	r2, #2
 8002c68:	541a      	strb	r2, [r3, r0]
}
 8002c6a:	e7fa      	b.n	8002c62 <OS_SetEvent+0xe>
 8002c6c:	200001ec 	.word	0x200001ec

08002c70 <OS_DeleteEvent>:
/*****************************************************************************/
void OS_DeleteEvent(void* pvEvent)
{
	  uint32_t ulIndex = (uint32_t) pvEvent;

	  if (ulIndex <= OSAL_MAX_EVENTS)
 8002c70:	2810      	cmp	r0, #16
 8002c72:	d802      	bhi.n	8002c7a <OS_DeleteEvent+0xa>
	    s_eOsalEvents[ulIndex] = EVENT_STATE_DELETED;
 8002c74:	4b01      	ldr	r3, [pc, #4]	; (8002c7c <OS_DeleteEvent+0xc>)
 8002c76:	2203      	movs	r2, #3
 8002c78:	541a      	strb	r2, [r3, r0]
}
 8002c7a:	4770      	bx	lr
 8002c7c:	200001ec 	.word	0x200001ec

08002c80 <OS_WaitEvent>:
	  uint32_t    ulResult      = CIFX_NO_ERROR;
	  uint32_t    ulIndex       = (uint32_t) pvEvent;
	  uint32_t    ulStartTime   = 0;
	  uint32_t    ulCurrentTime = 0;

	  if (ulIndex > OSAL_MAX_EVENTS)
 8002c80:	2810      	cmp	r0, #16
 8002c82:	d901      	bls.n	8002c88 <OS_WaitEvent+0x8>
	    ulResult = CIFX_INVALID_PARAMETER;
 8002c84:	4814      	ldr	r0, [pc, #80]	; (8002cd8 <OS_WaitEvent+0x58>)
	      }
	      OS_Sleep(0);
	    }
	  }
	  return (ulResult);
}
 8002c86:	4770      	bx	lr
{ 
 8002c88:	b570      	push	{r4, r5, r6, lr}
 8002c8a:	4604      	mov	r4, r0
 8002c8c:	460d      	mov	r5, r1
	    ulStartTime = OS_GetMilliSecCounter();
 8002c8e:	f7ff ff60 	bl	8002b52 <OS_GetMilliSecCounter>
 8002c92:	4606      	mov	r6, r0
	      if (s_eOsalEvents[ulIndex] == EVENT_STATE_SET)
 8002c94:	4b11      	ldr	r3, [pc, #68]	; (8002cdc <OS_WaitEvent+0x5c>)
 8002c96:	5d1b      	ldrb	r3, [r3, r4]
 8002c98:	b2db      	uxtb	r3, r3
 8002c9a:	2b02      	cmp	r3, #2
 8002c9c:	d010      	beq.n	8002cc0 <OS_WaitEvent+0x40>
	      if (s_eOsalEvents[ulIndex] < EVENT_STATE_CLEAR
 8002c9e:	4b0f      	ldr	r3, [pc, #60]	; (8002cdc <OS_WaitEvent+0x5c>)
 8002ca0:	5d1b      	ldrb	r3, [r3, r4]
 8002ca2:	b193      	cbz	r3, 8002cca <OS_WaitEvent+0x4a>
	      ||  s_eOsalEvents[ulIndex] > EVENT_STATE_SET)
 8002ca4:	4b0d      	ldr	r3, [pc, #52]	; (8002cdc <OS_WaitEvent+0x5c>)
 8002ca6:	5d1b      	ldrb	r3, [r3, r4]
 8002ca8:	b2db      	uxtb	r3, r3
 8002caa:	2b02      	cmp	r3, #2
 8002cac:	d80f      	bhi.n	8002cce <OS_WaitEvent+0x4e>
	      ulCurrentTime = OS_GetMilliSecCounter();
 8002cae:	f7ff ff50 	bl	8002b52 <OS_GetMilliSecCounter>
	      if ((ulCurrentTime - ulStartTime) >= ulTimeout)
 8002cb2:	1b80      	subs	r0, r0, r6
 8002cb4:	42a8      	cmp	r0, r5
 8002cb6:	d20c      	bcs.n	8002cd2 <OS_WaitEvent+0x52>
	      OS_Sleep(0);
 8002cb8:	2000      	movs	r0, #0
 8002cba:	f7ff ff4f 	bl	8002b5c <OS_Sleep>
	      if (s_eOsalEvents[ulIndex] == EVENT_STATE_SET)
 8002cbe:	e7e9      	b.n	8002c94 <OS_WaitEvent+0x14>
	        s_eOsalEvents[ulIndex] = EVENT_STATE_CLEAR;
 8002cc0:	4b06      	ldr	r3, [pc, #24]	; (8002cdc <OS_WaitEvent+0x5c>)
 8002cc2:	2201      	movs	r2, #1
 8002cc4:	551a      	strb	r2, [r3, r4]
	  uint32_t    ulResult      = CIFX_NO_ERROR;
 8002cc6:	2000      	movs	r0, #0
}
 8002cc8:	bd70      	pop	{r4, r5, r6, pc}
	        ulResult = CIFX_INVALID_PARAMETER;
 8002cca:	4803      	ldr	r0, [pc, #12]	; (8002cd8 <OS_WaitEvent+0x58>)
 8002ccc:	e7fc      	b.n	8002cc8 <OS_WaitEvent+0x48>
 8002cce:	4802      	ldr	r0, [pc, #8]	; (8002cd8 <OS_WaitEvent+0x58>)
 8002cd0:	e7fa      	b.n	8002cc8 <OS_WaitEvent+0x48>
	        ulResult = CIFX_EVENT_TIMEOUT;
 8002cd2:	2001      	movs	r0, #1
	  return (ulResult);
 8002cd4:	e7f8      	b.n	8002cc8 <OS_WaitEvent+0x48>
 8002cd6:	bf00      	nop
 8002cd8:	800a0005 	.word	0x800a0005
 8002cdc:	200001ec 	.word	0x200001ec

08002ce0 <OS_Strcmp>:
*     \param pszBuf1  String buffer 1
*     \param pszBuf2  String buffer 2
*     \return 0 if strings are equal                                         */
/*****************************************************************************/
int OS_Strcmp(const char* pszBuf1, const char* pszBuf2)
{
 8002ce0:	b508      	push	{r3, lr}
  return strcmp(pszBuf1, pszBuf2);
 8002ce2:	f7fd faad 	bl	8000240 <strcmp>
}
 8002ce6:	bd08      	pop	{r3, pc}

08002ce8 <OS_Strnicmp>:
*     \param pszBuf2  String buffer 2
*     \param ulLen    Maximum length to compare
*     \return 0 if strings are equal                                         */
/*****************************************************************************/
int OS_Strnicmp(const char* pszBuf1, const char* pszBuf2, uint32_t ulLen)
{
 8002ce8:	b508      	push	{r3, lr}
  return strncasecmp(pszBuf1, pszBuf2, ulLen);
 8002cea:	f006 ff27 	bl	8009b3c <strncasecmp>
}
 8002cee:	bd08      	pop	{r3, pc}

08002cf0 <OS_Strlen>:
/*! Get length of string
*     \param szText  Text buffer
*     \return Length of given string                                         */
/*****************************************************************************/
int OS_Strlen(const char* szText)
{
 8002cf0:	b508      	push	{r3, lr}
  return strlen(szText);
 8002cf2:	f7fd faaf 	bl	8000254 <strlen>
}
 8002cf6:	bd08      	pop	{r3, pc}

08002cf8 <OS_Strncpy>:
*     \param szSource Source string
*     \param ulLen    Maximum length to copy
*     \return Pointer to szDest                                              */
/*****************************************************************************/
char* OS_Strncpy(char* szDest, const char* szSource, uint32_t ulLen)
{
 8002cf8:	b508      	push	{r3, lr}
  return strncpy(szDest, szSource, ulLen);
 8002cfa:	f006 ff3f 	bl	8009b7c <strncpy>
}
 8002cfe:	bd08      	pop	{r3, pc}

08002d00 <OS_SpiInit>:
/*****************************************************************************/
long OS_SpiInit(void* pvOSDependent)
{
  /* initialize SPI device */
  return 0;
}
 8002d00:	2000      	movs	r0, #0
 8002d02:	4770      	bx	lr

08002d04 <OS_SpiAssert>:
/*****************************************************************************/
/*! Assert chip select
*   \param pvOSDependent OS Dependent parameter to identify card             */
/*****************************************************************************/
void OS_SpiAssert(void* pvOSDependent)
{
 8002d04:	b508      	push	{r3, lr}
	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_RESET);
 8002d06:	2200      	movs	r2, #0
 8002d08:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8002d0c:	4801      	ldr	r0, [pc, #4]	; (8002d14 <OS_SpiAssert+0x10>)
 8002d0e:	f7fe f929 	bl	8000f64 <HAL_GPIO_WritePin>
}
 8002d12:	bd08      	pop	{r3, pc}
 8002d14:	40020c00 	.word	0x40020c00

08002d18 <OS_SpiDeassert>:
/*****************************************************************************/
/*! Deassert chip select
*   \param pvOSDependent OS Dependent parameter to identify card             */
/*****************************************************************************/
void OS_SpiDeassert(void* pvOSDependent)
{
 8002d18:	b508      	push	{r3, lr}
	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_SET);
 8002d1a:	2201      	movs	r2, #1
 8002d1c:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8002d20:	4801      	ldr	r0, [pc, #4]	; (8002d28 <OS_SpiDeassert+0x10>)
 8002d22:	f7fe f91f 	bl	8000f64 <HAL_GPIO_WritePin>
}
 8002d26:	bd08      	pop	{r3, pc}
 8002d28:	40020c00 	.word	0x40020c00

08002d2c <OS_SpiLock>:
/*****************************************************************************/
/*! Lock the SPI bus
*   \param pvOSDependent OS Dependent parameter                              */
/*****************************************************************************/
void OS_SpiLock(void* pvOSDependent)
{
 8002d2c:	b508      	push	{r3, lr}
  /* lock access to SPI device */
	HAL_NVIC_DisableIRQ(TIMx_IRQn); // disable IRQ at NVIC
 8002d2e:	201d      	movs	r0, #29
 8002d30:	f7fd ffdc 	bl	8000cec <HAL_NVIC_DisableIRQ>
}
 8002d34:	bd08      	pop	{r3, pc}

08002d36 <OS_SpiUnlock>:
/*****************************************************************************/
/*! Unlock the SPI bus
*   \param pvOSDependent OS Dependent parameter                              */
/*****************************************************************************/
void OS_SpiUnlock(void* pvOSDependent)
{
 8002d36:	b508      	push	{r3, lr}
	/* unlock access to SPI device */
	HAL_NVIC_EnableIRQ(TIMx_IRQn); // enable IRQ at NVIC
 8002d38:	201d      	movs	r0, #29
 8002d3a:	f7fd ffc9 	bl	8000cd0 <HAL_NVIC_EnableIRQ>
}
 8002d3e:	bd08      	pop	{r3, pc}

08002d40 <OS_SpiTransfer>:
*   \param pbSend        Send buffer (NULL for polling)
*   \param pbRecv        Receive buffer (NULL if discard)
*   \param ulLen         Length of SPI transfer                              */
/*****************************************************************************/
void OS_SpiTransfer(void* pvOSDependent, uint8_t* pbSend, uint8_t* pbRecv, uint32_t ulLen)
{
 8002d40:	b508      	push	{r3, lr}
	HAL_StatusTypeDef tRet=HAL_OK;
	static uint32_t ulErrCnt=0;

	/*no receive data requested (just transmit) */
	if(pbRecv==NULL){
 8002d42:	b182      	cbz	r2, 8002d66 <OS_SpiTransfer+0x26>
 8002d44:	4610      	mov	r0, r2
		tRet=HAL_SPI_Transmit_IT(&SpiHandle, pbSend, (uint16_t) ulLen);

	}
	/*no transmit data (just receive) */
	else if(pbSend==NULL) {
 8002d46:	b199      	cbz	r1, 8002d70 <OS_SpiTransfer+0x30>
		tRet=HAL_SPI_Receive_IT(&SpiHandle, pbRecv, (uint16_t) ulLen);
	}
	else {
		tRet=HAL_SPI_TransmitReceive_IT(&SpiHandle, pbSend, pbRecv, (uint16_t) ulLen);
 8002d48:	b29b      	uxth	r3, r3
 8002d4a:	480c      	ldr	r0, [pc, #48]	; (8002d7c <OS_SpiTransfer+0x3c>)
 8002d4c:	f7fe fefa 	bl	8001b44 <HAL_SPI_TransmitReceive_IT>
	}


	if(tRet!=HAL_OK){
 8002d50:	b118      	cbz	r0, 8002d5a <OS_SpiTransfer+0x1a>
		ulErrCnt++;
 8002d52:	4a0b      	ldr	r2, [pc, #44]	; (8002d80 <OS_SpiTransfer+0x40>)
 8002d54:	6813      	ldr	r3, [r2, #0]
 8002d56:	3301      	adds	r3, #1
 8002d58:	6013      	str	r3, [r2, #0]
	}

	/*blocking SPI transfer, wait until all bytes are transferred*/
	while(HAL_SPI_STATE_READY != HAL_SPI_GetState(&SpiHandle));
 8002d5a:	4808      	ldr	r0, [pc, #32]	; (8002d7c <OS_SpiTransfer+0x3c>)
 8002d5c:	f7ff fa09 	bl	8002172 <HAL_SPI_GetState>
 8002d60:	2801      	cmp	r0, #1
 8002d62:	d1fa      	bne.n	8002d5a <OS_SpiTransfer+0x1a>
}
 8002d64:	bd08      	pop	{r3, pc}
		tRet=HAL_SPI_Transmit_IT(&SpiHandle, pbSend, (uint16_t) ulLen);
 8002d66:	b29a      	uxth	r2, r3
 8002d68:	4804      	ldr	r0, [pc, #16]	; (8002d7c <OS_SpiTransfer+0x3c>)
 8002d6a:	f7fe fe95 	bl	8001a98 <HAL_SPI_Transmit_IT>
 8002d6e:	e7ef      	b.n	8002d50 <OS_SpiTransfer+0x10>
		tRet=HAL_SPI_Receive_IT(&SpiHandle, pbRecv, (uint16_t) ulLen);
 8002d70:	b29a      	uxth	r2, r3
 8002d72:	4601      	mov	r1, r0
 8002d74:	4801      	ldr	r0, [pc, #4]	; (8002d7c <OS_SpiTransfer+0x3c>)
 8002d76:	f7fe ff6d 	bl	8001c54 <HAL_SPI_Receive_IT>
 8002d7a:	e7e9      	b.n	8002d50 <OS_SpiTransfer+0x10>
 8002d7c:	200000b4 	.word	0x200000b4
 8002d80:	20000208 	.word	0x20000208

08002d84 <Write_NX51>:
*   \param pvAddr         Address offset in DPM to write data to
*   \param pvData         Data to write to SPI interface
*   \param ulLen          Number of bytes to write                           */
/*****************************************************************************/
static void* Write_NX51( uint32_t ulOption, void* pvDevInstance, void* pvAddr, void* pvData, uint32_t ulLen)
{
 8002d84:	b570      	push	{r4, r5, r6, lr}
 8002d86:	b082      	sub	sp, #8
 8002d88:	460c      	mov	r4, r1
 8002d8a:	4615      	mov	r5, r2
 8002d8c:	461e      	mov	r6, r3
  DEVICEINSTANCE* ptDevice = (DEVICEINSTANCE*) pvDevInstance;
  uint8_t         abSend[3];

  /* Assemble command */
  abSend[0] = (uint8_t)(CMD_WRITE_NX51((uint32_t)pvAddr));
 8002d8e:	f3c2 4303 	ubfx	r3, r2, #16, #4
 8002d92:	f88d 3004 	strb.w	r3, [sp, #4]
  abSend[1] = (uint8_t)(((uint32_t)pvAddr >> 8) & 0xFF);
 8002d96:	f3c2 2307 	ubfx	r3, r2, #8, #8
 8002d9a:	f88d 3005 	strb.w	r3, [sp, #5]
  abSend[2] = (uint8_t)(((uint32_t)pvAddr >> 0) & 0xFF);
 8002d9e:	f88d 2006 	strb.w	r2, [sp, #6]

  OS_SpiLock(ptDevice->pvOSDependent);
 8002da2:	69c8      	ldr	r0, [r1, #28]
 8002da4:	f7ff ffc2 	bl	8002d2c <OS_SpiLock>
  OS_SpiAssert(pvDevInstance);
 8002da8:	4620      	mov	r0, r4
 8002daa:	f7ff ffab 	bl	8002d04 <OS_SpiAssert>
  OS_SpiTransfer(pvDevInstance, abSend, NULL, MAX_CNT(abSend));
 8002dae:	2303      	movs	r3, #3
 8002db0:	2200      	movs	r2, #0
 8002db2:	a901      	add	r1, sp, #4
 8002db4:	4620      	mov	r0, r4
 8002db6:	f7ff ffc3 	bl	8002d40 <OS_SpiTransfer>
  OS_SpiTransfer(pvDevInstance, (uint8_t*)pvData, NULL, ulLen);
 8002dba:	9b06      	ldr	r3, [sp, #24]
 8002dbc:	2200      	movs	r2, #0
 8002dbe:	4631      	mov	r1, r6
 8002dc0:	4620      	mov	r0, r4
 8002dc2:	f7ff ffbd 	bl	8002d40 <OS_SpiTransfer>
  OS_SpiDeassert(pvDevInstance);
 8002dc6:	4620      	mov	r0, r4
 8002dc8:	f7ff ffa6 	bl	8002d18 <OS_SpiDeassert>
  OS_SpiUnlock(ptDevice->pvOSDependent);
 8002dcc:	69e0      	ldr	r0, [r4, #28]
 8002dce:	f7ff ffb2 	bl	8002d36 <OS_SpiUnlock>
  return pvAddr;
}
 8002dd2:	4628      	mov	r0, r5
 8002dd4:	b002      	add	sp, #8
 8002dd6:	bd70      	pop	{r4, r5, r6, pc}

08002dd8 <Write_NX10>:
{
 8002dd8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002dda:	b083      	sub	sp, #12
 8002ddc:	460c      	mov	r4, r1
 8002dde:	4615      	mov	r5, r2
 8002de0:	461e      	mov	r6, r3
 8002de2:	9f08      	ldr	r7, [sp, #32]
  abSend[0] = (uint8_t)(((uint32_t)pvAddr >> 8) & 0xFF);
 8002de4:	f3c2 2307 	ubfx	r3, r2, #8, #8
 8002de8:	f88d 3004 	strb.w	r3, [sp, #4]
  abSend[1] = (uint8_t)(((uint32_t)pvAddr >> 0) & 0xFF);
 8002dec:	f88d 2005 	strb.w	r2, [sp, #5]
  abSend[2] = (uint8_t)(CMD_WRITE_NX10(ulLen));
 8002df0:	2f7f      	cmp	r7, #127	; 0x7f
 8002df2:	d81d      	bhi.n	8002e30 <Write_NX10+0x58>
 8002df4:	b2fb      	uxtb	r3, r7
 8002df6:	f88d 3006 	strb.w	r3, [sp, #6]
  OS_SpiLock(ptDevice->pvOSDependent);
 8002dfa:	69e0      	ldr	r0, [r4, #28]
 8002dfc:	f7ff ff96 	bl	8002d2c <OS_SpiLock>
  OS_SpiAssert(pvDevInstance);
 8002e00:	4620      	mov	r0, r4
 8002e02:	f7ff ff7f 	bl	8002d04 <OS_SpiAssert>
  OS_SpiTransfer(pvDevInstance, abSend, NULL, MAX_CNT(abSend));
 8002e06:	2303      	movs	r3, #3
 8002e08:	2200      	movs	r2, #0
 8002e0a:	a901      	add	r1, sp, #4
 8002e0c:	4620      	mov	r0, r4
 8002e0e:	f7ff ff97 	bl	8002d40 <OS_SpiTransfer>
  OS_SpiTransfer(pvDevInstance, (uint8_t*)pvData, NULL, ulLen);
 8002e12:	463b      	mov	r3, r7
 8002e14:	2200      	movs	r2, #0
 8002e16:	4631      	mov	r1, r6
 8002e18:	4620      	mov	r0, r4
 8002e1a:	f7ff ff91 	bl	8002d40 <OS_SpiTransfer>
  OS_SpiDeassert(pvDevInstance);
 8002e1e:	4620      	mov	r0, r4
 8002e20:	f7ff ff7a 	bl	8002d18 <OS_SpiDeassert>
  OS_SpiUnlock(ptDevice->pvOSDependent);
 8002e24:	69e0      	ldr	r0, [r4, #28]
 8002e26:	f7ff ff86 	bl	8002d36 <OS_SpiUnlock>
}
 8002e2a:	4628      	mov	r0, r5
 8002e2c:	b003      	add	sp, #12
 8002e2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  abSend[2] = (uint8_t)(CMD_WRITE_NX10(ulLen));
 8002e30:	2300      	movs	r3, #0
 8002e32:	e7e0      	b.n	8002df6 <Write_NX10+0x1e>

08002e34 <Write_NX50>:
{
 8002e34:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002e38:	b083      	sub	sp, #12
 8002e3a:	460d      	mov	r5, r1
 8002e3c:	4691      	mov	r9, r2
 8002e3e:	4698      	mov	r8, r3
 8002e40:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  uint32_t        ulDpmAddr = (uint32_t)pvAddr;
 8002e42:	4617      	mov	r7, r2
  OS_SpiLock(ptDevice->pvOSDependent);
 8002e44:	69c8      	ldr	r0, [r1, #28]
 8002e46:	f7ff ff71 	bl	8002d2c <OS_SpiLock>
  while (ulLen > 0)
 8002e4a:	e020      	b.n	8002e8e <Write_NX50+0x5a>
    uint32_t ulChunkLen = MIN(MAX_TRANSFER_LEN, ulLen);
 8002e4c:	4634      	mov	r4, r6
 8002e4e:	2e7c      	cmp	r6, #124	; 0x7c
 8002e50:	bf28      	it	cs
 8002e52:	247c      	movcs	r4, #124	; 0x7c
    ulLen -= ulChunkLen;
 8002e54:	1b36      	subs	r6, r6, r4
    abSend[0] = (uint8_t)((ulDpmAddr >> 8) & 0xFF);
 8002e56:	f3c7 2307 	ubfx	r3, r7, #8, #8
 8002e5a:	f88d 3004 	strb.w	r3, [sp, #4]
    abSend[1] = (uint8_t)((ulDpmAddr >> 0) & 0xFF);
 8002e5e:	f88d 7005 	strb.w	r7, [sp, #5]
    abSend[2] = (uint8_t)ulChunkLen;
 8002e62:	f88d 4006 	strb.w	r4, [sp, #6]
    OS_SpiAssert(pvDevInstance);
 8002e66:	4628      	mov	r0, r5
 8002e68:	f7ff ff4c 	bl	8002d04 <OS_SpiAssert>
    OS_SpiTransfer(pvDevInstance, abSend, NULL, MAX_CNT(abSend));
 8002e6c:	2303      	movs	r3, #3
 8002e6e:	2200      	movs	r2, #0
 8002e70:	a901      	add	r1, sp, #4
 8002e72:	4628      	mov	r0, r5
 8002e74:	f7ff ff64 	bl	8002d40 <OS_SpiTransfer>
    OS_SpiTransfer(pvDevInstance, pabData, NULL, ulChunkLen);
 8002e78:	4623      	mov	r3, r4
 8002e7a:	2200      	movs	r2, #0
 8002e7c:	4641      	mov	r1, r8
 8002e7e:	4628      	mov	r0, r5
 8002e80:	f7ff ff5e 	bl	8002d40 <OS_SpiTransfer>
    OS_SpiDeassert(pvDevInstance);
 8002e84:	4628      	mov	r0, r5
 8002e86:	f7ff ff47 	bl	8002d18 <OS_SpiDeassert>
    ulDpmAddr += ulChunkLen;
 8002e8a:	4427      	add	r7, r4
    pabData   += ulChunkLen;      /*lint !e662 */
 8002e8c:	44a0      	add	r8, r4
  while (ulLen > 0)
 8002e8e:	2e00      	cmp	r6, #0
 8002e90:	d1dc      	bne.n	8002e4c <Write_NX50+0x18>
  OS_SpiUnlock(ptDevice->pvOSDependent);
 8002e92:	69e8      	ldr	r0, [r5, #28]
 8002e94:	f7ff ff4f 	bl	8002d36 <OS_SpiUnlock>
}
 8002e98:	4648      	mov	r0, r9
 8002e9a:	b003      	add	sp, #12
 8002e9c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08002ea0 <Read_NX50>:
{
 8002ea0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002ea4:	b085      	sub	sp, #20
 8002ea6:	460d      	mov	r5, r1
 8002ea8:	461f      	mov	r7, r3
 8002eaa:	9301      	str	r3, [sp, #4]
 8002eac:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
  uint8_t         bUnused       = 0x00;
 8002eb0:	2300      	movs	r3, #0
 8002eb2:	f88d 300f 	strb.w	r3, [sp, #15]
  uint32_t        ulDpmAddr     = (uint32_t)pvAddr;
 8002eb6:	4692      	mov	sl, r2
  OS_SpiLock(ptDevice->pvOSDependent);
 8002eb8:	69c8      	ldr	r0, [r1, #28]
 8002eba:	f7ff ff37 	bl	8002d2c <OS_SpiLock>
  uint32_t        ulByteTimeout = 100;
 8002ebe:	2464      	movs	r4, #100	; 0x64
  while (ulLen > 0)
 8002ec0:	f1bb 0f00 	cmp.w	fp, #0
 8002ec4:	d042      	beq.n	8002f4c <Read_NX50+0xac>
    uint32_t ulChunkLen = MIN(MAX_TRANSFER_LEN, ulLen);
 8002ec6:	465e      	mov	r6, fp
 8002ec8:	2e7c      	cmp	r6, #124	; 0x7c
 8002eca:	bf28      	it	cs
 8002ecc:	267c      	movcs	r6, #124	; 0x7c
    ulLen -= ulChunkLen;
 8002ece:	ebab 0b06 	sub.w	fp, fp, r6
    abSend[0] = (uint8_t)((ulDpmAddr >> 8) & 0xFF);
 8002ed2:	f3ca 2307 	ubfx	r3, sl, #8, #8
 8002ed6:	f88d 300c 	strb.w	r3, [sp, #12]
    abSend[1] = (uint8_t)((ulDpmAddr >> 0) & 0xFF);
 8002eda:	f88d a00d 	strb.w	sl, [sp, #13]
    abSend[2] = (uint8_t)(CMD_READ_NX50(ulChunkLen));
 8002ede:	f066 037f 	orn	r3, r6, #127	; 0x7f
 8002ee2:	f88d 300e 	strb.w	r3, [sp, #14]
    OS_SpiAssert(pvDevInstance);
 8002ee6:	4628      	mov	r0, r5
 8002ee8:	f7ff ff0c 	bl	8002d04 <OS_SpiAssert>
    OS_SpiTransfer(pvDevInstance, abSend, NULL, MAX_CNT(abSend));
 8002eec:	2303      	movs	r3, #3
 8002eee:	2200      	movs	r2, #0
 8002ef0:	a903      	add	r1, sp, #12
 8002ef2:	4628      	mov	r0, r5
 8002ef4:	f7ff ff24 	bl	8002d40 <OS_SpiTransfer>
      if(ulByteTimeout == 0)
 8002ef8:	b164      	cbz	r4, 8002f14 <Read_NX50+0x74>
      --ulByteTimeout;
 8002efa:	3c01      	subs	r4, #1
      OS_SpiTransfer(pvDevInstance, NULL, &bUnused, 1);
 8002efc:	2301      	movs	r3, #1
 8002efe:	f10d 020f 	add.w	r2, sp, #15
 8002f02:	2100      	movs	r1, #0
 8002f04:	4628      	mov	r0, r5
 8002f06:	f7ff ff1b 	bl	8002d40 <OS_SpiTransfer>
    } while((bUnused & 0xFF) != 0xA5);
 8002f0a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002f0e:	2ba5      	cmp	r3, #165	; 0xa5
 8002f10:	d1f2      	bne.n	8002ef8 <Read_NX50+0x58>
 8002f12:	e011      	b.n	8002f38 <Read_NX50+0x98>
          OS_SpiDeassert(pvDevInstance);
 8002f14:	4628      	mov	r0, r5
 8002f16:	f7ff feff 	bl	8002d18 <OS_SpiDeassert>
}
 8002f1a:	9801      	ldr	r0, [sp, #4]
 8002f1c:	b005      	add	sp, #20
 8002f1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      OS_SpiTransfer(pvDevInstance, &bUnused, pabData++, 1);
 8002f22:	f107 0901 	add.w	r9, r7, #1
 8002f26:	2301      	movs	r3, #1
 8002f28:	463a      	mov	r2, r7
 8002f2a:	f10d 010f 	add.w	r1, sp, #15
 8002f2e:	4628      	mov	r0, r5
 8002f30:	f7ff ff06 	bl	8002d40 <OS_SpiTransfer>
    while(ulChunkLen--)
 8002f34:	4646      	mov	r6, r8
      OS_SpiTransfer(pvDevInstance, &bUnused, pabData++, 1);
 8002f36:	464f      	mov	r7, r9
    while(ulChunkLen--)
 8002f38:	f106 38ff 	add.w	r8, r6, #4294967295
 8002f3c:	2e00      	cmp	r6, #0
 8002f3e:	d1f0      	bne.n	8002f22 <Read_NX50+0x82>
    OS_SpiDeassert(pvDevInstance);
 8002f40:	4628      	mov	r0, r5
 8002f42:	f7ff fee9 	bl	8002d18 <OS_SpiDeassert>
    ulDpmAddr += MAX_TRANSFER_LEN;
 8002f46:	f10a 0a7c 	add.w	sl, sl, #124	; 0x7c
 8002f4a:	e7b9      	b.n	8002ec0 <Read_NX50+0x20>
  OS_SpiUnlock(ptDevice->pvOSDependent);
 8002f4c:	69e8      	ldr	r0, [r5, #28]
 8002f4e:	f7ff fef2 	bl	8002d36 <OS_SpiUnlock>
  return pvData;
 8002f52:	e7e2      	b.n	8002f1a <Read_NX50+0x7a>

08002f54 <ReadModifyWrite_NX500>:
{
 8002f54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002f58:	b085      	sub	sp, #20
 8002f5a:	4688      	mov	r8, r1
 8002f5c:	4617      	mov	r7, r2
 8002f5e:	461c      	mov	r4, r3
 8002f60:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
  uint32_t ulDpmAddr = (uint32_t)pvAddr;
 8002f64:	4692      	mov	sl, r2
  if (ulDpmAddr&0x3)
 8002f66:	f012 0603 	ands.w	r6, r2, #3
 8002f6a:	d109      	bne.n	8002f80 <ReadModifyWrite_NX500+0x2c>
  if (ulLen&~0x3)
 8002f6c:	f039 0503 	bics.w	r5, r9, #3
 8002f70:	d12c      	bne.n	8002fcc <ReadModifyWrite_NX500+0x78>
  if (ulLen&0x3)
 8002f72:	f019 0f03 	tst.w	r9, #3
 8002f76:	d135      	bne.n	8002fe4 <ReadModifyWrite_NX500+0x90>
}
 8002f78:	4638      	mov	r0, r7
 8002f7a:	b005      	add	sp, #20
 8002f7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint32_t ulAlignedAddr = ulDpmAddr&~0x3;
 8002f80:	f022 0b03 	bic.w	fp, r2, #3
    uint8_t* pabRead       = &abRead[ulDpmAddr&0x3];
 8002f84:	ab03      	add	r3, sp, #12
 8002f86:	199d      	adds	r5, r3, r6
    uint32_t ulPartLen     = MIN(ulLen, (4 - (ulDpmAddr&0x3)));
 8002f88:	f1c6 0604 	rsb	r6, r6, #4
 8002f8c:	454e      	cmp	r6, r9
 8002f8e:	bf28      	it	cs
 8002f90:	464e      	movcs	r6, r9
    ulLen     -= ulPartLen;
 8002f92:	eba9 0906 	sub.w	r9, r9, r6
    ulDpmAddr += ulPartLen;
 8002f96:	eb02 0a06 	add.w	sl, r2, r6
    (void) Read_NX50( 0, pvDevInstance, (void*)ulAlignedAddr, abRead, 4);
 8002f9a:	2304      	movs	r3, #4
 8002f9c:	9300      	str	r3, [sp, #0]
 8002f9e:	ab03      	add	r3, sp, #12
 8002fa0:	465a      	mov	r2, fp
 8002fa2:	2000      	movs	r0, #0
 8002fa4:	f7ff ff7c 	bl	8002ea0 <Read_NX50>
    while (ulPartLen--)
 8002fa8:	e004      	b.n	8002fb4 <ReadModifyWrite_NX500+0x60>
      *pabRead++ = *pabData++;
 8002faa:	f814 2b01 	ldrb.w	r2, [r4], #1
 8002fae:	f805 2b01 	strb.w	r2, [r5], #1
    while (ulPartLen--)
 8002fb2:	461e      	mov	r6, r3
 8002fb4:	1e73      	subs	r3, r6, #1
 8002fb6:	2e00      	cmp	r6, #0
 8002fb8:	d1f7      	bne.n	8002faa <ReadModifyWrite_NX500+0x56>
    (void) Write_NX50( 0, pvDevInstance, (void*)ulAlignedAddr, abRead, 4);
 8002fba:	2304      	movs	r3, #4
 8002fbc:	9300      	str	r3, [sp, #0]
 8002fbe:	ab03      	add	r3, sp, #12
 8002fc0:	465a      	mov	r2, fp
 8002fc2:	4641      	mov	r1, r8
 8002fc4:	2000      	movs	r0, #0
 8002fc6:	f7ff ff35 	bl	8002e34 <Write_NX50>
 8002fca:	e7cf      	b.n	8002f6c <ReadModifyWrite_NX500+0x18>
    (void) Write_NX50( 0, pvDevInstance, (void*)ulDpmAddr, pabData, ulAlignedLen);
 8002fcc:	9500      	str	r5, [sp, #0]
 8002fce:	4623      	mov	r3, r4
 8002fd0:	4652      	mov	r2, sl
 8002fd2:	4641      	mov	r1, r8
 8002fd4:	2000      	movs	r0, #0
 8002fd6:	f7ff ff2d 	bl	8002e34 <Write_NX50>
    pabData   += ulAlignedLen;
 8002fda:	442c      	add	r4, r5
    ulDpmAddr += ulAlignedLen;
 8002fdc:	44aa      	add	sl, r5
    ulLen     -= ulAlignedLen;
 8002fde:	eba9 0905 	sub.w	r9, r9, r5
 8002fe2:	e7c6      	b.n	8002f72 <ReadModifyWrite_NX500+0x1e>
    (void) Read_NX50( 0, pvDevInstance, (void*)ulDpmAddr, abRead, 4);
 8002fe4:	4655      	mov	r5, sl
 8002fe6:	2304      	movs	r3, #4
 8002fe8:	9300      	str	r3, [sp, #0]
 8002fea:	ab03      	add	r3, sp, #12
 8002fec:	4652      	mov	r2, sl
 8002fee:	4641      	mov	r1, r8
 8002ff0:	2000      	movs	r0, #0
 8002ff2:	f7ff ff55 	bl	8002ea0 <Read_NX50>
    uint8_t* pabRead = &abRead[0];
 8002ff6:	ab03      	add	r3, sp, #12
    while (ulLen--)
 8002ff8:	e004      	b.n	8003004 <ReadModifyWrite_NX500+0xb0>
      *pabRead++ = *pabData++;
 8002ffa:	f814 1b01 	ldrb.w	r1, [r4], #1
 8002ffe:	f803 1b01 	strb.w	r1, [r3], #1
    while (ulLen--)
 8003002:	4691      	mov	r9, r2
 8003004:	f109 32ff 	add.w	r2, r9, #4294967295
 8003008:	f1b9 0f00 	cmp.w	r9, #0
 800300c:	d1f5      	bne.n	8002ffa <ReadModifyWrite_NX500+0xa6>
    (void) Write_NX50( 0, pvDevInstance, (void*)ulDpmAddr, abRead, 4);
 800300e:	2304      	movs	r3, #4
 8003010:	9300      	str	r3, [sp, #0]
 8003012:	ab03      	add	r3, sp, #12
 8003014:	462a      	mov	r2, r5
 8003016:	4641      	mov	r1, r8
 8003018:	2000      	movs	r0, #0
 800301a:	f7ff ff0b 	bl	8002e34 <Write_NX50>
 800301e:	e7ab      	b.n	8002f78 <ReadModifyWrite_NX500+0x24>

08003020 <Read_NX500>:
{
 8003020:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003024:	b085      	sub	sp, #20
 8003026:	460d      	mov	r5, r1
 8003028:	469a      	mov	sl, r3
 800302a:	9301      	str	r3, [sp, #4]
 800302c:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
  uint8_t         bUnused       = 0x00;
 8003030:	2300      	movs	r3, #0
 8003032:	f88d 300f 	strb.w	r3, [sp, #15]
  uint32_t        ulPreLen      = ulDpmAddr&0x3;
 8003036:	f002 0b03 	and.w	fp, r2, #3
  ulDpmAddr &= ~0x3;
 800303a:	f022 0603 	bic.w	r6, r2, #3
  OS_SpiLock(ptDevice->pvOSDependent);
 800303e:	69c8      	ldr	r0, [r1, #28]
 8003040:	f7ff fe74 	bl	8002d2c <OS_SpiLock>
  uint32_t        ulByteTimeout = 100;
 8003044:	2464      	movs	r4, #100	; 0x64
  while (ulLen > 0)
 8003046:	f1b9 0f00 	cmp.w	r9, #0
 800304a:	d052      	beq.n	80030f2 <Read_NX500+0xd2>
    uint32_t ulChunkLen   = MIN(MAX_TRANSFER_LEN, ulLen);
 800304c:	464f      	mov	r7, r9
 800304e:	2f7c      	cmp	r7, #124	; 0x7c
 8003050:	bf28      	it	cs
 8003052:	277c      	movcs	r7, #124	; 0x7c
    uint32_t ulAlignedLen = (ulChunkLen+3)&~0x3;
 8003054:	f107 0803 	add.w	r8, r7, #3
 8003058:	f028 0803 	bic.w	r8, r8, #3
    ulLen -= ulChunkLen;
 800305c:	eba9 0907 	sub.w	r9, r9, r7
    abSend[0] = (uint8_t)((ulDpmAddr >> 8) & 0xFF);
 8003060:	f3c6 2307 	ubfx	r3, r6, #8, #8
 8003064:	f88d 300c 	strb.w	r3, [sp, #12]
    abSend[1] = (uint8_t)((ulDpmAddr >> 0) & 0xFF);
 8003068:	f88d 600d 	strb.w	r6, [sp, #13]
    abSend[2] = (uint8_t)(CMD_READ_NX50(ulAlignedLen));
 800306c:	f068 037f 	orn	r3, r8, #127	; 0x7f
 8003070:	f88d 300e 	strb.w	r3, [sp, #14]
    OS_SpiAssert(pvDevInstance);
 8003074:	4628      	mov	r0, r5
 8003076:	f7ff fe45 	bl	8002d04 <OS_SpiAssert>
    OS_SpiTransfer(pvDevInstance, abSend, NULL, MAX_CNT(abSend));
 800307a:	2303      	movs	r3, #3
 800307c:	2200      	movs	r2, #0
 800307e:	a903      	add	r1, sp, #12
 8003080:	4628      	mov	r0, r5
 8003082:	f7ff fe5d 	bl	8002d40 <OS_SpiTransfer>
      if(ulByteTimeout == 0)
 8003086:	b1e4      	cbz	r4, 80030c2 <Read_NX500+0xa2>
      --ulByteTimeout;
 8003088:	3c01      	subs	r4, #1
      OS_SpiTransfer(pvDevInstance, NULL, &bUnused, 1);
 800308a:	2301      	movs	r3, #1
 800308c:	f10d 020f 	add.w	r2, sp, #15
 8003090:	2100      	movs	r1, #0
 8003092:	4628      	mov	r0, r5
 8003094:	f7ff fe54 	bl	8002d40 <OS_SpiTransfer>
    } while((bUnused & 0xFF) != 0xA5);
 8003098:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800309c:	2ba5      	cmp	r3, #165	; 0xa5
 800309e:	d1f2      	bne.n	8003086 <Read_NX500+0x66>
    if (ulPreLen)
 80030a0:	f1bb 0f00 	cmp.w	fp, #0
 80030a4:	d114      	bne.n	80030d0 <Read_NX500+0xb0>
    OS_SpiTransfer(pvDevInstance, NULL, pabData, ulChunkLen);
 80030a6:	463b      	mov	r3, r7
 80030a8:	4652      	mov	r2, sl
 80030aa:	2100      	movs	r1, #0
 80030ac:	4628      	mov	r0, r5
 80030ae:	f7ff fe47 	bl	8002d40 <OS_SpiTransfer>
    if (0 != (ulAlignedLen - ulChunkLen))
 80030b2:	4547      	cmp	r7, r8
 80030b4:	d115      	bne.n	80030e2 <Read_NX500+0xc2>
    OS_SpiDeassert(pvDevInstance);
 80030b6:	4628      	mov	r0, r5
 80030b8:	f7ff fe2e 	bl	8002d18 <OS_SpiDeassert>
    ulDpmAddr += ulChunkLen;
 80030bc:	443e      	add	r6, r7
    pabData   += ulChunkLen;      /*lint !e662 */
 80030be:	44ba      	add	sl, r7
 80030c0:	e7c1      	b.n	8003046 <Read_NX500+0x26>
          OS_SpiDeassert(pvDevInstance);
 80030c2:	4628      	mov	r0, r5
 80030c4:	f7ff fe28 	bl	8002d18 <OS_SpiDeassert>
}
 80030c8:	9801      	ldr	r0, [sp, #4]
 80030ca:	b005      	add	sp, #20
 80030cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      OS_SpiTransfer(pvDevInstance, NULL, NULL, ulPreLen);
 80030d0:	465b      	mov	r3, fp
 80030d2:	2200      	movs	r2, #0
 80030d4:	4611      	mov	r1, r2
 80030d6:	4628      	mov	r0, r5
 80030d8:	f7ff fe32 	bl	8002d40 <OS_SpiTransfer>
      ulPreLen = 0;
 80030dc:	f04f 0b00 	mov.w	fp, #0
 80030e0:	e7e1      	b.n	80030a6 <Read_NX500+0x86>
      OS_SpiTransfer(pvDevInstance, NULL, NULL, ulAlignedLen - ulChunkLen);
 80030e2:	eba8 0307 	sub.w	r3, r8, r7
 80030e6:	2200      	movs	r2, #0
 80030e8:	4611      	mov	r1, r2
 80030ea:	4628      	mov	r0, r5
 80030ec:	f7ff fe28 	bl	8002d40 <OS_SpiTransfer>
 80030f0:	e7e1      	b.n	80030b6 <Read_NX500+0x96>
  OS_SpiUnlock(ptDevice->pvOSDependent);
 80030f2:	69e8      	ldr	r0, [r5, #28]
 80030f4:	f7ff fe1f 	bl	8002d36 <OS_SpiUnlock>
  return pvData;
 80030f8:	e7e6      	b.n	80030c8 <Read_NX500+0xa8>

080030fa <Read_NX10>:
{
 80030fa:	b570      	push	{r4, r5, r6, lr}
 80030fc:	b082      	sub	sp, #8
 80030fe:	460c      	mov	r4, r1
 8003100:	461d      	mov	r5, r3
 8003102:	9e06      	ldr	r6, [sp, #24]
  abSend[0] = (uint8_t)(((uint32_t)pvAddr >> 8) & 0xFF);
 8003104:	f3c2 2307 	ubfx	r3, r2, #8, #8
 8003108:	f88d 3004 	strb.w	r3, [sp, #4]
  abSend[1] = (uint8_t)(((uint32_t)pvAddr >> 0) & 0xFF);
 800310c:	f88d 2005 	strb.w	r2, [sp, #5]
  abSend[2] = (uint8_t)(CMD_READ_NX10(ulLen));
 8003110:	2e7f      	cmp	r6, #127	; 0x7f
 8003112:	d81f      	bhi.n	8003154 <Read_NX10+0x5a>
 8003114:	f046 0380 	orr.w	r3, r6, #128	; 0x80
 8003118:	b2db      	uxtb	r3, r3
 800311a:	f88d 3006 	strb.w	r3, [sp, #6]
  OS_SpiLock(ptDevice->pvOSDependent);
 800311e:	69e0      	ldr	r0, [r4, #28]
 8003120:	f7ff fe04 	bl	8002d2c <OS_SpiLock>
  OS_SpiAssert(pvDevInstance);
 8003124:	4620      	mov	r0, r4
 8003126:	f7ff fded 	bl	8002d04 <OS_SpiAssert>
  OS_SpiTransfer(pvDevInstance, abSend, NULL, MAX_CNT(abSend));
 800312a:	2303      	movs	r3, #3
 800312c:	2200      	movs	r2, #0
 800312e:	a901      	add	r1, sp, #4
 8003130:	4620      	mov	r0, r4
 8003132:	f7ff fe05 	bl	8002d40 <OS_SpiTransfer>
  OS_SpiTransfer(pvDevInstance, NULL, (uint8_t*)pvData, ulLen);
 8003136:	4633      	mov	r3, r6
 8003138:	462a      	mov	r2, r5
 800313a:	2100      	movs	r1, #0
 800313c:	4620      	mov	r0, r4
 800313e:	f7ff fdff 	bl	8002d40 <OS_SpiTransfer>
  OS_SpiDeassert(pvDevInstance);
 8003142:	4620      	mov	r0, r4
 8003144:	f7ff fde8 	bl	8002d18 <OS_SpiDeassert>
  OS_SpiUnlock(ptDevice->pvOSDependent);
 8003148:	69e0      	ldr	r0, [r4, #28]
 800314a:	f7ff fdf4 	bl	8002d36 <OS_SpiUnlock>
}
 800314e:	4628      	mov	r0, r5
 8003150:	b002      	add	sp, #8
 8003152:	bd70      	pop	{r4, r5, r6, pc}
  abSend[2] = (uint8_t)(CMD_READ_NX10(ulLen));
 8003154:	2380      	movs	r3, #128	; 0x80
 8003156:	e7e0      	b.n	800311a <Read_NX10+0x20>

08003158 <Read_NX51>:
{
 8003158:	b570      	push	{r4, r5, r6, lr}
 800315a:	b082      	sub	sp, #8
 800315c:	460c      	mov	r4, r1
 800315e:	461d      	mov	r5, r3
 8003160:	9e06      	ldr	r6, [sp, #24]
  abSend[0] = (uint8_t)(CMD_READ_NX51((uint32_t)pvAddr));
 8003162:	f3c2 4303 	ubfx	r3, r2, #16, #4
 8003166:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800316a:	f88d 3004 	strb.w	r3, [sp, #4]
  abSend[1] = (uint8_t)(((uint32_t)pvAddr >> 8) & 0xFF);
 800316e:	f3c2 2307 	ubfx	r3, r2, #8, #8
 8003172:	f88d 3005 	strb.w	r3, [sp, #5]
  abSend[2] = (uint8_t)(((uint32_t)pvAddr >> 0) & 0xFF);
 8003176:	f88d 2006 	strb.w	r2, [sp, #6]
  abSend[3] = (uint8_t)(CMD_LEN_NX51(ulLen));
 800317a:	2eff      	cmp	r6, #255	; 0xff
 800317c:	d81e      	bhi.n	80031bc <Read_NX51+0x64>
 800317e:	b2f3      	uxtb	r3, r6
 8003180:	f88d 3007 	strb.w	r3, [sp, #7]
  OS_SpiLock(ptDevice->pvOSDependent);
 8003184:	69e0      	ldr	r0, [r4, #28]
 8003186:	f7ff fdd1 	bl	8002d2c <OS_SpiLock>
  OS_SpiAssert(pvDevInstance);
 800318a:	4620      	mov	r0, r4
 800318c:	f7ff fdba 	bl	8002d04 <OS_SpiAssert>
  OS_SpiTransfer(pvDevInstance, abSend, NULL, MAX_CNT(abSend));
 8003190:	2304      	movs	r3, #4
 8003192:	2200      	movs	r2, #0
 8003194:	eb0d 0103 	add.w	r1, sp, r3
 8003198:	4620      	mov	r0, r4
 800319a:	f7ff fdd1 	bl	8002d40 <OS_SpiTransfer>
  OS_SpiTransfer(pvDevInstance, NULL, (uint8_t*)pvData, ulLen);
 800319e:	4633      	mov	r3, r6
 80031a0:	462a      	mov	r2, r5
 80031a2:	2100      	movs	r1, #0
 80031a4:	4620      	mov	r0, r4
 80031a6:	f7ff fdcb 	bl	8002d40 <OS_SpiTransfer>
  OS_SpiDeassert(pvDevInstance);
 80031aa:	4620      	mov	r0, r4
 80031ac:	f7ff fdb4 	bl	8002d18 <OS_SpiDeassert>
  OS_SpiUnlock(ptDevice->pvOSDependent);
 80031b0:	69e0      	ldr	r0, [r4, #28]
 80031b2:	f7ff fdc0 	bl	8002d36 <OS_SpiUnlock>
}
 80031b6:	4628      	mov	r0, r5
 80031b8:	b002      	add	sp, #8
 80031ba:	bd70      	pop	{r4, r5, r6, pc}
  abSend[3] = (uint8_t)(CMD_LEN_NX51(ulLen));
 80031bc:	2300      	movs	r3, #0
 80031be:	e7df      	b.n	8003180 <Read_NX51+0x28>

080031c0 <SerialDPM_Init>:
/*! Initialize serial DPM interface
*   \param ptDevice  Device Instance
*   \return protocol type identifier                                         */
/*****************************************************************************/
int SerialDPM_Init(DEVICEINSTANCE* ptDevice)
{
 80031c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80031c2:	b087      	sub	sp, #28
 80031c4:	4604      	mov	r4, r0
  uint8_t bUnused;
  int     iSerDpmType   = SERDPM_UNKNOWN;
  int     iDummyReadCnt = 0;

  if (CIFX_NO_ERROR == OS_SpiInit(ptDevice->pvOSDependent))
 80031c6:	69c0      	ldr	r0, [r0, #28]
 80031c8:	f7ff fd9a 	bl	8002d00 <OS_SpiInit>
 80031cc:	b118      	cbz	r0, 80031d6 <SerialDPM_Init+0x16>
  int     iSerDpmType   = SERDPM_UNKNOWN;
 80031ce:	2600      	movs	r6, #0
    /* The DPM address must be zero, as we only transfer address offsets via the SPI interface. */
    ptDevice->pbDPM          = NULL;
  }

  return iSerDpmType;
}
 80031d0:	4630      	mov	r0, r6
 80031d2:	b007      	add	sp, #28
 80031d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80031d6:	4607      	mov	r7, r0
    uint32_t ulDetect  = 0;
 80031d8:	2300      	movs	r3, #0
 80031da:	9304      	str	r3, [sp, #16]
    uint8_t  abSend[]  = {CMD_READ_NX51(0xFF), 0xFF, CMD_READ_NX50(4)};
 80031dc:	4b40      	ldr	r3, [pc, #256]	; (80032e0 <SerialDPM_Init+0x120>)
 80031de:	681b      	ldr	r3, [r3, #0]
 80031e0:	f8ad 300c 	strh.w	r3, [sp, #12]
 80031e4:	0c1b      	lsrs	r3, r3, #16
 80031e6:	f88d 300e 	strb.w	r3, [sp, #14]
    OS_SpiLock(ptDevice->pvOSDependent);
 80031ea:	69e0      	ldr	r0, [r4, #28]
 80031ec:	f7ff fd9e 	bl	8002d2c <OS_SpiLock>
  int     iDummyReadCnt = 0;
 80031f0:	463d      	mov	r5, r7
 80031f2:	e009      	b.n	8003208 <SerialDPM_Init+0x48>
        iSerDpmType = SERDPM_NETX51;
 80031f4:	2603      	movs	r6, #3
 80031f6:	e000      	b.n	80031fa <SerialDPM_Init+0x3a>
        iSerDpmType = SERDPM_NETX10;
 80031f8:	2601      	movs	r6, #1
      iDummyReadCnt++;
 80031fa:	3501      	adds	r5, #1
    } while ((iDummyReadCnt < 2) && (iSerDpmType == SERDPM_UNKNOWN));
 80031fc:	fab6 f386 	clz	r3, r6
 8003200:	095b      	lsrs	r3, r3, #5
 8003202:	2d01      	cmp	r5, #1
 8003204:	dc20      	bgt.n	8003248 <SerialDPM_Init+0x88>
 8003206:	b1fb      	cbz	r3, 8003248 <SerialDPM_Init+0x88>
      OS_SpiAssert(ptDevice);
 8003208:	4620      	mov	r0, r4
 800320a:	f7ff fd7b 	bl	8002d04 <OS_SpiAssert>
      OS_SpiTransfer(ptDevice, abSend, (unsigned char*)&ulDetect, MAX_CNT(abSend));
 800320e:	2303      	movs	r3, #3
 8003210:	aa04      	add	r2, sp, #16
 8003212:	a903      	add	r1, sp, #12
 8003214:	4620      	mov	r0, r4
 8003216:	f7ff fd93 	bl	8002d40 <OS_SpiTransfer>
      OS_SpiDeassert(ptDevice);
 800321a:	4620      	mov	r0, r4
 800321c:	f7ff fd7c 	bl	8002d18 <OS_SpiDeassert>
      if (0 == ulDetect)
 8003220:	9b04      	ldr	r3, [sp, #16]
 8003222:	2b00      	cmp	r3, #0
 8003224:	d0e8      	beq.n	80031f8 <SerialDPM_Init+0x38>
      } else if (0x00FFFFFF == ulDetect)
 8003226:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 800322a:	4293      	cmp	r3, r2
 800322c:	d008      	beq.n	8003240 <SerialDPM_Init+0x80>
      } else if (0x64 == (0xFF & ulDetect))
 800322e:	b2da      	uxtb	r2, r3
 8003230:	2a64      	cmp	r2, #100	; 0x64
 8003232:	d007      	beq.n	8003244 <SerialDPM_Init+0x84>
      } else if (0x11 == (0x1F & ulDetect))
 8003234:	f003 031f 	and.w	r3, r3, #31
 8003238:	2b11      	cmp	r3, #17
 800323a:	d0db      	beq.n	80031f4 <SerialDPM_Init+0x34>
        iSerDpmType = SERDPM_UNKNOWN;
 800323c:	463e      	mov	r6, r7
 800323e:	e7dc      	b.n	80031fa <SerialDPM_Init+0x3a>
        iSerDpmType = SERDPM_NETX50;
 8003240:	2602      	movs	r6, #2
 8003242:	e7da      	b.n	80031fa <SerialDPM_Init+0x3a>
        iSerDpmType = SERDPM_NETX100;
 8003244:	2604      	movs	r6, #4
 8003246:	e7d8      	b.n	80031fa <SerialDPM_Init+0x3a>
    OS_SpiUnlock(ptDevice->pvOSDependent);
 8003248:	69e0      	ldr	r0, [r4, #28]
 800324a:	f7ff fd74 	bl	8002d36 <OS_SpiUnlock>
    switch (iSerDpmType)
 800324e:	1e73      	subs	r3, r6, #1
 8003250:	2b03      	cmp	r3, #3
 8003252:	d809      	bhi.n	8003268 <SerialDPM_Init+0xa8>
 8003254:	e8df f003 	tbb	[pc, r3]
 8003258:	022b0c13 	.word	0x022b0c13
        ptDevice->pfnHwIfRead  = Read_NX500;
 800325c:	4b21      	ldr	r3, [pc, #132]	; (80032e4 <SerialDPM_Init+0x124>)
 800325e:	f8c4 32c4 	str.w	r3, [r4, #708]	; 0x2c4
        ptDevice->pfnHwIfWrite = ReadModifyWrite_NX500;
 8003262:	4b21      	ldr	r3, [pc, #132]	; (80032e8 <SerialDPM_Init+0x128>)
 8003264:	f8c4 32c8 	str.w	r3, [r4, #712]	; 0x2c8
    ptDevice->fPCICard       = 0;
 8003268:	2300      	movs	r3, #0
 800326a:	60e3      	str	r3, [r4, #12]
    ptDevice->pbDPM          = NULL;
 800326c:	6223      	str	r3, [r4, #32]
 800326e:	e7af      	b.n	80031d0 <SerialDPM_Init+0x10>
        ptDevice->pfnHwIfRead  = Read_NX50;
 8003270:	4b1e      	ldr	r3, [pc, #120]	; (80032ec <SerialDPM_Init+0x12c>)
 8003272:	f8c4 32c4 	str.w	r3, [r4, #708]	; 0x2c4
        ptDevice->pfnHwIfWrite = Write_NX50;
 8003276:	4b1e      	ldr	r3, [pc, #120]	; (80032f0 <SerialDPM_Init+0x130>)
 8003278:	f8c4 32c8 	str.w	r3, [r4, #712]	; 0x2c8
        break;
 800327c:	e7f4      	b.n	8003268 <SerialDPM_Init+0xa8>
        ptDevice->pfnHwIfRead  = Read_NX10;
 800327e:	4b1d      	ldr	r3, [pc, #116]	; (80032f4 <SerialDPM_Init+0x134>)
 8003280:	f8c4 32c4 	str.w	r3, [r4, #708]	; 0x2c4
        ptDevice->pfnHwIfWrite = Write_NX10;
 8003284:	4b1c      	ldr	r3, [pc, #112]	; (80032f8 <SerialDPM_Init+0x138>)
 8003286:	f8c4 32c8 	str.w	r3, [r4, #712]	; 0x2c8
        (void) Read_NX10(0, ptDevice, 0, &bUnused, 1);
 800328a:	2501      	movs	r5, #1
 800328c:	9500      	str	r5, [sp, #0]
 800328e:	f10d 0317 	add.w	r3, sp, #23
 8003292:	2200      	movs	r2, #0
 8003294:	4621      	mov	r1, r4
 8003296:	4610      	mov	r0, r2
 8003298:	f7ff ff2f 	bl	80030fa <Read_NX10>
        (void) Read_NX10(0, ptDevice, 0, &bUnused, 1);
 800329c:	9500      	str	r5, [sp, #0]
 800329e:	f10d 0317 	add.w	r3, sp, #23
 80032a2:	2200      	movs	r2, #0
 80032a4:	4621      	mov	r1, r4
 80032a6:	4610      	mov	r0, r2
 80032a8:	f7ff ff27 	bl	80030fa <Read_NX10>
        break;
 80032ac:	e7dc      	b.n	8003268 <SerialDPM_Init+0xa8>
        ptDevice->pfnHwIfRead  = Read_NX51;
 80032ae:	4b13      	ldr	r3, [pc, #76]	; (80032fc <SerialDPM_Init+0x13c>)
 80032b0:	f8c4 32c4 	str.w	r3, [r4, #708]	; 0x2c4
        ptDevice->pfnHwIfWrite = Write_NX51;
 80032b4:	4b12      	ldr	r3, [pc, #72]	; (8003300 <SerialDPM_Init+0x140>)
 80032b6:	f8c4 32c8 	str.w	r3, [r4, #712]	; 0x2c8
        (void) Read_NX51(0, ptDevice, 0, &bUnused, 1);
 80032ba:	2501      	movs	r5, #1
 80032bc:	9500      	str	r5, [sp, #0]
 80032be:	f10d 0317 	add.w	r3, sp, #23
 80032c2:	2200      	movs	r2, #0
 80032c4:	4621      	mov	r1, r4
 80032c6:	4610      	mov	r0, r2
 80032c8:	f7ff ff46 	bl	8003158 <Read_NX51>
        (void) Read_NX51(0, ptDevice, 0, &bUnused, 1);
 80032cc:	9500      	str	r5, [sp, #0]
 80032ce:	f10d 0317 	add.w	r3, sp, #23
 80032d2:	2200      	movs	r2, #0
 80032d4:	4621      	mov	r1, r4
 80032d6:	4610      	mov	r0, r2
 80032d8:	f7ff ff3e 	bl	8003158 <Read_NX51>
        break;
 80032dc:	e7c4      	b.n	8003268 <SerialDPM_Init+0xa8>
 80032de:	bf00      	nop
 80032e0:	0800a810 	.word	0x0800a810
 80032e4:	08003021 	.word	0x08003021
 80032e8:	08002f55 	.word	0x08002f55
 80032ec:	08002ea1 	.word	0x08002ea1
 80032f0:	08002e35 	.word	0x08002e35
 80032f4:	080030fb 	.word	0x080030fb
 80032f8:	08002dd9 	.word	0x08002dd9
 80032fc:	08003159 	.word	0x08003159
 8003300:	08002d85 	.word	0x08002d85

08003304 <CreateCRC32>:
*   \param ulLength Buffer length
*   \return CRC32 value                                                      */
/*****************************************************************************/
uint32_t CreateCRC32(uint32_t ulCRC, uint8_t* pabBuffer, uint32_t ulLength)
{
  if( (0 == pabBuffer) || (0 == ulLength) ) return ulCRC;
 8003304:	2a00      	cmp	r2, #0
 8003306:	bf18      	it	ne
 8003308:	2900      	cmpne	r1, #0
 800330a:	d014      	beq.n	8003336 <CreateCRC32+0x32>
{
 800330c:	b410      	push	{r4}
 800330e:	460b      	mov	r3, r1
 8003310:	4614      	mov	r4, r2
  ulCRC = ulCRC ^ 0xffffffff;
 8003312:	43c0      	mvns	r0, r0
  for(;ulLength > 0; --ulLength)
 8003314:	e009      	b.n	800332a <CreateCRC32+0x26>
  {
    ulCRC = (Crc32Table[((ulCRC) ^ (*(pabBuffer++)) ) & 0xff] ^ ((ulCRC) >> 8));
 8003316:	f813 2b01 	ldrb.w	r2, [r3], #1
 800331a:	4042      	eors	r2, r0
 800331c:	b2d2      	uxtb	r2, r2
 800331e:	4906      	ldr	r1, [pc, #24]	; (8003338 <CreateCRC32+0x34>)
 8003320:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 8003324:	ea82 2010 	eor.w	r0, r2, r0, lsr #8
  for(;ulLength > 0; --ulLength)
 8003328:	3c01      	subs	r4, #1
 800332a:	2c00      	cmp	r4, #0
 800332c:	d1f3      	bne.n	8003316 <CreateCRC32+0x12>
  }
  return ulCRC ^ 0xffffffff;
 800332e:	43c0      	mvns	r0, r0
 8003330:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003334:	4770      	bx	lr
 8003336:	4770      	bx	lr
 8003338:	0800a814 	.word	0x0800a814

0800333c <md5_memcpy>:
#  define BYTE_ORDER 0
#endif

static void* md5_memcpy(void* pvDest, const void* pvSrc, long iSize)
{
  char* pcDest=(char*)pvDest;
 800333c:	4603      	mov	r3, r0
  const char* pcSrc=(const char*)pvSrc;
  while(iSize-->0)
 800333e:	e004      	b.n	800334a <md5_memcpy+0xe>
  {
    *(pcDest++)=*(pcSrc)++;
 8003340:	f811 2b01 	ldrb.w	r2, [r1], #1
 8003344:	f803 2b01 	strb.w	r2, [r3], #1
  while(iSize-->0)
 8003348:	4662      	mov	r2, ip
 800334a:	f102 3cff 	add.w	ip, r2, #4294967295
 800334e:	2a00      	cmp	r2, #0
 8003350:	dcf6      	bgt.n	8003340 <md5_memcpy+0x4>
  }
  return pvDest;
}
 8003352:	4770      	bx	lr

08003354 <md5_process>:
#define T64 /* 0xeb86d391 */ (T_MASK ^ 0x14792c6e)


static void
md5_process(md5_state_t *pms, const md5_byte_t *data /*[64]*/)
{
 8003354:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003358:	b09b      	sub	sp, #108	; 0x6c
 800335a:	4604      	mov	r4, r0
    md5_word_t
  a = pms->abcd[0], b = pms->abcd[1],
 800335c:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8003360:	68c5      	ldr	r5, [r0, #12]
  c = pms->abcd[2], d = pms->abcd[3];
 8003362:	6907      	ldr	r7, [r0, #16]
 8003364:	6946      	ldr	r6, [r0, #20]
  {
      /*
       * On little-endian machines, we can process properly aligned
       * data without copying it.
       */
      if (!((data - /*lint -e413*/ (const md5_byte_t *)0) & 3)) {
 8003366:	f011 0f03 	tst.w	r1, #3
 800336a:	f040 8326 	bne.w	80039ba <md5_process+0x666>
#define F(x, y, z) (((x) & (y)) | (~(x) & (z)))
#define SET(a, b, c, d, k, s, Ti)\
  t = a + F(b,c,d) + X[k] + Ti;\
  a = ROTATE_LEFT(t, s) + b
    /* Do the following 16 operations. */
    SET(a, b, c, d,  0,  7,  T1);
 800336e:	ea87 0306 	eor.w	r3, r7, r6
 8003372:	402b      	ands	r3, r5
 8003374:	4073      	eors	r3, r6
 8003376:	4443      	add	r3, r8
 8003378:	f8d1 9000 	ldr.w	r9, [r1]
 800337c:	444b      	add	r3, r9
 800337e:	4add      	ldr	r2, [pc, #884]	; (80036f4 <md5_process+0x3a0>)
 8003380:	441a      	add	r2, r3
 8003382:	eb05 6272 	add.w	r2, r5, r2, ror #25
    SET(d, a, b, c,  1, 12,  T2);
 8003386:	ea85 0007 	eor.w	r0, r5, r7
 800338a:	4010      	ands	r0, r2
 800338c:	4078      	eors	r0, r7
 800338e:	4430      	add	r0, r6
 8003390:	684b      	ldr	r3, [r1, #4]
 8003392:	9301      	str	r3, [sp, #4]
 8003394:	4418      	add	r0, r3
 8003396:	4bd8      	ldr	r3, [pc, #864]	; (80036f8 <md5_process+0x3a4>)
 8003398:	4403      	add	r3, r0
 800339a:	eb02 5333 	add.w	r3, r2, r3, ror #20
    SET(c, d, a, b,  2, 17,  T3);
 800339e:	ea85 0602 	eor.w	r6, r5, r2
 80033a2:	401e      	ands	r6, r3
 80033a4:	406e      	eors	r6, r5
 80033a6:	443e      	add	r6, r7
 80033a8:	6888      	ldr	r0, [r1, #8]
 80033aa:	9002      	str	r0, [sp, #8]
 80033ac:	4406      	add	r6, r0
 80033ae:	48d3      	ldr	r0, [pc, #844]	; (80036fc <md5_process+0x3a8>)
 80033b0:	4430      	add	r0, r6
 80033b2:	eb03 30f0 	add.w	r0, r3, r0, ror #15
    SET(b, c, d, a,  3, 22,  T4);
 80033b6:	ea82 0603 	eor.w	r6, r2, r3
 80033ba:	4006      	ands	r6, r0
 80033bc:	4056      	eors	r6, r2
 80033be:	442e      	add	r6, r5
 80033c0:	68cd      	ldr	r5, [r1, #12]
 80033c2:	9509      	str	r5, [sp, #36]	; 0x24
 80033c4:	442e      	add	r6, r5
 80033c6:	4dce      	ldr	r5, [pc, #824]	; (8003700 <md5_process+0x3ac>)
 80033c8:	4435      	add	r5, r6
 80033ca:	eb00 25b5 	add.w	r5, r0, r5, ror #10
    SET(a, b, c, d,  4,  7,  T5);
 80033ce:	ea83 0600 	eor.w	r6, r3, r0
 80033d2:	402e      	ands	r6, r5
 80033d4:	405e      	eors	r6, r3
 80033d6:	4416      	add	r6, r2
 80033d8:	690f      	ldr	r7, [r1, #16]
 80033da:	9703      	str	r7, [sp, #12]
 80033dc:	443e      	add	r6, r7
 80033de:	4ac9      	ldr	r2, [pc, #804]	; (8003704 <md5_process+0x3b0>)
 80033e0:	4432      	add	r2, r6
 80033e2:	eb05 6272 	add.w	r2, r5, r2, ror #25
    SET(d, a, b, c,  5, 12,  T6);
 80033e6:	ea80 0605 	eor.w	r6, r0, r5
 80033ea:	4016      	ands	r6, r2
 80033ec:	4046      	eors	r6, r0
 80033ee:	441e      	add	r6, r3
 80033f0:	f8d1 c014 	ldr.w	ip, [r1, #20]
 80033f4:	4466      	add	r6, ip
 80033f6:	4bc4      	ldr	r3, [pc, #784]	; (8003708 <md5_process+0x3b4>)
 80033f8:	4433      	add	r3, r6
 80033fa:	eb02 5333 	add.w	r3, r2, r3, ror #20
    SET(c, d, a, b,  6, 17,  T7);
 80033fe:	ea85 0602 	eor.w	r6, r5, r2
 8003402:	401e      	ands	r6, r3
 8003404:	406e      	eors	r6, r5
 8003406:	4406      	add	r6, r0
 8003408:	698f      	ldr	r7, [r1, #24]
 800340a:	9704      	str	r7, [sp, #16]
 800340c:	443e      	add	r6, r7
 800340e:	48bf      	ldr	r0, [pc, #764]	; (800370c <md5_process+0x3b8>)
 8003410:	4430      	add	r0, r6
 8003412:	eb03 30f0 	add.w	r0, r3, r0, ror #15
    SET(b, c, d, a,  7, 22,  T8);
 8003416:	ea82 0603 	eor.w	r6, r2, r3
 800341a:	4006      	ands	r6, r0
 800341c:	4056      	eors	r6, r2
 800341e:	442e      	add	r6, r5
 8003420:	f8d1 801c 	ldr.w	r8, [r1, #28]
 8003424:	4446      	add	r6, r8
 8003426:	4dba      	ldr	r5, [pc, #744]	; (8003710 <md5_process+0x3bc>)
 8003428:	4435      	add	r5, r6
 800342a:	eb00 25b5 	add.w	r5, r0, r5, ror #10
    SET(a, b, c, d,  8,  7,  T9);
 800342e:	ea83 0600 	eor.w	r6, r3, r0
 8003432:	402e      	ands	r6, r5
 8003434:	405e      	eors	r6, r3
 8003436:	4416      	add	r6, r2
 8003438:	6a0a      	ldr	r2, [r1, #32]
 800343a:	9205      	str	r2, [sp, #20]
 800343c:	4416      	add	r6, r2
 800343e:	4ab5      	ldr	r2, [pc, #724]	; (8003714 <md5_process+0x3c0>)
 8003440:	4432      	add	r2, r6
 8003442:	eb05 6272 	add.w	r2, r5, r2, ror #25
    SET(d, a, b, c,  9, 12, T10);
 8003446:	ea80 0605 	eor.w	r6, r0, r5
 800344a:	4016      	ands	r6, r2
 800344c:	4046      	eors	r6, r0
 800344e:	441e      	add	r6, r3
 8003450:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8003452:	9306      	str	r3, [sp, #24]
 8003454:	441e      	add	r6, r3
 8003456:	4bb0      	ldr	r3, [pc, #704]	; (8003718 <md5_process+0x3c4>)
 8003458:	4433      	add	r3, r6
 800345a:	eb02 5333 	add.w	r3, r2, r3, ror #20
    SET(c, d, a, b, 10, 17, T11);
 800345e:	ea85 0602 	eor.w	r6, r5, r2
 8003462:	401e      	ands	r6, r3
 8003464:	406e      	eors	r6, r5
 8003466:	4406      	add	r6, r0
 8003468:	6a88      	ldr	r0, [r1, #40]	; 0x28
 800346a:	9007      	str	r0, [sp, #28]
 800346c:	4406      	add	r6, r0
 800346e:	48ab      	ldr	r0, [pc, #684]	; (800371c <md5_process+0x3c8>)
 8003470:	4430      	add	r0, r6
 8003472:	eb03 30f0 	add.w	r0, r3, r0, ror #15
    SET(b, c, d, a, 11, 22, T12);
 8003476:	ea82 0603 	eor.w	r6, r2, r3
 800347a:	4006      	ands	r6, r0
 800347c:	4056      	eors	r6, r2
 800347e:	442e      	add	r6, r5
 8003480:	6acd      	ldr	r5, [r1, #44]	; 0x2c
 8003482:	442e      	add	r6, r5
 8003484:	4fa6      	ldr	r7, [pc, #664]	; (8003720 <md5_process+0x3cc>)
 8003486:	4437      	add	r7, r6
 8003488:	eb00 2ab7 	add.w	sl, r0, r7, ror #10
    SET(a, b, c, d, 12,  7, T13);
 800348c:	ea83 0600 	eor.w	r6, r3, r0
 8003490:	ea06 060a 	and.w	r6, r6, sl
 8003494:	405e      	eors	r6, r3
 8003496:	4416      	add	r6, r2
 8003498:	6b0f      	ldr	r7, [r1, #48]	; 0x30
 800349a:	443e      	add	r6, r7
 800349c:	4aa1      	ldr	r2, [pc, #644]	; (8003724 <md5_process+0x3d0>)
 800349e:	4432      	add	r2, r6
 80034a0:	eb0a 6272 	add.w	r2, sl, r2, ror #25
    SET(d, a, b, c, 13, 12, T14);
 80034a4:	ea80 0e0a 	eor.w	lr, r0, sl
 80034a8:	ea0e 0e02 	and.w	lr, lr, r2
 80034ac:	ea8e 0e00 	eor.w	lr, lr, r0
 80034b0:	449e      	add	lr, r3
 80034b2:	6b4e      	ldr	r6, [r1, #52]	; 0x34
 80034b4:	9608      	str	r6, [sp, #32]
 80034b6:	44b6      	add	lr, r6
 80034b8:	4b9b      	ldr	r3, [pc, #620]	; (8003728 <md5_process+0x3d4>)
 80034ba:	4473      	add	r3, lr
 80034bc:	eb02 5333 	add.w	r3, r2, r3, ror #20
    SET(c, d, a, b, 14, 17, T15);
 80034c0:	ea8a 0b02 	eor.w	fp, sl, r2
 80034c4:	ea0b 0b03 	and.w	fp, fp, r3
 80034c8:	ea8b 0b0a 	eor.w	fp, fp, sl
 80034cc:	4483      	add	fp, r0
 80034ce:	f8d1 e038 	ldr.w	lr, [r1, #56]	; 0x38
 80034d2:	44f3      	add	fp, lr
 80034d4:	4895      	ldr	r0, [pc, #596]	; (800372c <md5_process+0x3d8>)
 80034d6:	4458      	add	r0, fp
 80034d8:	eb03 30f0 	add.w	r0, r3, r0, ror #15
    SET(b, c, d, a, 15, 22, T16);
 80034dc:	ea82 0b03 	eor.w	fp, r2, r3
 80034e0:	ea0b 0b00 	and.w	fp, fp, r0
 80034e4:	ea8b 0b02 	eor.w	fp, fp, r2
 80034e8:	44d3      	add	fp, sl
 80034ea:	f8d1 a03c 	ldr.w	sl, [r1, #60]	; 0x3c
 80034ee:	44d3      	add	fp, sl
 80034f0:	498f      	ldr	r1, [pc, #572]	; (8003730 <md5_process+0x3dc>)
 80034f2:	4459      	add	r1, fp
 80034f4:	eb00 21b1 	add.w	r1, r0, r1, ror #10
#define G(x, y, z) (((x) & (z)) | ((y) & ~(z)))
#define SET(a, b, c, d, k, s, Ti)\
  t = a + G(b,c,d) + X[k] + Ti;\
  a = ROTATE_LEFT(t, s) + b
     /* Do the following 16 operations. */
    SET(a, b, c, d,  1,  5, T17);
 80034f8:	ea80 0b01 	eor.w	fp, r0, r1
 80034fc:	ea0b 0b03 	and.w	fp, fp, r3
 8003500:	ea8b 0b00 	eor.w	fp, fp, r0
 8003504:	4493      	add	fp, r2
 8003506:	9a01      	ldr	r2, [sp, #4]
 8003508:	4493      	add	fp, r2
 800350a:	4a8a      	ldr	r2, [pc, #552]	; (8003734 <md5_process+0x3e0>)
 800350c:	445a      	add	r2, fp
 800350e:	eb01 62f2 	add.w	r2, r1, r2, ror #27
    SET(d, a, b, c,  6,  9, T18);
 8003512:	ea81 0b02 	eor.w	fp, r1, r2
 8003516:	ea0b 0b00 	and.w	fp, fp, r0
 800351a:	ea8b 0b01 	eor.w	fp, fp, r1
 800351e:	449b      	add	fp, r3
 8003520:	9e04      	ldr	r6, [sp, #16]
 8003522:	44b3      	add	fp, r6
 8003524:	4b84      	ldr	r3, [pc, #528]	; (8003738 <md5_process+0x3e4>)
 8003526:	445b      	add	r3, fp
 8003528:	eb02 53f3 	add.w	r3, r2, r3, ror #23
    SET(c, d, a, b, 11, 14, T19);
 800352c:	ea82 0b03 	eor.w	fp, r2, r3
 8003530:	ea0b 0b01 	and.w	fp, fp, r1
 8003534:	ea8b 0b02 	eor.w	fp, fp, r2
 8003538:	4483      	add	fp, r0
 800353a:	44ab      	add	fp, r5
 800353c:	487f      	ldr	r0, [pc, #508]	; (800373c <md5_process+0x3e8>)
 800353e:	4458      	add	r0, fp
 8003540:	eb03 40b0 	add.w	r0, r3, r0, ror #18
    SET(b, c, d, a,  0, 20, T20);
 8003544:	ea83 0b00 	eor.w	fp, r3, r0
 8003548:	ea0b 0b02 	and.w	fp, fp, r2
 800354c:	ea8b 0b03 	eor.w	fp, fp, r3
 8003550:	448b      	add	fp, r1
 8003552:	44cb      	add	fp, r9
 8003554:	497a      	ldr	r1, [pc, #488]	; (8003740 <md5_process+0x3ec>)
 8003556:	4459      	add	r1, fp
 8003558:	eb00 3131 	add.w	r1, r0, r1, ror #12
    SET(a, b, c, d,  5,  5, T21);
 800355c:	ea80 0b01 	eor.w	fp, r0, r1
 8003560:	ea0b 0b03 	and.w	fp, fp, r3
 8003564:	ea8b 0b00 	eor.w	fp, fp, r0
 8003568:	4493      	add	fp, r2
 800356a:	44e3      	add	fp, ip
 800356c:	4a75      	ldr	r2, [pc, #468]	; (8003744 <md5_process+0x3f0>)
 800356e:	445a      	add	r2, fp
 8003570:	eb01 62f2 	add.w	r2, r1, r2, ror #27
    SET(d, a, b, c, 10,  9, T22);
 8003574:	ea81 0b02 	eor.w	fp, r1, r2
 8003578:	ea0b 0b00 	and.w	fp, fp, r0
 800357c:	ea8b 0b01 	eor.w	fp, fp, r1
 8003580:	449b      	add	fp, r3
 8003582:	9e07      	ldr	r6, [sp, #28]
 8003584:	44b3      	add	fp, r6
 8003586:	4b70      	ldr	r3, [pc, #448]	; (8003748 <md5_process+0x3f4>)
 8003588:	445b      	add	r3, fp
 800358a:	eb02 53f3 	add.w	r3, r2, r3, ror #23
    SET(c, d, a, b, 15, 14, T23);
 800358e:	ea82 0b03 	eor.w	fp, r2, r3
 8003592:	ea0b 0b01 	and.w	fp, fp, r1
 8003596:	ea8b 0b02 	eor.w	fp, fp, r2
 800359a:	4483      	add	fp, r0
 800359c:	44d3      	add	fp, sl
 800359e:	486b      	ldr	r0, [pc, #428]	; (800374c <md5_process+0x3f8>)
 80035a0:	4458      	add	r0, fp
 80035a2:	eb03 40b0 	add.w	r0, r3, r0, ror #18
    SET(b, c, d, a,  4, 20, T24);
 80035a6:	ea83 0b00 	eor.w	fp, r3, r0
 80035aa:	ea0b 0b02 	and.w	fp, fp, r2
 80035ae:	ea8b 0b03 	eor.w	fp, fp, r3
 80035b2:	448b      	add	fp, r1
 80035b4:	9e03      	ldr	r6, [sp, #12]
 80035b6:	44b3      	add	fp, r6
 80035b8:	4965      	ldr	r1, [pc, #404]	; (8003750 <md5_process+0x3fc>)
 80035ba:	4459      	add	r1, fp
 80035bc:	eb00 3131 	add.w	r1, r0, r1, ror #12
    SET(a, b, c, d,  9,  5, T25);
 80035c0:	ea80 0b01 	eor.w	fp, r0, r1
 80035c4:	ea0b 0b03 	and.w	fp, fp, r3
 80035c8:	ea8b 0b00 	eor.w	fp, fp, r0
 80035cc:	4493      	add	fp, r2
 80035ce:	9e06      	ldr	r6, [sp, #24]
 80035d0:	44b3      	add	fp, r6
 80035d2:	4a60      	ldr	r2, [pc, #384]	; (8003754 <md5_process+0x400>)
 80035d4:	445a      	add	r2, fp
 80035d6:	eb01 62f2 	add.w	r2, r1, r2, ror #27
    SET(d, a, b, c, 14,  9, T26);
 80035da:	ea81 0b02 	eor.w	fp, r1, r2
 80035de:	ea0b 0b00 	and.w	fp, fp, r0
 80035e2:	ea8b 0b01 	eor.w	fp, fp, r1
 80035e6:	449b      	add	fp, r3
 80035e8:	44f3      	add	fp, lr
 80035ea:	4b5b      	ldr	r3, [pc, #364]	; (8003758 <md5_process+0x404>)
 80035ec:	445b      	add	r3, fp
 80035ee:	eb02 53f3 	add.w	r3, r2, r3, ror #23
    SET(c, d, a, b,  3, 14, T27);
 80035f2:	ea82 0b03 	eor.w	fp, r2, r3
 80035f6:	ea0b 0b01 	and.w	fp, fp, r1
 80035fa:	ea8b 0b02 	eor.w	fp, fp, r2
 80035fe:	4483      	add	fp, r0
 8003600:	9809      	ldr	r0, [sp, #36]	; 0x24
 8003602:	4483      	add	fp, r0
 8003604:	4855      	ldr	r0, [pc, #340]	; (800375c <md5_process+0x408>)
 8003606:	4458      	add	r0, fp
 8003608:	eb03 40b0 	add.w	r0, r3, r0, ror #18
    SET(b, c, d, a,  8, 20, T28);
 800360c:	ea83 0b00 	eor.w	fp, r3, r0
 8003610:	ea0b 0b02 	and.w	fp, fp, r2
 8003614:	ea8b 0b03 	eor.w	fp, fp, r3
 8003618:	448b      	add	fp, r1
 800361a:	9e05      	ldr	r6, [sp, #20]
 800361c:	44b3      	add	fp, r6
 800361e:	4950      	ldr	r1, [pc, #320]	; (8003760 <md5_process+0x40c>)
 8003620:	4459      	add	r1, fp
 8003622:	eb00 3131 	add.w	r1, r0, r1, ror #12
    SET(a, b, c, d, 13,  5, T29);
 8003626:	ea80 0b01 	eor.w	fp, r0, r1
 800362a:	ea0b 0b03 	and.w	fp, fp, r3
 800362e:	ea8b 0b00 	eor.w	fp, fp, r0
 8003632:	4493      	add	fp, r2
 8003634:	9a08      	ldr	r2, [sp, #32]
 8003636:	4493      	add	fp, r2
 8003638:	4a4a      	ldr	r2, [pc, #296]	; (8003764 <md5_process+0x410>)
 800363a:	445a      	add	r2, fp
 800363c:	eb01 62f2 	add.w	r2, r1, r2, ror #27
    SET(d, a, b, c,  2,  9, T30);
 8003640:	ea81 0b02 	eor.w	fp, r1, r2
 8003644:	ea0b 0b00 	and.w	fp, fp, r0
 8003648:	ea8b 0b01 	eor.w	fp, fp, r1
 800364c:	449b      	add	fp, r3
 800364e:	9b02      	ldr	r3, [sp, #8]
 8003650:	449b      	add	fp, r3
 8003652:	4b45      	ldr	r3, [pc, #276]	; (8003768 <md5_process+0x414>)
 8003654:	445b      	add	r3, fp
 8003656:	eb02 53f3 	add.w	r3, r2, r3, ror #23
    SET(c, d, a, b,  7, 14, T31);
 800365a:	ea82 0b03 	eor.w	fp, r2, r3
 800365e:	ea0b 0b01 	and.w	fp, fp, r1
 8003662:	ea8b 0b02 	eor.w	fp, fp, r2
 8003666:	4483      	add	fp, r0
 8003668:	44c3      	add	fp, r8
 800366a:	4840      	ldr	r0, [pc, #256]	; (800376c <md5_process+0x418>)
 800366c:	4458      	add	r0, fp
 800366e:	eb03 40b0 	add.w	r0, r3, r0, ror #18
    SET(b, c, d, a, 12, 20, T32);
 8003672:	ea83 0b00 	eor.w	fp, r3, r0
 8003676:	ea0b 0b02 	and.w	fp, fp, r2
 800367a:	ea8b 0b03 	eor.w	fp, fp, r3
 800367e:	448b      	add	fp, r1
 8003680:	44bb      	add	fp, r7
 8003682:	493b      	ldr	r1, [pc, #236]	; (8003770 <md5_process+0x41c>)
 8003684:	4459      	add	r1, fp
 8003686:	eb00 3131 	add.w	r1, r0, r1, ror #12
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define SET(a, b, c, d, k, s, Ti)\
  t = a + H(b,c,d) + X[k] + Ti;\
  a = ROTATE_LEFT(t, s) + b
     /* Do the following 16 operations. */
    SET(a, b, c, d,  5,  4, T33);
 800368a:	ea80 0b01 	eor.w	fp, r0, r1
 800368e:	ea8b 0b03 	eor.w	fp, fp, r3
 8003692:	4493      	add	fp, r2
 8003694:	44e3      	add	fp, ip
 8003696:	4a37      	ldr	r2, [pc, #220]	; (8003774 <md5_process+0x420>)
 8003698:	445a      	add	r2, fp
 800369a:	eb01 7232 	add.w	r2, r1, r2, ror #28
    SET(d, a, b, c,  8, 11, T34);
 800369e:	ea81 0b02 	eor.w	fp, r1, r2
 80036a2:	ea8b 0b00 	eor.w	fp, fp, r0
 80036a6:	445b      	add	r3, fp
 80036a8:	4433      	add	r3, r6
 80036aa:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 8003784 <md5_process+0x430>
 80036ae:	449b      	add	fp, r3
 80036b0:	eb02 5b7b 	add.w	fp, r2, fp, ror #21
    SET(c, d, a, b, 11, 16, T35);
 80036b4:	ea82 030b 	eor.w	r3, r2, fp
 80036b8:	404b      	eors	r3, r1
 80036ba:	4403      	add	r3, r0
 80036bc:	442b      	add	r3, r5
 80036be:	482e      	ldr	r0, [pc, #184]	; (8003778 <md5_process+0x424>)
 80036c0:	4418      	add	r0, r3
 80036c2:	eb0b 4030 	add.w	r0, fp, r0, ror #16
    SET(b, c, d, a, 14, 23, T36);
 80036c6:	ea8b 0300 	eor.w	r3, fp, r0
 80036ca:	4053      	eors	r3, r2
 80036cc:	4419      	add	r1, r3
 80036ce:	4471      	add	r1, lr
 80036d0:	4b2a      	ldr	r3, [pc, #168]	; (800377c <md5_process+0x428>)
 80036d2:	440b      	add	r3, r1
 80036d4:	eb00 2373 	add.w	r3, r0, r3, ror #9
    SET(a, b, c, d,  1,  4, T37);
 80036d8:	ea80 0103 	eor.w	r1, r0, r3
 80036dc:	ea81 010b 	eor.w	r1, r1, fp
 80036e0:	440a      	add	r2, r1
 80036e2:	9901      	ldr	r1, [sp, #4]
 80036e4:	440a      	add	r2, r1
 80036e6:	4926      	ldr	r1, [pc, #152]	; (8003780 <md5_process+0x42c>)
 80036e8:	4411      	add	r1, r2
 80036ea:	eb03 7131 	add.w	r1, r3, r1, ror #28
    SET(d, a, b, c,  4, 11, T38);
 80036ee:	ea83 0201 	eor.w	r2, r3, r1
 80036f2:	e049      	b.n	8003788 <md5_process+0x434>
 80036f4:	d76aa478 	.word	0xd76aa478
 80036f8:	e8c7b756 	.word	0xe8c7b756
 80036fc:	242070db 	.word	0x242070db
 8003700:	c1bdceee 	.word	0xc1bdceee
 8003704:	f57c0faf 	.word	0xf57c0faf
 8003708:	4787c62a 	.word	0x4787c62a
 800370c:	a8304613 	.word	0xa8304613
 8003710:	fd469501 	.word	0xfd469501
 8003714:	698098d8 	.word	0x698098d8
 8003718:	8b44f7af 	.word	0x8b44f7af
 800371c:	ffff5bb1 	.word	0xffff5bb1
 8003720:	895cd7be 	.word	0x895cd7be
 8003724:	6b901122 	.word	0x6b901122
 8003728:	fd987193 	.word	0xfd987193
 800372c:	a679438e 	.word	0xa679438e
 8003730:	49b40821 	.word	0x49b40821
 8003734:	f61e2562 	.word	0xf61e2562
 8003738:	c040b340 	.word	0xc040b340
 800373c:	265e5a51 	.word	0x265e5a51
 8003740:	e9b6c7aa 	.word	0xe9b6c7aa
 8003744:	d62f105d 	.word	0xd62f105d
 8003748:	02441453 	.word	0x02441453
 800374c:	d8a1e681 	.word	0xd8a1e681
 8003750:	e7d3fbc8 	.word	0xe7d3fbc8
 8003754:	21e1cde6 	.word	0x21e1cde6
 8003758:	c33707d6 	.word	0xc33707d6
 800375c:	f4d50d87 	.word	0xf4d50d87
 8003760:	455a14ed 	.word	0x455a14ed
 8003764:	a9e3e905 	.word	0xa9e3e905
 8003768:	fcefa3f8 	.word	0xfcefa3f8
 800376c:	676f02d9 	.word	0x676f02d9
 8003770:	8d2a4c8a 	.word	0x8d2a4c8a
 8003774:	fffa3942 	.word	0xfffa3942
 8003778:	6d9d6122 	.word	0x6d9d6122
 800377c:	fde5380c 	.word	0xfde5380c
 8003780:	a4beea44 	.word	0xa4beea44
 8003784:	8771f681 	.word	0x8771f681
 8003788:	4042      	eors	r2, r0
 800378a:	445a      	add	r2, fp
 800378c:	9e03      	ldr	r6, [sp, #12]
 800378e:	4432      	add	r2, r6
 8003790:	f8df b294 	ldr.w	fp, [pc, #660]	; 8003a28 <md5_process+0x6d4>
 8003794:	4493      	add	fp, r2
 8003796:	eb01 5b7b 	add.w	fp, r1, fp, ror #21
    SET(c, d, a, b,  7, 16, T39);
 800379a:	ea81 020b 	eor.w	r2, r1, fp
 800379e:	405a      	eors	r2, r3
 80037a0:	4410      	add	r0, r2
 80037a2:	4440      	add	r0, r8
 80037a4:	4a88      	ldr	r2, [pc, #544]	; (80039c8 <md5_process+0x674>)
 80037a6:	4402      	add	r2, r0
 80037a8:	eb0b 4232 	add.w	r2, fp, r2, ror #16
    SET(b, c, d, a, 10, 23, T40);
 80037ac:	ea8b 0002 	eor.w	r0, fp, r2
 80037b0:	4048      	eors	r0, r1
 80037b2:	4403      	add	r3, r0
 80037b4:	9807      	ldr	r0, [sp, #28]
 80037b6:	4403      	add	r3, r0
 80037b8:	4884      	ldr	r0, [pc, #528]	; (80039cc <md5_process+0x678>)
 80037ba:	4418      	add	r0, r3
 80037bc:	eb02 2070 	add.w	r0, r2, r0, ror #9
    SET(a, b, c, d, 13,  4, T41);
 80037c0:	ea82 0300 	eor.w	r3, r2, r0
 80037c4:	ea83 030b 	eor.w	r3, r3, fp
 80037c8:	440b      	add	r3, r1
 80037ca:	9e08      	ldr	r6, [sp, #32]
 80037cc:	4433      	add	r3, r6
 80037ce:	4980      	ldr	r1, [pc, #512]	; (80039d0 <md5_process+0x67c>)
 80037d0:	4419      	add	r1, r3
 80037d2:	eb00 7131 	add.w	r1, r0, r1, ror #28
    SET(d, a, b, c,  0, 11, T42);
 80037d6:	ea80 0301 	eor.w	r3, r0, r1
 80037da:	4053      	eors	r3, r2
 80037dc:	449b      	add	fp, r3
 80037de:	44cb      	add	fp, r9
 80037e0:	4b7c      	ldr	r3, [pc, #496]	; (80039d4 <md5_process+0x680>)
 80037e2:	445b      	add	r3, fp
 80037e4:	eb01 5373 	add.w	r3, r1, r3, ror #21
    SET(c, d, a, b,  3, 16, T43);
 80037e8:	ea81 0b03 	eor.w	fp, r1, r3
 80037ec:	ea8b 0b00 	eor.w	fp, fp, r0
 80037f0:	445a      	add	r2, fp
 80037f2:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80037f4:	4432      	add	r2, r6
 80037f6:	f8df b234 	ldr.w	fp, [pc, #564]	; 8003a2c <md5_process+0x6d8>
 80037fa:	4493      	add	fp, r2
 80037fc:	eb03 4b3b 	add.w	fp, r3, fp, ror #16
    SET(b, c, d, a,  6, 23, T44);
 8003800:	ea83 020b 	eor.w	r2, r3, fp
 8003804:	404a      	eors	r2, r1
 8003806:	4402      	add	r2, r0
 8003808:	9804      	ldr	r0, [sp, #16]
 800380a:	4402      	add	r2, r0
 800380c:	4872      	ldr	r0, [pc, #456]	; (80039d8 <md5_process+0x684>)
 800380e:	4410      	add	r0, r2
 8003810:	eb0b 2070 	add.w	r0, fp, r0, ror #9
    SET(a, b, c, d,  9,  4, T45);
 8003814:	ea8b 0200 	eor.w	r2, fp, r0
 8003818:	405a      	eors	r2, r3
 800381a:	4411      	add	r1, r2
 800381c:	9a06      	ldr	r2, [sp, #24]
 800381e:	4411      	add	r1, r2
 8003820:	4a6e      	ldr	r2, [pc, #440]	; (80039dc <md5_process+0x688>)
 8003822:	440a      	add	r2, r1
 8003824:	eb00 7232 	add.w	r2, r0, r2, ror #28
    SET(d, a, b, c, 12, 11, T46);
 8003828:	ea80 0102 	eor.w	r1, r0, r2
 800382c:	ea81 010b 	eor.w	r1, r1, fp
 8003830:	440b      	add	r3, r1
 8003832:	443b      	add	r3, r7
 8003834:	496a      	ldr	r1, [pc, #424]	; (80039e0 <md5_process+0x68c>)
 8003836:	4419      	add	r1, r3
 8003838:	eb02 5171 	add.w	r1, r2, r1, ror #21
    SET(c, d, a, b, 15, 16, T47);
 800383c:	ea82 0301 	eor.w	r3, r2, r1
 8003840:	4043      	eors	r3, r0
 8003842:	445b      	add	r3, fp
 8003844:	4453      	add	r3, sl
 8003846:	f8df b1e8 	ldr.w	fp, [pc, #488]	; 8003a30 <md5_process+0x6dc>
 800384a:	449b      	add	fp, r3
 800384c:	eb01 4b3b 	add.w	fp, r1, fp, ror #16
    SET(b, c, d, a,  2, 23, T48);
 8003850:	ea81 030b 	eor.w	r3, r1, fp
 8003854:	4053      	eors	r3, r2
 8003856:	4418      	add	r0, r3
 8003858:	9b02      	ldr	r3, [sp, #8]
 800385a:	4418      	add	r0, r3
 800385c:	4b61      	ldr	r3, [pc, #388]	; (80039e4 <md5_process+0x690>)
 800385e:	4403      	add	r3, r0
 8003860:	eb0b 2373 	add.w	r3, fp, r3, ror #9
#define I(x, y, z) ((y) ^ ((x) | ~(z)))
#define SET(a, b, c, d, k, s, Ti)\
  t = a + I(b,c,d) + X[k] + Ti;\
  a = ROTATE_LEFT(t, s) + b
     /* Do the following 16 operations. */
    SET(a, b, c, d,  0,  6, T49);
 8003864:	ea63 0001 	orn	r0, r3, r1
 8003868:	ea80 000b 	eor.w	r0, r0, fp
 800386c:	4410      	add	r0, r2
 800386e:	4448      	add	r0, r9
 8003870:	4a5d      	ldr	r2, [pc, #372]	; (80039e8 <md5_process+0x694>)
 8003872:	4402      	add	r2, r0
 8003874:	eb03 62b2 	add.w	r2, r3, r2, ror #26
    SET(d, a, b, c,  7, 10, T50);
 8003878:	ea62 000b 	orn	r0, r2, fp
 800387c:	4058      	eors	r0, r3
 800387e:	4408      	add	r0, r1
 8003880:	4440      	add	r0, r8
 8003882:	495a      	ldr	r1, [pc, #360]	; (80039ec <md5_process+0x698>)
 8003884:	4401      	add	r1, r0
 8003886:	eb02 51b1 	add.w	r1, r2, r1, ror #22
    SET(c, d, a, b, 14, 15, T51);
 800388a:	ea61 0003 	orn	r0, r1, r3
 800388e:	4050      	eors	r0, r2
 8003890:	4458      	add	r0, fp
 8003892:	4486      	add	lr, r0
 8003894:	4856      	ldr	r0, [pc, #344]	; (80039f0 <md5_process+0x69c>)
 8003896:	4470      	add	r0, lr
 8003898:	eb01 4070 	add.w	r0, r1, r0, ror #17
    SET(b, c, d, a,  5, 21, T52);
 800389c:	ea60 0e02 	orn	lr, r0, r2
 80038a0:	ea8e 0e01 	eor.w	lr, lr, r1
 80038a4:	449e      	add	lr, r3
 80038a6:	44e6      	add	lr, ip
 80038a8:	4b52      	ldr	r3, [pc, #328]	; (80039f4 <md5_process+0x6a0>)
 80038aa:	4473      	add	r3, lr
 80038ac:	eb00 23f3 	add.w	r3, r0, r3, ror #11
    SET(a, b, c, d, 12,  6, T53);
 80038b0:	ea63 0c01 	orn	ip, r3, r1
 80038b4:	ea8c 0c00 	eor.w	ip, ip, r0
 80038b8:	4494      	add	ip, r2
 80038ba:	44bc      	add	ip, r7
 80038bc:	4a4e      	ldr	r2, [pc, #312]	; (80039f8 <md5_process+0x6a4>)
 80038be:	4462      	add	r2, ip
 80038c0:	eb03 62b2 	add.w	r2, r3, r2, ror #26
    SET(d, a, b, c,  3, 10, T54);
 80038c4:	ea62 0700 	orn	r7, r2, r0
 80038c8:	405f      	eors	r7, r3
 80038ca:	440f      	add	r7, r1
 80038cc:	4437      	add	r7, r6
 80038ce:	494b      	ldr	r1, [pc, #300]	; (80039fc <md5_process+0x6a8>)
 80038d0:	4439      	add	r1, r7
 80038d2:	eb02 51b1 	add.w	r1, r2, r1, ror #22
    SET(c, d, a, b, 10, 15, T55);
 80038d6:	ea61 0703 	orn	r7, r1, r3
 80038da:	4057      	eors	r7, r2
 80038dc:	4407      	add	r7, r0
 80038de:	9807      	ldr	r0, [sp, #28]
 80038e0:	4407      	add	r7, r0
 80038e2:	4847      	ldr	r0, [pc, #284]	; (8003a00 <md5_process+0x6ac>)
 80038e4:	4438      	add	r0, r7
 80038e6:	eb01 4070 	add.w	r0, r1, r0, ror #17
    SET(b, c, d, a,  1, 21, T56);
 80038ea:	ea60 0702 	orn	r7, r0, r2
 80038ee:	404f      	eors	r7, r1
 80038f0:	441f      	add	r7, r3
 80038f2:	9b01      	ldr	r3, [sp, #4]
 80038f4:	441f      	add	r7, r3
 80038f6:	4b43      	ldr	r3, [pc, #268]	; (8003a04 <md5_process+0x6b0>)
 80038f8:	443b      	add	r3, r7
 80038fa:	eb00 23f3 	add.w	r3, r0, r3, ror #11
    SET(a, b, c, d,  8,  6, T57);
 80038fe:	ea63 0701 	orn	r7, r3, r1
 8003902:	4047      	eors	r7, r0
 8003904:	443a      	add	r2, r7
 8003906:	9f05      	ldr	r7, [sp, #20]
 8003908:	443a      	add	r2, r7
 800390a:	4f3f      	ldr	r7, [pc, #252]	; (8003a08 <md5_process+0x6b4>)
 800390c:	4417      	add	r7, r2
 800390e:	eb03 67b7 	add.w	r7, r3, r7, ror #26
    SET(d, a, b, c, 15, 10, T58);
 8003912:	ea67 0200 	orn	r2, r7, r0
 8003916:	405a      	eors	r2, r3
 8003918:	440a      	add	r2, r1
 800391a:	4492      	add	sl, r2
 800391c:	4a3b      	ldr	r2, [pc, #236]	; (8003a0c <md5_process+0x6b8>)
 800391e:	4452      	add	r2, sl
 8003920:	eb07 5cb2 	add.w	ip, r7, r2, ror #22
    SET(c, d, a, b,  6, 15, T59);
 8003924:	ea6c 0203 	orn	r2, ip, r3
 8003928:	407a      	eors	r2, r7
 800392a:	4402      	add	r2, r0
 800392c:	9804      	ldr	r0, [sp, #16]
 800392e:	4402      	add	r2, r0
 8003930:	4937      	ldr	r1, [pc, #220]	; (8003a10 <md5_process+0x6bc>)
 8003932:	4411      	add	r1, r2
 8003934:	eb0c 4171 	add.w	r1, ip, r1, ror #17
    SET(b, c, d, a, 13, 21, T60);
 8003938:	ea61 0207 	orn	r2, r1, r7
 800393c:	ea82 020c 	eor.w	r2, r2, ip
 8003940:	4413      	add	r3, r2
 8003942:	9e08      	ldr	r6, [sp, #32]
 8003944:	441e      	add	r6, r3
 8003946:	4a33      	ldr	r2, [pc, #204]	; (8003a14 <md5_process+0x6c0>)
 8003948:	4432      	add	r2, r6
 800394a:	eb01 22f2 	add.w	r2, r1, r2, ror #11
    SET(a, b, c, d,  4,  6, T61);
 800394e:	ea62 030c 	orn	r3, r2, ip
 8003952:	404b      	eors	r3, r1
 8003954:	443b      	add	r3, r7
 8003956:	9e03      	ldr	r6, [sp, #12]
 8003958:	18f0      	adds	r0, r6, r3
 800395a:	4b2f      	ldr	r3, [pc, #188]	; (8003a18 <md5_process+0x6c4>)
 800395c:	4403      	add	r3, r0
 800395e:	eb02 63b3 	add.w	r3, r2, r3, ror #26
    SET(d, a, b, c, 11, 10, T62);
 8003962:	ea63 0001 	orn	r0, r3, r1
 8003966:	4050      	eors	r0, r2
 8003968:	4460      	add	r0, ip
 800396a:	4405      	add	r5, r0
 800396c:	482b      	ldr	r0, [pc, #172]	; (8003a1c <md5_process+0x6c8>)
 800396e:	4428      	add	r0, r5
 8003970:	eb03 50b0 	add.w	r0, r3, r0, ror #22
    SET(c, d, a, b,  2, 15, T63);
 8003974:	ea60 0502 	orn	r5, r0, r2
 8003978:	405d      	eors	r5, r3
 800397a:	4429      	add	r1, r5
 800397c:	9d02      	ldr	r5, [sp, #8]
 800397e:	440d      	add	r5, r1
 8003980:	4927      	ldr	r1, [pc, #156]	; (8003a20 <md5_process+0x6cc>)
 8003982:	4429      	add	r1, r5
 8003984:	eb00 4171 	add.w	r1, r0, r1, ror #17
    SET(b, c, d, a,  9, 21, T64);
 8003988:	ea61 0503 	orn	r5, r1, r3
 800398c:	4045      	eors	r5, r0
 800398e:	442a      	add	r2, r5
 8003990:	9e06      	ldr	r6, [sp, #24]
 8003992:	4432      	add	r2, r6
 8003994:	4d23      	ldr	r5, [pc, #140]	; (8003a24 <md5_process+0x6d0>)
 8003996:	4415      	add	r5, r2
 8003998:	eb01 25f5 	add.w	r5, r1, r5, ror #11
#undef SET

     /* Then perform the following additions. (That is increment each
        of the four registers by the value it had before this block
        was started.) */
    pms->abcd[0] += a;
 800399c:	68a2      	ldr	r2, [r4, #8]
 800399e:	441a      	add	r2, r3
 80039a0:	60a2      	str	r2, [r4, #8]
    pms->abcd[1] += b;
 80039a2:	68e3      	ldr	r3, [r4, #12]
 80039a4:	442b      	add	r3, r5
 80039a6:	60e3      	str	r3, [r4, #12]
    pms->abcd[2] += c;
 80039a8:	6923      	ldr	r3, [r4, #16]
 80039aa:	440b      	add	r3, r1
 80039ac:	6123      	str	r3, [r4, #16]
    pms->abcd[3] += d;
 80039ae:	6963      	ldr	r3, [r4, #20]
 80039b0:	4403      	add	r3, r0
 80039b2:	6163      	str	r3, [r4, #20]
}
 80039b4:	b01b      	add	sp, #108	; 0x6c
 80039b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        (void)md5_memcpy(xbuf, data, 64);
 80039ba:	2240      	movs	r2, #64	; 0x40
 80039bc:	a80a      	add	r0, sp, #40	; 0x28
 80039be:	f7ff fcbd 	bl	800333c <md5_memcpy>
        X = xbuf;
 80039c2:	a90a      	add	r1, sp, #40	; 0x28
 80039c4:	e4d3      	b.n	800336e <md5_process+0x1a>
 80039c6:	bf00      	nop
 80039c8:	f6bb4b60 	.word	0xf6bb4b60
 80039cc:	bebfbc70 	.word	0xbebfbc70
 80039d0:	289b7ec6 	.word	0x289b7ec6
 80039d4:	eaa127fa 	.word	0xeaa127fa
 80039d8:	04881d05 	.word	0x04881d05
 80039dc:	d9d4d039 	.word	0xd9d4d039
 80039e0:	e6db99e5 	.word	0xe6db99e5
 80039e4:	c4ac5665 	.word	0xc4ac5665
 80039e8:	f4292244 	.word	0xf4292244
 80039ec:	432aff97 	.word	0x432aff97
 80039f0:	ab9423a7 	.word	0xab9423a7
 80039f4:	fc93a039 	.word	0xfc93a039
 80039f8:	655b59c3 	.word	0x655b59c3
 80039fc:	8f0ccc92 	.word	0x8f0ccc92
 8003a00:	ffeff47d 	.word	0xffeff47d
 8003a04:	85845dd1 	.word	0x85845dd1
 8003a08:	6fa87e4f 	.word	0x6fa87e4f
 8003a0c:	fe2ce6e0 	.word	0xfe2ce6e0
 8003a10:	a3014314 	.word	0xa3014314
 8003a14:	4e0811a1 	.word	0x4e0811a1
 8003a18:	f7537e82 	.word	0xf7537e82
 8003a1c:	bd3af235 	.word	0xbd3af235
 8003a20:	2ad7d2bb 	.word	0x2ad7d2bb
 8003a24:	eb86d391 	.word	0xeb86d391
 8003a28:	4bdecfa9 	.word	0x4bdecfa9
 8003a2c:	d4ef3085 	.word	0xd4ef3085
 8003a30:	1fa27cf8 	.word	0x1fa27cf8

08003a34 <md5_init>:

void
md5_init(md5_state_t *pms)
{
    pms->count[0] = pms->count[1] = 0;
 8003a34:	2300      	movs	r3, #0
 8003a36:	6043      	str	r3, [r0, #4]
 8003a38:	6003      	str	r3, [r0, #0]
    pms->abcd[0] = 0x67452301;
 8003a3a:	4b08      	ldr	r3, [pc, #32]	; (8003a5c <md5_init+0x28>)
 8003a3c:	6083      	str	r3, [r0, #8]
    pms->abcd[1] = /*0xefcdab89*/ T_MASK ^ 0x10325476;
 8003a3e:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
 8003a42:	60c3      	str	r3, [r0, #12]
    pms->abcd[2] = /*0x98badcfe*/ T_MASK ^ 0x67452301;
 8003a44:	f103 4329 	add.w	r3, r3, #2835349504	; 0xa9000000
 8003a48:	f5a3 1396 	sub.w	r3, r3, #1228800	; 0x12c000
 8003a4c:	f6a3 638b 	subw	r3, r3, #3723	; 0xe8b
 8003a50:	6103      	str	r3, [r0, #16]
    pms->abcd[3] = 0x10325476;
 8003a52:	f1a3 3388 	sub.w	r3, r3, #2290649224	; 0x88888888
 8003a56:	6143      	str	r3, [r0, #20]
}
 8003a58:	4770      	bx	lr
 8003a5a:	bf00      	nop
 8003a5c:	67452301 	.word	0x67452301

08003a60 <md5_append>:

void
md5_append(md5_state_t *pms, const md5_byte_t *data, long nbytes)
{
 8003a60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    const md5_byte_t *p = data;
    long left = nbytes;
    long offset = (pms->count[0] >> 3) & 63;
 8003a64:	6803      	ldr	r3, [r0, #0]
 8003a66:	f3c3 07c5 	ubfx	r7, r3, #3, #6
    md5_word_t nbits = (md5_word_t)(nbytes << 3);

    if (nbytes <= 0)
 8003a6a:	2a00      	cmp	r2, #0
 8003a6c:	dd31      	ble.n	8003ad2 <md5_append+0x72>
 8003a6e:	4606      	mov	r6, r0
 8003a70:	460d      	mov	r5, r1
 8003a72:	4614      	mov	r4, r2
 8003a74:	00d1      	lsls	r1, r2, #3
      return;

    /* Update the message length. */
    pms->count[1] += nbytes >> 29;
 8003a76:	6842      	ldr	r2, [r0, #4]
 8003a78:	eb02 7264 	add.w	r2, r2, r4, asr #29
 8003a7c:	6042      	str	r2, [r0, #4]
    pms->count[0] += nbits;
 8003a7e:	440b      	add	r3, r1
 8003a80:	6003      	str	r3, [r0, #0]
    if (pms->count[0] < nbits)
 8003a82:	428b      	cmp	r3, r1
 8003a84:	d201      	bcs.n	8003a8a <md5_append+0x2a>
      pms->count[1]++;
 8003a86:	3201      	adds	r2, #1
 8003a88:	6042      	str	r2, [r0, #4]

    /* Process an initial partial block. */
    if (offset) {
 8003a8a:	b1ff      	cbz	r7, 8003acc <md5_append+0x6c>
      long copy = (offset + nbytes > 64 ? 64 - offset : nbytes);
 8003a8c:	19e3      	adds	r3, r4, r7
 8003a8e:	2b40      	cmp	r3, #64	; 0x40
 8003a90:	dd02      	ble.n	8003a98 <md5_append+0x38>
 8003a92:	f1c7 0840 	rsb	r8, r7, #64	; 0x40
 8003a96:	e000      	b.n	8003a9a <md5_append+0x3a>
 8003a98:	46a0      	mov	r8, r4

      (void)md5_memcpy(pms->buf + offset, p, copy);
 8003a9a:	f106 0918 	add.w	r9, r6, #24
 8003a9e:	4642      	mov	r2, r8
 8003aa0:	4629      	mov	r1, r5
 8003aa2:	eb09 0007 	add.w	r0, r9, r7
 8003aa6:	f7ff fc49 	bl	800333c <md5_memcpy>
      if (offset + copy < 64)
 8003aaa:	4447      	add	r7, r8
 8003aac:	2f3f      	cmp	r7, #63	; 0x3f
 8003aae:	dd10      	ble.n	8003ad2 <md5_append+0x72>
          return;
      p += copy;
 8003ab0:	4445      	add	r5, r8
      left -= copy;
 8003ab2:	eba4 0408 	sub.w	r4, r4, r8
      md5_process(pms, pms->buf);
 8003ab6:	4649      	mov	r1, r9
 8003ab8:	4630      	mov	r0, r6
 8003aba:	f7ff fc4b 	bl	8003354 <md5_process>
 8003abe:	e005      	b.n	8003acc <md5_append+0x6c>
    }

    /* Process full blocks. */
    for (; left >= 64; p += 64, left -= 64)
      md5_process(pms, p);
 8003ac0:	4629      	mov	r1, r5
 8003ac2:	4630      	mov	r0, r6
 8003ac4:	f7ff fc46 	bl	8003354 <md5_process>
    for (; left >= 64; p += 64, left -= 64)
 8003ac8:	3540      	adds	r5, #64	; 0x40
 8003aca:	3c40      	subs	r4, #64	; 0x40
 8003acc:	2c3f      	cmp	r4, #63	; 0x3f
 8003ace:	dcf7      	bgt.n	8003ac0 <md5_append+0x60>

    /* Process a final partial block. */
    if (left)
 8003ad0:	b90c      	cbnz	r4, 8003ad6 <md5_append+0x76>
      (void)md5_memcpy(pms->buf, p, left);
}
 8003ad2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      (void)md5_memcpy(pms->buf, p, left);
 8003ad6:	4622      	mov	r2, r4
 8003ad8:	4629      	mov	r1, r5
 8003ada:	f106 0018 	add.w	r0, r6, #24
 8003ade:	f7ff fc2d 	bl	800333c <md5_memcpy>
 8003ae2:	e7f6      	b.n	8003ad2 <md5_append+0x72>

08003ae4 <md5_finish>:

void
md5_finish(md5_state_t *pms, md5_byte_t digest[16])
{
 8003ae4:	b530      	push	{r4, r5, lr}
 8003ae6:	b083      	sub	sp, #12
 8003ae8:	4604      	mov	r4, r0
 8003aea:	460d      	mov	r5, r1
    };
    md5_byte_t data[8];
    long i;

    /* Save the length before padding. */
    for (i = 0; i < 8; ++i)
 8003aec:	2300      	movs	r3, #0
 8003aee:	2b07      	cmp	r3, #7
 8003af0:	dc0d      	bgt.n	8003b0e <md5_finish+0x2a>
      data[i] = (md5_byte_t)(pms->count[i >> 2] >> ((i & 3) << 3));
 8003af2:	109a      	asrs	r2, r3, #2
 8003af4:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8003af8:	00d9      	lsls	r1, r3, #3
 8003afa:	f001 0118 	and.w	r1, r1, #24
 8003afe:	40ca      	lsrs	r2, r1
 8003b00:	f103 0108 	add.w	r1, r3, #8
 8003b04:	4469      	add	r1, sp
 8003b06:	f801 2c08 	strb.w	r2, [r1, #-8]
    for (i = 0; i < 8; ++i)
 8003b0a:	3301      	adds	r3, #1
 8003b0c:	e7ef      	b.n	8003aee <md5_finish+0xa>
    /* Pad to 56 bytes mod 64. */
    md5_append(pms, pad, ((55 - (pms->count[0] >> 3)) & 63) + 1);
 8003b0e:	6823      	ldr	r3, [r4, #0]
 8003b10:	08da      	lsrs	r2, r3, #3
 8003b12:	f1c2 0237 	rsb	r2, r2, #55	; 0x37
 8003b16:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8003b1a:	3201      	adds	r2, #1
 8003b1c:	490d      	ldr	r1, [pc, #52]	; (8003b54 <md5_finish+0x70>)
 8003b1e:	4620      	mov	r0, r4
 8003b20:	f7ff ff9e 	bl	8003a60 <md5_append>
    /* Append the length. */
    md5_append(pms, data, 8);
 8003b24:	2208      	movs	r2, #8
 8003b26:	4669      	mov	r1, sp
 8003b28:	4620      	mov	r0, r4
 8003b2a:	f7ff ff99 	bl	8003a60 <md5_append>
    for (i = 0; i < 16; ++i)
 8003b2e:	2300      	movs	r3, #0
 8003b30:	e00b      	b.n	8003b4a <md5_finish+0x66>
      digest[i] = (md5_byte_t)(pms->abcd[i >> 2] >> ((i & 3) << 3));
 8003b32:	109a      	asrs	r2, r3, #2
 8003b34:	3202      	adds	r2, #2
 8003b36:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8003b3a:	ea4f 0cc3 	mov.w	ip, r3, lsl #3
 8003b3e:	f00c 0c18 	and.w	ip, ip, #24
 8003b42:	fa22 f20c 	lsr.w	r2, r2, ip
 8003b46:	54ea      	strb	r2, [r5, r3]
    for (i = 0; i < 16; ++i)
 8003b48:	3301      	adds	r3, #1
 8003b4a:	2b0f      	cmp	r3, #15
 8003b4c:	ddf1      	ble.n	8003b32 <md5_finish+0x4e>
}
 8003b4e:	b003      	add	sp, #12
 8003b50:	bd30      	pop	{r4, r5, pc}
 8003b52:	bf00      	nop
 8003b54:	0800ac14 	.word	0x0800ac14

08003b58 <DEV_IsFWFile>:
/*! Check if we have a firmware file
*   \param pszFileName      Input file name
*   \return 1 on success                                                     */
/*****************************************************************************/
int DEV_IsFWFile( char* pszFileName)
{
 8003b58:	b510      	push	{r4, lr}
 8003b5a:	4604      	mov	r4, r0
  /* Check if we have a .NXO, .NXF,.NXM or .MOD extension */
  int fRet    = 0;
  int iStrlen = OS_Strlen(pszFileName);
 8003b5c:	f7ff f8c8 	bl	8002cf0 <OS_Strlen>

  if( iStrlen >= CIFX_MIN_FILE_NAME_LENGTH)  /* At least x.abc */
 8003b60:	2804      	cmp	r0, #4
 8003b62:	dc01      	bgt.n	8003b68 <DEV_IsFWFile+0x10>
  int fRet    = 0;
 8003b64:	2000      	movs	r0, #0
      fRet = 1;
    }
  }

  return fRet;
}
 8003b66:	bd10      	pop	{r4, pc}
    if ( (0 == OS_Strnicmp( HIL_FILE_EXTENSION_FIRMWARE,     &pszFileName[iStrlen - 4], 4) ) ||
 8003b68:	1f03      	subs	r3, r0, #4
 8003b6a:	441c      	add	r4, r3
 8003b6c:	2204      	movs	r2, #4
 8003b6e:	4621      	mov	r1, r4
 8003b70:	480f      	ldr	r0, [pc, #60]	; (8003bb0 <DEV_IsFWFile+0x58>)
 8003b72:	f7ff f8b9 	bl	8002ce8 <OS_Strnicmp>
 8003b76:	b908      	cbnz	r0, 8003b7c <DEV_IsFWFile+0x24>
      fRet = 1;
 8003b78:	2001      	movs	r0, #1
 8003b7a:	e7f4      	b.n	8003b66 <DEV_IsFWFile+0xe>
         (0 == OS_Strnicmp( HIL_FILE_EXTENSION_NXM_FIRMWARE, &pszFileName[iStrlen - 4], 4) ) ||
 8003b7c:	2204      	movs	r2, #4
 8003b7e:	4621      	mov	r1, r4
 8003b80:	480c      	ldr	r0, [pc, #48]	; (8003bb4 <DEV_IsFWFile+0x5c>)
 8003b82:	f7ff f8b1 	bl	8002ce8 <OS_Strnicmp>
    if ( (0 == OS_Strnicmp( HIL_FILE_EXTENSION_FIRMWARE,     &pszFileName[iStrlen - 4], 4) ) ||
 8003b86:	b908      	cbnz	r0, 8003b8c <DEV_IsFWFile+0x34>
      fRet = 1;
 8003b88:	2001      	movs	r0, #1
 8003b8a:	e7ec      	b.n	8003b66 <DEV_IsFWFile+0xe>
         (0 == OS_Strnicmp( HIL_FILE_EXTENSION_OPTION,       &pszFileName[iStrlen - 4], 4) ) ||
 8003b8c:	2204      	movs	r2, #4
 8003b8e:	4621      	mov	r1, r4
 8003b90:	4809      	ldr	r0, [pc, #36]	; (8003bb8 <DEV_IsFWFile+0x60>)
 8003b92:	f7ff f8a9 	bl	8002ce8 <OS_Strnicmp>
         (0 == OS_Strnicmp( HIL_FILE_EXTENSION_NXM_FIRMWARE, &pszFileName[iStrlen - 4], 4) ) ||
 8003b96:	b908      	cbnz	r0, 8003b9c <DEV_IsFWFile+0x44>
      fRet = 1;
 8003b98:	2001      	movs	r0, #1
 8003b9a:	e7e4      	b.n	8003b66 <DEV_IsFWFile+0xe>
         (0 == OS_Strnicmp( ".MOD", &pszFileName[iStrlen - 4], 4) )  )
 8003b9c:	2204      	movs	r2, #4
 8003b9e:	4621      	mov	r1, r4
 8003ba0:	4806      	ldr	r0, [pc, #24]	; (8003bbc <DEV_IsFWFile+0x64>)
 8003ba2:	f7ff f8a1 	bl	8002ce8 <OS_Strnicmp>
         (0 == OS_Strnicmp( HIL_FILE_EXTENSION_OPTION,       &pszFileName[iStrlen - 4], 4) ) ||
 8003ba6:	b108      	cbz	r0, 8003bac <DEV_IsFWFile+0x54>
  int fRet    = 0;
 8003ba8:	2000      	movs	r0, #0
 8003baa:	e7dc      	b.n	8003b66 <DEV_IsFWFile+0xe>
      fRet = 1;
 8003bac:	2001      	movs	r0, #1
  return fRet;
 8003bae:	e7da      	b.n	8003b66 <DEV_IsFWFile+0xe>
 8003bb0:	0800ac54 	.word	0x0800ac54
 8003bb4:	0800ac5c 	.word	0x0800ac5c
 8003bb8:	0800ac64 	.word	0x0800ac64
 8003bbc:	0800ac6c 	.word	0x0800ac6c

08003bc0 <DEV_IsFWFileNetX90or4000>:
/*! Check if we have a firmware (update) file for netX90 and netX4000
*   \param pszFileName      Input file name
*   \return 1 on success                                                     */
/*****************************************************************************/
int DEV_IsFWFileNetX90or4000( char* pszFileName)
{
 8003bc0:	b570      	push	{r4, r5, r6, lr}
 8003bc2:	4605      	mov	r5, r0
  /* Check if we have a .NXI or .NAI extension, or FWUPDATE.ZIP / FWUPDATE.NXS
     Note: NXE or NAE should be downloaded in update container.
  */
  int fRet    = 0;
  int iStrlen = OS_Strlen(pszFileName);
 8003bc4:	f7ff f894 	bl	8002cf0 <OS_Strlen>

  if( iStrlen >= CIFX_MIN_FILE_NAME_LENGTH)  /* At least x.abc */
 8003bc8:	2804      	cmp	r0, #4
 8003bca:	dc01      	bgt.n	8003bd0 <DEV_IsFWFileNetX90or4000+0x10>
  int fRet    = 0;
 8003bcc:	2000      	movs	r0, #0
      fRet = 1;
    }
  }

  return fRet;
}
 8003bce:	bd70      	pop	{r4, r5, r6, pc}
 8003bd0:	4604      	mov	r4, r0
    if ( (0 == OS_Strnicmp( HIL_FILE_EXTENSION_NXI_FIRMWARE, &pszFileName[iStrlen - 4], 4) ) ||
 8003bd2:	1f06      	subs	r6, r0, #4
 8003bd4:	442e      	add	r6, r5
 8003bd6:	2204      	movs	r2, #4
 8003bd8:	4631      	mov	r1, r6
 8003bda:	4816      	ldr	r0, [pc, #88]	; (8003c34 <DEV_IsFWFileNetX90or4000+0x74>)
 8003bdc:	f7ff f884 	bl	8002ce8 <OS_Strnicmp>
 8003be0:	b908      	cbnz	r0, 8003be6 <DEV_IsFWFileNetX90or4000+0x26>
      fRet = 1;
 8003be2:	2001      	movs	r0, #1
 8003be4:	e7f3      	b.n	8003bce <DEV_IsFWFileNetX90or4000+0xe>
         (0 == OS_Strnicmp( HIL_FILE_EXTENSION_NAI_FIRMWARE, &pszFileName[iStrlen - 4], 4) )  )
 8003be6:	2204      	movs	r2, #4
 8003be8:	4631      	mov	r1, r6
 8003bea:	4813      	ldr	r0, [pc, #76]	; (8003c38 <DEV_IsFWFileNetX90or4000+0x78>)
 8003bec:	f7ff f87c 	bl	8002ce8 <OS_Strnicmp>
    if ( (0 == OS_Strnicmp( HIL_FILE_EXTENSION_NXI_FIRMWARE, &pszFileName[iStrlen - 4], 4) ) ||
 8003bf0:	b908      	cbnz	r0, 8003bf6 <DEV_IsFWFileNetX90or4000+0x36>
      fRet = 1;
 8003bf2:	2001      	movs	r0, #1
 8003bf4:	e7eb      	b.n	8003bce <DEV_IsFWFileNetX90or4000+0xe>
    } else if( (iStrlen == OS_Strlen("FWUPDATE.ZIP"))                         &&
 8003bf6:	4811      	ldr	r0, [pc, #68]	; (8003c3c <DEV_IsFWFileNetX90or4000+0x7c>)
 8003bf8:	f7ff f87a 	bl	8002cf0 <OS_Strlen>
 8003bfc:	42a0      	cmp	r0, r4
 8003bfe:	d006      	beq.n	8003c0e <DEV_IsFWFileNetX90or4000+0x4e>
    } else if( (iStrlen == OS_Strlen("FWUPDATE.NXS"))                         &&
 8003c00:	480f      	ldr	r0, [pc, #60]	; (8003c40 <DEV_IsFWFileNetX90or4000+0x80>)
 8003c02:	f7ff f875 	bl	8002cf0 <OS_Strlen>
 8003c06:	42a0      	cmp	r0, r4
 8003c08:	d00a      	beq.n	8003c20 <DEV_IsFWFileNetX90or4000+0x60>
  int fRet    = 0;
 8003c0a:	2000      	movs	r0, #0
 8003c0c:	e7df      	b.n	8003bce <DEV_IsFWFileNetX90or4000+0xe>
               (0       == OS_Strnicmp( "FWUPDATE.ZIP", &pszFileName[0], iStrlen)) )
 8003c0e:	4622      	mov	r2, r4
 8003c10:	4629      	mov	r1, r5
 8003c12:	480a      	ldr	r0, [pc, #40]	; (8003c3c <DEV_IsFWFileNetX90or4000+0x7c>)
 8003c14:	f7ff f868 	bl	8002ce8 <OS_Strnicmp>
    } else if( (iStrlen == OS_Strlen("FWUPDATE.ZIP"))                         &&
 8003c18:	2800      	cmp	r0, #0
 8003c1a:	d1f1      	bne.n	8003c00 <DEV_IsFWFileNetX90or4000+0x40>
      fRet = 1;
 8003c1c:	2001      	movs	r0, #1
 8003c1e:	e7d6      	b.n	8003bce <DEV_IsFWFileNetX90or4000+0xe>
               (0       == OS_Strnicmp( "FWUPDATE.NXS", &pszFileName[0], iStrlen)) )
 8003c20:	4622      	mov	r2, r4
 8003c22:	4629      	mov	r1, r5
 8003c24:	4806      	ldr	r0, [pc, #24]	; (8003c40 <DEV_IsFWFileNetX90or4000+0x80>)
 8003c26:	f7ff f85f 	bl	8002ce8 <OS_Strnicmp>
    } else if( (iStrlen == OS_Strlen("FWUPDATE.NXS"))                         &&
 8003c2a:	b108      	cbz	r0, 8003c30 <DEV_IsFWFileNetX90or4000+0x70>
  int fRet    = 0;
 8003c2c:	2000      	movs	r0, #0
 8003c2e:	e7ce      	b.n	8003bce <DEV_IsFWFileNetX90or4000+0xe>
      fRet = 1;
 8003c30:	2001      	movs	r0, #1
  return fRet;
 8003c32:	e7cc      	b.n	8003bce <DEV_IsFWFileNetX90or4000+0xe>
 8003c34:	0800ac74 	.word	0x0800ac74
 8003c38:	0800ac7c 	.word	0x0800ac7c
 8003c3c:	0800ac84 	.word	0x0800ac84
 8003c40:	0800ac94 	.word	0x0800ac94

08003c44 <DEV_IsNXOFile>:
/*! Check if we have a NXO file
*   \param pszFileName      Input file name
*   \return 1 on success                                                     */
/*****************************************************************************/
int DEV_IsNXOFile( char* pszFileName)
{
 8003c44:	b510      	push	{r4, lr}
 8003c46:	4604      	mov	r4, r0
  /* Check if we have a .NXO, .NXF,.NXM or .MOD extension */
  int fRet    = 0;
  int iStrlen = OS_Strlen(pszFileName);
 8003c48:	f7ff f852 	bl	8002cf0 <OS_Strlen>

  if( iStrlen >= CIFX_MIN_FILE_NAME_LENGTH)  /* At least x.abc */
 8003c4c:	2804      	cmp	r0, #4
 8003c4e:	dc01      	bgt.n	8003c54 <DEV_IsNXOFile+0x10>
  int fRet    = 0;
 8003c50:	2000      	movs	r0, #0
      fRet = 1;
    }
  }

  return fRet;
}
 8003c52:	bd10      	pop	{r4, pc}
    if ( 0 == OS_Strnicmp( HIL_FILE_EXTENSION_OPTION, &pszFileName[iStrlen - 4], 4) )
 8003c54:	1f01      	subs	r1, r0, #4
 8003c56:	2204      	movs	r2, #4
 8003c58:	4421      	add	r1, r4
 8003c5a:	4804      	ldr	r0, [pc, #16]	; (8003c6c <DEV_IsNXOFile+0x28>)
 8003c5c:	f7ff f844 	bl	8002ce8 <OS_Strnicmp>
 8003c60:	b108      	cbz	r0, 8003c66 <DEV_IsNXOFile+0x22>
  int fRet    = 0;
 8003c62:	2000      	movs	r0, #0
 8003c64:	e7f5      	b.n	8003c52 <DEV_IsNXOFile+0xe>
      fRet = 1;
 8003c66:	2001      	movs	r0, #1
  return fRet;
 8003c68:	e7f3      	b.n	8003c52 <DEV_IsNXOFile+0xe>
 8003c6a:	bf00      	nop
 8003c6c:	0800ac64 	.word	0x0800ac64

08003c70 <DEV_IsNXFFile>:
/*! Check if we have a NXF file
*   \param pszFileName      Input file name
*   \return 1 on success                                                     */
/*****************************************************************************/
int DEV_IsNXFFile( char* pszFileName)
{
 8003c70:	b510      	push	{r4, lr}
 8003c72:	4604      	mov	r4, r0
  /* Check if we have a .NXO, .NXF,.NXM or .MOD extension */
  int fRet    = 0;
  int iStrlen = OS_Strlen(pszFileName);
 8003c74:	f7ff f83c 	bl	8002cf0 <OS_Strlen>

  if( iStrlen >= CIFX_MIN_FILE_NAME_LENGTH)  /* At least x.abc */
 8003c78:	2804      	cmp	r0, #4
 8003c7a:	dc01      	bgt.n	8003c80 <DEV_IsNXFFile+0x10>
  int fRet    = 0;
 8003c7c:	2000      	movs	r0, #0
      fRet = 1;
    }
  }

  return fRet;
}
 8003c7e:	bd10      	pop	{r4, pc}
    if ( 0 == OS_Strnicmp( HIL_FILE_EXTENSION_FIRMWARE, &pszFileName[iStrlen - 4], 4) )
 8003c80:	1f01      	subs	r1, r0, #4
 8003c82:	2204      	movs	r2, #4
 8003c84:	4421      	add	r1, r4
 8003c86:	4804      	ldr	r0, [pc, #16]	; (8003c98 <DEV_IsNXFFile+0x28>)
 8003c88:	f7ff f82e 	bl	8002ce8 <OS_Strnicmp>
 8003c8c:	b108      	cbz	r0, 8003c92 <DEV_IsNXFFile+0x22>
  int fRet    = 0;
 8003c8e:	2000      	movs	r0, #0
 8003c90:	e7f5      	b.n	8003c7e <DEV_IsNXFFile+0xe>
      fRet = 1;
 8003c92:	2001      	movs	r0, #1
  return fRet;
 8003c94:	e7f3      	b.n	8003c7e <DEV_IsNXFFile+0xe>
 8003c96:	bf00      	nop
 8003c98:	0800ac54 	.word	0x0800ac54

08003c9c <DEV_DeleteFile>:
/*****************************************************************************/
int32_t DEV_DeleteFile(void* pvChannel, uint32_t ulChannelNumber, char* pszFileName,
                       PFN_TRANSFER_PACKET    pfnTransferPacket,
                       PFN_RECV_PKT_CALLBACK  pfnRecvPacket,
                       void*                  pvUser)
{
 8003c9c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003ca0:	f6ad 4d8c 	subw	sp, sp, #3212	; 0xc8c
 8003ca4:	4607      	mov	r7, r0
 8003ca6:	4688      	mov	r8, r1
 8003ca8:	4615      	mov	r5, r2
 8003caa:	461e      	mov	r6, r3

  }                       uSendPkt;
  CIFX_PACKET             tConf;
  char*                   pbCopyPtr     = NULL;
  uint32_t                ulCopySize    = 0;
  uint16_t                usFileNameLen = (uint16_t)OS_Strlen(pszFileName);
 8003cac:	4610      	mov	r0, r2
 8003cae:	f7ff f81f 	bl	8002cf0 <OS_Strlen>
 8003cb2:	b284      	uxth	r4, r0
  int32_t                 lRet          = CIFX_NO_ERROR;
  uint32_t                ulSrc         = OS_GetMilliSecCounter(); /* Early versions used pvChannel as ulSrc,
 8003cb4:	f7fe ff4d 	bl	8002b52 <OS_GetMilliSecCounter>
 8003cb8:	4681      	mov	r9, r0
                                                                      but this won't work on 64 Bit machines.
                                                                      As we need something unique we use the current system time */


  OS_Memset(&uSendPkt, 0, sizeof(uSendPkt));
 8003cba:	f240 623c 	movw	r2, #1596	; 0x63c
 8003cbe:	2100      	movs	r1, #0
 8003cc0:	f20d 604c 	addw	r0, sp, #1612	; 0x64c
 8003cc4:	f7fe ff2b 	bl	8002b1e <OS_Memset>
  OS_Memset(&tConf,    0, sizeof(tConf));
 8003cc8:	f240 623c 	movw	r2, #1596	; 0x63c
 8003ccc:	2100      	movs	r1, #0
 8003cce:	a804      	add	r0, sp, #16
 8003cd0:	f7fe ff25 	bl	8002b1e <OS_Memset>

  /* Initialize the message */
  uSendPkt.tFileDelete.tHead.ulSrc    = HOST_TO_LE32(ulSrc);
 8003cd4:	f8cd 9650 	str.w	r9, [sp, #1616]	; 0x650
  uSendPkt.tFileDelete.tHead.ulDest   = HOST_TO_LE32(HIL_PACKET_DEST_SYSTEM);
 8003cd8:	2300      	movs	r3, #0
 8003cda:	f8cd 364c 	str.w	r3, [sp, #1612]	; 0x64c
  uSendPkt.tFileDelete.tHead.ulCmd    = HOST_TO_LE32(HIL_FILE_DELETE_REQ);
 8003cde:	f641 626a 	movw	r2, #7786	; 0x1e6a
 8003ce2:	f8cd 2668 	str.w	r2, [sp, #1640]	; 0x668
  uSendPkt.tFileDelete.tHead.ulExt    = HOST_TO_LE32(HIL_PACKET_SEQ_NONE);
 8003ce6:	f8cd 366c 	str.w	r3, [sp, #1644]	; 0x66c
  uSendPkt.tFileDelete.tHead.ulLen    = HOST_TO_LE32((uint32_t)(sizeof(uSendPkt.tFileDelete.tData) +
 8003cea:	1de3      	adds	r3, r4, #7
 8003cec:	f8cd 365c 	str.w	r3, [sp, #1628]	; 0x65c
                                                                usFileNameLen + 1));

  /* Insert file data */
  uSendPkt.tFileDelete.tData.ulChannelNo      = HOST_TO_LE32(ulChannelNumber);
 8003cf0:	f8cd 8674 	str.w	r8, [sp, #1652]	; 0x674
  uSendPkt.tFileDelete.tData.usFileNameLength = HOST_TO_LE16( (uint16_t)(usFileNameLen + 1) );
 8003cf4:	3401      	adds	r4, #1
 8003cf6:	b2a4      	uxth	r4, r4
 8003cf8:	f8ad 4678 	strh.w	r4, [sp, #1656]	; 0x678
  /* Setup copy buffer and copy size */
  pbCopyPtr   = ((char*)(&uSendPkt.tPacket.abData[0])) + sizeof(uSendPkt.tFileDelete.tData);
  ulCopySize  = min( (sizeof(uSendPkt.tPacket.abData) - sizeof(uSendPkt.tFileDelete.tData)), uSendPkt.tFileDelete.tData.usFileNameLength);

  /* Insert file name */
  (void)OS_Strncpy( pbCopyPtr, pszFileName, ulCopySize);
 8003cfc:	f240 620e 	movw	r2, #1550	; 0x60e
 8003d00:	42a2      	cmp	r2, r4
 8003d02:	bf28      	it	cs
 8003d04:	4622      	movcs	r2, r4
 8003d06:	4629      	mov	r1, r5
 8003d08:	f20d 607a 	addw	r0, sp, #1658	; 0x67a
 8003d0c:	f7fe fff4 	bl	8002cf8 <OS_Strncpy>

  /* Send delete packet */
  lRet = pfnTransferPacket( pvChannel,
 8003d10:	f8dd 3cac 	ldr.w	r3, [sp, #3244]	; 0xcac
 8003d14:	9302      	str	r3, [sp, #8]
 8003d16:	f8dd 3ca8 	ldr.w	r3, [sp, #3240]	; 0xca8
 8003d1a:	9301      	str	r3, [sp, #4]
 8003d1c:	f644 6320 	movw	r3, #20000	; 0x4e20
 8003d20:	9300      	str	r3, [sp, #0]
 8003d22:	f240 633c 	movw	r3, #1596	; 0x63c
 8003d26:	aa04      	add	r2, sp, #16
 8003d28:	f20d 614c 	addw	r1, sp, #1612	; 0x64c
 8003d2c:	4638      	mov	r0, r7
 8003d2e:	47b0      	blx	r6
                            (uint32_t)sizeof(tConf),
                            CIFX_TO_FIRMWARE_START,       /* Could take a little while */
                            pfnRecvPacket,
                            pvUser);

  if(CIFX_NO_ERROR == lRet)
 8003d30:	b900      	cbnz	r0, 8003d34 <DEV_DeleteFile+0x98>
    lRet = LE32_TO_HOST(tConf.tHeader.ulState);
 8003d32:	980a      	ldr	r0, [sp, #40]	; 0x28

  return lRet;
}
 8003d34:	f60d 4d8c 	addw	sp, sp, #3212	; 0xc8c
 8003d38:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08003d3c <DEV_RemoveChannelFiles>:
{
 8003d3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003d40:	b08d      	sub	sp, #52	; 0x34
 8003d42:	4680      	mov	r8, r0
 8003d44:	460f      	mov	r7, r1
 8003d46:	9203      	str	r2, [sp, #12]
 8003d48:	461e      	mov	r6, r3
 8003d4a:	f8dd a058 	ldr.w	sl, [sp, #88]	; 0x58
 8003d4e:	f8dd b05c 	ldr.w	fp, [sp, #92]	; 0x5c
  int                 fFindFirst      = 1;
 8003d52:	f04f 0901 	mov.w	r9, #1
 8003d56:	e03a      	b.n	8003dce <DEV_RemoveChannelFiles+0x92>
                (0 == OS_Strnicmp( szExceptFile, &tDirectoryEntry.szFilename[iStrlen - 4], 4)))   )
 8003d58:	3d04      	subs	r5, #4
 8003d5a:	ab05      	add	r3, sp, #20
 8003d5c:	1959      	adds	r1, r3, r5
 8003d5e:	2204      	movs	r2, #4
 8003d60:	4411      	add	r1, r2
 8003d62:	4658      	mov	r0, fp
 8003d64:	f7fe ffc0 	bl	8002ce8 <OS_Strnicmp>
          if( !((NULL != szExceptFile)                                                          &&
 8003d68:	b380      	cbz	r0, 8003dcc <DEV_RemoveChannelFiles+0x90>
 8003d6a:	e050      	b.n	8003e0e <DEV_RemoveChannelFiles+0xd2>
      if ( !(CIFX_NO_ERROR == (lRet = xSysdeviceFindNextFile( ptChannel, ulChannel, &tDirectoryEntry, pfnRecvPacket, pvUser))))
 8003d6c:	f8cd a000 	str.w	sl, [sp]
 8003d70:	4633      	mov	r3, r6
 8003d72:	aa05      	add	r2, sp, #20
 8003d74:	4639      	mov	r1, r7
 8003d76:	4640      	mov	r0, r8
 8003d78:	f001 f958 	bl	800502c <xSysdeviceFindNextFile>
 8003d7c:	4604      	mov	r4, r0
 8003d7e:	2800      	cmp	r0, #0
 8003d80:	d14f      	bne.n	8003e22 <DEV_RemoveChannelFiles+0xe6>
        int iStrlen = OS_Strlen(tDirectoryEntry.szFilename);
 8003d82:	a806      	add	r0, sp, #24
 8003d84:	f7fe ffb4 	bl	8002cf0 <OS_Strlen>
 8003d88:	4605      	mov	r5, r0
        if( iStrlen >= CIFX_MIN_FILE_NAME_LENGTH)  /* At least x.abc */
 8003d8a:	2804      	cmp	r0, #4
 8003d8c:	dd1e      	ble.n	8003dcc <DEV_RemoveChannelFiles+0x90>
          if( !((NULL != szExceptFile)                                            &&
 8003d8e:	f1bb 0f00 	cmp.w	fp, #0
 8003d92:	d004      	beq.n	8003d9e <DEV_RemoveChannelFiles+0x62>
                (4 == OS_Strlen(szExceptFile))                                    &&
 8003d94:	4658      	mov	r0, fp
 8003d96:	f7fe ffab 	bl	8002cf0 <OS_Strlen>
          if( !((NULL != szExceptFile)                                            &&
 8003d9a:	2804      	cmp	r0, #4
 8003d9c:	d00b      	beq.n	8003db6 <DEV_RemoveChannelFiles+0x7a>
            (void)DEV_DeleteFile( ptChannel, ulChannel, tDirectoryEntry.szFilename, pfnTransferPacket, pfnRecvPacket, pvUser);
 8003d9e:	f8cd a004 	str.w	sl, [sp, #4]
 8003da2:	9600      	str	r6, [sp, #0]
 8003da4:	9b03      	ldr	r3, [sp, #12]
 8003da6:	aa06      	add	r2, sp, #24
 8003da8:	4639      	mov	r1, r7
 8003daa:	4640      	mov	r0, r8
 8003dac:	f7ff ff76 	bl	8003c9c <DEV_DeleteFile>
            fFindFirst = 1;
 8003db0:	f04f 0901 	mov.w	r9, #1
 8003db4:	e00a      	b.n	8003dcc <DEV_RemoveChannelFiles+0x90>
                (0 == OS_Strnicmp( szExceptFile, &tDirectoryEntry.szFilename[iStrlen - 4], 4)))   )
 8003db6:	3d04      	subs	r5, #4
 8003db8:	ab05      	add	r3, sp, #20
 8003dba:	1959      	adds	r1, r3, r5
 8003dbc:	2204      	movs	r2, #4
 8003dbe:	4411      	add	r1, r2
 8003dc0:	4658      	mov	r0, fp
 8003dc2:	f7fe ff91 	bl	8002ce8 <OS_Strnicmp>
          if( !((NULL != szExceptFile)                                            &&
 8003dc6:	b108      	cbz	r0, 8003dcc <DEV_RemoveChannelFiles+0x90>
 8003dc8:	e7e9      	b.n	8003d9e <DEV_RemoveChannelFiles+0x62>
          fFindFirst = 0;
 8003dca:	46a1      	mov	r9, r4
  } while ( CIFX_NO_ERROR == lRet);
 8003dcc:	bb4c      	cbnz	r4, 8003e22 <DEV_RemoveChannelFiles+0xe6>
    if ( fFindFirst)
 8003dce:	f1b9 0f00 	cmp.w	r9, #0
 8003dd2:	d0cb      	beq.n	8003d6c <DEV_RemoveChannelFiles+0x30>
       OS_Memset(&tDirectoryEntry, 0, sizeof(tDirectoryEntry));
 8003dd4:	2219      	movs	r2, #25
 8003dd6:	2100      	movs	r1, #0
 8003dd8:	a805      	add	r0, sp, #20
 8003dda:	f7fe fea0 	bl	8002b1e <OS_Memset>
      if ( !(CIFX_NO_ERROR == (lRet = xSysdeviceFindFirstFile( ptChannel, ulChannel, &tDirectoryEntry, pfnRecvPacket, pvUser))))
 8003dde:	f8cd a000 	str.w	sl, [sp]
 8003de2:	4633      	mov	r3, r6
 8003de4:	aa05      	add	r2, sp, #20
 8003de6:	4639      	mov	r1, r7
 8003de8:	4640      	mov	r0, r8
 8003dea:	f001 f8bb 	bl	8004f64 <xSysdeviceFindFirstFile>
 8003dee:	4604      	mov	r4, r0
 8003df0:	b9b8      	cbnz	r0, 8003e22 <DEV_RemoveChannelFiles+0xe6>
        int iStrlen = OS_Strlen(tDirectoryEntry.szFilename);
 8003df2:	a806      	add	r0, sp, #24
 8003df4:	f7fe ff7c 	bl	8002cf0 <OS_Strlen>
 8003df8:	4605      	mov	r5, r0
        if( iStrlen >= CIFX_MIN_FILE_NAME_LENGTH)  /* At least x.abc */
 8003dfa:	2804      	cmp	r0, #4
 8003dfc:	dde5      	ble.n	8003dca <DEV_RemoveChannelFiles+0x8e>
          if( !((NULL != szExceptFile)                                                          &&
 8003dfe:	f1bb 0f00 	cmp.w	fp, #0
 8003e02:	d004      	beq.n	8003e0e <DEV_RemoveChannelFiles+0xd2>
                (4 == OS_Strlen(szExceptFile))                                                  &&
 8003e04:	4658      	mov	r0, fp
 8003e06:	f7fe ff73 	bl	8002cf0 <OS_Strlen>
          if( !((NULL != szExceptFile)                                                          &&
 8003e0a:	2804      	cmp	r0, #4
 8003e0c:	d0a4      	beq.n	8003d58 <DEV_RemoveChannelFiles+0x1c>
            (void)DEV_DeleteFile( ptChannel, ulChannel, tDirectoryEntry.szFilename, pfnTransferPacket, pfnRecvPacket, pvUser);
 8003e0e:	f8cd a004 	str.w	sl, [sp, #4]
 8003e12:	9600      	str	r6, [sp, #0]
 8003e14:	9b03      	ldr	r3, [sp, #12]
 8003e16:	aa06      	add	r2, sp, #24
 8003e18:	4639      	mov	r1, r7
 8003e1a:	4640      	mov	r0, r8
 8003e1c:	f7ff ff3e 	bl	8003c9c <DEV_DeleteFile>
 8003e20:	e7d4      	b.n	8003dcc <DEV_RemoveChannelFiles+0x90>
}
 8003e22:	2001      	movs	r0, #1
 8003e24:	b00d      	add	sp, #52	; 0x34
 8003e26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08003e2c <DEV_GetFWTransferTypeFromFileName>:
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t DEV_GetFWTransferTypeFromFileName( CIFX_TOOLKIT_CHIPTYPE_E eChipType,
                                           char*                   pszFileName,
                                           uint32_t*               pulTransferType)
{
 8003e2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003e2e:	4606      	mov	r6, r0
 8003e30:	460c      	mov	r4, r1
 8003e32:	4617      	mov	r7, r2
  /* Check if we have a NXF or .NXM / .MOD extension */
  int32_t lRet = CIFX_NO_ERROR;

  int iStrlen = (int)OS_Strlen(pszFileName);
 8003e34:	4608      	mov	r0, r1
 8003e36:	f7fe ff5b 	bl	8002cf0 <OS_Strlen>
  if( iStrlen < CIFX_MIN_FILE_NAME_LENGTH)  /* At least x.abc */
 8003e3a:	2804      	cmp	r0, #4
 8003e3c:	dd2e      	ble.n	8003e9c <DEV_GetFWTransferTypeFromFileName+0x70>
 8003e3e:	4605      	mov	r5, r0
  {
    /* Check if we have a valid firmware file */
    lRet = CIFX_FILE_TYPE_INVALID;

    /* netX90/netX4000 files */
    if( (eCHIP_TYPE_NETX90   == eChipType) ||
 8003e40:	2e07      	cmp	r6, #7
 8003e42:	bf18      	it	ne
 8003e44:	2e09      	cmpne	r6, #9
 8003e46:	d107      	bne.n	8003e58 <DEV_GetFWTransferTypeFromFileName+0x2c>
        (eCHIP_TYPE_NETX4000 == eChipType) )
    {
      if (DEV_IsFWFileNetX90or4000( pszFileName))
 8003e48:	4620      	mov	r0, r4
 8003e4a:	f7ff feb9 	bl	8003bc0 <DEV_IsFWFileNetX90or4000>
 8003e4e:	b338      	cbz	r0, 8003ea0 <DEV_GetFWTransferTypeFromFileName+0x74>
      {
        /* Use file transfer type for netX90/4000 updates */
        *pulTransferType = HIL_FILE_XFER_FILE;
 8003e50:	2301      	movs	r3, #1
 8003e52:	603b      	str	r3, [r7, #0]
        lRet = CIFX_NO_ERROR;
 8003e54:	2000      	movs	r0, #0
      lRet = CIFX_NO_ERROR;
    }
  }

  return lRet;
}
 8003e56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    } else if (DEV_IsFWFile( pszFileName))
 8003e58:	4620      	mov	r0, r4
 8003e5a:	f7ff fe7d 	bl	8003b58 <DEV_IsFWFile>
 8003e5e:	b308      	cbz	r0, 8003ea4 <DEV_GetFWTransferTypeFromFileName+0x78>
      if ( (0 == OS_Strnicmp( HIL_FILE_EXTENSION_NXM_FIRMWARE, &pszFileName[iStrlen - 4], 4) ) ||
 8003e60:	3d04      	subs	r5, #4
 8003e62:	442c      	add	r4, r5
 8003e64:	2204      	movs	r2, #4
 8003e66:	4621      	mov	r1, r4
 8003e68:	480f      	ldr	r0, [pc, #60]	; (8003ea8 <DEV_GetFWTransferTypeFromFileName+0x7c>)
 8003e6a:	f7fe ff3d 	bl	8002ce8 <OS_Strnicmp>
 8003e6e:	b918      	cbnz	r0, 8003e78 <DEV_GetFWTransferTypeFromFileName+0x4c>
        *pulTransferType = HIL_FILE_XFER_MODULE;
 8003e70:	2302      	movs	r3, #2
 8003e72:	603b      	str	r3, [r7, #0]
      lRet = CIFX_NO_ERROR;
 8003e74:	2000      	movs	r0, #0
        *pulTransferType = HIL_FILE_XFER_MODULE;
 8003e76:	e7ee      	b.n	8003e56 <DEV_GetFWTransferTypeFromFileName+0x2a>
           (0 == OS_Strnicmp( HIL_FILE_EXTENSION_OPTION,       &pszFileName[iStrlen - 4], 4) ) ||
 8003e78:	2204      	movs	r2, #4
 8003e7a:	4621      	mov	r1, r4
 8003e7c:	480b      	ldr	r0, [pc, #44]	; (8003eac <DEV_GetFWTransferTypeFromFileName+0x80>)
 8003e7e:	f7fe ff33 	bl	8002ce8 <OS_Strnicmp>
      if ( (0 == OS_Strnicmp( HIL_FILE_EXTENSION_NXM_FIRMWARE, &pszFileName[iStrlen - 4], 4) ) ||
 8003e82:	2800      	cmp	r0, #0
 8003e84:	d0f4      	beq.n	8003e70 <DEV_GetFWTransferTypeFromFileName+0x44>
           (0 == OS_Strnicmp( ".MOD", &pszFileName[iStrlen - 4], 4) )  )
 8003e86:	2204      	movs	r2, #4
 8003e88:	4621      	mov	r1, r4
 8003e8a:	4809      	ldr	r0, [pc, #36]	; (8003eb0 <DEV_GetFWTransferTypeFromFileName+0x84>)
 8003e8c:	f7fe ff2c 	bl	8002ce8 <OS_Strnicmp>
           (0 == OS_Strnicmp( HIL_FILE_EXTENSION_OPTION,       &pszFileName[iStrlen - 4], 4) ) ||
 8003e90:	2800      	cmp	r0, #0
 8003e92:	d0ed      	beq.n	8003e70 <DEV_GetFWTransferTypeFromFileName+0x44>
        *pulTransferType = HIL_FILE_XFER_FILE;
 8003e94:	2301      	movs	r3, #1
 8003e96:	603b      	str	r3, [r7, #0]
      lRet = CIFX_NO_ERROR;
 8003e98:	2000      	movs	r0, #0
 8003e9a:	e7dc      	b.n	8003e56 <DEV_GetFWTransferTypeFromFileName+0x2a>
    lRet = CIFX_FILE_NAME_INVALID;
 8003e9c:	4805      	ldr	r0, [pc, #20]	; (8003eb4 <DEV_GetFWTransferTypeFromFileName+0x88>)
 8003e9e:	e7da      	b.n	8003e56 <DEV_GetFWTransferTypeFromFileName+0x2a>
    lRet = CIFX_FILE_TYPE_INVALID;
 8003ea0:	4805      	ldr	r0, [pc, #20]	; (8003eb8 <DEV_GetFWTransferTypeFromFileName+0x8c>)
 8003ea2:	e7d8      	b.n	8003e56 <DEV_GetFWTransferTypeFromFileName+0x2a>
 8003ea4:	4804      	ldr	r0, [pc, #16]	; (8003eb8 <DEV_GetFWTransferTypeFromFileName+0x8c>)
  return lRet;
 8003ea6:	e7d6      	b.n	8003e56 <DEV_GetFWTransferTypeFromFileName+0x2a>
 8003ea8:	0800ac5c 	.word	0x0800ac5c
 8003eac:	0800ac64 	.word	0x0800ac64
 8003eb0:	0800ac6c 	.word	0x0800ac6c
 8003eb4:	800a0010 	.word	0x800a0010
 8003eb8:	800a000f 	.word	0x800a000f

08003ebc <DEV_CheckForDownload>:
int32_t DEV_CheckForDownload( void* pvChannel, uint32_t ulChannelNumber, int* pfDownload,
                           char* pszFileName, void* pvFileData, uint32_t ulFileSize,
                           PFN_TRANSFER_PACKET   pfnTransferPacket,
                           PFN_RECV_PKT_CALLBACK pfnRecvPacket,
                           void*                 pvUser)
{
 8003ebc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003ec0:	f5ad 6d4f 	sub.w	sp, sp, #3312	; 0xcf0
 8003ec4:	4605      	mov	r5, r0
 8003ec6:	4688      	mov	r8, r1
 8003ec8:	4617      	mov	r7, r2
 8003eca:	461e      	mov	r6, r3
  int32_t          lRet          = CIFX_NO_ERROR;
  PCHANNELINSTANCE ptChannel     = (PCHANNELINSTANCE)pvChannel;
  PDEVICEINSTANCE  ptDevInstance = (PDEVICEINSTANCE)ptChannel->pvDeviceInstance;
 8003ecc:	f8d0 9000 	ldr.w	r9, [r0]
    CIFX_PACKET             tPacket;
    HIL_FILE_GET_MD5_CNF_T  tConf;
  }                         uConf;
  char*                     pbCopyPtr     = NULL;
  uint32_t                  ulCopySize    = 0;
  uint16_t                  usFileNameLen = (uint16_t)OS_Strlen(pszFileName);
 8003ed0:	4618      	mov	r0, r3
 8003ed2:	f7fe ff0d 	bl	8002cf0 <OS_Strlen>
 8003ed6:	b284      	uxth	r4, r0
  uint32_t                  ulSrc         = OS_GetMilliSecCounter(); /* Early versions used pvChannel as ulSrc,
 8003ed8:	f7fe fe3b 	bl	8002b52 <OS_GetMilliSecCounter>
 8003edc:	4682      	mov	sl, r0
                                                                        but this won't work on 64 Bit machines.
                                                                        As we need something unique we use the current system time */

  OS_Memset(&uSendPkt, 0, sizeof(uSendPkt));
 8003ede:	f240 623c 	movw	r2, #1596	; 0x63c
 8003ee2:	2100      	movs	r1, #0
 8003ee4:	f20d 60b4 	addw	r0, sp, #1716	; 0x6b4
 8003ee8:	f7fe fe19 	bl	8002b1e <OS_Memset>
  OS_Memset(&uConf,    0, sizeof(uConf));
 8003eec:	f240 623c 	movw	r2, #1596	; 0x63c
 8003ef0:	2100      	movs	r1, #0
 8003ef2:	a81e      	add	r0, sp, #120	; 0x78
 8003ef4:	f7fe fe13 	bl	8002b1e <OS_Memset>

  /* Set flag to download always necessary */
  *pfDownload = 1;
 8003ef8:	2301      	movs	r3, #1
 8003efa:	603b      	str	r3, [r7, #0]

  /* Initialize the message */
  uSendPkt.tRequest.tHead.ulSrc              = HOST_TO_LE32(ulSrc);
 8003efc:	f8cd a6b8 	str.w	sl, [sp, #1720]	; 0x6b8
  uSendPkt.tRequest.tHead.ulDest             = HOST_TO_LE32(HIL_PACKET_DEST_SYSTEM);
 8003f00:	2300      	movs	r3, #0
 8003f02:	f8cd 36b4 	str.w	r3, [sp, #1716]	; 0x6b4
  uSendPkt.tRequest.tHead.ulCmd              = HOST_TO_LE32(HIL_FILE_GET_MD5_REQ);
 8003f06:	f641 6268 	movw	r2, #7784	; 0x1e68
 8003f0a:	f8cd 26d0 	str.w	r2, [sp, #1744]	; 0x6d0
  uSendPkt.tRequest.tHead.ulExt              = HOST_TO_LE32(HIL_PACKET_SEQ_NONE);
 8003f0e:	f8cd 36d4 	str.w	r3, [sp, #1748]	; 0x6d4
  uSendPkt.tRequest.tHead.ulLen              = HOST_TO_LE32((uint32_t)(sizeof(uSendPkt.tRequest.tData) + usFileNameLen + 1));
 8003f12:	1de3      	adds	r3, r4, #7
 8003f14:	f8cd 36c4 	str.w	r3, [sp, #1732]	; 0x6c4
  uSendPkt.tRequest.tData.usFileNameLength   = HOST_TO_LE16( (uint16_t)(usFileNameLen + 1) );
 8003f18:	3401      	adds	r4, #1
 8003f1a:	b2a4      	uxth	r4, r4
 8003f1c:	f8ad 46e0 	strh.w	r4, [sp, #1760]	; 0x6e0
  uSendPkt.tRequest.tData.ulChannelNo        = HOST_TO_LE32(ulChannelNumber);
 8003f20:	f8cd 86dc 	str.w	r8, [sp, #1756]	; 0x6dc
  /* Setup copy buffer and copy size */
  pbCopyPtr   = ((char*)(&uSendPkt.tPacket.abData[0])) + sizeof(uSendPkt.tRequest.tData);
  ulCopySize  = min( (sizeof(uSendPkt.tPacket.abData) - sizeof(uSendPkt.tRequest.tData)), uSendPkt.tRequest.tData.usFileNameLength);

  /* Insert file name */
  (void)OS_Strncpy( pbCopyPtr, pszFileName, ulCopySize);
 8003f24:	f240 620e 	movw	r2, #1550	; 0x60e
 8003f28:	42a2      	cmp	r2, r4
 8003f2a:	bf28      	it	cs
 8003f2c:	4622      	movcs	r2, r4
 8003f2e:	4631      	mov	r1, r6
 8003f30:	f20d 60e2 	addw	r0, sp, #1762	; 0x6e2
 8003f34:	f7fe fee0 	bl	8002cf8 <OS_Strncpy>

  /* Read the MD5 from the system */
  lRet = pfnTransferPacket( pvChannel,
 8003f38:	f8dd 3d20 	ldr.w	r3, [sp, #3360]	; 0xd20
 8003f3c:	9302      	str	r3, [sp, #8]
 8003f3e:	f8dd 3d1c 	ldr.w	r3, [sp, #3356]	; 0xd1c
 8003f42:	9301      	str	r3, [sp, #4]
 8003f44:	f644 6320 	movw	r3, #20000	; 0x4e20
 8003f48:	9300      	str	r3, [sp, #0]
 8003f4a:	f240 633c 	movw	r3, #1596	; 0x63c
 8003f4e:	aa1e      	add	r2, sp, #120	; 0x78
 8003f50:	f20d 61b4 	addw	r1, sp, #1716	; 0x6b4
 8003f54:	4628      	mov	r0, r5
 8003f56:	f8dd 4d18 	ldr.w	r4, [sp, #3352]	; 0xd18
 8003f5a:	47a0      	blx	r4
                            (uint32_t)sizeof(uConf.tPacket),
                            CIFX_TO_FIRMWARE_START,       /* Could take a little while */
                            pfnRecvPacket,
                            pvUser);

  if(CIFX_NO_ERROR != lRet)
 8003f5c:	4604      	mov	r4, r0
 8003f5e:	b180      	cbz	r0, 8003f82 <DEV_CheckForDownload+0xc6>
  {
    /* Error reading MD5 checksum */
    if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8003f60:	4b28      	ldr	r3, [pc, #160]	; (8004004 <DEV_CheckForDownload+0x148>)
 8003f62:	681b      	ldr	r3, [r3, #0]
 8003f64:	f013 0f08 	tst.w	r3, #8
 8003f68:	d104      	bne.n	8003f74 <DEV_CheckForDownload+0xb8>
      }
    }
  }

  return lRet;
} /*lint !e429 : pvFileData not freed or returned */
 8003f6a:	4620      	mov	r0, r4
 8003f6c:	f50d 6d4f 	add.w	sp, sp, #3312	; 0xcf0
 8003f70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      USER_Trace(ptDevInstance,
 8003f74:	4603      	mov	r3, r0
 8003f76:	4a24      	ldr	r2, [pc, #144]	; (8004008 <DEV_CheckForDownload+0x14c>)
 8003f78:	2108      	movs	r1, #8
 8003f7a:	4648      	mov	r0, r9
 8003f7c:	f005 fb60 	bl	8009640 <USER_Trace>
 8003f80:	e7f3      	b.n	8003f6a <DEV_CheckForDownload+0xae>
  } else if(SUCCESS_HIL_OK != LE32_TO_HOST(uConf.tConf.tHead.ulSta))
 8003f82:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8003f84:	b153      	cbz	r3, 8003f9c <DEV_CheckForDownload+0xe0>
    if(g_ulTraceLevel & TRACE_LEVEL_INFO)
 8003f86:	4a1f      	ldr	r2, [pc, #124]	; (8004004 <DEV_CheckForDownload+0x148>)
 8003f88:	6812      	ldr	r2, [r2, #0]
 8003f8a:	f012 0f02 	tst.w	r2, #2
 8003f8e:	d0ec      	beq.n	8003f6a <DEV_CheckForDownload+0xae>
      USER_Trace(ptDevInstance,
 8003f90:	4a1e      	ldr	r2, [pc, #120]	; (800400c <DEV_CheckForDownload+0x150>)
 8003f92:	2102      	movs	r1, #2
 8003f94:	4648      	mov	r0, r9
 8003f96:	f005 fb53 	bl	8009640 <USER_Trace>
 8003f9a:	e7e6      	b.n	8003f6a <DEV_CheckForDownload+0xae>
    OS_Memset(abMd5, 0, sizeof(abMd5));
 8003f9c:	2210      	movs	r2, #16
 8003f9e:	2100      	movs	r1, #0
 8003fa0:	eb0d 0002 	add.w	r0, sp, r2
 8003fa4:	f7fe fdbb 	bl	8002b1e <OS_Memset>
    md5_init(&tMd5State);
 8003fa8:	a808      	add	r0, sp, #32
 8003faa:	f7ff fd43 	bl	8003a34 <md5_init>
    md5_append(&tMd5State, (md5_byte_t*)pvFileData, ulFileSize);
 8003fae:	f8dd 2d14 	ldr.w	r2, [sp, #3348]	; 0xd14
 8003fb2:	f8dd 1d10 	ldr.w	r1, [sp, #3344]	; 0xd10
 8003fb6:	a808      	add	r0, sp, #32
 8003fb8:	f7ff fd52 	bl	8003a60 <md5_append>
    md5_finish(&tMd5State, abMd5);
 8003fbc:	a904      	add	r1, sp, #16
 8003fbe:	a808      	add	r0, sp, #32
 8003fc0:	f7ff fd90 	bl	8003ae4 <md5_finish>
    if(OS_Memcmp(abMd5, uConf.tConf.tData.abMD5, sizeof(abMd5)) == 0)
 8003fc4:	2210      	movs	r2, #16
 8003fc6:	a928      	add	r1, sp, #160	; 0xa0
 8003fc8:	eb0d 0002 	add.w	r0, sp, r2
 8003fcc:	f7fe fdaf 	bl	8002b2e <OS_Memcmp>
 8003fd0:	b960      	cbnz	r0, 8003fec <DEV_CheckForDownload+0x130>
      *pfDownload = 0;
 8003fd2:	2300      	movs	r3, #0
 8003fd4:	603b      	str	r3, [r7, #0]
      if(g_ulTraceLevel & TRACE_LEVEL_INFO)
 8003fd6:	4b0b      	ldr	r3, [pc, #44]	; (8004004 <DEV_CheckForDownload+0x148>)
 8003fd8:	681b      	ldr	r3, [r3, #0]
 8003fda:	f013 0f02 	tst.w	r3, #2
 8003fde:	d0c4      	beq.n	8003f6a <DEV_CheckForDownload+0xae>
        USER_Trace(ptDevInstance,
 8003fe0:	4a0b      	ldr	r2, [pc, #44]	; (8004010 <DEV_CheckForDownload+0x154>)
 8003fe2:	2102      	movs	r1, #2
 8003fe4:	4648      	mov	r0, r9
 8003fe6:	f005 fb2b 	bl	8009640 <USER_Trace>
 8003fea:	e7be      	b.n	8003f6a <DEV_CheckForDownload+0xae>
      if(g_ulTraceLevel & TRACE_LEVEL_INFO)
 8003fec:	4b05      	ldr	r3, [pc, #20]	; (8004004 <DEV_CheckForDownload+0x148>)
 8003fee:	681b      	ldr	r3, [r3, #0]
 8003ff0:	f013 0f02 	tst.w	r3, #2
 8003ff4:	d0b9      	beq.n	8003f6a <DEV_CheckForDownload+0xae>
        USER_Trace(ptDevInstance,
 8003ff6:	4a07      	ldr	r2, [pc, #28]	; (8004014 <DEV_CheckForDownload+0x158>)
 8003ff8:	2102      	movs	r1, #2
 8003ffa:	4648      	mov	r0, r9
 8003ffc:	f005 fb20 	bl	8009640 <USER_Trace>
  return lRet;
 8004000:	e7b3      	b.n	8003f6a <DEV_CheckForDownload+0xae>
 8004002:	bf00      	nop
 8004004:	20000038 	.word	0x20000038
 8004008:	0800aca4 	.word	0x0800aca4
 800400c:	0800acd0 	.word	0x0800acd0
 8004010:	0800ad30 	.word	0x0800ad30
 8004014:	0800ad64 	.word	0x0800ad64

08004018 <DEV_DownloadFile>:
                         void*                 pvData,
                         PFN_TRANSFER_PACKET   pfnTransferPacket,
                         PFN_PROGRESS_CALLBACK pfnCallback,
                         PFN_RECV_PKT_CALLBACK pfnRecvPktCallback,
                         void*                 pvUser)
{
 8004018:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800401c:	f6ad 4dbc 	subw	sp, sp, #3260	; 0xcbc
 8004020:	9007      	str	r0, [sp, #28]
 8004022:	910e      	str	r1, [sp, #56]	; 0x38
 8004024:	920f      	str	r2, [sp, #60]	; 0x3c
 8004026:	930d      	str	r3, [sp, #52]	; 0x34
 8004028:	f8dd 8cf8 	ldr.w	r8, [sp, #3320]	; 0xcf8
    HIL_FILE_DOWNLOAD_DATA_CNF_T  tDownloadDataCnf;
    HIL_FILE_DOWNLOAD_ABORT_CNF_T tAbortCnf;
  }          uRecvPkt;

  /* Set download state informations */
  uint32_t   ulMaxDataLength     = ulMailboxSize -  /* Maximum possible user data length */
 800402c:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8004030:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t   ulCmdDataState      = HIL_PACKET_SEQ_NONE;
  int        fStopDownload       = 0;
  int32_t    lRetAbort           = CIFX_NO_ERROR;
  int32_t    lRet                = CIFX_NO_ERROR;
  uint32_t   ulCurrentId         = 0;
  uint32_t   ulSrc               = OS_GetMilliSecCounter(); /* Early versions used pvChannel as ulSrc,
 8004032:	f7fe fd8e 	bl	8002b52 <OS_GetMilliSecCounter>
 8004036:	9006      	str	r0, [sp, #24]
                                                               but this won't work on 64 Bit machines.
                                                               As we need something unique we use the current system time */
  uint32_t   ulTransferTimeout   = CIFX_TO_SEND_PACKET;

  OS_Memset(&uSendPkt, 0, sizeof(uSendPkt));
 8004038:	f240 623c 	movw	r2, #1596	; 0x63c
 800403c:	2100      	movs	r1, #0
 800403e:	f20d 607c 	addw	r0, sp, #1660	; 0x67c
 8004042:	f7fe fd6c 	bl	8002b1e <OS_Memset>
  OS_Memset(&uRecvPkt, 0, sizeof(uRecvPkt));
 8004046:	f240 623c 	movw	r2, #1596	; 0x63c
 800404a:	2100      	movs	r1, #0
 800404c:	a810      	add	r0, sp, #64	; 0x40
 800404e:	f7fe fd66 	bl	8002b1e <OS_Memset>

  /* Check parameters */
  if( NULL == pvData)
 8004052:	f8dd 3ce8 	ldr.w	r3, [sp, #3304]	; 0xce8
 8004056:	2b00      	cmp	r3, #0
 8004058:	f000 8190 	beq.w	800437c <DEV_DownloadFile+0x364>
    return CIFX_INVALID_POINTER;

  if( 0 == ulFileLength)
 800405c:	f8dd 3ce4 	ldr.w	r3, [sp, #3300]	; 0xce4
 8004060:	2b00      	cmp	r3, #0
 8004062:	f000 818d 	beq.w	8004380 <DEV_DownloadFile+0x368>
  uint32_t   ulTransferTimeout   = CIFX_TO_SEND_PACKET;
 8004066:	f241 3b88 	movw	fp, #5000	; 0x1388
  uint32_t   ulCurrentId         = 0;
 800406a:	2500      	movs	r5, #0
  int32_t    lRet                = CIFX_NO_ERROR;
 800406c:	462e      	mov	r6, r5
  int32_t    lRetAbort           = CIFX_NO_ERROR;
 800406e:	950a      	str	r5, [sp, #40]	; 0x28
  int        fStopDownload       = 0;
 8004070:	462f      	mov	r7, r5
  uint32_t   ulCmdDataState      = HIL_PACKET_SEQ_NONE;
 8004072:	9508      	str	r5, [sp, #32]
  uint32_t   ulState             = HIL_FILE_DOWNLOAD_REQ;
 8004074:	f641 6462 	movw	r4, #7778	; 0x1e62
  uint32_t   ulBlockNumber       = 0;
 8004078:	46a9      	mov	r9, r5
  uint32_t   ulCRC               = 0;
 800407a:	9509      	str	r5, [sp, #36]	; 0x24
  uint32_t   ulTransferedLength  = 0;
 800407c:	950b      	str	r5, [sp, #44]	; 0x2c
  uint32_t   ulSendLen           = 0;
 800407e:	46aa      	mov	sl, r5
 8004080:	9505      	str	r5, [sp, #20]
 8004082:	e14b      	b.n	800431c <DEV_DownloadFile+0x304>
    {
      /* Send download request */
      case HIL_FILE_DOWNLOAD_REQ:
      {
        /* Validate filename length to fit mailbox/packet */
        uint32_t ulFileNameLength = min( ((uint32_t)OS_Strlen(szFileName) + 1),
 8004084:	f8dd 0ce0 	ldr.w	r0, [sp, #3296]	; 0xce0
 8004088:	f7fe fe32 	bl	8002cf0 <OS_Strlen>
 800408c:	3001      	adds	r0, #1
 800408e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8004090:	f1a3 023a 	sub.w	r2, r3, #58	; 0x3a
 8004094:	4290      	cmp	r0, r2
 8004096:	d95d      	bls.n	8004154 <DEV_DownloadFile+0x13c>
                                          (ulMailboxSize - (uint32_t)sizeof(HIL_FILE_DOWNLOAD_REQ_T))); /*lint !e666 : function call OS_Strlen() */

        /* Insert packet data */
        ++ulCurrentId;
 8004098:	9805      	ldr	r0, [sp, #20]
 800409a:	3001      	adds	r0, #1
 800409c:	9005      	str	r0, [sp, #20]
        uSendPkt.tDownloadReq.tHead.ulDest   = HOST_TO_LE32(HIL_PACKET_DEST_SYSTEM);
 800409e:	2300      	movs	r3, #0
 80040a0:	f8cd 367c 	str.w	r3, [sp, #1660]	; 0x67c
        uSendPkt.tDownloadReq.tHead.ulSrc    = HOST_TO_LE32(ulSrc);
 80040a4:	9906      	ldr	r1, [sp, #24]
 80040a6:	f8cd 1680 	str.w	r1, [sp, #1664]	; 0x680
        uSendPkt.tDownloadReq.tHead.ulDestId = HOST_TO_LE32(0);
 80040aa:	f8cd 3684 	str.w	r3, [sp, #1668]	; 0x684
        uSendPkt.tDownloadReq.tHead.ulSrcId  = HOST_TO_LE32(0);
 80040ae:	f8cd 3688 	str.w	r3, [sp, #1672]	; 0x688
        uSendPkt.tDownloadReq.tHead.ulLen    = HOST_TO_LE32((uint32_t)(sizeof(HIL_FILE_DOWNLOAD_REQ_DATA_T) +
 80040b2:	f102 0112 	add.w	r1, r2, #18
 80040b6:	f8cd 168c 	str.w	r1, [sp, #1676]	; 0x68c
                                                                       ulFileNameLength));
        uSendPkt.tDownloadReq.tHead.ulId     = HOST_TO_LE32(ulCurrentId);
 80040ba:	f8cd 0690 	str.w	r0, [sp, #1680]	; 0x690
        uSendPkt.tDownloadReq.tHead.ulSta    = HOST_TO_LE32(0);
 80040be:	f8cd 3694 	str.w	r3, [sp, #1684]	; 0x694
        uSendPkt.tDownloadReq.tHead.ulCmd    = HOST_TO_LE32(HIL_FILE_DOWNLOAD_REQ);
 80040c2:	f641 6162 	movw	r1, #7778	; 0x1e62
 80040c6:	f8cd 1698 	str.w	r1, [sp, #1688]	; 0x698
        uSendPkt.tDownloadReq.tHead.ulExt    = HOST_TO_LE32(ulCmdDataState);
 80040ca:	9908      	ldr	r1, [sp, #32]
 80040cc:	f8cd 169c 	str.w	r1, [sp, #1692]	; 0x69c
        uSendPkt.tDownloadReq.tHead.ulRout   = HOST_TO_LE32(0);
 80040d0:	f8cd 36a0 	str.w	r3, [sp, #1696]	; 0x6a0

        /* Insert command data (extended data) */
        uSendPkt.tDownloadReq.tData.ulFileLength     = HOST_TO_LE32(ulFileLength);
 80040d4:	f8dd 3ce4 	ldr.w	r3, [sp, #3300]	; 0xce4
 80040d8:	f8cd 36ac 	str.w	r3, [sp, #1708]	; 0x6ac
        uSendPkt.tDownloadReq.tData.ulMaxBlockSize   = HOST_TO_LE32(ulMaxDataLength);
 80040dc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80040de:	f8cd 36a8 	str.w	r3, [sp, #1704]	; 0x6a8
        uSendPkt.tDownloadReq.tData.ulXferType       = HOST_TO_LE32(ulTransferType);
 80040e2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80040e4:	f8cd 36a4 	str.w	r3, [sp, #1700]	; 0x6a4
        uSendPkt.tDownloadReq.tData.ulChannelNo      = HOST_TO_LE32(ulChannel);
 80040e8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80040ea:	f8cd 36b0 	str.w	r3, [sp, #1712]	; 0x6b0
        uSendPkt.tDownloadReq.tData.usFileNameLength = HOST_TO_LE16((uint16_t)ulFileNameLength);
 80040ee:	b292      	uxth	r2, r2
 80040f0:	f8ad 26b4 	strh.w	r2, [sp, #1716]	; 0x6b4
        /* Setup copy buffer and copy size */
        pbCopyPtr   = ((char*)(&uSendPkt.tPacket.abData[0])) + sizeof(uSendPkt.tDownloadReq.tData);
        ulCopySize  = min( (sizeof(uSendPkt.tPacket.abData) - sizeof(uSendPkt.tDownloadReq.tData)), uSendPkt.tDownloadReq.tData.usFileNameLength);

        /* Insert file name */
        (void)OS_Strncpy( pbCopyPtr, szFileName, ulCopySize);
 80040f4:	f240 6302 	movw	r3, #1538	; 0x602
 80040f8:	429a      	cmp	r2, r3
 80040fa:	bf28      	it	cs
 80040fc:	461a      	movcs	r2, r3
 80040fe:	f8dd 1ce0 	ldr.w	r1, [sp, #3296]	; 0xce0
 8004102:	f20d 60b6 	addw	r0, sp, #1718	; 0x6b6
 8004106:	f7fe fdf7 	bl	8002cf8 <OS_Strncpy>

        /* Transfer packet */
        lRet = pfnTransferPacket(pvChannel,
 800410a:	f8cd 8008 	str.w	r8, [sp, #8]
 800410e:	f8dd 3cf4 	ldr.w	r3, [sp, #3316]	; 0xcf4
 8004112:	9301      	str	r3, [sp, #4]
 8004114:	f8cd b000 	str.w	fp, [sp]
 8004118:	f240 633c 	movw	r3, #1596	; 0x63c
 800411c:	aa10      	add	r2, sp, #64	; 0x40
 800411e:	f20d 617c 	addw	r1, sp, #1660	; 0x67c
 8004122:	9807      	ldr	r0, [sp, #28]
 8004124:	f8dd 4cec 	ldr.w	r4, [sp, #3308]	; 0xcec
 8004128:	47a0      	blx	r4
                                 (uint32_t)sizeof(uRecvPkt.tPacket),
                                 ulTransferTimeout,
                                 pfnRecvPktCallback,
                                 pvUser);

        if( (CIFX_NO_ERROR  != lRet)                                 ||
 800412a:	4606      	mov	r6, r0
 800412c:	b908      	cbnz	r0, 8004132 <DEV_DownloadFile+0x11a>
            (SUCCESS_HIL_OK != (lRet = LE32_TO_HOST((int32_t)uRecvPkt.tDownloadCnf.tHead.ulSta))) )
 800412e:	9e16      	ldr	r6, [sp, #88]	; 0x58
        if( (CIFX_NO_ERROR  != lRet)                                 ||
 8004130:	b1b6      	cbz	r6, 8004160 <DEV_DownloadFile+0x148>
        {
          /* Error during first packet, end download */
          /* Send progress notification */
          if(pfnCallback)
 8004132:	f8dd 3cf0 	ldr.w	r3, [sp, #3312]	; 0xcf0
 8004136:	2b00      	cmp	r3, #0
 8004138:	f000 8101 	beq.w	800433e <DEV_DownloadFile+0x326>
            pfnCallback(ulTransferedLength, ulFileLength, pvUser, CIFX_CALLBACK_FINISHED, lRet);
 800413c:	9600      	str	r6, [sp, #0]
 800413e:	2301      	movs	r3, #1
 8004140:	4642      	mov	r2, r8
 8004142:	f8dd 1ce4 	ldr.w	r1, [sp, #3300]	; 0xce4
 8004146:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8004148:	f8dd 4cf0 	ldr.w	r4, [sp, #3312]	; 0xcf0
 800414c:	47a0      	blx	r4

          /* Send abort request on unusable data */
          ulState = HIL_FILE_DOWNLOAD_ABORT_REQ;
 800414e:	f641 6466 	movw	r4, #7782	; 0x1e66
 8004152:	e0e2      	b.n	800431a <DEV_DownloadFile+0x302>
        uint32_t ulFileNameLength = min( ((uint32_t)OS_Strlen(szFileName) + 1),
 8004154:	f8dd 0ce0 	ldr.w	r0, [sp, #3296]	; 0xce0
 8004158:	f7fe fdca 	bl	8002cf0 <OS_Strlen>
 800415c:	1c42      	adds	r2, r0, #1
 800415e:	e79b      	b.n	8004098 <DEV_DownloadFile+0x80>
        } else if( LE32_TO_HOST(uRecvPkt.tDownloadCnf.tData.ulMaxBlockSize) == 0)
 8004160:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8004162:	b98b      	cbnz	r3, 8004188 <DEV_DownloadFile+0x170>
        {
          /* Error in device information, stop download (Device returned illegal block size */
          lRet = CIFX_INVALID_ACCESS_SIZE;

          /* Send progress notification */
          if(pfnCallback)
 8004164:	f8dd 3cf0 	ldr.w	r3, [sp, #3312]	; 0xcf0
 8004168:	2b00      	cmp	r3, #0
 800416a:	f000 80eb 	beq.w	8004344 <DEV_DownloadFile+0x32c>
            pfnCallback(ulTransferedLength, ulFileLength, pvUser, CIFX_CALLBACK_FINISHED, lRet);
 800416e:	4e85      	ldr	r6, [pc, #532]	; (8004384 <DEV_DownloadFile+0x36c>)
 8004170:	9600      	str	r6, [sp, #0]
 8004172:	2301      	movs	r3, #1
 8004174:	4642      	mov	r2, r8
 8004176:	f8dd 1ce4 	ldr.w	r1, [sp, #3300]	; 0xce4
 800417a:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800417c:	f8dd 4cf0 	ldr.w	r4, [sp, #3312]	; 0xcf0
 8004180:	47a0      	blx	r4

          /* Send abort request on unusable data */
          ulState = HIL_FILE_DOWNLOAD_ABORT_REQ;
 8004182:	f641 6466 	movw	r4, #7782	; 0x1e66
 8004186:	e0c8      	b.n	800431a <DEV_DownloadFile+0x302>
        {
          /* Everything went ok, so start transmitting file data now */
          /* Get download packet size from the device confirmation.
             If the devices packet size is smaller than our size, use the length from the device.
             Otherwise use our length. */
          if( ulMaxDataLength > LE32_TO_HOST(uRecvPkt.tDownloadCnf.tData.ulMaxBlockSize))
 8004188:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800418a:	4293      	cmp	r3, r2
 800418c:	d200      	bcs.n	8004190 <DEV_DownloadFile+0x178>
            ulMaxDataLength = LE32_TO_HOST(uRecvPkt.tDownloadCnf.tData.ulMaxBlockSize);
 800418e:	930c      	str	r3, [sp, #48]	; 0x30

          /* Check if the file fits into one packet or if we have to send multiple packets */
          ulSendLen = ulMaxDataLength;
          if(ulFileLength <= ulSendLen)
 8004190:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004192:	f8dd 2ce4 	ldr.w	r2, [sp, #3300]	; 0xce4
 8004196:	4293      	cmp	r3, r2
 8004198:	f0c0 80d8 	bcc.w	800434c <DEV_DownloadFile+0x334>
          {
            /* We have only one packet to send */
            ulSendLen       = ulFileLength;
 800419c:	4692      	mov	sl, r2
            ulCmdDataState  = HIL_PACKET_SEQ_NONE;
 800419e:	2300      	movs	r3, #0
 80041a0:	9308      	str	r3, [sp, #32]
            /* We have to send multiple packets */
            ulCmdDataState  = HIL_PACKET_SEQ_FIRST;
          }

          /* Goto next state */
          ulState = HIL_FILE_DOWNLOAD_DATA_REQ;
 80041a2:	f641 6464 	movw	r4, #7780	; 0x1e64
 80041a6:	e0b8      	b.n	800431a <DEV_DownloadFile+0x302>
      break;

      /* Data download packets */
      case HIL_FILE_DOWNLOAD_DATA_REQ:
      {
        ++ulCurrentId;
 80041a8:	9a05      	ldr	r2, [sp, #20]
 80041aa:	3201      	adds	r2, #1
 80041ac:	9205      	str	r2, [sp, #20]
        uSendPkt.tDownloadDataReq.tHead.ulDest     = HOST_TO_LE32(HIL_PACKET_DEST_SYSTEM);
 80041ae:	2300      	movs	r3, #0
 80041b0:	f8cd 367c 	str.w	r3, [sp, #1660]	; 0x67c
        uSendPkt.tDownloadDataReq.tHead.ulSrc      = HOST_TO_LE32(ulSrc);
 80041b4:	9b06      	ldr	r3, [sp, #24]
 80041b6:	f8cd 3680 	str.w	r3, [sp, #1664]	; 0x680
        uSendPkt.tDownloadDataReq.tHead.ulCmd      = HOST_TO_LE32(HIL_FILE_DOWNLOAD_DATA_REQ);
 80041ba:	f641 6364 	movw	r3, #7780	; 0x1e64
 80041be:	f8cd 3698 	str.w	r3, [sp, #1688]	; 0x698
        uSendPkt.tDownloadDataReq.tHead.ulId       = HOST_TO_LE32(ulCurrentId);
 80041c2:	f8cd 2690 	str.w	r2, [sp, #1680]	; 0x690
        uSendPkt.tDownloadDataReq.tHead.ulExt      = HOST_TO_LE32(ulCmdDataState);
 80041c6:	9b08      	ldr	r3, [sp, #32]
 80041c8:	f8cd 369c 	str.w	r3, [sp, #1692]	; 0x69c

        /* Copy file data to packet */
        OS_Memcpy( &uSendPkt.tDownloadDataReq.tData + 1, pabActData, ulSendLen);
 80041cc:	4652      	mov	r2, sl
 80041ce:	f8dd 1ce8 	ldr.w	r1, [sp, #3304]	; 0xce8
 80041d2:	f20d 60ac 	addw	r0, sp, #1708	; 0x6ac
 80041d6:	f7fe fca6 	bl	8002b26 <OS_Memcpy>

        /* Adjust packet length */
        uSendPkt.tDownloadDataReq.tHead.ulLen      = HOST_TO_LE32((uint32_t)(sizeof(HIL_FILE_DOWNLOAD_DATA_REQ_DATA_T) +
 80041da:	f10a 0308 	add.w	r3, sl, #8
 80041de:	f8cd 368c 	str.w	r3, [sp, #1676]	; 0x68c
                                                                             ulSendLen));

        /* Create continued CRC */
        ulCRC = CreateCRC32( ulCRC, pabActData, ulSendLen);
 80041e2:	4652      	mov	r2, sl
 80041e4:	f8dd 1ce8 	ldr.w	r1, [sp, #3304]	; 0xce8
 80041e8:	9809      	ldr	r0, [sp, #36]	; 0x24
 80041ea:	f7ff f88b 	bl	8003304 <CreateCRC32>
 80041ee:	9009      	str	r0, [sp, #36]	; 0x24
        uSendPkt.tDownloadDataReq.tData.ulChksum   = HOST_TO_LE32(ulCRC);
 80041f0:	f8cd 06a8 	str.w	r0, [sp, #1704]	; 0x6a8
        uSendPkt.tDownloadDataReq.tData.ulBlockNo  = HOST_TO_LE32(ulBlockNumber);
 80041f4:	f8cd 96a4 	str.w	r9, [sp, #1700]	; 0x6a4
        ++ulBlockNumber;
 80041f8:	f109 0901 	add.w	r9, r9, #1

        /* Transfer packet */
        lRet = pfnTransferPacket(pvChannel,
 80041fc:	f8cd 8008 	str.w	r8, [sp, #8]
 8004200:	f8dd 3cf4 	ldr.w	r3, [sp, #3316]	; 0xcf4
 8004204:	9301      	str	r3, [sp, #4]
 8004206:	f8cd b000 	str.w	fp, [sp]
 800420a:	f240 633c 	movw	r3, #1596	; 0x63c
 800420e:	aa10      	add	r2, sp, #64	; 0x40
 8004210:	f20d 617c 	addw	r1, sp, #1660	; 0x67c
 8004214:	9807      	ldr	r0, [sp, #28]
 8004216:	f8dd 6cec 	ldr.w	r6, [sp, #3308]	; 0xcec
 800421a:	47b0      	blx	r6
                                (uint32_t)sizeof(uRecvPkt.tPacket),
                                ulTransferTimeout,
                                pfnRecvPktCallback,
                                pvUser);

        if( (CIFX_NO_ERROR  != lRet)                                   ||
 800421c:	4606      	mov	r6, r0
 800421e:	b908      	cbnz	r0, 8004224 <DEV_DownloadFile+0x20c>
            (SUCCESS_HIL_OK != (lRet = LE32_TO_HOST((int32_t)(uRecvPkt.tDownloadDataCnf.tHead.ulSta)))) )
 8004220:	9e16      	ldr	r6, [sp, #88]	; 0x58
        if( (CIFX_NO_ERROR  != lRet)                                   ||
 8004222:	b186      	cbz	r6, 8004246 <DEV_DownloadFile+0x22e>
        {
          /* Driver error during transfer packet, end download */
          /* Always try to send an abort request */
          if(pfnCallback)
 8004224:	f8dd 3cf0 	ldr.w	r3, [sp, #3312]	; 0xcf0
 8004228:	2b00      	cmp	r3, #0
 800422a:	f000 8096 	beq.w	800435a <DEV_DownloadFile+0x342>
            pfnCallback(ulTransferedLength, ulFileLength, pvUser, CIFX_CALLBACK_FINISHED, lRet);
 800422e:	9600      	str	r6, [sp, #0]
 8004230:	2301      	movs	r3, #1
 8004232:	4642      	mov	r2, r8
 8004234:	f8dd 1ce4 	ldr.w	r1, [sp, #3300]	; 0xce4
 8004238:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800423a:	f8dd 4cf0 	ldr.w	r4, [sp, #3312]	; 0xcf0
 800423e:	47a0      	blx	r4

          ulState = HIL_FILE_DOWNLOAD_ABORT_REQ;
 8004240:	f641 6466 	movw	r4, #7782	; 0x1e66
 8004244:	e069      	b.n	800431a <DEV_DownloadFile+0x302>
        } else
        {
          /* Add send size to transferred size */
          ulTransferedLength += ulSendLen;
 8004246:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8004248:	4453      	add	r3, sl
 800424a:	4618      	mov	r0, r3
 800424c:	930b      	str	r3, [sp, #44]	; 0x2c

          /* Indicate progress, if user wants a notification */
          if(pfnCallback)
 800424e:	f8dd 2cf0 	ldr.w	r2, [sp, #3312]	; 0xcf0
 8004252:	b162      	cbz	r2, 800426e <DEV_DownloadFile+0x256>
            pfnCallback(ulTransferedLength, ulFileLength, pvUser,
 8004254:	9600      	str	r6, [sp, #0]
 8004256:	f8dd 2ce4 	ldr.w	r2, [sp, #3300]	; 0xce4
 800425a:	429a      	cmp	r2, r3
 800425c:	bf14      	ite	ne
 800425e:	2300      	movne	r3, #0
 8004260:	2301      	moveq	r3, #1
 8004262:	4642      	mov	r2, r8
 8004264:	f8dd 1ce4 	ldr.w	r1, [sp, #3300]	; 0xce4
 8004268:	f8dd 5cf0 	ldr.w	r5, [sp, #3312]	; 0xcf0
 800426c:	47a8      	blx	r5
                        (ulTransferedLength == ulFileLength) ? CIFX_CALLBACK_FINISHED : CIFX_CALLBACK_ACTIVE,
                        lRet);

          /* Check if we are done with the download */
          if( (HIL_PACKET_SEQ_LAST == ulCmdDataState) ||
 800426e:	9b08      	ldr	r3, [sp, #32]
 8004270:	2b00      	cmp	r3, #0
 8004272:	bf18      	it	ne
 8004274:	2b40      	cmpne	r3, #64	; 0x40
 8004276:	d073      	beq.n	8004360 <DEV_DownloadFile+0x348>
            /* No more packets to send, end download */
            fStopDownload = 1;
          } else
          {
            /* Move data pointer to next data */
            pabActData += ulSendLen;
 8004278:	f8dd 3ce8 	ldr.w	r3, [sp, #3304]	; 0xce8
 800427c:	4453      	add	r3, sl
 800427e:	f8cd 3ce8 	str.w	r3, [sp, #3304]	; 0xce8

            /* Calculate next message length */
            if ( ulFileLength <= (ulSendLen + ulTransferedLength))
 8004282:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8004284:	eb0a 0302 	add.w	r3, sl, r2
 8004288:	f8dd 1ce4 	ldr.w	r1, [sp, #3300]	; 0xce4
 800428c:	428b      	cmp	r3, r1
 800428e:	d369      	bcc.n	8004364 <DEV_DownloadFile+0x34c>
            {
              /* Set the send length to rest of data,
                 This will be the last packet */
              ulSendLen = ulFileLength - ulTransferedLength;
 8004290:	eba1 0a02 	sub.w	sl, r1, r2
              ulCmdDataState = HIL_PACKET_SEQ_LAST;

              /* ATTENTION: Check the transfer type */
              if ( HIL_FILE_XFER_MODULE == ulTransferType)
 8004294:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8004296:	2b02      	cmp	r3, #2
 8004298:	d002      	beq.n	80042a0 <DEV_DownloadFile+0x288>
              ulCmdDataState = HIL_PACKET_SEQ_LAST;
 800429a:	2340      	movs	r3, #64	; 0x40
 800429c:	9308      	str	r3, [sp, #32]
 800429e:	e03c      	b.n	800431a <DEV_DownloadFile+0x302>
                /* Module loading will relocate the module with the last packet.
                   So the confirmation packet takes longer, depending on the
                   file size (and contained firmware).
                   Measurements showed that for every 100kB the module needs
                   one additional second for relocation */
                ulTransferTimeout += (ulFileLength / (100 * 1024)) * 1000;
 80042a0:	4b39      	ldr	r3, [pc, #228]	; (8004388 <DEV_DownloadFile+0x370>)
 80042a2:	460a      	mov	r2, r1
 80042a4:	fba3 2302 	umull	r2, r3, r3, r2
 80042a8:	0bdb      	lsrs	r3, r3, #15
 80042aa:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80042ae:	fb02 bb03 	mla	fp, r2, r3, fp
              ulCmdDataState = HIL_PACKET_SEQ_LAST;
 80042b2:	2340      	movs	r3, #64	; 0x40
 80042b4:	9308      	str	r3, [sp, #32]
 80042b6:	e030      	b.n	800431a <DEV_DownloadFile+0x302>
      break;

      /* Abort active download */
      case HIL_FILE_DOWNLOAD_ABORT_REQ:
      {
        ++ulCurrentId;
 80042b8:	9a05      	ldr	r2, [sp, #20]
 80042ba:	3201      	adds	r2, #1
 80042bc:	4611      	mov	r1, r2
 80042be:	9205      	str	r2, [sp, #20]
        uSendPkt.tAbortReq.tHead.ulDest   = HOST_TO_LE32(HIL_PACKET_DEST_SYSTEM);
 80042c0:	2300      	movs	r3, #0
 80042c2:	f8cd 367c 	str.w	r3, [sp, #1660]	; 0x67c
        uSendPkt.tAbortReq.tHead.ulSrc    = HOST_TO_LE32(ulSrc);
 80042c6:	9a06      	ldr	r2, [sp, #24]
 80042c8:	f8cd 2680 	str.w	r2, [sp, #1664]	; 0x680
        uSendPkt.tAbortReq.tHead.ulDestId = HOST_TO_LE32(0);
 80042cc:	f8cd 3684 	str.w	r3, [sp, #1668]	; 0x684
        uSendPkt.tAbortReq.tHead.ulSrcId  = HOST_TO_LE32(0);
 80042d0:	f8cd 3688 	str.w	r3, [sp, #1672]	; 0x688
        uSendPkt.tAbortReq.tHead.ulLen    = HOST_TO_LE32(0);
 80042d4:	f8cd 368c 	str.w	r3, [sp, #1676]	; 0x68c
        uSendPkt.tAbortReq.tHead.ulId     = HOST_TO_LE32(ulCurrentId);
 80042d8:	f8cd 1690 	str.w	r1, [sp, #1680]	; 0x690
        uSendPkt.tAbortReq.tHead.ulSta    = HOST_TO_LE32(0);
 80042dc:	f8cd 3694 	str.w	r3, [sp, #1684]	; 0x694
        uSendPkt.tAbortReq.tHead.ulCmd    = HOST_TO_LE32(HIL_FILE_DOWNLOAD_ABORT_REQ);
 80042e0:	f641 6266 	movw	r2, #7782	; 0x1e66
 80042e4:	f8cd 2698 	str.w	r2, [sp, #1688]	; 0x698
        uSendPkt.tAbortReq.tHead.ulExt    = HOST_TO_LE32(HIL_PACKET_SEQ_NONE);
 80042e8:	f8cd 369c 	str.w	r3, [sp, #1692]	; 0x69c
        uSendPkt.tAbortReq.tHead.ulRout   = HOST_TO_LE32(0);
 80042ec:	f8cd 36a0 	str.w	r3, [sp, #1696]	; 0x6a0

        /* Transfer packet */
        lRetAbort = pfnTransferPacket(pvChannel,
 80042f0:	f8cd 8008 	str.w	r8, [sp, #8]
 80042f4:	f8dd 3cf4 	ldr.w	r3, [sp, #3316]	; 0xcf4
 80042f8:	9301      	str	r3, [sp, #4]
 80042fa:	f8cd b000 	str.w	fp, [sp]
 80042fe:	f240 633c 	movw	r3, #1596	; 0x63c
 8004302:	aa10      	add	r2, sp, #64	; 0x40
 8004304:	f20d 617c 	addw	r1, sp, #1660	; 0x67c
 8004308:	9807      	ldr	r0, [sp, #28]
 800430a:	f8dd 7cec 	ldr.w	r7, [sp, #3308]	; 0xcec
 800430e:	47b8      	blx	r7
                                      (uint32_t)sizeof(uRecvPkt.tPacket),
                                      ulTransferTimeout,
                                      pfnRecvPktCallback,
                                      pvUser);

        if( lRetAbort == CIFX_NO_ERROR)
 8004310:	900a      	str	r0, [sp, #40]	; 0x28
 8004312:	bb50      	cbnz	r0, 800436a <DEV_DownloadFile+0x352>
        {
          /* Return packet state if function succeeded */
          lRetAbort = LE32_TO_HOST((int32_t)uRecvPkt.tAbortCnf.tHead.ulSta);
 8004314:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8004316:	930a      	str	r3, [sp, #40]	; 0x28
        }

        /* End download */
        fStopDownload = 1;
 8004318:	2701      	movs	r7, #1
        /* End download */
        fStopDownload = 1;
        break;
    }

  } while(!fStopDownload);
 800431a:	bb47      	cbnz	r7, 800436e <DEV_DownloadFile+0x356>
    switch (ulState)
 800431c:	f641 6364 	movw	r3, #7780	; 0x1e64
 8004320:	429c      	cmp	r4, r3
 8004322:	f43f af41 	beq.w	80041a8 <DEV_DownloadFile+0x190>
 8004326:	f641 6366 	movw	r3, #7782	; 0x1e66
 800432a:	429c      	cmp	r4, r3
 800432c:	d0c4      	beq.n	80042b8 <DEV_DownloadFile+0x2a0>
 800432e:	f641 6362 	movw	r3, #7778	; 0x1e62
 8004332:	429c      	cmp	r4, r3
 8004334:	f43f aea6 	beq.w	8004084 <DEV_DownloadFile+0x6c>
 8004338:	4e14      	ldr	r6, [pc, #80]	; (800438c <DEV_DownloadFile+0x374>)
 800433a:	2701      	movs	r7, #1
 800433c:	e7ed      	b.n	800431a <DEV_DownloadFile+0x302>
          ulState = HIL_FILE_DOWNLOAD_ABORT_REQ;
 800433e:	f641 6466 	movw	r4, #7782	; 0x1e66
 8004342:	e7ea      	b.n	800431a <DEV_DownloadFile+0x302>
          lRet = CIFX_INVALID_ACCESS_SIZE;
 8004344:	4e0f      	ldr	r6, [pc, #60]	; (8004384 <DEV_DownloadFile+0x36c>)
          ulState = HIL_FILE_DOWNLOAD_ABORT_REQ;
 8004346:	f641 6466 	movw	r4, #7782	; 0x1e66
 800434a:	e7e6      	b.n	800431a <DEV_DownloadFile+0x302>
          ulSendLen = ulMaxDataLength;
 800434c:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
            ulCmdDataState  = HIL_PACKET_SEQ_FIRST;
 8004350:	2380      	movs	r3, #128	; 0x80
 8004352:	9308      	str	r3, [sp, #32]
          ulState = HIL_FILE_DOWNLOAD_DATA_REQ;
 8004354:	f641 6464 	movw	r4, #7780	; 0x1e64
 8004358:	e7df      	b.n	800431a <DEV_DownloadFile+0x302>
          ulState = HIL_FILE_DOWNLOAD_ABORT_REQ;
 800435a:	f641 6466 	movw	r4, #7782	; 0x1e66
 800435e:	e7dc      	b.n	800431a <DEV_DownloadFile+0x302>
            fStopDownload = 1;
 8004360:	2701      	movs	r7, #1
 8004362:	e7da      	b.n	800431a <DEV_DownloadFile+0x302>
              ulCmdDataState = HIL_PACKET_SEQ_MIDDLE;
 8004364:	23c0      	movs	r3, #192	; 0xc0
 8004366:	9308      	str	r3, [sp, #32]
 8004368:	e7d7      	b.n	800431a <DEV_DownloadFile+0x302>
        fStopDownload = 1;
 800436a:	2701      	movs	r7, #1
 800436c:	e7d5      	b.n	800431a <DEV_DownloadFile+0x302>

  /* Always return lRet first, then abort error */
  if( CIFX_NO_ERROR != lRet)
 800436e:	b906      	cbnz	r6, 8004372 <DEV_DownloadFile+0x35a>
    return lRet;
  else if( CIFX_NO_ERROR != lRetAbort)
    return lRetAbort;
  else
    return CIFX_NO_ERROR;
 8004370:	9e0a      	ldr	r6, [sp, #40]	; 0x28
} /*lint !e429 : pvData not freed or returned */
 8004372:	4630      	mov	r0, r6
 8004374:	f60d 4dbc 	addw	sp, sp, #3260	; 0xcbc
 8004378:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return CIFX_INVALID_POINTER;
 800437c:	4e04      	ldr	r6, [pc, #16]	; (8004390 <DEV_DownloadFile+0x378>)
 800437e:	e7f8      	b.n	8004372 <DEV_DownloadFile+0x35a>
    return CIFX_INVALID_PARAMETER;
 8004380:	4e04      	ldr	r6, [pc, #16]	; (8004394 <DEV_DownloadFile+0x37c>)
 8004382:	e7f6      	b.n	8004372 <DEV_DownloadFile+0x35a>
 8004384:	800a0008 	.word	0x800a0008
 8004388:	51eb851f 	.word	0x51eb851f
 800438c:	800a0009 	.word	0x800a0009
 8004390:	800a0001 	.word	0x800a0001
 8004394:	800a0005 	.word	0x800a0005

08004398 <DEV_ProcessFWDownload>:
{
 8004398:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800439c:	b08b      	sub	sp, #44	; 0x2c
 800439e:	4604      	mov	r4, r0
 80043a0:	460e      	mov	r6, r1
 80043a2:	4690      	mov	r8, r2
 80043a4:	461d      	mov	r5, r3
 80043a6:	9f16      	ldr	r7, [sp, #88]	; 0x58
  PCHANNELINSTANCE ptSysDevice = &ptDevInstance->tSystemDevice;
 80043a8:	f100 0af4 	add.w	sl, r0, #244	; 0xf4
  *pbLoadState  =  CIFXTKIT_DOWNLOAD_NONE;
 80043ac:	2300      	movs	r3, #0
 80043ae:	703b      	strb	r3, [r7, #0]
  switch (ptDevInstance->eDeviceType)
 80043b0:	7d03      	ldrb	r3, [r0, #20]
 80043b2:	2b02      	cmp	r3, #2
 80043b4:	d00d      	beq.n	80043d2 <DEV_ProcessFWDownload+0x3a>
 80043b6:	2b03      	cmp	r3, #3
 80043b8:	d070      	beq.n	800449c <DEV_ProcessFWDownload+0x104>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80043ba:	4aa3      	ldr	r2, [pc, #652]	; (8004648 <DEV_ProcessFWDownload+0x2b0>)
 80043bc:	6812      	ldr	r2, [r2, #0]
 80043be:	f012 0f08 	tst.w	r2, #8
 80043c2:	f040 8155 	bne.w	8004670 <DEV_ProcessFWDownload+0x2d8>
  int32_t          lRet        = CIFX_NO_ERROR;
 80043c6:	f04f 0900 	mov.w	r9, #0
} /*lint !e429 : pbBuffer not freed or returned */
 80043ca:	4648      	mov	r0, r9
 80043cc:	b00b      	add	sp, #44	; 0x2c
 80043ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if( DEV_IsNXFFile(pszFileName) &&
 80043d2:	4628      	mov	r0, r5
 80043d4:	f7ff fc4c 	bl	8003c70 <DEV_IsNXFFile>
 80043d8:	b188      	cbz	r0, 80043fe <DEV_ProcessFWDownload+0x66>
 80043da:	b186      	cbz	r6, 80043fe <DEV_ProcessFWDownload+0x66>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80043dc:	4b9a      	ldr	r3, [pc, #616]	; (8004648 <DEV_ProcessFWDownload+0x2b0>)
 80043de:	681b      	ldr	r3, [r3, #0]
 80043e0:	f013 0f08 	tst.w	r3, #8
 80043e4:	d102      	bne.n	80043ec <DEV_ProcessFWDownload+0x54>
  int32_t          lRet        = CIFX_NO_ERROR;
 80043e6:	f04f 0900 	mov.w	r9, #0
 80043ea:	e7ee      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
          USER_Trace(ptDevInstance,
 80043ec:	4633      	mov	r3, r6
 80043ee:	4a97      	ldr	r2, [pc, #604]	; (800464c <DEV_ProcessFWDownload+0x2b4>)
 80043f0:	2108      	movs	r1, #8
 80043f2:	4620      	mov	r0, r4
 80043f4:	f005 f924 	bl	8009640 <USER_Trace>
  int32_t          lRet        = CIFX_NO_ERROR;
 80043f8:	f04f 0900 	mov.w	r9, #0
 80043fc:	e7e5      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
      } else if( DEV_IsNXOFile(pszFileName) &&
 80043fe:	4628      	mov	r0, r5
 8004400:	f7ff fc20 	bl	8003c44 <DEV_IsNXOFile>
 8004404:	b178      	cbz	r0, 8004426 <DEV_ProcessFWDownload+0x8e>
                 (!ptDevInstance->fModuleLoad))
 8004406:	f8d4 9010 	ldr.w	r9, [r4, #16]
      } else if( DEV_IsNXOFile(pszFileName) &&
 800440a:	f1b9 0f00 	cmp.w	r9, #0
 800440e:	d10a      	bne.n	8004426 <DEV_ProcessFWDownload+0x8e>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8004410:	4b8d      	ldr	r3, [pc, #564]	; (8004648 <DEV_ProcessFWDownload+0x2b0>)
 8004412:	681b      	ldr	r3, [r3, #0]
 8004414:	f013 0f08 	tst.w	r3, #8
 8004418:	d0d7      	beq.n	80043ca <DEV_ProcessFWDownload+0x32>
          USER_Trace(ptDevInstance,
 800441a:	4a8d      	ldr	r2, [pc, #564]	; (8004650 <DEV_ProcessFWDownload+0x2b8>)
 800441c:	2108      	movs	r1, #8
 800441e:	4620      	mov	r0, r4
 8004420:	f005 f90e 	bl	8009640 <USER_Trace>
 8004424:	e7d1      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
        lRet = DEV_DownloadFile(ptSysDevice,
 8004426:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8004428:	9306      	str	r3, [sp, #24]
 800442a:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800442c:	9305      	str	r3, [sp, #20]
 800442e:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8004430:	9304      	str	r3, [sp, #16]
 8004432:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8004434:	9303      	str	r3, [sp, #12]
 8004436:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8004438:	9302      	str	r3, [sp, #8]
 800443a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800443c:	9301      	str	r3, [sp, #4]
 800443e:	9500      	str	r5, [sp, #0]
 8004440:	2302      	movs	r3, #2
 8004442:	f8d4 216c 	ldr.w	r2, [r4, #364]	; 0x16c
 8004446:	4631      	mov	r1, r6
 8004448:	4650      	mov	r0, sl
 800444a:	f7ff fde5 	bl	8004018 <DEV_DownloadFile>
        if(CIFX_NO_ERROR != lRet)
 800444e:	4681      	mov	r9, r0
 8004450:	b160      	cbz	r0, 800446c <DEV_ProcessFWDownload+0xd4>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8004452:	4b7d      	ldr	r3, [pc, #500]	; (8004648 <DEV_ProcessFWDownload+0x2b0>)
 8004454:	681b      	ldr	r3, [r3, #0]
 8004456:	f013 0f08 	tst.w	r3, #8
 800445a:	d0b6      	beq.n	80043ca <DEV_ProcessFWDownload+0x32>
            USER_Trace(ptDevInstance,
 800445c:	9000      	str	r0, [sp, #0]
 800445e:	4643      	mov	r3, r8
 8004460:	4a7c      	ldr	r2, [pc, #496]	; (8004654 <DEV_ProcessFWDownload+0x2bc>)
 8004462:	2108      	movs	r1, #8
 8004464:	4620      	mov	r0, r4
 8004466:	f005 f8eb 	bl	8009640 <USER_Trace>
 800446a:	e7ae      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
          if ( DEV_IsNXFFile( pszFileName))
 800446c:	4628      	mov	r0, r5
 800446e:	f7ff fbff 	bl	8003c70 <DEV_IsNXFFile>
 8004472:	b108      	cbz	r0, 8004478 <DEV_ProcessFWDownload+0xe0>
            *pbLoadState = CIFXTKIT_DOWNLOAD_FIRMWARE | CIFXTKIT_DOWNLOAD_EXECUTED; /* we have a firmware loaded */
 8004474:	2381      	movs	r3, #129	; 0x81
 8004476:	703b      	strb	r3, [r7, #0]
          if ( DEV_IsNXOFile( pszFileName))
 8004478:	4628      	mov	r0, r5
 800447a:	f7ff fbe3 	bl	8003c44 <DEV_IsNXOFile>
 800447e:	b108      	cbz	r0, 8004484 <DEV_ProcessFWDownload+0xec>
            *pbLoadState = CIFXTKIT_DOWNLOAD_MODULE  | CIFXTKIT_DOWNLOAD_EXECUTED;  /* we have a module loaded */
 8004480:	2382      	movs	r3, #130	; 0x82
 8004482:	703b      	strb	r3, [r7, #0]
          if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8004484:	4b70      	ldr	r3, [pc, #448]	; (8004648 <DEV_ProcessFWDownload+0x2b0>)
 8004486:	681b      	ldr	r3, [r3, #0]
 8004488:	f013 0f01 	tst.w	r3, #1
 800448c:	d09d      	beq.n	80043ca <DEV_ProcessFWDownload+0x32>
            USER_Trace(ptDevInstance,
 800448e:	4643      	mov	r3, r8
 8004490:	4a71      	ldr	r2, [pc, #452]	; (8004658 <DEV_ProcessFWDownload+0x2c0>)
 8004492:	2101      	movs	r1, #1
 8004494:	4620      	mov	r0, r4
 8004496:	f005 f8d3 	bl	8009640 <USER_Trace>
 800449a:	e796      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
      int      fDownload       = 0;
 800449c:	2300      	movs	r3, #0
 800449e:	9309      	str	r3, [sp, #36]	; 0x24
      if ( CIFX_NO_ERROR != (lRet = DEV_CheckForDownload( ptSysDevice,
 80044a0:	9304      	str	r3, [sp, #16]
 80044a2:	9303      	str	r3, [sp, #12]
 80044a4:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80044a6:	9302      	str	r3, [sp, #8]
 80044a8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80044aa:	9301      	str	r3, [sp, #4]
 80044ac:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80044ae:	9300      	str	r3, [sp, #0]
 80044b0:	462b      	mov	r3, r5
 80044b2:	aa09      	add	r2, sp, #36	; 0x24
 80044b4:	4650      	mov	r0, sl
 80044b6:	f7ff fd01 	bl	8003ebc <DEV_CheckForDownload>
 80044ba:	4681      	mov	r9, r0
 80044bc:	b158      	cbz	r0, 80044d6 <DEV_ProcessFWDownload+0x13e>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80044be:	4b62      	ldr	r3, [pc, #392]	; (8004648 <DEV_ProcessFWDownload+0x2b0>)
 80044c0:	681b      	ldr	r3, [r3, #0]
 80044c2:	f013 0f08 	tst.w	r3, #8
 80044c6:	d080      	beq.n	80043ca <DEV_ProcessFWDownload+0x32>
          USER_Trace(ptDevInstance,
 80044c8:	4643      	mov	r3, r8
 80044ca:	4a64      	ldr	r2, [pc, #400]	; (800465c <DEV_ProcessFWDownload+0x2c4>)
 80044cc:	2108      	movs	r1, #8
 80044ce:	4620      	mov	r0, r4
 80044d0:	f005 f8b6 	bl	8009640 <USER_Trace>
 80044d4:	e779      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
      } else if(!fDownload)
 80044d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80044d8:	bb6b      	cbnz	r3, 8004536 <DEV_ProcessFWDownload+0x19e>
        if(DEV_IsNXOFile(pszFileName))
 80044da:	4628      	mov	r0, r5
 80044dc:	f7ff fbb2 	bl	8003c44 <DEV_IsNXOFile>
 80044e0:	b300      	cbz	r0, 8004524 <DEV_ProcessFWDownload+0x18c>
          if( !ptDevInstance->fModuleLoad)
 80044e2:	6923      	ldr	r3, [r4, #16]
 80044e4:	b97b      	cbnz	r3, 8004506 <DEV_ProcessFWDownload+0x16e>
            if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80044e6:	4b58      	ldr	r3, [pc, #352]	; (8004648 <DEV_ProcessFWDownload+0x2b0>)
 80044e8:	681b      	ldr	r3, [r3, #0]
 80044ea:	f013 0f08 	tst.w	r3, #8
 80044ee:	d102      	bne.n	80044f6 <DEV_ProcessFWDownload+0x15e>
            lRet = CIFX_FILE_TYPE_INVALID;
 80044f0:	f8df 9174 	ldr.w	r9, [pc, #372]	; 8004668 <DEV_ProcessFWDownload+0x2d0>
 80044f4:	e769      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
              USER_Trace(ptDevInstance,
 80044f6:	4a56      	ldr	r2, [pc, #344]	; (8004650 <DEV_ProcessFWDownload+0x2b8>)
 80044f8:	2108      	movs	r1, #8
 80044fa:	4620      	mov	r0, r4
 80044fc:	f005 f8a0 	bl	8009640 <USER_Trace>
            lRet = CIFX_FILE_TYPE_INVALID;
 8004500:	f8df 9164 	ldr.w	r9, [pc, #356]	; 8004668 <DEV_ProcessFWDownload+0x2d0>
 8004504:	e761      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
            if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8004506:	4b50      	ldr	r3, [pc, #320]	; (8004648 <DEV_ProcessFWDownload+0x2b0>)
 8004508:	681b      	ldr	r3, [r3, #0]
 800450a:	f013 0f01 	tst.w	r3, #1
 800450e:	d102      	bne.n	8004516 <DEV_ProcessFWDownload+0x17e>
            *pbLoadState = CIFXTKIT_DOWNLOAD_MODULE;
 8004510:	2302      	movs	r3, #2
 8004512:	703b      	strb	r3, [r7, #0]
 8004514:	e759      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
              USER_Trace(ptDevInstance,
 8004516:	4643      	mov	r3, r8
 8004518:	4a51      	ldr	r2, [pc, #324]	; (8004660 <DEV_ProcessFWDownload+0x2c8>)
 800451a:	2101      	movs	r1, #1
 800451c:	4620      	mov	r0, r4
 800451e:	f005 f88f 	bl	8009640 <USER_Trace>
 8004522:	e7f5      	b.n	8004510 <DEV_ProcessFWDownload+0x178>
        } else if(DEV_IsNXFFile(pszFileName))
 8004524:	4628      	mov	r0, r5
 8004526:	f7ff fba3 	bl	8003c70 <DEV_IsNXFFile>
 800452a:	2800      	cmp	r0, #0
 800452c:	f000 8089 	beq.w	8004642 <DEV_ProcessFWDownload+0x2aa>
          *pbLoadState = CIFXTKIT_DOWNLOAD_FIRMWARE;
 8004530:	2301      	movs	r3, #1
 8004532:	703b      	strb	r3, [r7, #0]
 8004534:	e749      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
        if( DEV_IsNXFFile(pszFileName))
 8004536:	4628      	mov	r0, r5
 8004538:	f7ff fb9a 	bl	8003c70 <DEV_IsNXFFile>
 800453c:	2800      	cmp	r0, #0
 800453e:	d04a      	beq.n	80045d6 <DEV_ProcessFWDownload+0x23e>
          if (0 != ulChannel)
 8004540:	2e00      	cmp	r6, #0
 8004542:	d046      	beq.n	80045d2 <DEV_ProcessFWDownload+0x23a>
            if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8004544:	4b40      	ldr	r3, [pc, #256]	; (8004648 <DEV_ProcessFWDownload+0x2b0>)
 8004546:	681b      	ldr	r3, [r3, #0]
 8004548:	f013 0f08 	tst.w	r3, #8
 800454c:	d12a      	bne.n	80045a4 <DEV_ProcessFWDownload+0x20c>
            fDownload = 0;
 800454e:	2300      	movs	r3, #0
 8004550:	9309      	str	r3, [sp, #36]	; 0x24
            lRet = CIFX_INVALID_PARAMETER;
 8004552:	f8df 9118 	ldr.w	r9, [pc, #280]	; 800466c <DEV_ProcessFWDownload+0x2d4>
        if(fDownload)
 8004556:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004558:	2b00      	cmp	r3, #0
 800455a:	f43f af36 	beq.w	80043ca <DEV_ProcessFWDownload+0x32>
          lRet = DEV_DownloadFile(ptSysDevice,
 800455e:	2300      	movs	r3, #0
 8004560:	9306      	str	r3, [sp, #24]
 8004562:	9305      	str	r3, [sp, #20]
 8004564:	9304      	str	r3, [sp, #16]
 8004566:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8004568:	9303      	str	r3, [sp, #12]
 800456a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800456c:	9302      	str	r3, [sp, #8]
 800456e:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8004570:	9301      	str	r3, [sp, #4]
 8004572:	9500      	str	r5, [sp, #0]
 8004574:	2301      	movs	r3, #1
 8004576:	f8d4 216c 	ldr.w	r2, [r4, #364]	; 0x16c
 800457a:	4631      	mov	r1, r6
 800457c:	4650      	mov	r0, sl
 800457e:	f7ff fd4b 	bl	8004018 <DEV_DownloadFile>
          if(CIFX_NO_ERROR != lRet)
 8004582:	4681      	mov	r9, r0
 8004584:	2800      	cmp	r0, #0
 8004586:	d04b      	beq.n	8004620 <DEV_ProcessFWDownload+0x288>
            if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8004588:	4b2f      	ldr	r3, [pc, #188]	; (8004648 <DEV_ProcessFWDownload+0x2b0>)
 800458a:	681b      	ldr	r3, [r3, #0]
 800458c:	f013 0f08 	tst.w	r3, #8
 8004590:	f43f af1b 	beq.w	80043ca <DEV_ProcessFWDownload+0x32>
              USER_Trace(ptDevInstance,
 8004594:	9000      	str	r0, [sp, #0]
 8004596:	4643      	mov	r3, r8
 8004598:	4a2e      	ldr	r2, [pc, #184]	; (8004654 <DEV_ProcessFWDownload+0x2bc>)
 800459a:	2108      	movs	r1, #8
 800459c:	4620      	mov	r0, r4
 800459e:	f005 f84f 	bl	8009640 <USER_Trace>
 80045a2:	e712      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
              USER_Trace(ptDevInstance,
 80045a4:	4633      	mov	r3, r6
 80045a6:	4a29      	ldr	r2, [pc, #164]	; (800464c <DEV_ProcessFWDownload+0x2b4>)
 80045a8:	2108      	movs	r1, #8
 80045aa:	4620      	mov	r0, r4
 80045ac:	f005 f848 	bl	8009640 <USER_Trace>
 80045b0:	e7cd      	b.n	800454e <DEV_ProcessFWDownload+0x1b6>
              (void)DEV_RemoveChannelFiles(ptSysDevice, ulChNum, pfnTransferPacket, NULL, NULL, NULL);
 80045b2:	2300      	movs	r3, #0
 80045b4:	9301      	str	r3, [sp, #4]
 80045b6:	9300      	str	r3, [sp, #0]
 80045b8:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80045ba:	4659      	mov	r1, fp
 80045bc:	4650      	mov	r0, sl
 80045be:	f7ff fbbd 	bl	8003d3c <DEV_RemoveChannelFiles>
            for ( ulChNum = 0; ulChNum < CIFX_MAX_NUMBER_OF_CHANNELS; ulChNum++)
 80045c2:	f10b 0b01 	add.w	fp, fp, #1
 80045c6:	f1bb 0f05 	cmp.w	fp, #5
 80045ca:	d9f2      	bls.n	80045b2 <DEV_ProcessFWDownload+0x21a>
            *pbLoadState = CIFXTKIT_DOWNLOAD_FIRMWARE;
 80045cc:	2301      	movs	r3, #1
 80045ce:	703b      	strb	r3, [r7, #0]
 80045d0:	e7c1      	b.n	8004556 <DEV_ProcessFWDownload+0x1be>
            for ( ulChNum = 0; ulChNum < CIFX_MAX_NUMBER_OF_CHANNELS; ulChNum++)
 80045d2:	46b3      	mov	fp, r6
 80045d4:	e7f7      	b.n	80045c6 <DEV_ProcessFWDownload+0x22e>
        } else if( DEV_IsNXOFile(pszFileName))
 80045d6:	4628      	mov	r0, r5
 80045d8:	f7ff fb34 	bl	8003c44 <DEV_IsNXOFile>
 80045dc:	b1e8      	cbz	r0, 800461a <DEV_ProcessFWDownload+0x282>
          if( !ptDevInstance->fModuleLoad)
 80045de:	6923      	ldr	r3, [r4, #16]
 80045e0:	b97b      	cbnz	r3, 8004602 <DEV_ProcessFWDownload+0x26a>
            if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80045e2:	4b19      	ldr	r3, [pc, #100]	; (8004648 <DEV_ProcessFWDownload+0x2b0>)
 80045e4:	681b      	ldr	r3, [r3, #0]
 80045e6:	f013 0f08 	tst.w	r3, #8
 80045ea:	d104      	bne.n	80045f6 <DEV_ProcessFWDownload+0x25e>
            fDownload = 0;
 80045ec:	2300      	movs	r3, #0
 80045ee:	9309      	str	r3, [sp, #36]	; 0x24
            lRet = CIFX_FILE_TYPE_INVALID;
 80045f0:	f8df 9074 	ldr.w	r9, [pc, #116]	; 8004668 <DEV_ProcessFWDownload+0x2d0>
 80045f4:	e7af      	b.n	8004556 <DEV_ProcessFWDownload+0x1be>
              USER_Trace(ptDevInstance,
 80045f6:	4a16      	ldr	r2, [pc, #88]	; (8004650 <DEV_ProcessFWDownload+0x2b8>)
 80045f8:	2108      	movs	r1, #8
 80045fa:	4620      	mov	r0, r4
 80045fc:	f005 f820 	bl	8009640 <USER_Trace>
 8004600:	e7f4      	b.n	80045ec <DEV_ProcessFWDownload+0x254>
            (void)DEV_RemoveChannelFiles( ptSysDevice, ulChannel, pfnTransferPacket, NULL, NULL, HIL_FILE_EXTENSION_FIRMWARE);
 8004602:	4b18      	ldr	r3, [pc, #96]	; (8004664 <DEV_ProcessFWDownload+0x2cc>)
 8004604:	9301      	str	r3, [sp, #4]
 8004606:	2300      	movs	r3, #0
 8004608:	9300      	str	r3, [sp, #0]
 800460a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 800460c:	4631      	mov	r1, r6
 800460e:	4650      	mov	r0, sl
 8004610:	f7ff fb94 	bl	8003d3c <DEV_RemoveChannelFiles>
            *pbLoadState = CIFXTKIT_DOWNLOAD_MODULE;
 8004614:	2302      	movs	r3, #2
 8004616:	703b      	strb	r3, [r7, #0]
 8004618:	e79d      	b.n	8004556 <DEV_ProcessFWDownload+0x1be>
          fDownload = 0;
 800461a:	2300      	movs	r3, #0
 800461c:	9309      	str	r3, [sp, #36]	; 0x24
 800461e:	e79a      	b.n	8004556 <DEV_ProcessFWDownload+0x1be>
            if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8004620:	4b09      	ldr	r3, [pc, #36]	; (8004648 <DEV_ProcessFWDownload+0x2b0>)
 8004622:	681b      	ldr	r3, [r3, #0]
 8004624:	f013 0f01 	tst.w	r3, #1
 8004628:	d104      	bne.n	8004634 <DEV_ProcessFWDownload+0x29c>
            *pbLoadState |= CIFXTKIT_DOWNLOAD_EXECUTED;
 800462a:	783b      	ldrb	r3, [r7, #0]
 800462c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8004630:	703b      	strb	r3, [r7, #0]
 8004632:	e6ca      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
              USER_Trace(ptDevInstance,
 8004634:	4643      	mov	r3, r8
 8004636:	4a08      	ldr	r2, [pc, #32]	; (8004658 <DEV_ProcessFWDownload+0x2c0>)
 8004638:	2101      	movs	r1, #1
 800463a:	4620      	mov	r0, r4
 800463c:	f005 f800 	bl	8009640 <USER_Trace>
 8004640:	e7f3      	b.n	800462a <DEV_ProcessFWDownload+0x292>
          lRet = CIFX_FILE_TYPE_INVALID;
 8004642:	f8df 9024 	ldr.w	r9, [pc, #36]	; 8004668 <DEV_ProcessFWDownload+0x2d0>
    break;
 8004646:	e6c0      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
 8004648:	20000038 	.word	0x20000038
 800464c:	0800ad90 	.word	0x0800ad90
 8004650:	0800adc8 	.word	0x0800adc8
 8004654:	0800ae04 	.word	0x0800ae04
 8004658:	0800ae40 	.word	0x0800ae40
 800465c:	0800ae78 	.word	0x0800ae78
 8004660:	0800ae9c 	.word	0x0800ae9c
 8004664:	0800ac54 	.word	0x0800ac54
 8004668:	800a000f 	.word	0x800a000f
 800466c:	800a0005 	.word	0x800a0005
        USER_Trace(ptDevInstance,
 8004670:	4a03      	ldr	r2, [pc, #12]	; (8004680 <DEV_ProcessFWDownload+0x2e8>)
 8004672:	2108      	movs	r1, #8
 8004674:	f004 ffe4 	bl	8009640 <USER_Trace>
  int32_t          lRet        = CIFX_NO_ERROR;
 8004678:	f04f 0900 	mov.w	r9, #0
 800467c:	e6a5      	b.n	80043ca <DEV_ProcessFWDownload+0x32>
 800467e:	bf00      	nop
 8004680:	0800aed4 	.word	0x0800aed4

08004684 <cifXConvertEndianess>:
  UNREFERENCED_PARAMETER(iBufferLen);
  UNREFERENCED_PARAMETER(atConv);
  UNREFERENCED_PARAMETER(iConvLen);
  return CIFX_NO_ERROR; /*lint !e438 : unused variables */
#endif /* CIFX_TOOLKIT_BIGENDIAN */
}
 8004684:	2000      	movs	r0, #0
 8004686:	4770      	bx	lr

08004688 <xSysdeviceOpen>:
*   \param szBoard      Name of the board to open
*   \param phSysdevice  Returned handle to the System device area
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xSysdeviceOpen(CIFXHANDLE hDriver, char* szBoard, CIFXHANDLE* phSysdevice)
{
 8004688:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int32_t  lRet = CIFX_INVALID_BOARD;
  uint32_t ulIdx;

  if(0 == g_tDriverInfo.ulOpenCount)
 800468a:	4b18      	ldr	r3, [pc, #96]	; (80046ec <xSysdeviceOpen+0x64>)
 800468c:	681b      	ldr	r3, [r3, #0]
 800468e:	b353      	cbz	r3, 80046e6 <xSysdeviceOpen+0x5e>
 8004690:	460d      	mov	r5, r1
 8004692:	4616      	mov	r6, r2

  CHECK_DRIVERHANDLE(hDriver);
  CHECK_POINTER(szBoard);
  CHECK_POINTER(phSysdevice);

  for(ulIdx = 0; ulIdx < g_ulDeviceCount; ++ulIdx)
 8004694:	2400      	movs	r4, #0
 8004696:	4b16      	ldr	r3, [pc, #88]	; (80046f0 <xSysdeviceOpen+0x68>)
 8004698:	681b      	ldr	r3, [r3, #0]
 800469a:	42a3      	cmp	r3, r4
 800469c:	d921      	bls.n	80046e2 <xSysdeviceOpen+0x5a>
  {
    if( (OS_Strcmp(g_pptDevices[ulIdx]->szName,  szBoard) == 0) ||
 800469e:	00a7      	lsls	r7, r4, #2
 80046a0:	4b14      	ldr	r3, [pc, #80]	; (80046f4 <xSysdeviceOpen+0x6c>)
 80046a2:	681b      	ldr	r3, [r3, #0]
 80046a4:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80046a8:	4629      	mov	r1, r5
 80046aa:	3029      	adds	r0, #41	; 0x29
 80046ac:	f7fe fb18 	bl	8002ce0 <OS_Strcmp>
 80046b0:	b150      	cbz	r0, 80046c8 <xSysdeviceOpen+0x40>
        (OS_Strcmp(g_pptDevices[ulIdx]->szAlias, szBoard) == 0) )
 80046b2:	4b10      	ldr	r3, [pc, #64]	; (80046f4 <xSysdeviceOpen+0x6c>)
 80046b4:	681b      	ldr	r3, [r3, #0]
 80046b6:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80046ba:	4629      	mov	r1, r5
 80046bc:	3039      	adds	r0, #57	; 0x39
 80046be:	f7fe fb0f 	bl	8002ce0 <OS_Strcmp>
    if( (OS_Strcmp(g_pptDevices[ulIdx]->szName,  szBoard) == 0) ||
 80046c2:	b108      	cbz	r0, 80046c8 <xSysdeviceOpen+0x40>
  for(ulIdx = 0; ulIdx < g_ulDeviceCount; ++ulIdx)
 80046c4:	3401      	adds	r4, #1
 80046c6:	e7e6      	b.n	8004696 <xSysdeviceOpen+0xe>
    {
      ++g_pptDevices[ulIdx]->tSystemDevice.ulOpenCount;
 80046c8:	4b0a      	ldr	r3, [pc, #40]	; (80046f4 <xSysdeviceOpen+0x6c>)
 80046ca:	681a      	ldr	r2, [r3, #0]
 80046cc:	59d1      	ldr	r1, [r2, r7]
 80046ce:	f8d1 3110 	ldr.w	r3, [r1, #272]	; 0x110
 80046d2:	3301      	adds	r3, #1
 80046d4:	f8c1 3110 	str.w	r3, [r1, #272]	; 0x110
      *phSysdevice = (CIFXHANDLE)(&g_pptDevices[ulIdx]->tSystemDevice);
 80046d8:	59d3      	ldr	r3, [r2, r7]
 80046da:	33f4      	adds	r3, #244	; 0xf4
 80046dc:	6033      	str	r3, [r6, #0]
      lRet = CIFX_NO_ERROR;
 80046de:	2000      	movs	r0, #0
      break;
    }
  }

  return lRet; /*lint !e438 */
}
 80046e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  int32_t  lRet = CIFX_INVALID_BOARD;
 80046e2:	4805      	ldr	r0, [pc, #20]	; (80046f8 <xSysdeviceOpen+0x70>)
 80046e4:	e7fc      	b.n	80046e0 <xSysdeviceOpen+0x58>
    return CIFX_DRV_NOT_OPENED;
 80046e6:	4805      	ldr	r0, [pc, #20]	; (80046fc <xSysdeviceOpen+0x74>)
 80046e8:	e7fa      	b.n	80046e0 <xSysdeviceOpen+0x58>
 80046ea:	bf00      	nop
 80046ec:	20000214 	.word	0x20000214
 80046f0:	2000021c 	.word	0x2000021c
 80046f4:	2000020c 	.word	0x2000020c
 80046f8:	800a0002 	.word	0x800a0002
 80046fc:	800b0034 	.word	0x800b0034

08004700 <xSysdeviceClose>:
{
  PCHANNELINSTANCE ptSysDevice = (PCHANNELINSTANCE)hSysdevice;

  CHECK_SYSDEVICEHANDLE(hSysdevice);

  --ptSysDevice->ulOpenCount;
 8004700:	69c3      	ldr	r3, [r0, #28]
 8004702:	3b01      	subs	r3, #1
 8004704:	61c3      	str	r3, [r0, #28]

  return CIFX_NO_ERROR;
}
 8004706:	2000      	movs	r0, #0
 8004708:	4770      	bx	lr
	...

0800470c <xSysdeviceDownload>:
                                     uint8_t*              pabFileData,
                                     uint32_t              ulFileSize,
                                     PFN_PROGRESS_CALLBACK pfnCallback,
                                     PFN_RECV_PKT_CALLBACK pfnRecvPktCallback,
                                     void*                 pvUser)
{
 800470c:	b570      	push	{r4, r5, r6, lr}
 800470e:	b08a      	sub	sp, #40	; 0x28
 8004710:	4604      	mov	r4, r0
 8004712:	460d      	mov	r5, r1
 8004714:	461e      	mov	r6, r3
  PCHANNELINSTANCE ptSysDevice    = (PCHANNELINSTANCE)hSysdevice;
  uint32_t         ulTransferType = 0;
 8004716:	2300      	movs	r3, #0
 8004718:	9309      	str	r3, [sp, #36]	; 0x24

  CHECK_SYSDEVICEHANDLE(hSysdevice);
  CHECK_POINTER(pszFileName);
  CHECK_POINTER(pabFileData);

  switch(ulMode)
 800471a:	3a01      	subs	r2, #1
 800471c:	2a05      	cmp	r2, #5
 800471e:	f200 8091 	bhi.w	8004844 <xSysdeviceDownload+0x138>
 8004722:	e8df f002 	tbb	[pc, r2]
 8004726:	2003      	.short	0x2003
 8004728:	47348f20 	.word	0x47348f20
  {
  case DOWNLOAD_MODE_FIRMWARE:
    if( CIFX_NO_ERROR != (lRet = DEV_GetFWTransferTypeFromFileName( ((PDEVICEINSTANCE)(ptSysDevice->pvDeviceInstance))->eChipType,
 800472c:	6803      	ldr	r3, [r0, #0]
 800472e:	aa09      	add	r2, sp, #36	; 0x24
 8004730:	4631      	mov	r1, r6
 8004732:	f893 0028 	ldrb.w	r0, [r3, #40]	; 0x28
 8004736:	f7ff fb79 	bl	8003e2c <DEV_GetFWTransferTypeFromFileName>
 800473a:	2800      	cmp	r0, #0
 800473c:	d125      	bne.n	800478a <xSysdeviceDownload+0x7e>
                                                                     pszFileName, &ulTransferType)))
      return lRet;

    lRet = DEV_DownloadFile(ptSysDevice,
 800473e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8004740:	9306      	str	r3, [sp, #24]
 8004742:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8004744:	9305      	str	r3, [sp, #20]
 8004746:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8004748:	9304      	str	r3, [sp, #16]
 800474a:	4b43      	ldr	r3, [pc, #268]	; (8004858 <xSysdeviceDownload+0x14c>)
 800474c:	9303      	str	r3, [sp, #12]
 800474e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8004750:	9302      	str	r3, [sp, #8]
 8004752:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8004754:	9301      	str	r3, [sp, #4]
 8004756:	9600      	str	r6, [sp, #0]
 8004758:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800475a:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 800475c:	4629      	mov	r1, r5
 800475e:	4620      	mov	r0, r4
 8004760:	f7ff fc5a 	bl	8004018 <DEV_DownloadFile>
                            DEV_TransferPacket,
                            pfnCallback,
                            pfnRecvPktCallback,
                            pvUser);

    break;
 8004764:	e011      	b.n	800478a <xSysdeviceDownload+0x7e>

  case DOWNLOAD_MODE_CONFIG:
  case DOWNLOAD_MODE_FILE:
      ulTransferType = HIL_FILE_XFER_FILE;
 8004766:	2301      	movs	r3, #1
 8004768:	9309      	str	r3, [sp, #36]	; 0x24
      lRet = DEV_DownloadFile(ptSysDevice,
 800476a:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800476c:	9206      	str	r2, [sp, #24]
 800476e:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8004770:	9205      	str	r2, [sp, #20]
 8004772:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8004774:	9204      	str	r2, [sp, #16]
 8004776:	4a38      	ldr	r2, [pc, #224]	; (8004858 <xSysdeviceDownload+0x14c>)
 8004778:	9203      	str	r2, [sp, #12]
 800477a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800477c:	9202      	str	r2, [sp, #8]
 800477e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8004780:	9201      	str	r2, [sp, #4]
 8004782:	9600      	str	r6, [sp, #0]
 8004784:	6f82      	ldr	r2, [r0, #120]	; 0x78
 8004786:	f7ff fc47 	bl	8004018 <DEV_DownloadFile>
  default:
    return CIFX_INVALID_PARAMETER;
  }

  return lRet;
}
 800478a:	b00a      	add	sp, #40	; 0x28
 800478c:	bd70      	pop	{r4, r5, r6, pc}
      ulTransferType = HIL_FILE_XFER_LICENSE_CODE;
 800478e:	2305      	movs	r3, #5
 8004790:	9309      	str	r3, [sp, #36]	; 0x24
      lRet = DEV_DownloadFile(ptSysDevice,
 8004792:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8004794:	9206      	str	r2, [sp, #24]
 8004796:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8004798:	9205      	str	r2, [sp, #20]
 800479a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800479c:	9204      	str	r2, [sp, #16]
 800479e:	4a2e      	ldr	r2, [pc, #184]	; (8004858 <xSysdeviceDownload+0x14c>)
 80047a0:	9203      	str	r2, [sp, #12]
 80047a2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80047a4:	9202      	str	r2, [sp, #8]
 80047a6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80047a8:	9201      	str	r2, [sp, #4]
 80047aa:	9600      	str	r6, [sp, #0]
 80047ac:	6f82      	ldr	r2, [r0, #120]	; 0x78
 80047ae:	f7ff fc33 	bl	8004018 <DEV_DownloadFile>
    break;
 80047b2:	e7ea      	b.n	800478a <xSysdeviceDownload+0x7e>
      PDEVICEINSTANCE   ptDevInstance = (PDEVICEINSTANCE)ptSysDevice->pvDeviceInstance;
 80047b4:	6804      	ldr	r4, [r0, #0]
      if ( !DEV_IsNXOFile( pszFileName))
 80047b6:	4630      	mov	r0, r6
 80047b8:	f7ff fa44 	bl	8003c44 <DEV_IsNXOFile>
 80047bc:	2800      	cmp	r0, #0
 80047be:	d043      	beq.n	8004848 <xSysdeviceDownload+0x13c>
      } else if(ulChannel >= ptDevInstance->ulCommChannelCount)
 80047c0:	f8d4 3260 	ldr.w	r3, [r4, #608]	; 0x260
 80047c4:	42ab      	cmp	r3, r5
 80047c6:	d941      	bls.n	800484c <xSysdeviceDownload+0x140>
        ptChannelInst = ptDevInstance->pptCommChannels[ulChannel];
 80047c8:	f8d4 3264 	ldr.w	r3, [r4, #612]	; 0x264
 80047cc:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
        if( !ptDevInstance->fModuleLoad)
 80047d0:	6923      	ldr	r3, [r4, #16]
 80047d2:	2b00      	cmp	r3, #0
 80047d4:	d03c      	beq.n	8004850 <xSysdeviceDownload+0x144>
        } else if( DEV_IsReady(ptChannelInst))
 80047d6:	f000 ff01 	bl	80055dc <DEV_IsReady>
 80047da:	2800      	cmp	r0, #0
 80047dc:	d13a      	bne.n	8004854 <xSysdeviceDownload+0x148>
          uint8_t bLoadState = CIFXTKIT_DOWNLOAD_NONE;
 80047de:	2200      	movs	r2, #0
 80047e0:	f88d 2023 	strb.w	r2, [sp, #35]	; 0x23
          if ( CIFX_NO_ERROR == (lRet = DEV_ProcessFWDownload( ptDevInstance,
 80047e4:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80047e6:	9306      	str	r3, [sp, #24]
 80047e8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80047ea:	9305      	str	r3, [sp, #20]
 80047ec:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80047ee:	9304      	str	r3, [sp, #16]
 80047f0:	4b19      	ldr	r3, [pc, #100]	; (8004858 <xSysdeviceDownload+0x14c>)
 80047f2:	9303      	str	r3, [sp, #12]
 80047f4:	f10d 0323 	add.w	r3, sp, #35	; 0x23
 80047f8:	9302      	str	r3, [sp, #8]
 80047fa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80047fc:	9301      	str	r3, [sp, #4]
 80047fe:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8004800:	9300      	str	r3, [sp, #0]
 8004802:	4633      	mov	r3, r6
 8004804:	4629      	mov	r1, r5
 8004806:	4620      	mov	r0, r4
 8004808:	f7ff fdc6 	bl	8004398 <DEV_ProcessFWDownload>
 800480c:	2800      	cmp	r0, #0
 800480e:	d1bc      	bne.n	800478a <xSysdeviceDownload+0x7e>
            if (CIFX_NO_ERROR == (lRet = cifXStartModule( ptDevInstance, ulChannel, pszFileName,
 8004810:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8004812:	9301      	str	r3, [sp, #4]
 8004814:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8004816:	9300      	str	r3, [sp, #0]
 8004818:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800481a:	4632      	mov	r2, r6
 800481c:	4629      	mov	r1, r5
 800481e:	4620      	mov	r0, r4
 8004820:	f003 fd26 	bl	8008270 <cifXStartModule>
 8004824:	2800      	cmp	r0, #0
 8004826:	d1b0      	bne.n	800478a <xSysdeviceDownload+0x7e>
              if ( CIFX_NO_ERROR == (lRet = cifXReadFirmwareIdent( ptDevInstance, ulChannel,
 8004828:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800482a:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800482c:	4629      	mov	r1, r5
 800482e:	4620      	mov	r0, r4
 8004830:	f003 fb16 	bl	8007e60 <cifXReadFirmwareIdent>
 8004834:	2800      	cmp	r0, #0
 8004836:	d1a8      	bne.n	800478a <xSysdeviceDownload+0x7e>
                if ( 0 == (bLoadState & CIFXTKIT_DOWNLOAD_EXECUTED))
 8004838:	f99d 3023 	ldrsb.w	r3, [sp, #35]	; 0x23
 800483c:	2b00      	cmp	r3, #0
 800483e:	dba4      	blt.n	800478a <xSysdeviceDownload+0x7e>
                  lRet = CIFX_DEV_MODULE_ALREADY_EXISTS;
 8004840:	4806      	ldr	r0, [pc, #24]	; (800485c <xSysdeviceDownload+0x150>)
 8004842:	e7a2      	b.n	800478a <xSysdeviceDownload+0x7e>
  switch(ulMode)
 8004844:	4806      	ldr	r0, [pc, #24]	; (8004860 <xSysdeviceDownload+0x154>)
 8004846:	e7a0      	b.n	800478a <xSysdeviceDownload+0x7e>
        lRet = CIFX_FILE_NAME_INVALID;
 8004848:	4806      	ldr	r0, [pc, #24]	; (8004864 <xSysdeviceDownload+0x158>)
 800484a:	e79e      	b.n	800478a <xSysdeviceDownload+0x7e>
        lRet = CIFX_INVALID_CHANNEL;
 800484c:	4806      	ldr	r0, [pc, #24]	; (8004868 <xSysdeviceDownload+0x15c>)
 800484e:	e79c      	b.n	800478a <xSysdeviceDownload+0x7e>
          lRet = CIFX_DRV_DOWNLOAD_MODULE_NO_BASEOS;
 8004850:	4806      	ldr	r0, [pc, #24]	; (800486c <xSysdeviceDownload+0x160>)
 8004852:	e79a      	b.n	800478a <xSysdeviceDownload+0x7e>
          lRet = CIFX_DEV_MODULE_ALREADY_RUNNING;
 8004854:	4806      	ldr	r0, [pc, #24]	; (8004870 <xSysdeviceDownload+0x164>)
 8004856:	e798      	b.n	800478a <xSysdeviceDownload+0x7e>
 8004858:	08005979 	.word	0x08005979
 800485c:	800c0041 	.word	0x800c0041
 8004860:	800a0005 	.word	0x800a0005
 8004864:	800a0010 	.word	0x800a0010
 8004868:	800a0003 	.word	0x800a0003
 800486c:	800b0042 	.word	0x800b0042
 8004870:	800c0040 	.word	0x800c0040

08004874 <xSysdeviceInfo>:
*   \param ulSize       Size of the passed structure
*   \param pvInfo       Pointer to the structure for returned data
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xSysdeviceInfo(CIFXHANDLE hSysdevice, uint32_t ulCmd, uint32_t ulSize, void* pvInfo)
{
 8004874:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004876:	b083      	sub	sp, #12
 8004878:	4606      	mov	r6, r0
 800487a:	461d      	mov	r5, r3
  HIL_DPM_SYSTEM_CHANNEL_T* ptSysChannel = NULL;

  CHECK_SYSDEVICEHANDLE(hSysdevice);
  CHECK_POINTER(pvInfo);

  ptSysChannel = (HIL_DPM_SYSTEM_CHANNEL_T*)ptSysDevice->pbDPMChannelStart;
 800487c:	6887      	ldr	r7, [r0, #8]

  switch(ulCmd)
 800487e:	3901      	subs	r1, #1
 8004880:	2904      	cmp	r1, #4
 8004882:	f200 80c0 	bhi.w	8004a06 <xSysdeviceInfo+0x192>
 8004886:	e8df f001 	tbb	[pc, r1]
 800488a:	2403      	.short	0x2403
 800488c:	8c3e      	.short	0x8c3e
 800488e:	a5          	.byte	0xa5
 800488f:	00          	.byte	0x00
  {
    case CIFX_INFO_CMD_SYSTEM_INFORMATION:
      if( ulSize < (uint32_t)sizeof(SYSTEM_CHANNEL_SYSTEM_INFORMATION))
 8004890:	2a17      	cmp	r2, #23
 8004892:	f240 80ba 	bls.w	8004a0a <xSysdeviceInfo+0x196>
      {
        /* Insert global system channel information */
        SYSTEM_CHANNEL_SYSTEM_INFORMATION* ptInfo = (SYSTEM_CHANNEL_SYSTEM_INFORMATION*)pvInfo;

        /* These values are directly read from DPM, so they need to be converted to host endianess */
        ptInfo->ulSystemError   = LE32_TO_HOST(HWIF_READ32(ptSysDevice->pvDeviceInstance, ptSysChannel->tSystemState.ulSystemError));
 8004896:	f107 01c8 	add.w	r1, r7, #200	; 0xc8
 800489a:	6800      	ldr	r0, [r0, #0]
 800489c:	f000 fd2d 	bl	80052fa <HwIfRead32>
 80048a0:	6028      	str	r0, [r5, #0]
        ptInfo->ulDpmTotalSize  = LE32_TO_HOST(HWIF_READ32(ptSysDevice->pvDeviceInstance, ptSysChannel->tSystemInfo.ulDpmTotalSize));
 80048a2:	1d39      	adds	r1, r7, #4
 80048a4:	6830      	ldr	r0, [r6, #0]
 80048a6:	f000 fd28 	bl	80052fa <HwIfRead32>
 80048aa:	6068      	str	r0, [r5, #4]
        ptInfo->ulDeviceNumber  = LE32_TO_HOST(HWIF_READ32(ptSysDevice->pvDeviceInstance, ptSysChannel->tSystemInfo.ulDeviceNumber));
 80048ac:	f107 0108 	add.w	r1, r7, #8
 80048b0:	6830      	ldr	r0, [r6, #0]
 80048b2:	f000 fd22 	bl	80052fa <HwIfRead32>
 80048b6:	60e8      	str	r0, [r5, #12]
        ptInfo->ulSerialNumber  = LE32_TO_HOST(HWIF_READ32(ptSysDevice->pvDeviceInstance, ptSysChannel->tSystemInfo.ulSerialNumber));
 80048b8:	f107 010c 	add.w	r1, r7, #12
 80048bc:	6830      	ldr	r0, [r6, #0]
 80048be:	f000 fd1c 	bl	80052fa <HwIfRead32>
 80048c2:	6128      	str	r0, [r5, #16]

        ptInfo->ulMBXSize       = ptSysDevice->tRecvMbx.ulRecvMailboxLength;
 80048c4:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
 80048c8:	60ab      	str	r3, [r5, #8]
        ptInfo->ulOpenCnt       = ptSysDevice->ulOpenCount;
 80048ca:	69f3      	ldr	r3, [r6, #28]
 80048cc:	616b      	str	r3, [r5, #20]
  int32_t                   lRet         = CIFX_NO_ERROR;
 80048ce:	2000      	movs	r0, #0
 80048d0:	e017      	b.n	8004902 <xSysdeviceInfo+0x8e>
      }
    break;

    case CIFX_INFO_CMD_SYSTEM_INFO_BLOCK:
      if( ulSize < (uint32_t)sizeof(SYSTEM_CHANNEL_SYSTEM_INFO_BLOCK))
 80048d2:	2a2f      	cmp	r2, #47	; 0x2f
 80048d4:	f240 809b 	bls.w	8004a0e <xSysdeviceInfo+0x19a>
      {
        lRet = CIFX_INVALID_BUFFERSIZE;
      } else
      {
        uint32_t ulCopyLen = min( ulSize,
 80048d8:	2a30      	cmp	r2, #48	; 0x30
 80048da:	bf28      	it	cs
 80048dc:	2230      	movcs	r2, #48	; 0x30
 80048de:	4614      	mov	r4, r2
                                  (uint32_t)sizeof(SYSTEM_CHANNEL_SYSTEM_INFO_BLOCK));

        HWIF_READN(ptSysDevice->pvDeviceInstance, pvInfo, &ptSysChannel->tSystemInfo, ulCopyLen);
 80048e0:	6801      	ldr	r1, [r0, #0]
 80048e2:	f8d1 62c4 	ldr.w	r6, [r1, #708]	; 0x2c4
 80048e6:	9200      	str	r2, [sp, #0]
 80048e8:	462b      	mov	r3, r5
 80048ea:	463a      	mov	r2, r7
 80048ec:	2000      	movs	r0, #0
 80048ee:	47b0      	blx	r6

        (void)cifXConvertEndianess(0,
 80048f0:	2305      	movs	r3, #5
 80048f2:	9300      	str	r3, [sp, #0]
 80048f4:	4b4b      	ldr	r3, [pc, #300]	; (8004a24 <xSysdeviceInfo+0x1b0>)
 80048f6:	4622      	mov	r2, r4
 80048f8:	4629      	mov	r1, r5
 80048fa:	2000      	movs	r0, #0
 80048fc:	f7ff fec2 	bl	8004684 <cifXConvertEndianess>
  int32_t                   lRet         = CIFX_NO_ERROR;
 8004900:	2000      	movs	r0, #0
    break;

  } /* end switch */

  return lRet;
}
 8004902:	b003      	add	sp, #12
 8004904:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if( ulSize < (uint32_t)sizeof(SYSTEM_CHANNEL_CHANNEL_INFO_BLOCK))
 8004906:	2a7f      	cmp	r2, #127	; 0x7f
 8004908:	f240 8083 	bls.w	8004a12 <xSysdeviceInfo+0x19e>
        uint32_t ulCopyLen = min( ulSize,
 800490c:	2a80      	cmp	r2, #128	; 0x80
 800490e:	bf28      	it	cs
 8004910:	2280      	movcs	r2, #128	; 0x80
 8004912:	4614      	mov	r4, r2
        HWIF_READN(ptSysDevice->pvDeviceInstance, pvInfo, &ptSysChannel->atChannelInfo[0], ulCopyLen);
 8004914:	6801      	ldr	r1, [r0, #0]
 8004916:	f8d1 62c4 	ldr.w	r6, [r1, #708]	; 0x2c4
 800491a:	9200      	str	r2, [sp, #0]
 800491c:	462b      	mov	r3, r5
 800491e:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8004922:	2000      	movs	r0, #0
 8004924:	47b0      	blx	r6
        for(iChannel = 0;
 8004926:	2600      	movs	r6, #0
 8004928:	e012      	b.n	8004950 <xSysdeviceInfo+0xdc>
          uint32_t ulBlockLength = (uint32_t)sizeof(ptSysChannel->atChannelInfo[0]);
 800492a:	2210      	movs	r2, #16
          switch(ptInfoBuffer->abInfoBlock[iChannel][0])
 800492c:	0133      	lsls	r3, r6, #4
 800492e:	5ceb      	ldrb	r3, [r5, r3]
 8004930:	3b03      	subs	r3, #3
 8004932:	2b03      	cmp	r3, #3
 8004934:	d80b      	bhi.n	800494e <xSysdeviceInfo+0xda>
 8004936:	e8df f003 	tbb	[pc, r3]
 800493a:	1702      	.short	0x1702
 800493c:	2920      	.short	0x2920
            (void)cifXConvertEndianess(0,
 800493e:	2302      	movs	r3, #2
 8004940:	9300      	str	r3, [sp, #0]
 8004942:	4b39      	ldr	r3, [pc, #228]	; (8004a28 <xSysdeviceInfo+0x1b4>)
 8004944:	eb05 1106 	add.w	r1, r5, r6, lsl #4
 8004948:	2000      	movs	r0, #0
 800494a:	f7ff fe9b 	bl	8004684 <cifXConvertEndianess>
            ++iChannel)
 800494e:	3601      	adds	r6, #1
            iChannel < (int) (sizeof(ptSysChannel->atChannelInfo) / sizeof(ptSysChannel->atChannelInfo[0]));
 8004950:	2e07      	cmp	r6, #7
 8004952:	dc24      	bgt.n	800499e <xSysdeviceInfo+0x12a>
          uint32_t ulOffset      = (uint32_t)(iChannel * ulBlockLength);
 8004954:	0132      	lsls	r2, r6, #4
          if( ulOffset > ulCopyLen)
 8004956:	ebb4 1f06 	cmp.w	r4, r6, lsl #4
 800495a:	d35c      	bcc.n	8004a16 <xSysdeviceInfo+0x1a2>
          if( (ulOffset + sizeof(ptSysChannel->atChannelInfo[0])) > ulCopyLen)
 800495c:	f102 0310 	add.w	r3, r2, #16
 8004960:	42a3      	cmp	r3, r4
 8004962:	d9e2      	bls.n	800492a <xSysdeviceInfo+0xb6>
            ulBlockLength = ulCopyLen - ulOffset;
 8004964:	1aa2      	subs	r2, r4, r2
 8004966:	e7e1      	b.n	800492c <xSysdeviceInfo+0xb8>
            (void)cifXConvertEndianess(0,
 8004968:	2301      	movs	r3, #1
 800496a:	9300      	str	r3, [sp, #0]
 800496c:	4b2f      	ldr	r3, [pc, #188]	; (8004a2c <xSysdeviceInfo+0x1b8>)
 800496e:	eb05 1106 	add.w	r1, r5, r6, lsl #4
 8004972:	2000      	movs	r0, #0
 8004974:	f7ff fe86 	bl	8004684 <cifXConvertEndianess>
            break;
 8004978:	e7e9      	b.n	800494e <xSysdeviceInfo+0xda>
            (void)cifXConvertEndianess(0,
 800497a:	2302      	movs	r3, #2
 800497c:	9300      	str	r3, [sp, #0]
 800497e:	4b2c      	ldr	r3, [pc, #176]	; (8004a30 <xSysdeviceInfo+0x1bc>)
 8004980:	eb05 1106 	add.w	r1, r5, r6, lsl #4
 8004984:	2000      	movs	r0, #0
 8004986:	f7ff fe7d 	bl	8004684 <cifXConvertEndianess>
            break;
 800498a:	e7e0      	b.n	800494e <xSysdeviceInfo+0xda>
            (void)cifXConvertEndianess(0,
 800498c:	2301      	movs	r3, #1
 800498e:	9300      	str	r3, [sp, #0]
 8004990:	4b28      	ldr	r3, [pc, #160]	; (8004a34 <xSysdeviceInfo+0x1c0>)
 8004992:	eb05 1106 	add.w	r1, r5, r6, lsl #4
 8004996:	2000      	movs	r0, #0
 8004998:	f7ff fe74 	bl	8004684 <cifXConvertEndianess>
            break;
 800499c:	e7d7      	b.n	800494e <xSysdeviceInfo+0xda>
  int32_t                   lRet         = CIFX_NO_ERROR;
 800499e:	2000      	movs	r0, #0
 80049a0:	e7af      	b.n	8004902 <xSysdeviceInfo+0x8e>
      if( ulSize < (uint32_t)sizeof(SYSTEM_CHANNEL_SYSTEM_CONTROL_BLOCK))
 80049a2:	2a07      	cmp	r2, #7
 80049a4:	d939      	bls.n	8004a1a <xSysdeviceInfo+0x1a6>
        uint32_t ulCopyLen = min(ulSize,
 80049a6:	2a08      	cmp	r2, #8
 80049a8:	bf28      	it	cs
 80049aa:	2208      	movcs	r2, #8
 80049ac:	4614      	mov	r4, r2
        HWIF_READN(ptSysDevice->pvDeviceInstance, pvInfo, &ptSysChannel->tSystemControl, ulCopyLen);
 80049ae:	6801      	ldr	r1, [r0, #0]
 80049b0:	f8d1 62c4 	ldr.w	r6, [r1, #708]	; 0x2c4
 80049b4:	9200      	str	r2, [sp, #0]
 80049b6:	462b      	mov	r3, r5
 80049b8:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 80049bc:	2000      	movs	r0, #0
 80049be:	47b0      	blx	r6
        (void)cifXConvertEndianess(0,
 80049c0:	2301      	movs	r3, #1
 80049c2:	9300      	str	r3, [sp, #0]
 80049c4:	4b1c      	ldr	r3, [pc, #112]	; (8004a38 <xSysdeviceInfo+0x1c4>)
 80049c6:	4622      	mov	r2, r4
 80049c8:	4629      	mov	r1, r5
 80049ca:	2000      	movs	r0, #0
 80049cc:	f7ff fe5a 	bl	8004684 <cifXConvertEndianess>
  int32_t                   lRet         = CIFX_NO_ERROR;
 80049d0:	2000      	movs	r0, #0
 80049d2:	e796      	b.n	8004902 <xSysdeviceInfo+0x8e>
      if( ulSize < (uint32_t)sizeof(SYSTEM_CHANNEL_SYSTEM_STATUS_BLOCK))
 80049d4:	2a3f      	cmp	r2, #63	; 0x3f
 80049d6:	d922      	bls.n	8004a1e <xSysdeviceInfo+0x1aa>
        uint32_t ulCopyLen = min(ulSize,
 80049d8:	2a40      	cmp	r2, #64	; 0x40
 80049da:	bf28      	it	cs
 80049dc:	2240      	movcs	r2, #64	; 0x40
 80049de:	4614      	mov	r4, r2
        HWIF_READN(ptSysDevice->pvDeviceInstance, pvInfo, &ptSysChannel->tSystemState, ulCopyLen);
 80049e0:	6801      	ldr	r1, [r0, #0]
 80049e2:	f8d1 62c4 	ldr.w	r6, [r1, #708]	; 0x2c4
 80049e6:	9200      	str	r2, [sp, #0]
 80049e8:	462b      	mov	r3, r5
 80049ea:	f107 02c0 	add.w	r2, r7, #192	; 0xc0
 80049ee:	2000      	movs	r0, #0
 80049f0:	47b0      	blx	r6
        (void)cifXConvertEndianess(0,
 80049f2:	2302      	movs	r3, #2
 80049f4:	9300      	str	r3, [sp, #0]
 80049f6:	4b11      	ldr	r3, [pc, #68]	; (8004a3c <xSysdeviceInfo+0x1c8>)
 80049f8:	4622      	mov	r2, r4
 80049fa:	4629      	mov	r1, r5
 80049fc:	2000      	movs	r0, #0
 80049fe:	f7ff fe41 	bl	8004684 <cifXConvertEndianess>
  int32_t                   lRet         = CIFX_NO_ERROR;
 8004a02:	2000      	movs	r0, #0
 8004a04:	e77d      	b.n	8004902 <xSysdeviceInfo+0x8e>
  switch(ulCmd)
 8004a06:	480e      	ldr	r0, [pc, #56]	; (8004a40 <xSysdeviceInfo+0x1cc>)
 8004a08:	e77b      	b.n	8004902 <xSysdeviceInfo+0x8e>
        lRet = CIFX_INVALID_BUFFERSIZE;
 8004a0a:	480e      	ldr	r0, [pc, #56]	; (8004a44 <xSysdeviceInfo+0x1d0>)
 8004a0c:	e779      	b.n	8004902 <xSysdeviceInfo+0x8e>
        lRet = CIFX_INVALID_BUFFERSIZE;
 8004a0e:	480d      	ldr	r0, [pc, #52]	; (8004a44 <xSysdeviceInfo+0x1d0>)
 8004a10:	e777      	b.n	8004902 <xSysdeviceInfo+0x8e>
        lRet = CIFX_INVALID_BUFFERSIZE;
 8004a12:	480c      	ldr	r0, [pc, #48]	; (8004a44 <xSysdeviceInfo+0x1d0>)
 8004a14:	e775      	b.n	8004902 <xSysdeviceInfo+0x8e>
  int32_t                   lRet         = CIFX_NO_ERROR;
 8004a16:	2000      	movs	r0, #0
 8004a18:	e773      	b.n	8004902 <xSysdeviceInfo+0x8e>
        lRet = CIFX_INVALID_BUFFERSIZE;
 8004a1a:	480a      	ldr	r0, [pc, #40]	; (8004a44 <xSysdeviceInfo+0x1d0>)
 8004a1c:	e771      	b.n	8004902 <xSysdeviceInfo+0x8e>
        lRet = CIFX_INVALID_BUFFERSIZE;
 8004a1e:	4809      	ldr	r0, [pc, #36]	; (8004a44 <xSysdeviceInfo+0x1d0>)
  return lRet;
 8004a20:	e76f      	b.n	8004902 <xSysdeviceInfo+0x8e>
 8004a22:	bf00      	nop
 8004a24:	0800af68 	.word	0x0800af68
 8004a28:	0800af44 	.word	0x0800af44
 8004a2c:	0800af38 	.word	0x0800af38
 8004a30:	0800af20 	.word	0x0800af20
 8004a34:	0800af14 	.word	0x0800af14
 8004a38:	0800af5c 	.word	0x0800af5c
 8004a3c:	0800afa4 	.word	0x0800afa4
 8004a40:	800a0006 	.word	0x800a0006
 8004a44:	800a0007 	.word	0x800a0007

08004a48 <xChannelOpen>:
*   \param phChannel  Returned handle to the channel (Needed for all channel
*                     specific operations)
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xChannelOpen(CIFXHANDLE hDriver, char* szBoard, uint32_t ulChannel, CIFXHANDLE* phChannel)
{
 8004a48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004a4c:	461f      	mov	r7, r3
  int32_t  lRet = CIFX_INVALID_BOARD;
  uint32_t ulIdx;

  if(0 == g_tDriverInfo.ulOpenCount)
 8004a4e:	4b1c      	ldr	r3, [pc, #112]	; (8004ac0 <xChannelOpen+0x78>)
 8004a50:	681b      	ldr	r3, [r3, #0]
 8004a52:	b38b      	cbz	r3, 8004ab8 <xChannelOpen+0x70>
 8004a54:	460d      	mov	r5, r1
 8004a56:	4616      	mov	r6, r2

  CHECK_DRIVERHANDLE(hDriver);
  CHECK_POINTER(szBoard);
  CHECK_POINTER(phChannel);

  for(ulIdx = 0; ulIdx < g_ulDeviceCount; ++ulIdx)
 8004a58:	2400      	movs	r4, #0
 8004a5a:	491a      	ldr	r1, [pc, #104]	; (8004ac4 <xChannelOpen+0x7c>)
 8004a5c:	6809      	ldr	r1, [r1, #0]
 8004a5e:	42a1      	cmp	r1, r4
 8004a60:	d928      	bls.n	8004ab4 <xChannelOpen+0x6c>
  {
    /* Try to find the requested board */
    if( (OS_Strcmp(g_pptDevices[ulIdx]->szName,  szBoard) == 0) ||
 8004a62:	ea4f 0884 	mov.w	r8, r4, lsl #2
 8004a66:	4b18      	ldr	r3, [pc, #96]	; (8004ac8 <xChannelOpen+0x80>)
 8004a68:	681b      	ldr	r3, [r3, #0]
 8004a6a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8004a6e:	4629      	mov	r1, r5
 8004a70:	3029      	adds	r0, #41	; 0x29
 8004a72:	f7fe f935 	bl	8002ce0 <OS_Strcmp>
 8004a76:	b150      	cbz	r0, 8004a8e <xChannelOpen+0x46>
        (OS_Strcmp(g_pptDevices[ulIdx]->szAlias, szBoard) == 0) )
 8004a78:	4b13      	ldr	r3, [pc, #76]	; (8004ac8 <xChannelOpen+0x80>)
 8004a7a:	681b      	ldr	r3, [r3, #0]
 8004a7c:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8004a80:	4629      	mov	r1, r5
 8004a82:	3039      	adds	r0, #57	; 0x39
 8004a84:	f7fe f92c 	bl	8002ce0 <OS_Strcmp>
    if( (OS_Strcmp(g_pptDevices[ulIdx]->szName,  szBoard) == 0) ||
 8004a88:	b108      	cbz	r0, 8004a8e <xChannelOpen+0x46>
  for(ulIdx = 0; ulIdx < g_ulDeviceCount; ++ulIdx)
 8004a8a:	3401      	adds	r4, #1
 8004a8c:	e7e5      	b.n	8004a5a <xChannelOpen+0x12>
    {
      /* Try to open the given channel */
      lRet = CIFX_INVALID_CHANNEL;
      if(ulChannel < g_pptDevices[ulIdx]->ulCommChannelCount)
 8004a8e:	4b0e      	ldr	r3, [pc, #56]	; (8004ac8 <xChannelOpen+0x80>)
 8004a90:	681b      	ldr	r3, [r3, #0]
 8004a92:	f853 3008 	ldr.w	r3, [r3, r8]
 8004a96:	f8d3 2260 	ldr.w	r2, [r3, #608]	; 0x260
 8004a9a:	42b2      	cmp	r2, r6
 8004a9c:	d90e      	bls.n	8004abc <xChannelOpen+0x74>
      {
        /* We found the channel */
        PCHANNELINSTANCE ptChannel = g_pptDevices[ulIdx]->pptCommChannels[ulChannel];
 8004a9e:	f8d3 3264 	ldr.w	r3, [r3, #612]	; 0x264
 8004aa2:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
        ++ptChannel->ulOpenCount;
 8004aa6:	69da      	ldr	r2, [r3, #28]
 8004aa8:	3201      	adds	r2, #1
 8004aaa:	61da      	str	r2, [r3, #28]
        *phChannel = (CIFXHANDLE)ptChannel;
 8004aac:	603b      	str	r3, [r7, #0]
        lRet = CIFX_NO_ERROR;
 8004aae:	2000      	movs	r0, #0
      break;
    }
  }

  return lRet; /*lint !e438 */
}
 8004ab0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  int32_t  lRet = CIFX_INVALID_BOARD;
 8004ab4:	4805      	ldr	r0, [pc, #20]	; (8004acc <xChannelOpen+0x84>)
 8004ab6:	e7fb      	b.n	8004ab0 <xChannelOpen+0x68>
    return CIFX_DRV_NOT_OPENED;
 8004ab8:	4805      	ldr	r0, [pc, #20]	; (8004ad0 <xChannelOpen+0x88>)
 8004aba:	e7f9      	b.n	8004ab0 <xChannelOpen+0x68>
      lRet = CIFX_INVALID_CHANNEL;
 8004abc:	4805      	ldr	r0, [pc, #20]	; (8004ad4 <xChannelOpen+0x8c>)
 8004abe:	e7f7      	b.n	8004ab0 <xChannelOpen+0x68>
 8004ac0:	20000214 	.word	0x20000214
 8004ac4:	2000021c 	.word	0x2000021c
 8004ac8:	2000020c 	.word	0x2000020c
 8004acc:	800a0002 	.word	0x800a0002
 8004ad0:	800b0034 	.word	0x800b0034
 8004ad4:	800a0003 	.word	0x800a0003

08004ad8 <xChannelClose>:
{
  PCHANNELINSTANCE ptChannel = (PCHANNELINSTANCE)hChannel;

  CHECK_CHANNELHANDLE(hChannel);

  --ptChannel->ulOpenCount;
 8004ad8:	69c3      	ldr	r3, [r0, #28]
 8004ada:	3b01      	subs	r3, #1
 8004adc:	61c3      	str	r3, [r0, #28]

  return CIFX_NO_ERROR;
}
 8004ade:	2000      	movs	r0, #0
 8004ae0:	4770      	bx	lr
	...

08004ae4 <xChannelPutPacket>:
*   \param ptSendPkt  Packet to send to channel
*   \param ulTimeout  Time in ms to wait for card to accept the packet
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xChannelPutPacket(CIFXHANDLE hChannel, CIFX_PACKET*  ptSendPkt, uint32_t ulTimeout)
{
 8004ae4:	b570      	push	{r4, r5, r6, lr}
 8004ae6:	4604      	mov	r4, r0
 8004ae8:	460e      	mov	r6, r1
 8004aea:	4615      	mov	r5, r2
  int32_t          lRet      = CIFX_NO_ERROR;
  PCHANNELINSTANCE ptChannel = (PCHANNELINSTANCE)hChannel;

  /* Check if another command is active */
  if ( 0 == OS_WaitMutex( ptChannel->tSendMbx.pvSendMBXMutex, ulTimeout))
 8004aec:	4611      	mov	r1, r2
 8004aee:	f8d0 0084 	ldr.w	r0, [r0, #132]	; 0x84
 8004af2:	f7fe f877 	bl	8002be4 <OS_WaitMutex>
 8004af6:	b158      	cbz	r0, 8004b10 <xChannelPutPacket+0x2c>
    return CIFX_DRV_CMD_ACTIVE;

  lRet = DEV_PutPacket(ptChannel, ptSendPkt, ulTimeout);
 8004af8:	462a      	mov	r2, r5
 8004afa:	4631      	mov	r1, r6
 8004afc:	4620      	mov	r0, r4
 8004afe:	f000 fd89 	bl	8005614 <DEV_PutPacket>
 8004b02:	4605      	mov	r5, r0

  /* Release command */
  OS_ReleaseMutex(ptChannel->tSendMbx.pvSendMBXMutex);
 8004b04:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 8004b08:	f7fe f878 	bl	8002bfc <OS_ReleaseMutex>

  return lRet;
}
 8004b0c:	4628      	mov	r0, r5
 8004b0e:	bd70      	pop	{r4, r5, r6, pc}
    return CIFX_DRV_CMD_ACTIVE;
 8004b10:	4d00      	ldr	r5, [pc, #0]	; (8004b14 <xChannelPutPacket+0x30>)
 8004b12:	e7fb      	b.n	8004b0c <xChannelPutPacket+0x28>
 8004b14:	800b0004 	.word	0x800b0004

08004b18 <xChannelGetPacket>:
*   \param ptRecvPkt  Returned packet
*   \param ulTimeout  Time in ms to wait for available message
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xChannelGetPacket(CIFXHANDLE hChannel, uint32_t ulSize, CIFX_PACKET* ptRecvPkt, uint32_t ulTimeout)
{
 8004b18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004b1a:	4604      	mov	r4, r0
 8004b1c:	460f      	mov	r7, r1
 8004b1e:	4616      	mov	r6, r2
 8004b20:	461d      	mov	r5, r3
  int32_t          lRet      = CIFX_NO_ERROR;
  PCHANNELINSTANCE ptChannel = (PCHANNELINSTANCE)hChannel;

  /* Check if another command is active */
  if ( 0 == OS_WaitMutex( ptChannel->tRecvMbx.pvRecvMBXMutex, ulTimeout))
 8004b22:	4619      	mov	r1, r3
 8004b24:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
 8004b28:	f7fe f85c 	bl	8002be4 <OS_WaitMutex>
 8004b2c:	b160      	cbz	r0, 8004b48 <xChannelGetPacket+0x30>
    return CIFX_DRV_CMD_ACTIVE;

  lRet = DEV_GetPacket(ptChannel, ptRecvPkt, ulSize, ulTimeout);
 8004b2e:	462b      	mov	r3, r5
 8004b30:	463a      	mov	r2, r7
 8004b32:	4631      	mov	r1, r6
 8004b34:	4620      	mov	r0, r4
 8004b36:	f000 fed5 	bl	80058e4 <DEV_GetPacket>
 8004b3a:	4605      	mov	r5, r0

  /* Release command */
  OS_ReleaseMutex(ptChannel->tRecvMbx.pvRecvMBXMutex);
 8004b3c:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
 8004b40:	f7fe f85c 	bl	8002bfc <OS_ReleaseMutex>

  return lRet;
}
 8004b44:	4628      	mov	r0, r5
 8004b46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return CIFX_DRV_CMD_ACTIVE;
 8004b48:	4d00      	ldr	r5, [pc, #0]	; (8004b4c <xChannelGetPacket+0x34>)
 8004b4a:	e7fb      	b.n	8004b44 <xChannelGetPacket+0x2c>
 8004b4c:	800b0004 	.word	0x800b0004

08004b50 <xChannelBusState>:
*   \param pulState         Return actual state on CIFX_GET_BUS_STATE
*   \param ulTimeout        Timeout in [ms]
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xChannelBusState(CIFXHANDLE  hChannel, uint32_t ulCmd, uint32_t* pulState, uint32_t ulTimeout)
{
 8004b50:	b508      	push	{r3, lr}
  int32_t lRet = CIFX_INVALID_PARAMETER;

  CHECK_CHANNELHANDLE(hChannel);
  CHECK_POINTER(pulState);

  lRet = DEV_BusState( (PCHANNELINSTANCE)hChannel,
 8004b52:	f001 f901 	bl	8005d58 <DEV_BusState>
                        ulCmd,
                        pulState,
                        ulTimeout);

  return lRet;
}
 8004b56:	bd08      	pop	{r3, pc}

08004b58 <xChannelIORead>:
*   \param pvData       Buffer to place returned data
*   \param ulTimeout    Timeout in ms to wait for finished I/O Handshake
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xChannelIORead(CIFXHANDLE hChannel, uint32_t ulAreaNumber, uint32_t ulOffset, uint32_t ulDataLen, void* pvData, uint32_t ulTimeout)
{
 8004b58:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004b5c:	b085      	sub	sp, #20
 8004b5e:	4604      	mov	r4, r0
 8004b60:	460d      	mov	r5, r1
 8004b62:	4617      	mov	r7, r2
 8004b64:	4698      	mov	r8, r3
 8004b66:	9e0d      	ldr	r6, [sp, #52]	; 0x34
  PCHANNELINSTANCE ptChannel   = (PCHANNELINSTANCE)hChannel;
  int32_t          lRet        = CIFX_NO_ERROR;
 8004b68:	2300      	movs	r3, #0
 8004b6a:	9303      	str	r3, [sp, #12]
  PIOINSTANCE      ptIOArea    = NULL;
  uint8_t          bIOBitState = HIL_FLAGS_NONE;

  if(!DEV_IsRunning(ptChannel))
 8004b6c:	f000 fe1c 	bl	80057a8 <DEV_IsRunning>
 8004b70:	2800      	cmp	r0, #0
 8004b72:	d055      	beq.n	8004c20 <xChannelIORead+0xc8>
    return CIFX_DEV_NOT_RUNNING;

  if(ulAreaNumber >= ptChannel->ulIOInputAreas)
 8004b74:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 8004b78:	42ab      	cmp	r3, r5
 8004b7a:	d953      	bls.n	8004c24 <xChannelIORead+0xcc>
    return CIFX_INVALID_PARAMETER;

  ptIOArea    = ptChannel->pptIOInputAreas[ulAreaNumber];
 8004b7c:	f8d4 313c 	ldr.w	r3, [r4, #316]	; 0x13c
 8004b80:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
  bIOBitState = DEV_GetIOBitstate(ptChannel, ptIOArea, 0);
 8004b84:	2200      	movs	r2, #0
 8004b86:	4629      	mov	r1, r5
 8004b88:	4620      	mov	r0, r4
 8004b8a:	f000 fb88 	bl	800529e <DEV_GetIOBitstate>
 8004b8e:	4681      	mov	r9, r0
#endif
  {
    /*---------------------------*/
    /* This is DPM data transfer */
    /*---------------------------*/
    if( (ulOffset + ulDataLen) > ptIOArea->ulDPMAreaLength)
 8004b90:	eb07 0308 	add.w	r3, r7, r8
 8004b94:	686a      	ldr	r2, [r5, #4]
 8004b96:	4293      	cmp	r3, r2
 8004b98:	d846      	bhi.n	8004c28 <xChannelIORead+0xd0>
      return CIFX_INVALID_ACCESS_SIZE; /* read size too long */

    /* Check if another command is active */
    if ( !OS_WaitMutex( ptIOArea->pvMutex, ulTimeout))
 8004b9a:	4631      	mov	r1, r6
 8004b9c:	6928      	ldr	r0, [r5, #16]
 8004b9e:	f7fe f821 	bl	8002be4 <OS_WaitMutex>
 8004ba2:	2800      	cmp	r0, #0
 8004ba4:	d042      	beq.n	8004c2c <xChannelIORead+0xd4>
      return CIFX_DRV_CMD_ACTIVE;

    /* Read data */
    if(HIL_FLAGS_NONE == bIOBitState)
 8004ba6:	f1b9 0fff 	cmp.w	r9, #255	; 0xff
 8004baa:	d114      	bne.n	8004bd6 <xChannelIORead+0x7e>
    {
      /* Read data */
      HWIF_READN( ptChannel->pvDeviceInstance,
 8004bac:	6821      	ldr	r1, [r4, #0]
 8004bae:	f8d1 62c4 	ldr.w	r6, [r1, #708]	; 0x2c4
 8004bb2:	682a      	ldr	r2, [r5, #0]
 8004bb4:	f8cd 8000 	str.w	r8, [sp]
 8004bb8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004bba:	443a      	add	r2, r7
 8004bbc:	2000      	movs	r0, #0
 8004bbe:	47b0      	blx	r6
                  pvData,
                  &ptIOArea->pbDPMAreaStart[ulOffset],
                  ulDataLen);

      /* Check COMM Flag for return value */
      (void)DEV_IsCommunicating(ptChannel, &lRet);
 8004bc0:	a903      	add	r1, sp, #12
 8004bc2:	4620      	mov	r0, r4
 8004bc4:	f000 fd64 	bl	8005690 <DEV_IsCommunicating>
      /* Check COMM Flag for return value */
      (void)DEV_IsCommunicating(ptChannel, &lRet);
    }

    /* Release command */
    OS_ReleaseMutex( ptIOArea->pvMutex);
 8004bc8:	6928      	ldr	r0, [r5, #16]
 8004bca:	f7fe f817 	bl	8002bfc <OS_ReleaseMutex>
  }

  return lRet;
 8004bce:	9803      	ldr	r0, [sp, #12]
}
 8004bd0:	b005      	add	sp, #20
 8004bd2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    } else if(!DEV_WaitForBitState(ptChannel, ptIOArea->bHandshakeBit, bIOBitState, ulTimeout))
 8004bd6:	4633      	mov	r3, r6
 8004bd8:	464a      	mov	r2, r9
 8004bda:	7a29      	ldrb	r1, [r5, #8]
 8004bdc:	4620      	mov	r0, r4
 8004bde:	f000 fc8e 	bl	80054fe <DEV_WaitForBitState>
 8004be2:	b910      	cbnz	r0, 8004bea <xChannelIORead+0x92>
      lRet = CIFX_DEV_EXCHANGE_FAILED;
 8004be4:	4b12      	ldr	r3, [pc, #72]	; (8004c30 <xChannelIORead+0xd8>)
 8004be6:	9303      	str	r3, [sp, #12]
 8004be8:	e7ee      	b.n	8004bc8 <xChannelIORead+0x70>
      HWIF_READN( ptChannel->pvDeviceInstance,
 8004bea:	6821      	ldr	r1, [r4, #0]
 8004bec:	f8d1 62c4 	ldr.w	r6, [r1, #708]	; 0x2c4
 8004bf0:	682a      	ldr	r2, [r5, #0]
 8004bf2:	f8cd 8000 	str.w	r8, [sp]
 8004bf6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004bf8:	443a      	add	r2, r7
 8004bfa:	2000      	movs	r0, #0
 8004bfc:	47b0      	blx	r6
      OS_EnterLock(ptChannel->pvLock);
 8004bfe:	69a0      	ldr	r0, [r4, #24]
 8004c00:	f7fd ffce 	bl	8002ba0 <OS_EnterLock>
      DEV_ToggleBit(ptChannel, (uint32_t)(1UL << ptIOArea->bHandshakeBit));
 8004c04:	7a2b      	ldrb	r3, [r5, #8]
 8004c06:	2101      	movs	r1, #1
 8004c08:	4099      	lsls	r1, r3
 8004c0a:	4620      	mov	r0, r4
 8004c0c:	f000 fb09 	bl	8005222 <DEV_ToggleBit>
      OS_LeaveLock(ptChannel->pvLock);
 8004c10:	69a0      	ldr	r0, [r4, #24]
 8004c12:	f7fd ffd1 	bl	8002bb8 <OS_LeaveLock>
      (void)DEV_IsCommunicating(ptChannel, &lRet);
 8004c16:	a903      	add	r1, sp, #12
 8004c18:	4620      	mov	r0, r4
 8004c1a:	f000 fd39 	bl	8005690 <DEV_IsCommunicating>
 8004c1e:	e7d3      	b.n	8004bc8 <xChannelIORead+0x70>
    return CIFX_DEV_NOT_RUNNING;
 8004c20:	4804      	ldr	r0, [pc, #16]	; (8004c34 <xChannelIORead+0xdc>)
 8004c22:	e7d5      	b.n	8004bd0 <xChannelIORead+0x78>
    return CIFX_INVALID_PARAMETER;
 8004c24:	4804      	ldr	r0, [pc, #16]	; (8004c38 <xChannelIORead+0xe0>)
 8004c26:	e7d3      	b.n	8004bd0 <xChannelIORead+0x78>
      return CIFX_INVALID_ACCESS_SIZE; /* read size too long */
 8004c28:	4804      	ldr	r0, [pc, #16]	; (8004c3c <xChannelIORead+0xe4>)
 8004c2a:	e7d1      	b.n	8004bd0 <xChannelIORead+0x78>
      return CIFX_DRV_CMD_ACTIVE;
 8004c2c:	4804      	ldr	r0, [pc, #16]	; (8004c40 <xChannelIORead+0xe8>)
 8004c2e:	e7cf      	b.n	8004bd0 <xChannelIORead+0x78>
 8004c30:	800c0022 	.word	0x800c0022
 8004c34:	800c0012 	.word	0x800c0012
 8004c38:	800a0005 	.word	0x800a0005
 8004c3c:	800a0008 	.word	0x800a0008
 8004c40:	800b0004 	.word	0x800b0004

08004c44 <xChannelIOWrite>:
*   \param pvData       Buffer containing send data
*   \param ulTimeout    Timeout in ms to wait for handshake completion
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xChannelIOWrite(CIFXHANDLE hChannel, uint32_t ulAreaNumber, uint32_t ulOffset, uint32_t ulDataLen, void* pvData, uint32_t ulTimeout)
{
 8004c44:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004c48:	b085      	sub	sp, #20
 8004c4a:	4604      	mov	r4, r0
 8004c4c:	460d      	mov	r5, r1
 8004c4e:	4617      	mov	r7, r2
 8004c50:	4698      	mov	r8, r3
 8004c52:	9e0d      	ldr	r6, [sp, #52]	; 0x34
  PCHANNELINSTANCE ptChannel   = (PCHANNELINSTANCE)hChannel;
  int32_t          lRet        = CIFX_NO_ERROR;
 8004c54:	2300      	movs	r3, #0
 8004c56:	9303      	str	r3, [sp, #12]
  PIOINSTANCE      ptIOArea    = NULL;
  uint8_t          bIOBitState = HIL_FLAGS_NONE;

  if(!DEV_IsRunning(ptChannel))
 8004c58:	f000 fda6 	bl	80057a8 <DEV_IsRunning>
 8004c5c:	2800      	cmp	r0, #0
 8004c5e:	d055      	beq.n	8004d0c <xChannelIOWrite+0xc8>
    return CIFX_DEV_NOT_RUNNING;
  if(ulAreaNumber >= ptChannel->ulIOOutputAreas)
 8004c60:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
 8004c64:	42ab      	cmp	r3, r5
 8004c66:	d953      	bls.n	8004d10 <xChannelIOWrite+0xcc>
    return CIFX_INVALID_PARAMETER;

  ptIOArea    = ptChannel->pptIOOutputAreas[ulAreaNumber];
 8004c68:	f8d4 3144 	ldr.w	r3, [r4, #324]	; 0x144
 8004c6c:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
  bIOBitState = DEV_GetIOBitstate(ptChannel, ptIOArea, 1);
 8004c70:	2201      	movs	r2, #1
 8004c72:	4629      	mov	r1, r5
 8004c74:	4620      	mov	r0, r4
 8004c76:	f000 fb12 	bl	800529e <DEV_GetIOBitstate>
 8004c7a:	4681      	mov	r9, r0
#endif
  {
    /*---------------------------*/
    /* This is DPM data transfer */
    /*---------------------------*/
    if( (ulOffset + ulDataLen) > ptIOArea->ulDPMAreaLength)
 8004c7c:	eb07 0308 	add.w	r3, r7, r8
 8004c80:	686a      	ldr	r2, [r5, #4]
 8004c82:	4293      	cmp	r3, r2
 8004c84:	d846      	bhi.n	8004d14 <xChannelIOWrite+0xd0>
      return CIFX_INVALID_ACCESS_SIZE; /* read size too long */

    /* Check if another command is active */
    if ( !OS_WaitMutex( ptIOArea->pvMutex, ulTimeout))
 8004c86:	4631      	mov	r1, r6
 8004c88:	6928      	ldr	r0, [r5, #16]
 8004c8a:	f7fd ffab 	bl	8002be4 <OS_WaitMutex>
 8004c8e:	2800      	cmp	r0, #0
 8004c90:	d042      	beq.n	8004d18 <xChannelIOWrite+0xd4>
      return CIFX_DRV_CMD_ACTIVE;

    /* Read data */
    /* TODO: define write procedure ??Toggle -> Write or Write->Toggle */
    if(HIL_FLAGS_NONE == bIOBitState)
 8004c92:	f1b9 0fff 	cmp.w	r9, #255	; 0xff
 8004c96:	d114      	bne.n	8004cc2 <xChannelIOWrite+0x7e>
    {
      /* Read data without handshake */
      HWIF_WRITEN(  ptChannel->pvDeviceInstance,
 8004c98:	6821      	ldr	r1, [r4, #0]
 8004c9a:	f8d1 62c8 	ldr.w	r6, [r1, #712]	; 0x2c8
 8004c9e:	682a      	ldr	r2, [r5, #0]
 8004ca0:	f8cd 8000 	str.w	r8, [sp]
 8004ca4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004ca6:	443a      	add	r2, r7
 8004ca8:	2000      	movs	r0, #0
 8004caa:	47b0      	blx	r6
                   &ptIOArea->pbDPMAreaStart[ulOffset],
                    pvData,
                    ulDataLen);

      /* Check COMM Flag for return value */
      (void)DEV_IsCommunicating(ptChannel, &lRet);
 8004cac:	a903      	add	r1, sp, #12
 8004cae:	4620      	mov	r0, r4
 8004cb0:	f000 fcee 	bl	8005690 <DEV_IsCommunicating>
        (void)DEV_IsCommunicating(ptChannel, &lRet);
      }
    }

    /* Release command */
    OS_ReleaseMutex( ptIOArea->pvMutex);
 8004cb4:	6928      	ldr	r0, [r5, #16]
 8004cb6:	f7fd ffa1 	bl	8002bfc <OS_ReleaseMutex>
  }

  return lRet;
 8004cba:	9803      	ldr	r0, [sp, #12]
}
 8004cbc:	b005      	add	sp, #20
 8004cbe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if(!DEV_WaitForBitState(ptChannel, ptIOArea->bHandshakeBit, bIOBitState, ulTimeout))
 8004cc2:	4633      	mov	r3, r6
 8004cc4:	464a      	mov	r2, r9
 8004cc6:	7a29      	ldrb	r1, [r5, #8]
 8004cc8:	4620      	mov	r0, r4
 8004cca:	f000 fc18 	bl	80054fe <DEV_WaitForBitState>
 8004cce:	b910      	cbnz	r0, 8004cd6 <xChannelIOWrite+0x92>
        lRet = CIFX_DEV_EXCHANGE_FAILED;
 8004cd0:	4b12      	ldr	r3, [pc, #72]	; (8004d1c <xChannelIOWrite+0xd8>)
 8004cd2:	9303      	str	r3, [sp, #12]
 8004cd4:	e7ee      	b.n	8004cb4 <xChannelIOWrite+0x70>
        HWIF_WRITEN(  ptChannel->pvDeviceInstance,
 8004cd6:	6821      	ldr	r1, [r4, #0]
 8004cd8:	f8d1 62c8 	ldr.w	r6, [r1, #712]	; 0x2c8
 8004cdc:	682a      	ldr	r2, [r5, #0]
 8004cde:	f8cd 8000 	str.w	r8, [sp]
 8004ce2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004ce4:	443a      	add	r2, r7
 8004ce6:	2000      	movs	r0, #0
 8004ce8:	47b0      	blx	r6
        OS_EnterLock(ptChannel->pvLock);
 8004cea:	69a0      	ldr	r0, [r4, #24]
 8004cec:	f7fd ff58 	bl	8002ba0 <OS_EnterLock>
        DEV_ToggleBit(ptChannel, (uint32_t)(1UL << ptIOArea->bHandshakeBit));
 8004cf0:	7a2b      	ldrb	r3, [r5, #8]
 8004cf2:	2101      	movs	r1, #1
 8004cf4:	4099      	lsls	r1, r3
 8004cf6:	4620      	mov	r0, r4
 8004cf8:	f000 fa93 	bl	8005222 <DEV_ToggleBit>
        OS_LeaveLock(ptChannel->pvLock);
 8004cfc:	69a0      	ldr	r0, [r4, #24]
 8004cfe:	f7fd ff5b 	bl	8002bb8 <OS_LeaveLock>
        (void)DEV_IsCommunicating(ptChannel, &lRet);
 8004d02:	a903      	add	r1, sp, #12
 8004d04:	4620      	mov	r0, r4
 8004d06:	f000 fcc3 	bl	8005690 <DEV_IsCommunicating>
 8004d0a:	e7d3      	b.n	8004cb4 <xChannelIOWrite+0x70>
    return CIFX_DEV_NOT_RUNNING;
 8004d0c:	4804      	ldr	r0, [pc, #16]	; (8004d20 <xChannelIOWrite+0xdc>)
 8004d0e:	e7d5      	b.n	8004cbc <xChannelIOWrite+0x78>
    return CIFX_INVALID_PARAMETER;
 8004d10:	4804      	ldr	r0, [pc, #16]	; (8004d24 <xChannelIOWrite+0xe0>)
 8004d12:	e7d3      	b.n	8004cbc <xChannelIOWrite+0x78>
      return CIFX_INVALID_ACCESS_SIZE; /* read size too long */
 8004d14:	4804      	ldr	r0, [pc, #16]	; (8004d28 <xChannelIOWrite+0xe4>)
 8004d16:	e7d1      	b.n	8004cbc <xChannelIOWrite+0x78>
      return CIFX_DRV_CMD_ACTIVE;
 8004d18:	4804      	ldr	r0, [pc, #16]	; (8004d2c <xChannelIOWrite+0xe8>)
 8004d1a:	e7cf      	b.n	8004cbc <xChannelIOWrite+0x78>
 8004d1c:	800c0022 	.word	0x800c0022
 8004d20:	800c0012 	.word	0x800c0012
 8004d24:	800a0005 	.word	0x800a0005
 8004d28:	800a0008 	.word	0x800a0008
 8004d2c:	800b0004 	.word	0x800b0004

08004d30 <xDriverOpen>:
*   \param phDriver     Returned handle to the driver
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xDriverOpen(CIFXHANDLE* phDriver)
{
  if(!g_tDriverInfo.fInitialized)
 8004d30:	4b05      	ldr	r3, [pc, #20]	; (8004d48 <xDriverOpen+0x18>)
 8004d32:	685b      	ldr	r3, [r3, #4]
 8004d34:	b133      	cbz	r3, 8004d44 <xDriverOpen+0x14>
    return CIFX_DRV_DRIVER_NOT_LOADED;

  CHECK_POINTER(phDriver);

  *phDriver = &g_tDriverInfo;
 8004d36:	4b04      	ldr	r3, [pc, #16]	; (8004d48 <xDriverOpen+0x18>)
 8004d38:	6003      	str	r3, [r0, #0]

  ++g_tDriverInfo.ulOpenCount;
 8004d3a:	681a      	ldr	r2, [r3, #0]
 8004d3c:	3201      	adds	r2, #1
 8004d3e:	601a      	str	r2, [r3, #0]

  return CIFX_NO_ERROR;
 8004d40:	2000      	movs	r0, #0
 8004d42:	4770      	bx	lr
    return CIFX_DRV_DRIVER_NOT_LOADED;
 8004d44:	4801      	ldr	r0, [pc, #4]	; (8004d4c <xDriverOpen+0x1c>)
}
 8004d46:	4770      	bx	lr
 8004d48:	20000214 	.word	0x20000214
 8004d4c:	800b0030 	.word	0x800b0030

08004d50 <xDriverClose>:
*   \param hDriver     Handle to connection, that is being closed
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xDriverClose(CIFXHANDLE hDriver)
{
  if(!g_tDriverInfo.fInitialized)
 8004d50:	4b07      	ldr	r3, [pc, #28]	; (8004d70 <xDriverClose+0x20>)
 8004d52:	685b      	ldr	r3, [r3, #4]
 8004d54:	b13b      	cbz	r3, 8004d66 <xDriverClose+0x16>
    return CIFX_DRV_DRIVER_NOT_LOADED;

  if(g_tDriverInfo.ulOpenCount == 0)
 8004d56:	4b06      	ldr	r3, [pc, #24]	; (8004d70 <xDriverClose+0x20>)
 8004d58:	681b      	ldr	r3, [r3, #0]
 8004d5a:	b133      	cbz	r3, 8004d6a <xDriverClose+0x1a>
    return CIFX_DRV_NOT_OPENED;

  CHECK_DRIVERHANDLE(hDriver);

  --g_tDriverInfo.ulOpenCount;
 8004d5c:	3b01      	subs	r3, #1
 8004d5e:	4a04      	ldr	r2, [pc, #16]	; (8004d70 <xDriverClose+0x20>)
 8004d60:	6013      	str	r3, [r2, #0]

  return CIFX_NO_ERROR; /*lint !e438 */
 8004d62:	2000      	movs	r0, #0
 8004d64:	4770      	bx	lr
    return CIFX_DRV_DRIVER_NOT_LOADED;
 8004d66:	4803      	ldr	r0, [pc, #12]	; (8004d74 <xDriverClose+0x24>)
 8004d68:	4770      	bx	lr
    return CIFX_DRV_NOT_OPENED;
 8004d6a:	4803      	ldr	r0, [pc, #12]	; (8004d78 <xDriverClose+0x28>)
}
 8004d6c:	4770      	bx	lr
 8004d6e:	bf00      	nop
 8004d70:	20000214 	.word	0x20000214
 8004d74:	800b0030 	.word	0x800b0030
 8004d78:	800b0034 	.word	0x800b0034

08004d7c <xDriverEnumBoards>:
*   \param ulSize       Size of return buffer
*   \param pvBoardInfo  Return buffer (BOARD_INFORMATION structure)
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xDriverEnumBoards(CIFXHANDLE hDriver, uint32_t ulBoard, uint32_t ulSize, void* pvBoardInfo)
{
 8004d7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004d80:	b082      	sub	sp, #8
 8004d82:	461c      	mov	r4, r3
  BOARD_INFORMATION*        ptBoardInfo   = (BOARD_INFORMATION*)pvBoardInfo;
  PDEVICEINSTANCE           ptDevInstance = NULL;
  HIL_DPM_SYSTEM_CHANNEL_T* ptSysChannel  = NULL;

  if(g_tDriverInfo.ulOpenCount == 0)
 8004d84:	4b28      	ldr	r3, [pc, #160]	; (8004e28 <xDriverEnumBoards+0xac>)
 8004d86:	681b      	ldr	r3, [r3, #0]
 8004d88:	2b00      	cmp	r3, #0
 8004d8a:	d046      	beq.n	8004e1a <xDriverEnumBoards+0x9e>
 8004d8c:	460e      	mov	r6, r1
    return CIFX_DRV_NOT_OPENED;

  CHECK_DRIVERHANDLE(hDriver);
  CHECK_POINTER(pvBoardInfo);

  if(ulSize < (uint32_t)sizeof(*ptBoardInfo))
 8004d8e:	2a6c      	cmp	r2, #108	; 0x6c
 8004d90:	d945      	bls.n	8004e1e <xDriverEnumBoards+0xa2>
    return CIFX_INVALID_BUFFERSIZE;

  if(ulBoard >= g_ulDeviceCount)
 8004d92:	4b26      	ldr	r3, [pc, #152]	; (8004e2c <xDriverEnumBoards+0xb0>)
 8004d94:	681b      	ldr	r3, [r3, #0]
 8004d96:	428b      	cmp	r3, r1
 8004d98:	d943      	bls.n	8004e22 <xDriverEnumBoards+0xa6>
    return CIFX_NO_MORE_ENTRIES;

  ptDevInstance = g_pptDevices[ulBoard];
 8004d9a:	4b25      	ldr	r3, [pc, #148]	; (8004e30 <xDriverEnumBoards+0xb4>)
 8004d9c:	681b      	ldr	r3, [r3, #0]
 8004d9e:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
  ptSysChannel  = (HIL_DPM_SYSTEM_CHANNEL_T*)ptDevInstance->pbDPM;
 8004da2:	6a2f      	ldr	r7, [r5, #32]

  (void)OS_Strncpy(ptBoardInfo->abBoardName,  ptDevInstance->szName,  sizeof(ptBoardInfo->abBoardName));
 8004da4:	2210      	movs	r2, #16
 8004da6:	f105 0129 	add.w	r1, r5, #41	; 0x29
 8004daa:	1d20      	adds	r0, r4, #4
 8004dac:	f7fd ffa4 	bl	8002cf8 <OS_Strncpy>
  (void)OS_Strncpy(ptBoardInfo->abBoardAlias, ptDevInstance->szAlias, sizeof(ptBoardInfo->abBoardAlias));
 8004db0:	2210      	movs	r2, #16
 8004db2:	f105 0139 	add.w	r1, r5, #57	; 0x39
 8004db6:	f104 0014 	add.w	r0, r4, #20
 8004dba:	f7fd ff9d 	bl	8002cf8 <OS_Strncpy>
  ptBoardInfo->ulBoardID         = ulBoard;
 8004dbe:	6266      	str	r6, [r4, #36]	; 0x24

  {
    ptBoardInfo->ulSystemError     = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysChannel->tSystemState.ulSystemError));
 8004dc0:	f107 01c8 	add.w	r1, r7, #200	; 0xc8
 8004dc4:	4628      	mov	r0, r5
 8004dc6:	f000 fa98 	bl	80052fa <HwIfRead32>
 8004dca:	62a0      	str	r0, [r4, #40]	; 0x28

    ptBoardInfo->ulPhysicalAddress = ptDevInstance->ulPhysicalAddress;
 8004dcc:	682b      	ldr	r3, [r5, #0]
 8004dce:	62e3      	str	r3, [r4, #44]	; 0x2c
    ptBoardInfo->ulIrqNumber       = ptDevInstance->ulIrqNumber;
 8004dd0:	686b      	ldr	r3, [r5, #4]
 8004dd2:	6323      	str	r3, [r4, #48]	; 0x30
    ptBoardInfo->bIrqEnabled       = ptDevInstance->fIrqEnabled? 1 : 0;
 8004dd4:	68ab      	ldr	r3, [r5, #8]
 8004dd6:	3b00      	subs	r3, #0
 8004dd8:	bf18      	it	ne
 8004dda:	2301      	movne	r3, #1
 8004ddc:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    ptBoardInfo->ulDpmTotalSize    = ptDevInstance->ulDPMSize;
 8004de0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8004de2:	f8c4 3039 	str.w	r3, [r4, #57]	; 0x39
    ptBoardInfo->ulChannelCnt      = ptDevInstance->ulCommChannelCount;
 8004de6:	f8d5 3260 	ldr.w	r3, [r5, #608]	; 0x260
 8004dea:	f8c4 3035 	str.w	r3, [r4, #53]	; 0x35

    HWIF_READN(ptDevInstance, &ptBoardInfo->tSystemInfo, &ptSysChannel->tSystemInfo, sizeof(ptBoardInfo->tSystemInfo));
 8004dee:	f8d5 82c4 	ldr.w	r8, [r5, #708]	; 0x2c4
 8004df2:	343d      	adds	r4, #61	; 0x3d
 8004df4:	2630      	movs	r6, #48	; 0x30
 8004df6:	9600      	str	r6, [sp, #0]
 8004df8:	4623      	mov	r3, r4
 8004dfa:	463a      	mov	r2, r7
 8004dfc:	4629      	mov	r1, r5
 8004dfe:	2000      	movs	r0, #0
 8004e00:	47c0      	blx	r8
  }

  (void)cifXConvertEndianess(0,
 8004e02:	2305      	movs	r3, #5
 8004e04:	9300      	str	r3, [sp, #0]
 8004e06:	4b0b      	ldr	r3, [pc, #44]	; (8004e34 <xDriverEnumBoards+0xb8>)
 8004e08:	4632      	mov	r2, r6
 8004e0a:	4621      	mov	r1, r4
 8004e0c:	2000      	movs	r0, #0
 8004e0e:	f7ff fc39 	bl	8004684 <cifXConvertEndianess>
                             &ptBoardInfo->tSystemInfo,
                             sizeof(ptBoardInfo->tSystemInfo),
                             s_atSystemInfoBlock,
                             sizeof(s_atSystemInfoBlock) / sizeof(s_atSystemInfoBlock[0]));

  return CIFX_NO_ERROR; /*lint !e438 */
 8004e12:	2000      	movs	r0, #0
}
 8004e14:	b002      	add	sp, #8
 8004e16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return CIFX_DRV_NOT_OPENED;
 8004e1a:	4807      	ldr	r0, [pc, #28]	; (8004e38 <xDriverEnumBoards+0xbc>)
 8004e1c:	e7fa      	b.n	8004e14 <xDriverEnumBoards+0x98>
    return CIFX_INVALID_BUFFERSIZE;
 8004e1e:	4807      	ldr	r0, [pc, #28]	; (8004e3c <xDriverEnumBoards+0xc0>)
 8004e20:	e7f8      	b.n	8004e14 <xDriverEnumBoards+0x98>
    return CIFX_NO_MORE_ENTRIES;
 8004e22:	4807      	ldr	r0, [pc, #28]	; (8004e40 <xDriverEnumBoards+0xc4>)
 8004e24:	e7f6      	b.n	8004e14 <xDriverEnumBoards+0x98>
 8004e26:	bf00      	nop
 8004e28:	20000214 	.word	0x20000214
 8004e2c:	2000021c 	.word	0x2000021c
 8004e30:	2000020c 	.word	0x2000020c
 8004e34:	0800af68 	.word	0x0800af68
 8004e38:	800b0034 	.word	0x800b0034
 8004e3c:	800a0007 	.word	0x800a0007
 8004e40:	800a0014 	.word	0x800a0014

08004e44 <xChannelInfo>:
*   \param ulSize         Size of return buffer
*   \param pvChannelInfo  Return buffer (CHANNEL_INFORMATION structure)
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xChannelInfo(CIFXHANDLE hChannel, uint32_t ulSize, void* pvChannelInfo)
{
 8004e44:	b570      	push	{r4, r5, r6, lr}
  PDEVICEINSTANCE       ptDevInstance = NULL;

  CHECK_CHANNELHANDLE(hChannel);
  CHECK_POINTER(pvChannelInfo);

  ptDevInstance = (PDEVICEINSTANCE)ptChannel->pvDeviceInstance;
 8004e46:	6805      	ldr	r5, [r0, #0]

  if(ulSize < (uint32_t)sizeof(*ptChannelInfo))
 8004e48:	29a3      	cmp	r1, #163	; 0xa3
 8004e4a:	d974      	bls.n	8004f36 <xChannelInfo+0xf2>
 8004e4c:	4606      	mov	r6, r0
 8004e4e:	4614      	mov	r4, r2
    return CIFX_INVALID_BUFFERSIZE;

  (void)OS_Strncpy(ptChannelInfo->abBoardName,
 8004e50:	2210      	movs	r2, #16
 8004e52:	f105 0129 	add.w	r1, r5, #41	; 0x29
 8004e56:	4620      	mov	r0, r4
 8004e58:	f7fd ff4e 	bl	8002cf8 <OS_Strncpy>
                   ptDevInstance->szName,
                   (uint32_t)sizeof(ptChannelInfo->abBoardName));
  (void)OS_Strncpy(ptChannelInfo->abBoardAlias,
 8004e5c:	2210      	movs	r2, #16
 8004e5e:	f105 0139 	add.w	r1, r5, #57	; 0x39
 8004e62:	18a0      	adds	r0, r4, r2
 8004e64:	f7fd ff48 	bl	8002cf8 <OS_Strncpy>
                   ptDevInstance->szAlias,
                   (uint32_t)sizeof(ptChannelInfo->abBoardAlias));

  ptChannelInfo->ulDeviceNumber   = ptDevInstance->ulDeviceNumber;
 8004e68:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8004e6a:	6223      	str	r3, [r4, #32]
  ptChannelInfo->ulSerialNumber   = ptDevInstance->ulSerialNumber;
 8004e6c:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8004e6e:	6263      	str	r3, [r4, #36]	; 0x24

  ptChannelInfo->usFWMajor        = ptChannel->tFirmwareIdent.tFwVersion.usMajor;
 8004e70:	8d33      	ldrh	r3, [r6, #40]	; 0x28
 8004e72:	8523      	strh	r3, [r4, #40]	; 0x28
  ptChannelInfo->usFWMinor        = ptChannel->tFirmwareIdent.tFwVersion.usMinor;
 8004e74:	8d73      	ldrh	r3, [r6, #42]	; 0x2a
 8004e76:	8563      	strh	r3, [r4, #42]	; 0x2a
  ptChannelInfo->usFWRevision     = ptChannel->tFirmwareIdent.tFwVersion.usRevision;
 8004e78:	8df3      	ldrh	r3, [r6, #46]	; 0x2e
 8004e7a:	85e3      	strh	r3, [r4, #46]	; 0x2e
  ptChannelInfo->usFWBuild        = ptChannel->tFirmwareIdent.tFwVersion.usBuild;
 8004e7c:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
 8004e7e:	85a3      	strh	r3, [r4, #44]	; 0x2c
  ptChannelInfo->bFWNameLength    = ptChannel->tFirmwareIdent.tFwName.bNameLength;
 8004e80:	f896 3030 	ldrb.w	r3, [r6, #48]	; 0x30
 8004e84:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30

  OS_Memcpy(ptChannelInfo->abFWName,
 8004e88:	223f      	movs	r2, #63	; 0x3f
 8004e8a:	f106 0131 	add.w	r1, r6, #49	; 0x31
 8004e8e:	f104 0031 	add.w	r0, r4, #49	; 0x31
 8004e92:	f7fd fe48 	bl	8002b26 <OS_Memcpy>
            ptChannel->tFirmwareIdent.tFwName.abName,
            sizeof(ptChannelInfo->abFWName));

  ptChannelInfo->usFWYear         = ptChannel->tFirmwareIdent.tFwDate.usYear;
 8004e96:	f8b6 3070 	ldrh.w	r3, [r6, #112]	; 0x70
 8004e9a:	f8a4 3070 	strh.w	r3, [r4, #112]	; 0x70
  ptChannelInfo->bFWMonth         = ptChannel->tFirmwareIdent.tFwDate.bMonth;
 8004e9e:	f896 3072 	ldrb.w	r3, [r6, #114]	; 0x72
 8004ea2:	f884 3072 	strb.w	r3, [r4, #114]	; 0x72
  ptChannelInfo->bFWDay           = ptChannel->tFirmwareIdent.tFwDate.bDay;
 8004ea6:	f896 3073 	ldrb.w	r3, [r6, #115]	; 0x73
 8004eaa:	f884 3073 	strb.w	r3, [r4, #115]	; 0x73

  ptChannelInfo->ulChannelError   = 0;
 8004eae:	2300      	movs	r3, #0
 8004eb0:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
 8004eb4:	f884 3075 	strb.w	r3, [r4, #117]	; 0x75
 8004eb8:	f884 3076 	strb.w	r3, [r4, #118]	; 0x76
 8004ebc:	f884 3077 	strb.w	r3, [r4, #119]	; 0x77
  if(0 != ptChannel->ptCommonStatusBlock)
 8004ec0:	f8d6 10dc 	ldr.w	r1, [r6, #220]	; 0xdc
 8004ec4:	b121      	cbz	r1, 8004ed0 <xChannelInfo+0x8c>
  {
    ptChannelInfo->ulChannelError = LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptChannel->ptCommonStatusBlock->ulCommunicationError));
 8004ec6:	3108      	adds	r1, #8
 8004ec8:	6830      	ldr	r0, [r6, #0]
 8004eca:	f000 fa16 	bl	80052fa <HwIfRead32>
 8004ece:	6760      	str	r0, [r4, #116]	; 0x74
  }

  ptChannelInfo->ulOpenCnt        = ptChannel->ulOpenCount;
 8004ed0:	69f3      	ldr	r3, [r6, #28]
 8004ed2:	67a3      	str	r3, [r4, #120]	; 0x78
  ptChannelInfo->ulPutPacketCnt   = ptChannel->tSendMbx.ulSendPacketCnt;
 8004ed4:	f8d6 3088 	ldr.w	r3, [r6, #136]	; 0x88
 8004ed8:	67e3      	str	r3, [r4, #124]	; 0x7c
  ptChannelInfo->ulGetPacketCnt   = ptChannel->tRecvMbx.ulRecvPacketCnt;
 8004eda:	f8d6 30a8 	ldr.w	r3, [r6, #168]	; 0xa8
 8004ede:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  ptChannelInfo->ulMailboxSize    = ptChannel->tSendMbx.ulSendMailboxLength;
 8004ee2:	6fb3      	ldr	r3, [r6, #120]	; 0x78
 8004ee4:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  ptChannelInfo->ulIOInAreaCnt    = ptChannel->ulIOInputAreas;
 8004ee8:	f8d6 3140 	ldr.w	r3, [r6, #320]	; 0x140
 8004eec:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  ptChannelInfo->ulIOOutAreaCnt   = ptChannel->ulIOOutputAreas;
 8004ef0:	f8d6 3148 	ldr.w	r3, [r6, #328]	; 0x148
 8004ef4:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
  ptChannelInfo->ulHskSize        = ptChannel->bHandshakeWidth;
 8004ef8:	f896 30f8 	ldrb.w	r3, [r6, #248]	; 0xf8
 8004efc:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90

  /* Check if we are in interrupt mode */
  if(!((PDEVICEINSTANCE)(ptChannel->pvDeviceInstance))->fIrqEnabled)
 8004f00:	6833      	ldr	r3, [r6, #0]
 8004f02:	689b      	ldr	r3, [r3, #8]
 8004f04:	b18b      	cbz	r3, 8004f2a <xChannelInfo+0xe6>
    DEV_ReadHandshakeFlags(ptChannel, 0, 1);

  ptChannelInfo->ulNetxFlags      = ptChannel->usNetxFlags;
 8004f06:	f8b6 30be 	ldrh.w	r3, [r6, #190]	; 0xbe
 8004f0a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
  ptChannelInfo->ulHostFlags      = ptChannel->usHostFlags;
 8004f0e:	f8b6 30bc 	ldrh.w	r3, [r6, #188]	; 0xbc
 8004f12:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
  ptChannelInfo->ulHostCOSFlags   = ptChannel->ulHostCOSFlags;
 8004f16:	f8d6 30c8 	ldr.w	r3, [r6, #200]	; 0xc8
 8004f1a:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
  ptChannelInfo->ulDeviceCOSFlags = ptChannel->ulDeviceCOSFlags;
 8004f1e:	f8d6 30c0 	ldr.w	r3, [r6, #192]	; 0xc0
 8004f22:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0

  return CIFX_NO_ERROR;
 8004f26:	2000      	movs	r0, #0
}
 8004f28:	bd70      	pop	{r4, r5, r6, pc}
    DEV_ReadHandshakeFlags(ptChannel, 0, 1);
 8004f2a:	2201      	movs	r2, #1
 8004f2c:	2100      	movs	r1, #0
 8004f2e:	4630      	mov	r0, r6
 8004f30:	f000 fa2b 	bl	800538a <DEV_ReadHandshakeFlags>
 8004f34:	e7e7      	b.n	8004f06 <xChannelInfo+0xc2>
    return CIFX_INVALID_BUFFERSIZE;
 8004f36:	4801      	ldr	r0, [pc, #4]	; (8004f3c <xChannelInfo+0xf8>)
 8004f38:	e7f6      	b.n	8004f28 <xChannelInfo+0xe4>
 8004f3a:	bf00      	nop
 8004f3c:	800a0007 	.word	0x800a0007

08004f40 <xChannelHostState>:
*   \param ulTimeout      Time in ms to wait for start/stop communication
*                         flag
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xChannelHostState(CIFXHANDLE hChannel, uint32_t ulCmd, uint32_t* pulState, uint32_t ulTimeout)
{
 8004f40:	b508      	push	{r3, lr}
  int32_t lRet = CIFX_INVALID_PARAMETER;

  CHECK_CHANNELHANDLE(hChannel);
  CHECK_POINTER(pulState);

  switch(ulCmd)
 8004f42:	2901      	cmp	r1, #1
 8004f44:	d905      	bls.n	8004f52 <xChannelHostState+0x12>
 8004f46:	2902      	cmp	r1, #2
 8004f48:	d107      	bne.n	8004f5a <xChannelHostState+0x1a>
  {
  case CIFX_HOST_STATE_READ:
    lRet = DEV_GetHostState( (PCHANNELINSTANCE)hChannel,
 8004f4a:	4611      	mov	r1, r2
 8004f4c:	f000 fbce 	bl	80056ec <DEV_GetHostState>
    lRet = CIFX_INVALID_COMMAND;
    break;
  }

  return lRet;
}
 8004f50:	bd08      	pop	{r3, pc}
    lRet = DEV_SetHostState( (PCHANNELINSTANCE)hChannel,
 8004f52:	461a      	mov	r2, r3
 8004f54:	f000 fbdc 	bl	8005710 <DEV_SetHostState>
    break;
 8004f58:	e7fa      	b.n	8004f50 <xChannelHostState+0x10>
  switch(ulCmd)
 8004f5a:	4801      	ldr	r0, [pc, #4]	; (8004f60 <xChannelHostState+0x20>)
  return lRet;
 8004f5c:	e7f8      	b.n	8004f50 <xChannelHostState+0x10>
 8004f5e:	bf00      	nop
 8004f60:	800a0006 	.word	0x800a0006

08004f64 <xSysdeviceFindFirstFile>:
*   \param pvUser             User data for callback function
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xSysdeviceFindFirstFile(CIFXHANDLE hSysdevice, uint32_t ulChannel, CIFX_DIRECTORYENTRY* ptDirectoryInfo,
                                      PFN_RECV_PKT_CALLBACK  pfnRecvPktCallback, void* pvUser)
{
 8004f64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004f68:	f5ad 6dd2 	sub.w	sp, sp, #1680	; 0x690
 8004f6c:	4604      	mov	r4, r0
 8004f6e:	460f      	mov	r7, r1
 8004f70:	4615      	mov	r5, r2
 8004f72:	461e      	mov	r6, r3
    HIL_DIR_LIST_REQ_T tDirListReq;

  }                   uSendPacket;
  HIL_DIR_LIST_CNF_T  tDirListCnf;

  OS_Memset(&uSendPacket, 0, sizeof(uSendPacket));
 8004f74:	f240 623c 	movw	r2, #1596	; 0x63c
 8004f78:	2100      	movs	r1, #0
 8004f7a:	a815      	add	r0, sp, #84	; 0x54
 8004f7c:	f7fd fdcf 	bl	8002b1e <OS_Memset>
  OS_Memset(&tDirListCnf, 0, sizeof(tDirListCnf));
 8004f80:	2240      	movs	r2, #64	; 0x40
 8004f82:	2100      	movs	r1, #0
 8004f84:	a805      	add	r0, sp, #20
 8004f86:	f7fd fdca 	bl	8002b1e <OS_Memset>
       return CIFX_INVALID_HANDLE;
#endif

  CHECK_POINTER(ptDirectoryInfo);

  if(OS_Strlen(ptDirectoryInfo->szFilename) > 0)
 8004f8a:	f105 0804 	add.w	r8, r5, #4
 8004f8e:	4640      	mov	r0, r8
 8004f90:	f7fd feae 	bl	8002cf0 <OS_Strlen>
 8004f94:	2800      	cmp	r0, #0
 8004f96:	dc34      	bgt.n	8005002 <xSysdeviceFindFirstFile+0x9e>
    (void)OS_Strncpy( (char*)((&uSendPacket.tDirListReq.tData) + 1),
                       ptDirectoryInfo->szFilename,
                       usDirNameLength);
  }

  uSendPacket.tDirListReq.tHead.ulDest      = HOST_TO_LE32(HIL_PACKET_DEST_SYSTEM);
 8004f98:	2300      	movs	r3, #0
 8004f9a:	9315      	str	r3, [sp, #84]	; 0x54
  uSendPacket.tDirListReq.tHead.ulSrc       = HOST_TO_LE32(((PDEVICEINSTANCE)(ptChannel->pvDeviceInstance))->ulPhysicalAddress);
 8004f9c:	6823      	ldr	r3, [r4, #0]
 8004f9e:	681b      	ldr	r3, [r3, #0]
 8004fa0:	9316      	str	r3, [sp, #88]	; 0x58
  uSendPacket.tDirListReq.tHead.ulCmd       = HOST_TO_LE32(HIL_DIR_LIST_REQ);
 8004fa2:	f641 6370 	movw	r3, #7792	; 0x1e70
 8004fa6:	931c      	str	r3, [sp, #112]	; 0x70
  uSendPacket.tDirListReq.tHead.ulLen       = HOST_TO_LE32( ((uint32_t)sizeof(uSendPacket.tDirListReq.tData) +
 8004fa8:	f8bd 3080 	ldrh.w	r3, [sp, #128]	; 0x80
 8004fac:	3306      	adds	r3, #6
 8004fae:	9319      	str	r3, [sp, #100]	; 0x64
                                                            uSendPacket.tDirListReq.tData.usDirNameLength) );
  uSendPacket.tDirListReq.tData.ulChannelNo = HOST_TO_LE32(ulChannel);
 8004fb0:	971f      	str	r7, [sp, #124]	; 0x7c


  lRet = DEV_TransferPacket(ptChannel,
 8004fb2:	f8dd 36a8 	ldr.w	r3, [sp, #1704]	; 0x6a8
 8004fb6:	9302      	str	r3, [sp, #8]
 8004fb8:	9601      	str	r6, [sp, #4]
 8004fba:	f241 3388 	movw	r3, #5000	; 0x1388
 8004fbe:	9300      	str	r3, [sp, #0]
 8004fc0:	2340      	movs	r3, #64	; 0x40
 8004fc2:	aa05      	add	r2, sp, #20
 8004fc4:	a915      	add	r1, sp, #84	; 0x54
 8004fc6:	4620      	mov	r0, r4
 8004fc8:	f000 fcd6 	bl	8005978 <DEV_TransferPacket>
                            sizeof(tDirListCnf),
                            CIFX_TO_SEND_PACKET,
                            pfnRecvPktCallback,
                            pvUser);

  if( CIFX_NO_ERROR == lRet)
 8004fcc:	4604      	mov	r4, r0
 8004fce:	b998      	cbnz	r0, 8004ff8 <xSysdeviceFindFirstFile+0x94>
  {
    if( SUCCESS_HIL_OK == (lRet = LE32_TO_HOST(tDirListCnf.tHead.ulSta)) )
 8004fd0:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8004fd2:	b98c      	cbnz	r4, 8004ff8 <xSysdeviceFindFirstFile+0x94>
    {
      uint8_t* pbListEntry = (uint8_t*)&ptDirectoryInfo->hList;
      if ((tDirListCnf.tHead.ulExt & HIL_PACKET_SEQ_MASK) == HIL_PACKET_SEQ_LAST)
 8004fd4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8004fd6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8004fda:	2b40      	cmp	r3, #64	; 0x40
 8004fdc:	d01f      	beq.n	800501e <xSysdeviceFindFirstFile+0xba>
        /* invalidate handle */
        *pbListEntry = 0;
      } else
      {
        /* TODO: Store handle for directory list, which needs to be set by firmware */
        *pbListEntry = 1;
 8004fde:	2301      	movs	r3, #1
 8004fe0:	702b      	strb	r3, [r5, #0]

        (void)OS_Strncpy(ptDirectoryInfo->szFilename,
 8004fe2:	2210      	movs	r2, #16
 8004fe4:	a90f      	add	r1, sp, #60	; 0x3c
 8004fe6:	4640      	mov	r0, r8
 8004fe8:	f7fd fe86 	bl	8002cf8 <OS_Strncpy>
                         (const char*)tDirListCnf.tData.szName,
                         sizeof(ptDirectoryInfo->szFilename));

        ptDirectoryInfo->bFiletype  = tDirListCnf.tData.bFileType;
 8004fec:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
 8004ff0:	752b      	strb	r3, [r5, #20]
        ptDirectoryInfo->ulFilesize = LE32_TO_HOST(tDirListCnf.tData.ulFileSize);
 8004ff2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8004ff4:	f8c5 3015 	str.w	r3, [r5, #21]
      }
    }
  }

  return lRet;
}
 8004ff8:	4620      	mov	r0, r4
 8004ffa:	f50d 6dd2 	add.w	sp, sp, #1680	; 0x690
 8004ffe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint16_t usDirNameLength = (uint16_t)(OS_Strlen(ptDirectoryInfo->szFilename) + 1);
 8005002:	4640      	mov	r0, r8
 8005004:	f7fd fe74 	bl	8002cf0 <OS_Strlen>
 8005008:	b282      	uxth	r2, r0
 800500a:	3201      	adds	r2, #1
 800500c:	b292      	uxth	r2, r2
    uSendPacket.tDirListReq.tData.usDirNameLength = HOST_TO_LE16(usDirNameLength);
 800500e:	f8ad 2080 	strh.w	r2, [sp, #128]	; 0x80
    (void)OS_Strncpy( (char*)((&uSendPacket.tDirListReq.tData) + 1),
 8005012:	4641      	mov	r1, r8
 8005014:	f10d 0082 	add.w	r0, sp, #130	; 0x82
 8005018:	f7fd fe6e 	bl	8002cf8 <OS_Strncpy>
 800501c:	e7bc      	b.n	8004f98 <xSysdeviceFindFirstFile+0x34>
        *pbListEntry = 0;
 800501e:	2300      	movs	r3, #0
 8005020:	702b      	strb	r3, [r5, #0]
        lRet = CIFX_NO_MORE_ENTRIES;
 8005022:	4c01      	ldr	r4, [pc, #4]	; (8005028 <xSysdeviceFindFirstFile+0xc4>)
 8005024:	e7e8      	b.n	8004ff8 <xSysdeviceFindFirstFile+0x94>
 8005026:	bf00      	nop
 8005028:	800a0014 	.word	0x800a0014

0800502c <xSysdeviceFindNextFile>:
*   \param pvUser             User data for callback function
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t APIENTRY xSysdeviceFindNextFile(CIFXHANDLE hSysdevice, uint32_t ulChannel, CIFX_DIRECTORYENTRY* ptDirectoryInfo,
                                     PFN_RECV_PKT_CALLBACK  pfnRecvPktCallback, void* pvUser)
{
 800502c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8005030:	f2ad 6d94 	subw	sp, sp, #1684	; 0x694
 8005034:	4605      	mov	r5, r0
 8005036:	4688      	mov	r8, r1
 8005038:	4616      	mov	r6, r2
 800503a:	461f      	mov	r7, r3

  }                   uSendPacket;
  HIL_DIR_LIST_CNF_T  tDirListCnf;
  uint16_t            usDirNameLen = 0;

  OS_Memset(&uSendPacket, 0, sizeof(uSendPacket));
 800503c:	f240 623c 	movw	r2, #1596	; 0x63c
 8005040:	2100      	movs	r1, #0
 8005042:	a815      	add	r0, sp, #84	; 0x54
 8005044:	f7fd fd6b 	bl	8002b1e <OS_Memset>
  OS_Memset(&tDirListCnf, 0, sizeof(tDirListCnf));
 8005048:	2240      	movs	r2, #64	; 0x40
 800504a:	2100      	movs	r1, #0
 800504c:	a805      	add	r0, sp, #20
 800504e:	f7fd fd66 	bl	8002b1e <OS_Memset>
       return CIFX_INVALID_HANDLE;
#endif

  CHECK_POINTER(ptDirectoryInfo);

  usDirNameLen = (uint16_t)(OS_Strlen(ptDirectoryInfo->szFilename) + 1);
 8005052:	f106 0904 	add.w	r9, r6, #4
 8005056:	4648      	mov	r0, r9
 8005058:	f7fd fe4a 	bl	8002cf0 <OS_Strlen>
 800505c:	b284      	uxth	r4, r0
 800505e:	3401      	adds	r4, #1
 8005060:	b2a4      	uxth	r4, r4
  uSendPacket.tDirListReq.tData.usDirNameLength = HOST_TO_LE16(usDirNameLen);
 8005062:	f8ad 4080 	strh.w	r4, [sp, #128]	; 0x80
  (void)OS_Strncpy( (char*)((&uSendPacket.tDirListReq.tData) + 1),
 8005066:	4622      	mov	r2, r4
 8005068:	4649      	mov	r1, r9
 800506a:	f10d 0082 	add.w	r0, sp, #130	; 0x82
 800506e:	f7fd fe43 	bl	8002cf8 <OS_Strncpy>
                    ptDirectoryInfo->szFilename,
                    usDirNameLen);

  uSendPacket.tDirListReq.tHead.ulDest      = HOST_TO_LE32(HIL_PACKET_DEST_SYSTEM);
 8005072:	2300      	movs	r3, #0
 8005074:	9315      	str	r3, [sp, #84]	; 0x54
  uSendPacket.tDirListReq.tHead.ulSrc       = HOST_TO_LE32(((PDEVICEINSTANCE)(ptChannel->pvDeviceInstance))->ulPhysicalAddress);
 8005076:	682b      	ldr	r3, [r5, #0]
 8005078:	681b      	ldr	r3, [r3, #0]
 800507a:	9316      	str	r3, [sp, #88]	; 0x58
  uSendPacket.tDirListReq.tHead.ulCmd       = HOST_TO_LE32(HIL_DIR_LIST_REQ);
 800507c:	f641 6370 	movw	r3, #7792	; 0x1e70
 8005080:	931c      	str	r3, [sp, #112]	; 0x70
  uSendPacket.tDirListReq.tHead.ulLen       = HOST_TO_LE32( ((uint32_t)sizeof(uSendPacket.tDirListReq.tData) + usDirNameLen) );
 8005082:	3406      	adds	r4, #6
 8005084:	9419      	str	r4, [sp, #100]	; 0x64
  uSendPacket.tDirListReq.tHead.ulExt       = HOST_TO_LE32(HIL_PACKET_SEQ_MIDDLE);
 8005086:	23c0      	movs	r3, #192	; 0xc0
 8005088:	931d      	str	r3, [sp, #116]	; 0x74

  uSendPacket.tDirListReq.tData.ulChannelNo = HOST_TO_LE32(ulChannel);
 800508a:	f8cd 807c 	str.w	r8, [sp, #124]	; 0x7c

  lRet = DEV_TransferPacket(ptChannel,
 800508e:	f8dd 36b0 	ldr.w	r3, [sp, #1712]	; 0x6b0
 8005092:	9302      	str	r3, [sp, #8]
 8005094:	9701      	str	r7, [sp, #4]
 8005096:	f241 3388 	movw	r3, #5000	; 0x1388
 800509a:	9300      	str	r3, [sp, #0]
 800509c:	2340      	movs	r3, #64	; 0x40
 800509e:	aa05      	add	r2, sp, #20
 80050a0:	a915      	add	r1, sp, #84	; 0x54
 80050a2:	4628      	mov	r0, r5
 80050a4:	f000 fc68 	bl	8005978 <DEV_TransferPacket>
                            sizeof(tDirListCnf),
                            CIFX_TO_SEND_PACKET,
                            pfnRecvPktCallback,
                            pvUser);

  if(CIFX_NO_ERROR == lRet)
 80050a8:	4604      	mov	r4, r0
 80050aa:	b988      	cbnz	r0, 80050d0 <xSysdeviceFindNextFile+0xa4>
  {
    if( SUCCESS_HIL_OK == (lRet = (LE32_TO_HOST(tDirListCnf.tHead.ulSta))) )
 80050ac:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80050ae:	b97c      	cbnz	r4, 80050d0 <xSysdeviceFindNextFile+0xa4>
    {
      if(( LE32_TO_HOST(tDirListCnf.tHead.ulExt) & HIL_PACKET_SEQ_MASK) == HIL_PACKET_SEQ_LAST)
 80050b0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80050b2:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 80050b6:	2b40      	cmp	r3, #64	; 0x40
 80050b8:	d00f      	beq.n	80050da <xSysdeviceFindNextFile+0xae>
        /* this is the last packet */
        lRet = CIFX_NO_MORE_ENTRIES;

      } else
      {
        (void)OS_Strncpy(ptDirectoryInfo->szFilename,
 80050ba:	2210      	movs	r2, #16
 80050bc:	a90f      	add	r1, sp, #60	; 0x3c
 80050be:	4648      	mov	r0, r9
 80050c0:	f7fd fe1a 	bl	8002cf8 <OS_Strncpy>
                         (const char*)tDirListCnf.tData.szName,
                         sizeof(tDirListCnf.tData.szName));

        ptDirectoryInfo->bFiletype  = tDirListCnf.tData.bFileType;
 80050c4:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
 80050c8:	7533      	strb	r3, [r6, #20]
        ptDirectoryInfo->ulFilesize = LE32_TO_HOST(tDirListCnf.tData.ulFileSize);
 80050ca:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80050cc:	f8c6 3015 	str.w	r3, [r6, #21]
      }
    }
  }

  return lRet;
}
 80050d0:	4620      	mov	r0, r4
 80050d2:	f20d 6d94 	addw	sp, sp, #1684	; 0x694
 80050d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        *pbListEntry = 0;
 80050da:	2300      	movs	r3, #0
 80050dc:	7033      	strb	r3, [r6, #0]
        lRet = CIFX_NO_MORE_ENTRIES;
 80050de:	4c01      	ldr	r4, [pc, #4]	; (80050e4 <xSysdeviceFindNextFile+0xb8>)
 80050e0:	e7f6      	b.n	80050d0 <xSysdeviceFindNextFile+0xa4>
 80050e2:	bf00      	nop
 80050e4:	800a0014 	.word	0x800a0014

080050e8 <DEV_Reset_Prepare>:
/*! Mark device to be in reset state and clear device internal structure for
*   reset preparation
*   \param ptDevInstance Device instance                                     */
/*****************************************************************************/
static void DEV_Reset_Prepare(PDEVICEINSTANCE ptDevInstance)
{
 80050e8:	b538      	push	{r3, r4, r5, lr}
 80050ea:	4605      	mov	r5, r0
  uint32_t ulIdx = 0;

  /* Reset is now active and DSR will ignore all incoming interrupts from now on */
  ptDevInstance->fResetActive = 1;
 80050ec:	2301      	movs	r3, #1
 80050ee:	f8c0 32b8 	str.w	r3, [r0, #696]	; 0x2b8

  /* Zero out all internal flags */
  OS_EnterLock(ptDevInstance->tSystemDevice.pvLock);
 80050f2:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
 80050f6:	f7fd fd53 	bl	8002ba0 <OS_EnterLock>
  ptDevInstance->tSystemDevice.usHostFlags = 0;
 80050fa:	2400      	movs	r4, #0
 80050fc:	f8a5 41b0 	strh.w	r4, [r5, #432]	; 0x1b0
  ptDevInstance->tSystemDevice.usNetxFlags = 0;
 8005100:	f8a5 41b2 	strh.w	r4, [r5, #434]	; 0x1b2
  OS_LeaveLock(ptDevInstance->tSystemDevice.pvLock);
 8005104:	f8d5 010c 	ldr.w	r0, [r5, #268]	; 0x10c
 8005108:	f7fd fd56 	bl	8002bb8 <OS_LeaveLock>

  for ( ulIdx = 0; ulIdx < ptDevInstance->ulCommChannelCount; ulIdx++)
 800510c:	e027      	b.n	800515e <DEV_Reset_Prepare+0x76>
  {
    OS_EnterLock(ptDevInstance->pptCommChannels[ulIdx]->pvLock);
 800510e:	f8d5 3264 	ldr.w	r3, [r5, #612]	; 0x264
 8005112:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8005116:	6998      	ldr	r0, [r3, #24]
 8005118:	f7fd fd42 	bl	8002ba0 <OS_EnterLock>
    ptDevInstance->pptCommChannels[ulIdx]->usHostFlags      = 0;
 800511c:	f8d5 3264 	ldr.w	r3, [r5, #612]	; 0x264
 8005120:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
 8005124:	2300      	movs	r3, #0
 8005126:	f8a2 30bc 	strh.w	r3, [r2, #188]	; 0xbc
    ptDevInstance->pptCommChannels[ulIdx]->usNetxFlags      = 0;
 800512a:	f8d5 2264 	ldr.w	r2, [r5, #612]	; 0x264
 800512e:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
 8005132:	f8a2 30be 	strh.w	r3, [r2, #190]	; 0xbe
    ptDevInstance->pptCommChannels[ulIdx]->ulDeviceCOSFlags = 0;
 8005136:	f8d5 2264 	ldr.w	r2, [r5, #612]	; 0x264
 800513a:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
 800513e:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
    ptDevInstance->pptCommChannels[ulIdx]->ulHostCOSFlags   = 0;
 8005142:	f8d5 2264 	ldr.w	r2, [r5, #612]	; 0x264
 8005146:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
 800514a:	f8c2 30c8 	str.w	r3, [r2, #200]	; 0xc8
    OS_LeaveLock(ptDevInstance->pptCommChannels[ulIdx]->pvLock);
 800514e:	f8d5 3264 	ldr.w	r3, [r5, #612]	; 0x264
 8005152:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8005156:	6998      	ldr	r0, [r3, #24]
 8005158:	f7fd fd2e 	bl	8002bb8 <OS_LeaveLock>
  for ( ulIdx = 0; ulIdx < ptDevInstance->ulCommChannelCount; ulIdx++)
 800515c:	3401      	adds	r4, #1
 800515e:	f8d5 3260 	ldr.w	r3, [r5, #608]	; 0x260
 8005162:	42a3      	cmp	r3, r4
 8005164:	d8d3      	bhi.n	800510e <DEV_Reset_Prepare+0x26>
  }
}
 8005166:	bd38      	pop	{r3, r4, r5, pc}

08005168 <DEV_WaitForBitState_Irq>:
{
 8005168:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800516c:	4604      	mov	r4, r0
 800516e:	468a      	mov	sl, r1
 8005170:	4616      	mov	r6, r2
 8005172:	461d      	mov	r5, r3
  uint32_t ulBitMask         = 1 << ulBitNumber;
 8005174:	f04f 0901 	mov.w	r9, #1
 8005178:	fa09 f901 	lsl.w	r9, r9, r1
  if( (HIL_FLAGS_CLEAR == bState) ||
 800517c:	f1a2 0802 	sub.w	r8, r2, #2
 8005180:	fa5f f888 	uxtb.w	r8, r8
 8005184:	f1b8 0f01 	cmp.w	r8, #1
 8005188:	d90e      	bls.n	80051a8 <DEV_WaitForBitState_Irq+0x40>
    if((ptChannel->usHostFlags ^ ptChannel->usNetxFlags) & ulBitMask)
 800518a:	f8b0 30bc 	ldrh.w	r3, [r0, #188]	; 0xbc
 800518e:	f8b0 20be 	ldrh.w	r2, [r0, #190]	; 0xbe
 8005192:	4053      	eors	r3, r2
 8005194:	ea13 0f09 	tst.w	r3, r9
 8005198:	d00f      	beq.n	80051ba <DEV_WaitForBitState_Irq+0x52>
      bActualState = HIL_FLAGS_NOT_EQUAL;
 800519a:	2301      	movs	r3, #1
  if(bActualState == bState)
 800519c:	42b3      	cmp	r3, r6
 800519e:	d03c      	beq.n	800521a <DEV_WaitForBitState_Irq+0xb2>
  if(0 == ulTimeout)
 80051a0:	b96d      	cbnz	r5, 80051be <DEV_WaitForBitState_Irq+0x56>
    return 0;
 80051a2:	2000      	movs	r0, #0
}
 80051a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bActualState = (ptChannel->usNetxFlags & ulBitMask)? HIL_FLAGS_SET : HIL_FLAGS_CLEAR;
 80051a8:	f8b0 30be 	ldrh.w	r3, [r0, #190]	; 0xbe
 80051ac:	ea13 0f09 	tst.w	r3, r9
 80051b0:	d001      	beq.n	80051b6 <DEV_WaitForBitState_Irq+0x4e>
 80051b2:	2303      	movs	r3, #3
 80051b4:	e7f2      	b.n	800519c <DEV_WaitForBitState_Irq+0x34>
 80051b6:	2302      	movs	r3, #2
 80051b8:	e7f0      	b.n	800519c <DEV_WaitForBitState_Irq+0x34>
      bActualState = HIL_FLAGS_EQUAL;
 80051ba:	2300      	movs	r3, #0
 80051bc:	e7ee      	b.n	800519c <DEV_WaitForBitState_Irq+0x34>
  lStartTime = (int32_t)OS_GetMilliSecCounter();
 80051be:	f7fd fcc8 	bl	8002b52 <OS_GetMilliSecCounter>
 80051c2:	4607      	mov	r7, r0
  uint32_t ulInternalTimeout = ulTimeout;
 80051c4:	4629      	mov	r1, r5
 80051c6:	e00d      	b.n	80051e4 <DEV_WaitForBitState_Irq+0x7c>
      bActualState = (ptChannel->usNetxFlags & ulBitMask)? HIL_FLAGS_SET : HIL_FLAGS_CLEAR;
 80051c8:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
 80051cc:	ea13 0f09 	tst.w	r3, r9
 80051d0:	d001      	beq.n	80051d6 <DEV_WaitForBitState_Irq+0x6e>
 80051d2:	2303      	movs	r3, #3
 80051d4:	e002      	b.n	80051dc <DEV_WaitForBitState_Irq+0x74>
 80051d6:	2302      	movs	r3, #2
 80051d8:	e000      	b.n	80051dc <DEV_WaitForBitState_Irq+0x74>
        bActualState = HIL_FLAGS_EQUAL;
 80051da:	2300      	movs	r3, #0
    if(bActualState == bState)
 80051dc:	42b3      	cmp	r3, r6
 80051de:	d01e      	beq.n	800521e <DEV_WaitForBitState_Irq+0xb6>
    if( ulDiffTime >= ulTimeout)
 80051e0:	4295      	cmp	r5, r2
 80051e2:	d918      	bls.n	8005216 <DEV_WaitForBitState_Irq+0xae>
    (void)OS_WaitEvent(ptChannel->ahHandshakeBitEvents[ulBitNumber], ulInternalTimeout);
 80051e4:	f10a 033e 	add.w	r3, sl, #62	; 0x3e
 80051e8:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 80051ec:	6858      	ldr	r0, [r3, #4]
 80051ee:	f7fd fd47 	bl	8002c80 <OS_WaitEvent>
    ulCurrentTime = OS_GetMilliSecCounter();
 80051f2:	f7fd fcae 	bl	8002b52 <OS_GetMilliSecCounter>
    ulDiffTime    = ulCurrentTime - lStartTime;
 80051f6:	1bc2      	subs	r2, r0, r7
    ulInternalTimeout = ulTimeout - ulDiffTime;
 80051f8:	1a38      	subs	r0, r7, r0
 80051fa:	1941      	adds	r1, r0, r5
    if( (HIL_FLAGS_CLEAR == bState) ||
 80051fc:	f1b8 0f01 	cmp.w	r8, #1
 8005200:	d9e2      	bls.n	80051c8 <DEV_WaitForBitState_Irq+0x60>
      if((ptChannel->usHostFlags ^ ptChannel->usNetxFlags) & ulBitMask)
 8005202:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
 8005206:	f8b4 00be 	ldrh.w	r0, [r4, #190]	; 0xbe
 800520a:	4043      	eors	r3, r0
 800520c:	ea13 0f09 	tst.w	r3, r9
 8005210:	d0e3      	beq.n	80051da <DEV_WaitForBitState_Irq+0x72>
        bActualState = HIL_FLAGS_NOT_EQUAL;
 8005212:	2301      	movs	r3, #1
 8005214:	e7e2      	b.n	80051dc <DEV_WaitForBitState_Irq+0x74>
  int      iRet              = 0;
 8005216:	2000      	movs	r0, #0
 8005218:	e7c4      	b.n	80051a4 <DEV_WaitForBitState_Irq+0x3c>
    return 1;
 800521a:	2001      	movs	r0, #1
 800521c:	e7c2      	b.n	80051a4 <DEV_WaitForBitState_Irq+0x3c>
      iRet = 1;
 800521e:	2001      	movs	r0, #1
 8005220:	e7c0      	b.n	80051a4 <DEV_WaitForBitState_Irq+0x3c>

08005222 <DEV_ToggleBit>:
{
 8005222:	b510      	push	{r4, lr}
 8005224:	b084      	sub	sp, #16
  ptChannel->usHostFlags ^= (uint16_t)ulBitMask;
 8005226:	b289      	uxth	r1, r1
 8005228:	f8b0 30bc 	ldrh.w	r3, [r0, #188]	; 0xbc
 800522c:	4059      	eors	r1, r3
 800522e:	b289      	uxth	r1, r1
 8005230:	f8a0 10bc 	strh.w	r1, [r0, #188]	; 0xbc
  if( ptChannel->bHandshakeWidth == HIL_HANDSHAKE_SIZE_8BIT)
 8005234:	f890 30f8 	ldrb.w	r3, [r0, #248]	; 0xf8
 8005238:	2b01      	cmp	r3, #1
 800523a:	d00f      	beq.n	800525c <DEV_ToggleBit+0x3a>
    HWIF_WRITE16(ptChannel->pvDeviceInstance, ptChannel->ptHandshakeCell->t16Bit.usHostFlags, HOST_TO_LE16(ptChannel->usHostFlags));
 800523c:	f8ad 100e 	strh.w	r1, [sp, #14]
 8005240:	6801      	ldr	r1, [r0, #0]
 8005242:	f8d1 42c8 	ldr.w	r4, [r1, #712]	; 0x2c8
 8005246:	f8d0 20f4 	ldr.w	r2, [r0, #244]	; 0xf4
 800524a:	2302      	movs	r3, #2
 800524c:	9300      	str	r3, [sp, #0]
 800524e:	f10d 030e 	add.w	r3, sp, #14
 8005252:	3202      	adds	r2, #2
 8005254:	2001      	movs	r0, #1
 8005256:	47a0      	blx	r4
}
 8005258:	b004      	add	sp, #16
 800525a:	bd10      	pop	{r4, pc}
    HWIF_WRITE8(ptChannel->pvDeviceInstance, ptChannel->ptHandshakeCell->t8Bit.bHostFlags, (uint8_t)ptChannel->usHostFlags);
 800525c:	f88d 100e 	strb.w	r1, [sp, #14]
 8005260:	6801      	ldr	r1, [r0, #0]
 8005262:	f8d1 42c8 	ldr.w	r4, [r1, #712]	; 0x2c8
 8005266:	f8d0 20f4 	ldr.w	r2, [r0, #244]	; 0xf4
 800526a:	2001      	movs	r0, #1
 800526c:	9000      	str	r0, [sp, #0]
 800526e:	f10d 030e 	add.w	r3, sp, #14
 8005272:	3203      	adds	r2, #3
 8005274:	47a0      	blx	r4
 8005276:	e7ef      	b.n	8005258 <DEV_ToggleBit+0x36>

08005278 <HwIfRead8>:
*   \param ptDev Device instance
*   \param pvSrc DPM address to read from
*   \return Byte read from DPM                                               */
/*****************************************************************************/
uint8_t HwIfRead8(PDEVICEINSTANCE ptDev, void* pvSrc)
{
 8005278:	b510      	push	{r4, lr}
 800527a:	b084      	sub	sp, #16
 800527c:	4684      	mov	ip, r0
 800527e:	460a      	mov	r2, r1
  uint8_t bData = 0;
 8005280:	2300      	movs	r3, #0
 8005282:	f88d 300f 	strb.w	r3, [sp, #15]
  (void)ptDev->pfnHwIfRead(1, ptDev, pvSrc, &bData, sizeof(bData));
 8005286:	f8d0 42c4 	ldr.w	r4, [r0, #708]	; 0x2c4
 800528a:	2001      	movs	r0, #1
 800528c:	9000      	str	r0, [sp, #0]
 800528e:	f10d 030f 	add.w	r3, sp, #15
 8005292:	4661      	mov	r1, ip
 8005294:	47a0      	blx	r4
  return bData;
}
 8005296:	f89d 000f 	ldrb.w	r0, [sp, #15]
 800529a:	b004      	add	sp, #16
 800529c:	bd10      	pop	{r4, pc}

0800529e <DEV_GetIOBitstate>:
{
 800529e:	b510      	push	{r4, lr}
  uint8_t  bRet        = ptIOInstance->bHandshakeBitState;
 80052a0:	7b0c      	ldrb	r4, [r1, #12]
  if(fOutput)
 80052a2:	b16a      	cbz	r2, 80052c0 <DEV_GetIOBitstate+0x22>
    pbIOHskMode = &ptChannel->ptCommonStatusBlock->bPDOutHskMode;
 80052a4:	f8d0 10dc 	ldr.w	r1, [r0, #220]	; 0xdc
 80052a8:	3112      	adds	r1, #18
  switch(HWIF_READ8(ptChannel->pvDeviceInstance, *pbIOHskMode))
 80052aa:	6800      	ldr	r0, [r0, #0]
 80052ac:	f7ff ffe4 	bl	8005278 <HwIfRead8>
 80052b0:	2803      	cmp	r0, #3
 80052b2:	d00b      	beq.n	80052cc <DEV_GetIOBitstate+0x2e>
 80052b4:	2804      	cmp	r0, #4
 80052b6:	d00b      	beq.n	80052d0 <DEV_GetIOBitstate+0x32>
 80052b8:	2802      	cmp	r0, #2
 80052ba:	d005      	beq.n	80052c8 <DEV_GetIOBitstate+0x2a>
}
 80052bc:	4620      	mov	r0, r4
 80052be:	bd10      	pop	{r4, pc}
    pbIOHskMode = &ptChannel->ptCommonStatusBlock->bPDInHskMode;
 80052c0:	f8d0 10dc 	ldr.w	r1, [r0, #220]	; 0xdc
 80052c4:	3110      	adds	r1, #16
 80052c6:	e7f0      	b.n	80052aa <DEV_GetIOBitstate+0xc>
      bRet = HIL_FLAGS_NOT_EQUAL;
 80052c8:	2401      	movs	r4, #1
 80052ca:	e7f7      	b.n	80052bc <DEV_GetIOBitstate+0x1e>
      bRet = HIL_FLAGS_NONE;
 80052cc:	24ff      	movs	r4, #255	; 0xff
 80052ce:	e7f5      	b.n	80052bc <DEV_GetIOBitstate+0x1e>
      bRet = HIL_FLAGS_EQUAL;
 80052d0:	2400      	movs	r4, #0
 80052d2:	e7f3      	b.n	80052bc <DEV_GetIOBitstate+0x1e>

080052d4 <HwIfRead16>:
*   \param ptDev Device instance
*   \param pvSrc DPM address to read from
*   \return Word read from DPM                                               */
/*****************************************************************************/
uint16_t HwIfRead16(PDEVICEINSTANCE ptDev, void* pvSrc)
{
 80052d4:	b510      	push	{r4, lr}
 80052d6:	b084      	sub	sp, #16
 80052d8:	460a      	mov	r2, r1
  uint16_t usData = 0;
 80052da:	2300      	movs	r3, #0
 80052dc:	f8ad 300e 	strh.w	r3, [sp, #14]
  (void)ptDev->pfnHwIfRead(1, ptDev, pvSrc, &usData, sizeof(usData));
 80052e0:	f8d0 42c4 	ldr.w	r4, [r0, #708]	; 0x2c4
 80052e4:	2302      	movs	r3, #2
 80052e6:	9300      	str	r3, [sp, #0]
 80052e8:	f10d 030e 	add.w	r3, sp, #14
 80052ec:	4601      	mov	r1, r0
 80052ee:	2001      	movs	r0, #1
 80052f0:	47a0      	blx	r4
  return usData;
}
 80052f2:	f8bd 000e 	ldrh.w	r0, [sp, #14]
 80052f6:	b004      	add	sp, #16
 80052f8:	bd10      	pop	{r4, pc}

080052fa <HwIfRead32>:
*   \param ptDev Device instance
*   \param pvSrc DPM address to read from
*   \return Double word read from DPM                                        */
/*****************************************************************************/
uint32_t HwIfRead32(PDEVICEINSTANCE ptDev, void* pvSrc)
{
 80052fa:	b510      	push	{r4, lr}
 80052fc:	b084      	sub	sp, #16
 80052fe:	460a      	mov	r2, r1
  uint32_t ulData = 0;
 8005300:	2300      	movs	r3, #0
 8005302:	9303      	str	r3, [sp, #12]
  (void)ptDev->pfnHwIfRead(1, ptDev, pvSrc, &ulData, sizeof(ulData));
 8005304:	f8d0 42c4 	ldr.w	r4, [r0, #708]	; 0x2c4
 8005308:	2304      	movs	r3, #4
 800530a:	9300      	str	r3, [sp, #0]
 800530c:	ab03      	add	r3, sp, #12
 800530e:	4601      	mov	r1, r0
 8005310:	2001      	movs	r0, #1
 8005312:	47a0      	blx	r4
  return ulData;
}
 8005314:	9803      	ldr	r0, [sp, #12]
 8005316:	b004      	add	sp, #16
 8005318:	bd10      	pop	{r4, pc}

0800531a <DEV_ReadHostFlags>:
{
 800531a:	b570      	push	{r4, r5, r6, lr}
 800531c:	4604      	mov	r4, r0
 800531e:	460d      	mov	r5, r1
  PDEVICEINSTANCE ptDevInstance = (PDEVICEINSTANCE)ptChannel->pvDeviceInstance;
 8005320:	6806      	ldr	r6, [r0, #0]
  if(ptChannel->bHandshakeWidth == HIL_HANDSHAKE_SIZE_8BIT)
 8005322:	f890 30f8 	ldrb.w	r3, [r0, #248]	; 0xf8
 8005326:	2b01      	cmp	r3, #1
 8005328:	d01f      	beq.n	800536a <DEV_ReadHostFlags+0x50>
    ptChannel->usHostFlags = LE16_TO_HOST(HWIF_READ16(ptChannel->pvDeviceInstance, ptChannel->ptHandshakeCell->t16Bit.usHostFlags));
 800532a:	f8d0 10f4 	ldr.w	r1, [r0, #244]	; 0xf4
 800532e:	3102      	adds	r1, #2
 8005330:	4630      	mov	r0, r6
 8005332:	f7ff ffcf 	bl	80052d4 <HwIfRead16>
 8005336:	f8a4 00bc 	strh.w	r0, [r4, #188]	; 0xbc
  if( (ptDevInstance->pbHandshakeBlock != NULL) &&
 800533a:	6e31      	ldr	r1, [r6, #96]	; 0x60
 800533c:	b109      	cbz	r1, 8005342 <DEV_ReadHostFlags+0x28>
      (ptChannel->fIsSysDevice) )
 800533e:	6a23      	ldr	r3, [r4, #32]
  if( (ptDevInstance->pbHandshakeBlock != NULL) &&
 8005340:	b9e3      	cbnz	r3, 800537c <DEV_ReadHostFlags+0x62>
  if(NULL != ptChannel->ptCommonStatusBlock)
 8005342:	f8d4 10dc 	ldr.w	r1, [r4, #220]	; 0xdc
 8005346:	b121      	cbz	r1, 8005352 <DEV_ReadHostFlags+0x38>
    ptChannel->ulDeviceCOSFlags = LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptChannel->ptCommonStatusBlock->ulCommunicationCOS));
 8005348:	6820      	ldr	r0, [r4, #0]
 800534a:	f7ff ffd6 	bl	80052fa <HwIfRead32>
 800534e:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
  if( fReadHostCOS)
 8005352:	b14d      	cbz	r5, 8005368 <DEV_ReadHostFlags+0x4e>
    if(NULL != ptChannel->ptControlBlock)
 8005354:	f8d4 10d0 	ldr.w	r1, [r4, #208]	; 0xd0
 8005358:	b131      	cbz	r1, 8005368 <DEV_ReadHostFlags+0x4e>
      ptChannel->ulHostCOSFlags       = LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptChannel->ptControlBlock->ulApplicationCOS));
 800535a:	6820      	ldr	r0, [r4, #0]
 800535c:	f7ff ffcd 	bl	80052fa <HwIfRead32>
 8005360:	f8c4 00c8 	str.w	r0, [r4, #200]	; 0xc8
      ptChannel->ulHostCOSFlagsSaved  = ptChannel->ulHostCOSFlags;
 8005364:	f8c4 00cc 	str.w	r0, [r4, #204]	; 0xcc
}
 8005368:	bd70      	pop	{r4, r5, r6, pc}
    ptChannel->usHostFlags = HWIF_READ8(ptChannel->pvDeviceInstance, ptChannel->ptHandshakeCell->t8Bit.bHostFlags);
 800536a:	f8d0 10f4 	ldr.w	r1, [r0, #244]	; 0xf4
 800536e:	3103      	adds	r1, #3
 8005370:	4630      	mov	r0, r6
 8005372:	f7ff ff81 	bl	8005278 <HwIfRead8>
 8005376:	f8a4 00bc 	strh.w	r0, [r4, #188]	; 0xbc
 800537a:	e7de      	b.n	800533a <DEV_ReadHostFlags+0x20>
    ptDevInstance->tSyncData.usHSyncFlags       = LE16_TO_HOST(HWIF_READ16(ptChannel->pvDeviceInstance, ptHandshakeBlock->atHsk[1].t16Bit.usHostFlags));
 800537c:	3106      	adds	r1, #6
 800537e:	6820      	ldr	r0, [r4, #0]
 8005380:	f7ff ffa8 	bl	80052d4 <HwIfRead16>
 8005384:	f8a6 0272 	strh.w	r0, [r6, #626]	; 0x272
 8005388:	e7db      	b.n	8005342 <DEV_ReadHostFlags+0x28>

0800538a <DEV_ReadHandshakeFlags>:
{
 800538a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800538c:	4604      	mov	r4, r0
 800538e:	460e      	mov	r6, r1
  PDEVICEINSTANCE ptDevInstance = (PDEVICEINSTANCE)ptChannel->pvDeviceInstance;
 8005390:	6805      	ldr	r5, [r0, #0]
  if(fLockNeeded)
 8005392:	4617      	mov	r7, r2
 8005394:	b9d2      	cbnz	r2, 80053cc <DEV_ReadHandshakeFlags+0x42>
  if( (ptDevInstance->pbHandshakeBlock != NULL) &&
 8005396:	6e29      	ldr	r1, [r5, #96]	; 0x60
 8005398:	b101      	cbz	r1, 800539c <DEV_ReadHandshakeFlags+0x12>
 800539a:	b9de      	cbnz	r6, 80053d4 <DEV_ReadHandshakeFlags+0x4a>
  if(ptChannel->bHandshakeWidth == HIL_HANDSHAKE_SIZE_8BIT)
 800539c:	f894 30f8 	ldrb.w	r3, [r4, #248]	; 0xf8
 80053a0:	2b01      	cmp	r3, #1
 80053a2:	d01e      	beq.n	80053e2 <DEV_ReadHandshakeFlags+0x58>
    ptChannel->usNetxFlags = LE16_TO_HOST(HWIF_READ16(ptDevInstance, ptChannel->ptHandshakeCell->t16Bit.usNetxFlags));
 80053a4:	f8d4 10f4 	ldr.w	r1, [r4, #244]	; 0xf4
 80053a8:	4628      	mov	r0, r5
 80053aa:	f7ff ff93 	bl	80052d4 <HwIfRead16>
 80053ae:	f8a4 00be 	strh.w	r0, [r4, #190]	; 0xbe
  if(ptChannel->fIsSysDevice)
 80053b2:	6a23      	ldr	r3, [r4, #32]
 80053b4:	b383      	cbz	r3, 8005418 <DEV_ReadHandshakeFlags+0x8e>
    HIL_DPM_SYSTEM_CHANNEL_T* ptSysChannel = (HIL_DPM_SYSTEM_CHANNEL_T*)ptChannel->pbDPMChannelStart;
 80053b6:	68a1      	ldr	r1, [r4, #8]
    if ((ptChannel->usNetxFlags ^ ptChannel->usHostFlags) & NSF_NETX_COS_CMD)
 80053b8:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
 80053bc:	f8b4 20bc 	ldrh.w	r2, [r4, #188]	; 0xbc
 80053c0:	4053      	eors	r3, r2
 80053c2:	f013 0f08 	tst.w	r3, #8
 80053c6:	d115      	bne.n	80053f4 <DEV_ReadHandshakeFlags+0x6a>
  if(fLockNeeded)
 80053c8:	bbb7      	cbnz	r7, 8005438 <DEV_ReadHandshakeFlags+0xae>
}
 80053ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    OS_EnterLock(ptChannel->pvLock);
 80053cc:	6980      	ldr	r0, [r0, #24]
 80053ce:	f7fd fbe7 	bl	8002ba0 <OS_EnterLock>
 80053d2:	e7e0      	b.n	8005396 <DEV_ReadHandshakeFlags+0xc>
    ptDevInstance->tSyncData.usNSyncFlags       = LE16_TO_HOST(HWIF_READ16(ptDevInstance, ptHandshakeBlock->atHsk[1].t16Bit.usNetxFlags));
 80053d4:	3104      	adds	r1, #4
 80053d6:	4628      	mov	r0, r5
 80053d8:	f7ff ff7c 	bl	80052d4 <HwIfRead16>
 80053dc:	f8a5 0274 	strh.w	r0, [r5, #628]	; 0x274
 80053e0:	e7dc      	b.n	800539c <DEV_ReadHandshakeFlags+0x12>
    ptChannel->usNetxFlags = HWIF_READ8(ptDevInstance, ptChannel->ptHandshakeCell->t8Bit.bNetxFlags);
 80053e2:	f8d4 10f4 	ldr.w	r1, [r4, #244]	; 0xf4
 80053e6:	3102      	adds	r1, #2
 80053e8:	4628      	mov	r0, r5
 80053ea:	f7ff ff45 	bl	8005278 <HwIfRead8>
 80053ee:	f8a4 00be 	strh.w	r0, [r4, #190]	; 0xbe
 80053f2:	e7de      	b.n	80053b2 <DEV_ReadHandshakeFlags+0x28>
      ulNewCOSFlags   = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysChannel->tSystemState.ulSystemCOS)); /* Read actual COS flags */
 80053f4:	31c0      	adds	r1, #192	; 0xc0
 80053f6:	4628      	mov	r0, r5
 80053f8:	f7ff ff7f 	bl	80052fa <HwIfRead32>
    if(ptChannel->ulDeviceCOSFlags != ulNewCOSFlags)
 80053fc:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 8005400:	4283      	cmp	r3, r0
 8005402:	d004      	beq.n	800540e <DEV_ReadHandshakeFlags+0x84>
      ptChannel->ulDeviceCOSFlagsChanged  = ptChannel->ulDeviceCOSFlags ^ ulNewCOSFlags;
 8005404:	4043      	eors	r3, r0
 8005406:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
      ptChannel->ulDeviceCOSFlags         = ulNewCOSFlags;
 800540a:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
    DEV_ToggleBit(ptChannel, usCOSAckBitMask);
 800540e:	2108      	movs	r1, #8
 8005410:	4620      	mov	r0, r4
 8005412:	f7ff ff06 	bl	8005222 <DEV_ToggleBit>
 8005416:	e7d7      	b.n	80053c8 <DEV_ReadHandshakeFlags+0x3e>
  } else if(NULL != ptChannel->ptCommonStatusBlock)
 8005418:	f8d4 10dc 	ldr.w	r1, [r4, #220]	; 0xdc
 800541c:	2900      	cmp	r1, #0
 800541e:	d0d3      	beq.n	80053c8 <DEV_ReadHandshakeFlags+0x3e>
    if ((ptChannel->usNetxFlags ^ ptChannel->usHostFlags) & NCF_NETX_COS_CMD)
 8005420:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
 8005424:	f8b4 20bc 	ldrh.w	r2, [r4, #188]	; 0xbc
 8005428:	4053      	eors	r3, r2
 800542a:	f013 0f08 	tst.w	r3, #8
 800542e:	d0cb      	beq.n	80053c8 <DEV_ReadHandshakeFlags+0x3e>
      ulNewCOSFlags   = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptChannel->ptCommonStatusBlock->ulCommunicationCOS)); /* Read actual COS flags */
 8005430:	4628      	mov	r0, r5
 8005432:	f7ff ff62 	bl	80052fa <HwIfRead32>
  if (usCOSAckBitMask)
 8005436:	e7e1      	b.n	80053fc <DEV_ReadHandshakeFlags+0x72>
    OS_LeaveLock(ptChannel->pvLock);
 8005438:	69a0      	ldr	r0, [r4, #24]
 800543a:	f7fd fbbd 	bl	8002bb8 <OS_LeaveLock>
}
 800543e:	e7c4      	b.n	80053ca <DEV_ReadHandshakeFlags+0x40>

08005440 <DEV_WaitForBitState_Poll>:
{
 8005440:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005444:	4604      	mov	r4, r0
 8005446:	4616      	mov	r6, r2
 8005448:	4699      	mov	r9, r3
  uint32_t  ulBitMask   = 1 << ulBitNumber;
 800544a:	2201      	movs	r2, #1
 800544c:	fa02 f801 	lsl.w	r8, r2, r1
  DEV_ReadHandshakeFlags(ptChannel, 0, 1);
 8005450:	2100      	movs	r1, #0
 8005452:	f7ff ff9a 	bl	800538a <DEV_ReadHandshakeFlags>
  if( (HIL_FLAGS_CLEAR == bState) ||
 8005456:	1eb7      	subs	r7, r6, #2
 8005458:	b2ff      	uxtb	r7, r7
 800545a:	2f01      	cmp	r7, #1
 800545c:	d910      	bls.n	8005480 <DEV_WaitForBitState_Poll+0x40>
    if((ptChannel->usHostFlags ^ ptChannel->usNetxFlags) & ulBitMask)
 800545e:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
 8005462:	f8b4 20be 	ldrh.w	r2, [r4, #190]	; 0xbe
 8005466:	4053      	eors	r3, r2
 8005468:	ea13 0f08 	tst.w	r3, r8
 800546c:	d011      	beq.n	8005492 <DEV_WaitForBitState_Poll+0x52>
      bActualState = HIL_FLAGS_NOT_EQUAL;
 800546e:	2501      	movs	r5, #1
  if(bActualState == bState)
 8005470:	42b5      	cmp	r5, r6
 8005472:	d03e      	beq.n	80054f2 <DEV_WaitForBitState_Poll+0xb2>
  if(0 == ulTimeout)
 8005474:	f1b9 0f00 	cmp.w	r9, #0
 8005478:	d10d      	bne.n	8005496 <DEV_WaitForBitState_Poll+0x56>
    return 0;
 800547a:	2000      	movs	r0, #0
}
 800547c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bActualState = (ptChannel->usNetxFlags & ulBitMask)? HIL_FLAGS_SET : HIL_FLAGS_CLEAR;
 8005480:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
 8005484:	ea13 0f08 	tst.w	r3, r8
 8005488:	d001      	beq.n	800548e <DEV_WaitForBitState_Poll+0x4e>
 800548a:	2503      	movs	r5, #3
 800548c:	e7f0      	b.n	8005470 <DEV_WaitForBitState_Poll+0x30>
 800548e:	2502      	movs	r5, #2
 8005490:	e7ee      	b.n	8005470 <DEV_WaitForBitState_Poll+0x30>
      bActualState = HIL_FLAGS_EQUAL;
 8005492:	2500      	movs	r5, #0
 8005494:	e7ec      	b.n	8005470 <DEV_WaitForBitState_Poll+0x30>
  lStartTime = (int32_t)OS_GetMilliSecCounter();
 8005496:	f7fd fb5c 	bl	8002b52 <OS_GetMilliSecCounter>
 800549a:	4682      	mov	sl, r0
  while(bActualState != bState)
 800549c:	e014      	b.n	80054c8 <DEV_WaitForBitState_Poll+0x88>
      bActualState = (ptChannel->usNetxFlags & ulBitMask)? HIL_FLAGS_SET : HIL_FLAGS_CLEAR;
 800549e:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
 80054a2:	ea13 0f08 	tst.w	r3, r8
 80054a6:	d001      	beq.n	80054ac <DEV_WaitForBitState_Poll+0x6c>
 80054a8:	2503      	movs	r5, #3
 80054aa:	e002      	b.n	80054b2 <DEV_WaitForBitState_Poll+0x72>
 80054ac:	2502      	movs	r5, #2
 80054ae:	e000      	b.n	80054b2 <DEV_WaitForBitState_Poll+0x72>
        bActualState = HIL_FLAGS_EQUAL;
 80054b0:	2500      	movs	r5, #0
    if(bActualState == bState)
 80054b2:	42b5      	cmp	r5, r6
 80054b4:	d01f      	beq.n	80054f6 <DEV_WaitForBitState_Poll+0xb6>
    ulDiffTime = OS_GetMilliSecCounter() - lStartTime;
 80054b6:	f7fd fb4c 	bl	8002b52 <OS_GetMilliSecCounter>
 80054ba:	eba0 000a 	sub.w	r0, r0, sl
    if ( ulDiffTime > ulTimeout)
 80054be:	4581      	cmp	r9, r0
 80054c0:	d31b      	bcc.n	80054fa <DEV_WaitForBitState_Poll+0xba>
    OS_Sleep(0);
 80054c2:	2000      	movs	r0, #0
 80054c4:	f7fd fb4a 	bl	8002b5c <OS_Sleep>
  while(bActualState != bState)
 80054c8:	42b5      	cmp	r5, r6
 80054ca:	d010      	beq.n	80054ee <DEV_WaitForBitState_Poll+0xae>
    DEV_ReadHandshakeFlags(ptChannel, 0, 1);
 80054cc:	2201      	movs	r2, #1
 80054ce:	2100      	movs	r1, #0
 80054d0:	4620      	mov	r0, r4
 80054d2:	f7ff ff5a 	bl	800538a <DEV_ReadHandshakeFlags>
    if( (HIL_FLAGS_CLEAR == bState) ||
 80054d6:	2f01      	cmp	r7, #1
 80054d8:	d9e1      	bls.n	800549e <DEV_WaitForBitState_Poll+0x5e>
      if((ptChannel->usHostFlags ^ ptChannel->usNetxFlags) & ulBitMask)
 80054da:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
 80054de:	f8b4 20be 	ldrh.w	r2, [r4, #190]	; 0xbe
 80054e2:	4053      	eors	r3, r2
 80054e4:	ea13 0f08 	tst.w	r3, r8
 80054e8:	d0e2      	beq.n	80054b0 <DEV_WaitForBitState_Poll+0x70>
        bActualState = HIL_FLAGS_NOT_EQUAL;
 80054ea:	2501      	movs	r5, #1
 80054ec:	e7e1      	b.n	80054b2 <DEV_WaitForBitState_Poll+0x72>
  int       iRet        = 0;
 80054ee:	2000      	movs	r0, #0
 80054f0:	e7c4      	b.n	800547c <DEV_WaitForBitState_Poll+0x3c>
    return 1;
 80054f2:	2001      	movs	r0, #1
 80054f4:	e7c2      	b.n	800547c <DEV_WaitForBitState_Poll+0x3c>
      iRet = 1;
 80054f6:	2001      	movs	r0, #1
 80054f8:	e7c0      	b.n	800547c <DEV_WaitForBitState_Poll+0x3c>
  int       iRet        = 0;
 80054fa:	2000      	movs	r0, #0
 80054fc:	e7be      	b.n	800547c <DEV_WaitForBitState_Poll+0x3c>

080054fe <DEV_WaitForBitState>:
{
 80054fe:	b510      	push	{r4, lr}
  if( ((PDEVICEINSTANCE)(ptChannel->pvDeviceInstance))->fIrqEnabled)
 8005500:	6804      	ldr	r4, [r0, #0]
 8005502:	68a4      	ldr	r4, [r4, #8]
 8005504:	b114      	cbz	r4, 800550c <DEV_WaitForBitState+0xe>
    return DEV_WaitForBitState_Irq(ptChannel, ulBitNumber, bState, ulTimeout);
 8005506:	f7ff fe2f 	bl	8005168 <DEV_WaitForBitState_Irq>
}
 800550a:	bd10      	pop	{r4, pc}
    return DEV_WaitForBitState_Poll(ptChannel, ulBitNumber, bState, ulTimeout);
 800550c:	f7ff ff98 	bl	8005440 <DEV_WaitForBitState_Poll>
 8005510:	e7fb      	b.n	800550a <DEV_WaitForBitState+0xc>
	...

08005514 <DEV_DoHostCOSChange>:
{
 8005514:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8005518:	b085      	sub	sp, #20
 800551a:	4604      	mov	r4, r0
 800551c:	460d      	mov	r5, r1
 800551e:	4616      	mov	r6, r2
 8005520:	461f      	mov	r7, r3
 8005522:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
  if( !DEV_WaitForBitState( ptChannel, HCF_HOST_COS_CMD_BIT_NO, HIL_FLAGS_EQUAL, ulTimeout))
 8005526:	464b      	mov	r3, r9
 8005528:	2200      	movs	r2, #0
 800552a:	2102      	movs	r1, #2
 800552c:	f7ff ffe7 	bl	80054fe <DEV_WaitForBitState>
 8005530:	b9b0      	cbnz	r0, 8005560 <DEV_DoHostCOSChange+0x4c>
 8005532:	4680      	mov	r8, r0
    if(0 == ulTimeout)
 8005534:	f1b9 0f00 	cmp.w	r9, #0
 8005538:	d148      	bne.n	80055cc <DEV_DoHostCOSChange+0xb8>
      OS_EnterLock(ptChannel->pvLock);
 800553a:	69a0      	ldr	r0, [r4, #24]
 800553c:	f7fd fb30 	bl	8002ba0 <OS_EnterLock>
      ptChannel->ulHostCOSFlags |= ulSetCOSMask;
 8005540:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8005544:	432b      	orrs	r3, r5
 8005546:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
      ptChannel->ulHostCOSFlags &= ~ulClearCOSMask;
 800554a:	ea23 0306 	bic.w	r3, r3, r6
 800554e:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
      OS_LeaveLock(ptChannel->pvLock);
 8005552:	69a0      	ldr	r0, [r4, #24]
 8005554:	f7fd fb30 	bl	8002bb8 <OS_LeaveLock>
}
 8005558:	4640      	mov	r0, r8
 800555a:	b005      	add	sp, #20
 800555c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    OS_EnterLock(ptChannel->pvLock);
 8005560:	69a0      	ldr	r0, [r4, #24]
 8005562:	f7fd fb1d 	bl	8002ba0 <OS_EnterLock>
    ptChannel->ulHostCOSFlags |= ulSetCOSMask;
 8005566:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 800556a:	431d      	orrs	r5, r3
 800556c:	f8c4 50c8 	str.w	r5, [r4, #200]	; 0xc8
    ptChannel->ulHostCOSFlags &= ~ulClearCOSMask;
 8005570:	ea25 0506 	bic.w	r5, r5, r6
 8005574:	f8c4 50c8 	str.w	r5, [r4, #200]	; 0xc8
    HWIF_WRITE32(ptChannel->pvDeviceInstance, ptChannel->ptControlBlock->ulApplicationCOS, HOST_TO_LE32(ptChannel->ulHostCOSFlags));
 8005578:	9503      	str	r5, [sp, #12]
 800557a:	6821      	ldr	r1, [r4, #0]
 800557c:	f8d1 62c8 	ldr.w	r6, [r1, #712]	; 0x2c8
 8005580:	2504      	movs	r5, #4
 8005582:	9500      	str	r5, [sp, #0]
 8005584:	ab03      	add	r3, sp, #12
 8005586:	f8d4 20d0 	ldr.w	r2, [r4, #208]	; 0xd0
 800558a:	2001      	movs	r0, #1
 800558c:	47b0      	blx	r6
    ptChannel->ulHostCOSFlagsSaved = ptChannel->ulHostCOSFlags;
 800558e:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8005592:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
    DEV_ToggleBit(ptChannel, HCF_HOST_COS_CMD);
 8005596:	4629      	mov	r1, r5
 8005598:	4620      	mov	r0, r4
 800559a:	f7ff fe42 	bl	8005222 <DEV_ToggleBit>
    ptChannel->ulHostCOSFlags &= ~ulPostClearCOSMask;
 800559e:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 80055a2:	ea23 0307 	bic.w	r3, r3, r7
 80055a6:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
    OS_LeaveLock(ptChannel->pvLock);
 80055aa:	69a0      	ldr	r0, [r4, #24]
 80055ac:	f7fd fb04 	bl	8002bb8 <OS_LeaveLock>
    if( !DEV_WaitForBitState( ptChannel, HCF_HOST_COS_CMD_BIT_NO, HIL_FLAGS_EQUAL, ulTimeout))
 80055b0:	464b      	mov	r3, r9
 80055b2:	2200      	movs	r2, #0
 80055b4:	2102      	movs	r1, #2
 80055b6:	4620      	mov	r0, r4
 80055b8:	f7ff ffa1 	bl	80054fe <DEV_WaitForBitState>
 80055bc:	4680      	mov	r8, r0
 80055be:	b940      	cbnz	r0, 80055d2 <DEV_DoHostCOSChange+0xbe>
      if(0 == ulTimeout)
 80055c0:	f1b9 0f00 	cmp.w	r9, #0
 80055c4:	d0c8      	beq.n	8005558 <DEV_DoHostCOSChange+0x44>
        lRet = lSignallingError;
 80055c6:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
  return lRet;
 80055ca:	e7c5      	b.n	8005558 <DEV_DoHostCOSChange+0x44>
      lRet = CIFX_DEV_FUNCTION_FAILED;
 80055cc:	f8df 8008 	ldr.w	r8, [pc, #8]	; 80055d8 <DEV_DoHostCOSChange+0xc4>
 80055d0:	e7c2      	b.n	8005558 <DEV_DoHostCOSChange+0x44>
      lRet = CIFX_NO_ERROR;
 80055d2:	f04f 0800 	mov.w	r8, #0
 80055d6:	e7bf      	b.n	8005558 <DEV_DoHostCOSChange+0x44>
 80055d8:	800c0025 	.word	0x800c0025

080055dc <DEV_IsReady>:
{
 80055dc:	b510      	push	{r4, lr}
 80055de:	4604      	mov	r4, r0
  if(!((PDEVICEINSTANCE)(ptChannel->pvDeviceInstance))->fIrqEnabled)
 80055e0:	6803      	ldr	r3, [r0, #0]
 80055e2:	689b      	ldr	r3, [r3, #8]
 80055e4:	b143      	cbz	r3, 80055f8 <DEV_IsReady+0x1c>
  if(ptChannel->fIsSysDevice)
 80055e6:	6a20      	ldr	r0, [r4, #32]
 80055e8:	b158      	cbz	r0, 8005602 <DEV_IsReady+0x26>
    if(ptChannel->usNetxFlags & NSF_READY)
 80055ea:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
 80055ee:	f013 0f01 	tst.w	r3, #1
 80055f2:	d10d      	bne.n	8005610 <DEV_IsReady+0x34>
  int iRet = 0;
 80055f4:	2000      	movs	r0, #0
}
 80055f6:	bd10      	pop	{r4, pc}
    DEV_ReadHandshakeFlags(ptChannel, 0, 1);
 80055f8:	2201      	movs	r2, #1
 80055fa:	2100      	movs	r1, #0
 80055fc:	f7ff fec5 	bl	800538a <DEV_ReadHandshakeFlags>
 8005600:	e7f1      	b.n	80055e6 <DEV_IsReady+0xa>
    if(ptChannel->ulDeviceCOSFlags & HIL_COMM_COS_READY)
 8005602:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 8005606:	f013 0f01 	tst.w	r3, #1
 800560a:	d0f4      	beq.n	80055f6 <DEV_IsReady+0x1a>
      iRet = 1;
 800560c:	2001      	movs	r0, #1
  return iRet;
 800560e:	e7f2      	b.n	80055f6 <DEV_IsReady+0x1a>
      iRet = 1;
 8005610:	2001      	movs	r0, #1
 8005612:	e7f0      	b.n	80055f6 <DEV_IsReady+0x1a>

08005614 <DEV_PutPacket>:
{
 8005614:	b570      	push	{r4, r5, r6, lr}
 8005616:	b082      	sub	sp, #8
 8005618:	4604      	mov	r4, r0
 800561a:	460d      	mov	r5, r1
 800561c:	4616      	mov	r6, r2
  if(!DEV_IsReady(ptChannel))
 800561e:	f7ff ffdd 	bl	80055dc <DEV_IsReady>
 8005622:	b348      	cbz	r0, 8005678 <DEV_PutPacket+0x64>
  if( (LE32_TO_HOST(ptSendPkt->tHeader.ulLen) + HIL_PACKET_HEADER_SIZE) > ptChannel->tSendMbx.ulSendMailboxLength)
 8005624:	692b      	ldr	r3, [r5, #16]
 8005626:	3328      	adds	r3, #40	; 0x28
 8005628:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 800562a:	4293      	cmp	r3, r2
 800562c:	d826      	bhi.n	800567c <DEV_PutPacket+0x68>
  if(DEV_WaitForBitState(ptChannel, ptChannel->tSendMbx.bSendCMDBitoffset, HIL_FLAGS_EQUAL, ulTimeout))
 800562e:	4633      	mov	r3, r6
 8005630:	2200      	movs	r2, #0
 8005632:	f894 1080 	ldrb.w	r1, [r4, #128]	; 0x80
 8005636:	4620      	mov	r0, r4
 8005638:	f7ff ff61 	bl	80054fe <DEV_WaitForBitState>
 800563c:	b300      	cbz	r0, 8005680 <DEV_PutPacket+0x6c>
    ++ptChannel->tSendMbx.ulSendPacketCnt;
 800563e:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8005642:	3301      	adds	r3, #1
 8005644:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    HWIF_WRITEN(ptChannel->pvDeviceInstance,
 8005648:	6821      	ldr	r1, [r4, #0]
 800564a:	f8d1 62c8 	ldr.w	r6, [r1, #712]	; 0x2c8
 800564e:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8005650:	692b      	ldr	r3, [r5, #16]
 8005652:	3328      	adds	r3, #40	; 0x28
 8005654:	9300      	str	r3, [sp, #0]
 8005656:	462b      	mov	r3, r5
 8005658:	3204      	adds	r2, #4
 800565a:	2000      	movs	r0, #0
 800565c:	47b0      	blx	r6
    OS_EnterLock(ptChannel->pvLock);
 800565e:	69a0      	ldr	r0, [r4, #24]
 8005660:	f7fd fa9e 	bl	8002ba0 <OS_EnterLock>
    DEV_ToggleBit(ptChannel, ptChannel->tSendMbx.ulSendCMDBitmask);
 8005664:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8005666:	4620      	mov	r0, r4
 8005668:	f7ff fddb 	bl	8005222 <DEV_ToggleBit>
    OS_LeaveLock(ptChannel->pvLock);
 800566c:	69a0      	ldr	r0, [r4, #24]
 800566e:	f7fd faa3 	bl	8002bb8 <OS_LeaveLock>
    lRet = CIFX_NO_ERROR;
 8005672:	2000      	movs	r0, #0
}
 8005674:	b002      	add	sp, #8
 8005676:	bd70      	pop	{r4, r5, r6, pc}
    return CIFX_DEV_NOT_READY;
 8005678:	4802      	ldr	r0, [pc, #8]	; (8005684 <DEV_PutPacket+0x70>)
 800567a:	e7fb      	b.n	8005674 <DEV_PutPacket+0x60>
    return CIFX_DEV_MAILBOX_TOO_SHORT;
 800567c:	4802      	ldr	r0, [pc, #8]	; (8005688 <DEV_PutPacket+0x74>)
 800567e:	e7f9      	b.n	8005674 <DEV_PutPacket+0x60>
  int32_t lRet = CIFX_DEV_MAILBOX_FULL;
 8005680:	4802      	ldr	r0, [pc, #8]	; (800568c <DEV_PutPacket+0x78>)
 8005682:	e7f7      	b.n	8005674 <DEV_PutPacket+0x60>
 8005684:	800c0011 	.word	0x800c0011
 8005688:	800c001a 	.word	0x800c001a
 800568c:	800c0016 	.word	0x800c0016

08005690 <DEV_IsCommunicating>:
{
 8005690:	b570      	push	{r4, r5, r6, lr}
 8005692:	460e      	mov	r6, r1
  if( ptChannel->fIsSysDevice)
 8005694:	6a05      	ldr	r5, [r0, #32]
 8005696:	b11d      	cbz	r5, 80056a0 <DEV_IsCommunicating+0x10>
    *plError = CIFX_INVALID_HANDLE;
 8005698:	4b10      	ldr	r3, [pc, #64]	; (80056dc <DEV_IsCommunicating+0x4c>)
 800569a:	600b      	str	r3, [r1, #0]
  int iRet = 0;
 800569c:	2000      	movs	r0, #0
}
 800569e:	bd70      	pop	{r4, r5, r6, pc}
 80056a0:	4604      	mov	r4, r0
  }else if( !DEV_IsReady(ptChannel))
 80056a2:	f7ff ff9b 	bl	80055dc <DEV_IsReady>
 80056a6:	b910      	cbnz	r0, 80056ae <DEV_IsCommunicating+0x1e>
    *plError = CIFX_DEV_NOT_READY;
 80056a8:	4b0d      	ldr	r3, [pc, #52]	; (80056e0 <DEV_IsCommunicating+0x50>)
 80056aa:	6033      	str	r3, [r6, #0]
 80056ac:	e7f7      	b.n	800569e <DEV_IsCommunicating+0xe>
  } else if( !(ptChannel->ulDeviceCOSFlags & HIL_COMM_COS_RUN))
 80056ae:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 80056b2:	f013 0f02 	tst.w	r3, #2
 80056b6:	d103      	bne.n	80056c0 <DEV_IsCommunicating+0x30>
    *plError = CIFX_DEV_NOT_RUNNING;
 80056b8:	4b0a      	ldr	r3, [pc, #40]	; (80056e4 <DEV_IsCommunicating+0x54>)
 80056ba:	6033      	str	r3, [r6, #0]
  int iRet = 0;
 80056bc:	4628      	mov	r0, r5
 80056be:	e7ee      	b.n	800569e <DEV_IsCommunicating+0xe>
  } else if ( ptChannel->usNetxFlags & NCF_COMMUNICATING)
 80056c0:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
 80056c4:	f013 0f01 	tst.w	r3, #1
 80056c8:	d003      	beq.n	80056d2 <DEV_IsCommunicating+0x42>
    *plError = CIFX_NO_ERROR;
 80056ca:	2300      	movs	r3, #0
 80056cc:	6033      	str	r3, [r6, #0]
    iRet = 1;
 80056ce:	2001      	movs	r0, #1
 80056d0:	e7e5      	b.n	800569e <DEV_IsCommunicating+0xe>
    *plError = CIFX_DEV_NO_COM_FLAG;
 80056d2:	4b05      	ldr	r3, [pc, #20]	; (80056e8 <DEV_IsCommunicating+0x58>)
 80056d4:	6033      	str	r3, [r6, #0]
  int iRet = 0;
 80056d6:	4628      	mov	r0, r5
  return iRet;
 80056d8:	e7e1      	b.n	800569e <DEV_IsCommunicating+0xe>
 80056da:	bf00      	nop
 80056dc:	800a0004 	.word	0x800a0004
 80056e0:	800c0011 	.word	0x800c0011
 80056e4:	800c0012 	.word	0x800c0012
 80056e8:	800c0021 	.word	0x800c0021

080056ec <DEV_GetHostState>:
{
 80056ec:	b538      	push	{r3, r4, r5, lr}
 80056ee:	4605      	mov	r5, r0
 80056f0:	460c      	mov	r4, r1
  if(!DEV_IsReady(ptChannel))
 80056f2:	f7ff ff73 	bl	80055dc <DEV_IsReady>
 80056f6:	b130      	cbz	r0, 8005706 <DEV_GetHostState+0x1a>
  *pulState = (ptChannel->ulHostCOSFlags & HIL_APP_COS_APPLICATION_READY)? CIFX_HOST_STATE_READY : CIFX_HOST_STATE_NOT_READY;
 80056f8:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
 80056fc:	f003 0301 	and.w	r3, r3, #1
 8005700:	6023      	str	r3, [r4, #0]
  return CIFX_NO_ERROR;
 8005702:	2000      	movs	r0, #0
}
 8005704:	bd38      	pop	{r3, r4, r5, pc}
    return CIFX_DEV_NOT_READY;
 8005706:	4801      	ldr	r0, [pc, #4]	; (800570c <DEV_GetHostState+0x20>)
 8005708:	e7fc      	b.n	8005704 <DEV_GetHostState+0x18>
 800570a:	bf00      	nop
 800570c:	800c0011 	.word	0x800c0011

08005710 <DEV_SetHostState>:
{
 8005710:	b570      	push	{r4, r5, r6, lr}
 8005712:	b082      	sub	sp, #8
 8005714:	4605      	mov	r5, r0
 8005716:	460c      	mov	r4, r1
 8005718:	4616      	mov	r6, r2
  if(!DEV_IsReady(ptChannel))
 800571a:	f7ff ff5f 	bl	80055dc <DEV_IsReady>
 800571e:	2800      	cmp	r0, #0
 8005720:	d037      	beq.n	8005792 <DEV_SetHostState+0x82>
  switch(ulNewState)
 8005722:	b124      	cbz	r4, 800572e <DEV_SetHostState+0x1e>
 8005724:	2c01      	cmp	r4, #1
 8005726:	d01b      	beq.n	8005760 <DEV_SetHostState+0x50>
 8005728:	481b      	ldr	r0, [pc, #108]	; (8005798 <DEV_SetHostState+0x88>)
}
 800572a:	b002      	add	sp, #8
 800572c:	bd70      	pop	{r4, r5, r6, pc}
    if( 0 == ulTimeout)
 800572e:	b96e      	cbnz	r6, 800574c <DEV_SetHostState+0x3c>
      OS_EnterLock(ptChannel->pvLock);
 8005730:	69a8      	ldr	r0, [r5, #24]
 8005732:	f7fd fa35 	bl	8002ba0 <OS_EnterLock>
      ptChannel->ulHostCOSFlags &= ~HIL_APP_COS_APPLICATION_READY;
 8005736:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
 800573a:	f023 0301 	bic.w	r3, r3, #1
 800573e:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
      OS_LeaveLock(ptChannel->pvLock);
 8005742:	69a8      	ldr	r0, [r5, #24]
 8005744:	f7fd fa38 	bl	8002bb8 <OS_LeaveLock>
  int32_t lRet = CIFX_NO_ERROR;
 8005748:	2000      	movs	r0, #0
 800574a:	e7ee      	b.n	800572a <DEV_SetHostState+0x1a>
      lRet = DEV_DoHostCOSChange(ptChannel,
 800574c:	9601      	str	r6, [sp, #4]
 800574e:	4b13      	ldr	r3, [pc, #76]	; (800579c <DEV_SetHostState+0x8c>)
 8005750:	9300      	str	r3, [sp, #0]
 8005752:	2300      	movs	r3, #0
 8005754:	2201      	movs	r2, #1
 8005756:	4619      	mov	r1, r3
 8005758:	4628      	mov	r0, r5
 800575a:	f7ff fedb 	bl	8005514 <DEV_DoHostCOSChange>
 800575e:	e7e4      	b.n	800572a <DEV_SetHostState+0x1a>
    if( 0 == ulTimeout)
 8005760:	b96e      	cbnz	r6, 800577e <DEV_SetHostState+0x6e>
      OS_EnterLock(ptChannel->pvLock);
 8005762:	69a8      	ldr	r0, [r5, #24]
 8005764:	f7fd fa1c 	bl	8002ba0 <OS_EnterLock>
      ptChannel->ulHostCOSFlags |= HIL_APP_COS_APPLICATION_READY;
 8005768:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
 800576c:	f043 0301 	orr.w	r3, r3, #1
 8005770:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
      OS_LeaveLock(ptChannel->pvLock);
 8005774:	69a8      	ldr	r0, [r5, #24]
 8005776:	f7fd fa1f 	bl	8002bb8 <OS_LeaveLock>
  int32_t lRet = CIFX_NO_ERROR;
 800577a:	2000      	movs	r0, #0
 800577c:	e7d5      	b.n	800572a <DEV_SetHostState+0x1a>
      lRet = DEV_DoHostCOSChange(ptChannel,
 800577e:	9601      	str	r6, [sp, #4]
 8005780:	4b07      	ldr	r3, [pc, #28]	; (80057a0 <DEV_SetHostState+0x90>)
 8005782:	9300      	str	r3, [sp, #0]
 8005784:	2300      	movs	r3, #0
 8005786:	461a      	mov	r2, r3
 8005788:	2101      	movs	r1, #1
 800578a:	4628      	mov	r0, r5
 800578c:	f7ff fec2 	bl	8005514 <DEV_DoHostCOSChange>
 8005790:	e7cb      	b.n	800572a <DEV_SetHostState+0x1a>
    return CIFX_DEV_NOT_READY;
 8005792:	4804      	ldr	r0, [pc, #16]	; (80057a4 <DEV_SetHostState+0x94>)
 8005794:	e7c9      	b.n	800572a <DEV_SetHostState+0x1a>
 8005796:	bf00      	nop
 8005798:	800a0006 	.word	0x800a0006
 800579c:	800c002c 	.word	0x800c002c
 80057a0:	800c002b 	.word	0x800c002b
 80057a4:	800c0011 	.word	0x800c0011

080057a8 <DEV_IsRunning>:
{
 80057a8:	b510      	push	{r4, lr}
 80057aa:	4604      	mov	r4, r0
  if(!((PDEVICEINSTANCE)(ptChannel->pvDeviceInstance))->fIrqEnabled)
 80057ac:	6803      	ldr	r3, [r0, #0]
 80057ae:	689b      	ldr	r3, [r3, #8]
 80057b0:	b14b      	cbz	r3, 80057c6 <DEV_IsRunning+0x1e>
  if(!ptChannel->fIsSysDevice)
 80057b2:	6a20      	ldr	r0, [r4, #32]
 80057b4:	b960      	cbnz	r0, 80057d0 <DEV_IsRunning+0x28>
    if( (ptChannel->ulDeviceCOSFlags & HIL_COMM_COS_READY) &&
 80057b6:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 80057ba:	f003 0303 	and.w	r3, r3, #3
 80057be:	2b03      	cmp	r3, #3
 80057c0:	d107      	bne.n	80057d2 <DEV_IsRunning+0x2a>
      iRet = 1;
 80057c2:	2001      	movs	r0, #1
  return iRet;
 80057c4:	e005      	b.n	80057d2 <DEV_IsRunning+0x2a>
    DEV_ReadHandshakeFlags(ptChannel, 0, 1);
 80057c6:	2201      	movs	r2, #1
 80057c8:	2100      	movs	r1, #0
 80057ca:	f7ff fdde 	bl	800538a <DEV_ReadHandshakeFlags>
 80057ce:	e7f0      	b.n	80057b2 <DEV_IsRunning+0xa>
  int iRet = 0;
 80057d0:	2000      	movs	r0, #0
}
 80057d2:	bd10      	pop	{r4, pc}

080057d4 <DEV_WaitForNotRunning_Poll>:
{
 80057d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80057d6:	4604      	mov	r4, r0
 80057d8:	460d      	mov	r5, r1
  int32_t  lStartTime   = (int32_t)OS_GetMilliSecCounter();
 80057da:	f7fd f9ba 	bl	8002b52 <OS_GetMilliSecCounter>
  if(ptChannel->fIsSysDevice)
 80057de:	6a27      	ldr	r7, [r4, #32]
 80057e0:	b9b7      	cbnz	r7, 8005810 <DEV_WaitForNotRunning_Poll+0x3c>
 80057e2:	4606      	mov	r6, r0
  if( 0 == ulTimeout)
 80057e4:	b165      	cbz	r5, 8005800 <DEV_WaitForNotRunning_Poll+0x2c>
    while(DEV_IsRunning(ptChannel))
 80057e6:	4620      	mov	r0, r4
 80057e8:	f7ff ffde 	bl	80057a8 <DEV_IsRunning>
 80057ec:	b170      	cbz	r0, 800580c <DEV_WaitForNotRunning_Poll+0x38>
      ulDiffTime = OS_GetMilliSecCounter() - lStartTime;
 80057ee:	f7fd f9b0 	bl	8002b52 <OS_GetMilliSecCounter>
 80057f2:	1b83      	subs	r3, r0, r6
      if(ulDiffTime > ulTimeout)
 80057f4:	429d      	cmp	r5, r3
 80057f6:	d30c      	bcc.n	8005812 <DEV_WaitForNotRunning_Poll+0x3e>
      OS_Sleep(1);
 80057f8:	2001      	movs	r0, #1
 80057fa:	f7fd f9af 	bl	8002b5c <OS_Sleep>
 80057fe:	e7f2      	b.n	80057e6 <DEV_WaitForNotRunning_Poll+0x12>
    if( DEV_IsRunning(ptChannel))
 8005800:	4620      	mov	r0, r4
 8005802:	f7ff ffd1 	bl	80057a8 <DEV_IsRunning>
 8005806:	b920      	cbnz	r0, 8005812 <DEV_WaitForNotRunning_Poll+0x3e>
  int      iActualState = 1;
 8005808:	2701      	movs	r7, #1
 800580a:	e002      	b.n	8005812 <DEV_WaitForNotRunning_Poll+0x3e>
 800580c:	2701      	movs	r7, #1
 800580e:	e000      	b.n	8005812 <DEV_WaitForNotRunning_Poll+0x3e>
    return iActualState;
 8005810:	2701      	movs	r7, #1
}
 8005812:	4638      	mov	r0, r7
 8005814:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005816 <DEV_WaitForRunning_Poll>:
{
 8005816:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005818:	4604      	mov	r4, r0
 800581a:	460d      	mov	r5, r1
  int32_t  lStartTime   = (int32_t)OS_GetMilliSecCounter();
 800581c:	f7fd f999 	bl	8002b52 <OS_GetMilliSecCounter>
  if(ptChannel->fIsSysDevice)
 8005820:	6a23      	ldr	r3, [r4, #32]
 8005822:	b9b3      	cbnz	r3, 8005852 <DEV_WaitForRunning_Poll+0x3c>
 8005824:	4606      	mov	r6, r0
  if( 0 == ulTimeout)
 8005826:	b16d      	cbz	r5, 8005844 <DEV_WaitForRunning_Poll+0x2e>
    while(!DEV_IsRunning(ptChannel))
 8005828:	4620      	mov	r0, r4
 800582a:	f7ff ffbd 	bl	80057a8 <DEV_IsRunning>
 800582e:	4607      	mov	r7, r0
 8005830:	b968      	cbnz	r0, 800584e <DEV_WaitForRunning_Poll+0x38>
      ulDiffTime = OS_GetMilliSecCounter() - lStartTime;
 8005832:	f7fd f98e 	bl	8002b52 <OS_GetMilliSecCounter>
 8005836:	1b83      	subs	r3, r0, r6
      if(ulDiffTime > ulTimeout)
 8005838:	429d      	cmp	r5, r3
 800583a:	d30b      	bcc.n	8005854 <DEV_WaitForRunning_Poll+0x3e>
      OS_Sleep(1);
 800583c:	2001      	movs	r0, #1
 800583e:	f7fd f98d 	bl	8002b5c <OS_Sleep>
 8005842:	e7f1      	b.n	8005828 <DEV_WaitForRunning_Poll+0x12>
    iActualState = DEV_IsRunning(ptChannel);
 8005844:	4620      	mov	r0, r4
 8005846:	f7ff ffaf 	bl	80057a8 <DEV_IsRunning>
 800584a:	4607      	mov	r7, r0
 800584c:	e002      	b.n	8005854 <DEV_WaitForRunning_Poll+0x3e>
  int      iActualState = 1;
 800584e:	2701      	movs	r7, #1
 8005850:	e000      	b.n	8005854 <DEV_WaitForRunning_Poll+0x3e>
    return iActualState;
 8005852:	2701      	movs	r7, #1
}
 8005854:	4638      	mov	r0, r7
 8005856:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005858 <DEV_Reset_Finish>:
{
 8005858:	b538      	push	{r3, r4, r5, lr}
 800585a:	4605      	mov	r5, r0
  ptDevInstance->fResetActive = 0;
 800585c:	2300      	movs	r3, #0
 800585e:	f8c0 32b8 	str.w	r3, [r0, #696]	; 0x2b8
  if(ptDevInstance->fIrqEnabled)
 8005862:	6883      	ldr	r3, [r0, #8]
 8005864:	b133      	cbz	r3, 8005874 <DEV_Reset_Finish+0x1c>
    (void)cifXTKitISRHandler(ptDevInstance,1);
 8005866:	2101      	movs	r1, #1
 8005868:	f003 f94a 	bl	8008b00 <cifXTKitISRHandler>
    cifXTKitDSRHandler(ptDevInstance);
 800586c:	4628      	mov	r0, r5
 800586e:	f003 fa09 	bl	8008c84 <cifXTKitDSRHandler>
}
 8005872:	bd38      	pop	{r3, r4, r5, pc}
    OS_EnterLock(ptDevInstance->tSystemDevice.pvLock);
 8005874:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
 8005878:	f7fd f992 	bl	8002ba0 <OS_EnterLock>
    DEV_ReadHostFlags( &ptDevInstance->tSystemDevice, 0);
 800587c:	f105 04f4 	add.w	r4, r5, #244	; 0xf4
 8005880:	2100      	movs	r1, #0
 8005882:	4620      	mov	r0, r4
 8005884:	f7ff fd49 	bl	800531a <DEV_ReadHostFlags>
    DEV_ReadHandshakeFlags(&ptDevInstance->tSystemDevice, 1, 0);
 8005888:	2200      	movs	r2, #0
 800588a:	2101      	movs	r1, #1
 800588c:	4620      	mov	r0, r4
 800588e:	f7ff fd7c 	bl	800538a <DEV_ReadHandshakeFlags>
    OS_LeaveLock(ptDevInstance->tSystemDevice.pvLock);
 8005892:	f8d5 010c 	ldr.w	r0, [r5, #268]	; 0x10c
 8005896:	f7fd f98f 	bl	8002bb8 <OS_LeaveLock>
    for ( ulIdx = 0; ulIdx < ptDevInstance->ulCommChannelCount; ulIdx++)
 800589a:	2400      	movs	r4, #0
 800589c:	e01d      	b.n	80058da <DEV_Reset_Finish+0x82>
      OS_EnterLock(ptDevInstance->pptCommChannels[ulIdx]->pvLock);
 800589e:	f8d5 3264 	ldr.w	r3, [r5, #612]	; 0x264
 80058a2:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80058a6:	6998      	ldr	r0, [r3, #24]
 80058a8:	f7fd f97a 	bl	8002ba0 <OS_EnterLock>
      DEV_ReadHostFlags( ptDevInstance->pptCommChannels[ulIdx], 1);
 80058ac:	f8d5 3264 	ldr.w	r3, [r5, #612]	; 0x264
 80058b0:	2101      	movs	r1, #1
 80058b2:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80058b6:	f7ff fd30 	bl	800531a <DEV_ReadHostFlags>
      DEV_ReadHandshakeFlags(ptDevInstance->pptCommChannels[ulIdx], 0, 0);
 80058ba:	f8d5 3264 	ldr.w	r3, [r5, #612]	; 0x264
 80058be:	2200      	movs	r2, #0
 80058c0:	4611      	mov	r1, r2
 80058c2:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80058c6:	f7ff fd60 	bl	800538a <DEV_ReadHandshakeFlags>
      OS_LeaveLock(ptDevInstance->pptCommChannels[ulIdx]->pvLock);
 80058ca:	f8d5 3264 	ldr.w	r3, [r5, #612]	; 0x264
 80058ce:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80058d2:	6998      	ldr	r0, [r3, #24]
 80058d4:	f7fd f970 	bl	8002bb8 <OS_LeaveLock>
    for ( ulIdx = 0; ulIdx < ptDevInstance->ulCommChannelCount; ulIdx++)
 80058d8:	3401      	adds	r4, #1
 80058da:	f8d5 3260 	ldr.w	r3, [r5, #608]	; 0x260
 80058de:	42a3      	cmp	r3, r4
 80058e0:	d8dd      	bhi.n	800589e <DEV_Reset_Finish+0x46>
 80058e2:	e7c6      	b.n	8005872 <DEV_Reset_Finish+0x1a>

080058e4 <DEV_GetPacket>:
{
 80058e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80058e8:	b083      	sub	sp, #12
 80058ea:	4604      	mov	r4, r0
 80058ec:	460f      	mov	r7, r1
 80058ee:	4615      	mov	r5, r2
 80058f0:	461e      	mov	r6, r3
  if(!DEV_IsReady(ptChannel))
 80058f2:	f7ff fe73 	bl	80055dc <DEV_IsReady>
 80058f6:	b398      	cbz	r0, 8005960 <DEV_GetPacket+0x7c>
  if(!DEV_WaitForBitState(ptChannel, ptChannel->tRecvMbx.bRecvACKBitoffset, HIL_FLAGS_NOT_EQUAL, ulTimeout))
 80058f8:	4633      	mov	r3, r6
 80058fa:	2201      	movs	r2, #1
 80058fc:	f894 10a0 	ldrb.w	r1, [r4, #160]	; 0xa0
 8005900:	4620      	mov	r0, r4
 8005902:	f7ff fdfc 	bl	80054fe <DEV_WaitForBitState>
 8005906:	b370      	cbz	r0, 8005966 <DEV_GetPacket+0x82>
  ++ptChannel->tRecvMbx.ulRecvPacketCnt;
 8005908:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 800590c:	3301      	adds	r3, #1
 800590e:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
  ptPacket   = (CIFX_PACKET*)ptChannel->tRecvMbx.ptRecvMailboxStart->abRecvMailbox;
 8005912:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
 8005916:	1d0e      	adds	r6, r1, #4
  ulCopySize = LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptPacket->tHeader.ulLen)) + HIL_PACKET_HEADER_SIZE;
 8005918:	3114      	adds	r1, #20
 800591a:	6820      	ldr	r0, [r4, #0]
 800591c:	f7ff fced 	bl	80052fa <HwIfRead32>
 8005920:	3028      	adds	r0, #40	; 0x28
  if(ulCopySize > ulRecvBufferSize)
 8005922:	42a8      	cmp	r0, r5
 8005924:	d819      	bhi.n	800595a <DEV_GetPacket+0x76>
  ulCopySize = LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptPacket->tHeader.ulLen)) + HIL_PACKET_HEADER_SIZE;
 8005926:	4605      	mov	r5, r0
  int32_t       lRet        = CIFX_NO_ERROR;
 8005928:	f04f 0800 	mov.w	r8, #0
  HWIF_READN(ptChannel->pvDeviceInstance, ptRecvPkt, ptPacket, ulCopySize);
 800592c:	6821      	ldr	r1, [r4, #0]
 800592e:	f8d1 92c4 	ldr.w	r9, [r1, #708]	; 0x2c4
 8005932:	9500      	str	r5, [sp, #0]
 8005934:	463b      	mov	r3, r7
 8005936:	4632      	mov	r2, r6
 8005938:	2000      	movs	r0, #0
 800593a:	47c8      	blx	r9
  OS_EnterLock(ptChannel->pvLock);
 800593c:	69a0      	ldr	r0, [r4, #24]
 800593e:	f7fd f92f 	bl	8002ba0 <OS_EnterLock>
  DEV_ToggleBit(ptChannel, ptChannel->tRecvMbx.ulRecvACKBitmask);
 8005942:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
 8005946:	4620      	mov	r0, r4
 8005948:	f7ff fc6b 	bl	8005222 <DEV_ToggleBit>
  OS_LeaveLock(ptChannel->pvLock);
 800594c:	69a0      	ldr	r0, [r4, #24]
 800594e:	f7fd f933 	bl	8002bb8 <OS_LeaveLock>
}
 8005952:	4640      	mov	r0, r8
 8005954:	b003      	add	sp, #12
 8005956:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    lRet = CIFX_BUFFER_TOO_SHORT;
 800595a:	f8df 8010 	ldr.w	r8, [pc, #16]	; 800596c <DEV_GetPacket+0x88>
 800595e:	e7e5      	b.n	800592c <DEV_GetPacket+0x48>
    return CIFX_DEV_NOT_READY;
 8005960:	f8df 800c 	ldr.w	r8, [pc, #12]	; 8005970 <DEV_GetPacket+0x8c>
 8005964:	e7f5      	b.n	8005952 <DEV_GetPacket+0x6e>
    return CIFX_DEV_GET_NO_PACKET;
 8005966:	f8df 800c 	ldr.w	r8, [pc, #12]	; 8005974 <DEV_GetPacket+0x90>
 800596a:	e7f2      	b.n	8005952 <DEV_GetPacket+0x6e>
 800596c:	800a0012 	.word	0x800a0012
 8005970:	800c0011 	.word	0x800c0011
 8005974:	800c0019 	.word	0x800c0019

08005978 <DEV_TransferPacket>:
{
 8005978:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800597c:	4681      	mov	r9, r0
 800597e:	460e      	mov	r6, r1
 8005980:	4614      	mov	r4, r2
 8005982:	4698      	mov	r8, r3
 8005984:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 8005988:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 800598a:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
  if( (lRet = DEV_PutPacket(ptChannel, ptSendPkt, ulTimeout)) == CIFX_NO_ERROR)
 800598e:	4652      	mov	r2, sl
 8005990:	f7ff fe40 	bl	8005614 <DEV_PutPacket>
 8005994:	4605      	mov	r5, r0
 8005996:	b148      	cbz	r0, 80059ac <DEV_TransferPacket+0x34>
}
 8005998:	4628      	mov	r0, r5
 800599a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
          if( NULL != pvPktCallback)
 800599e:	b117      	cbz	r7, 80059a6 <DEV_TransferPacket+0x2e>
            pvPktCallback(ptRecvPkt, pvUser);
 80059a0:	4659      	mov	r1, fp
 80059a2:	4620      	mov	r0, r4
 80059a4:	47b8      	blx	r7
        lCount++;
 80059a6:	3501      	adds	r5, #1
    } while ( lCount < 10);
 80059a8:	2d09      	cmp	r5, #9
 80059aa:	dc1a      	bgt.n	80059e2 <DEV_TransferPacket+0x6a>
      if( (lRet = DEV_GetPacket(ptChannel, ptRecvPkt, ulRecvBufferSize, ulTimeout)) == CIFX_NO_ERROR)
 80059ac:	4653      	mov	r3, sl
 80059ae:	4642      	mov	r2, r8
 80059b0:	4621      	mov	r1, r4
 80059b2:	4648      	mov	r0, r9
 80059b4:	f7ff ff96 	bl	80058e4 <DEV_GetPacket>
 80059b8:	b9a8      	cbnz	r0, 80059e6 <DEV_TransferPacket+0x6e>
        if(  ((LE32_TO_HOST(ptRecvPkt->tHeader.ulCmd) & ~HIL_MSK_PACKET_ANSWER) == LE32_TO_HOST(ptSendPkt->tHeader.ulCmd))  &&
 80059ba:	69e3      	ldr	r3, [r4, #28]
 80059bc:	f023 0301 	bic.w	r3, r3, #1
 80059c0:	69f2      	ldr	r2, [r6, #28]
 80059c2:	4293      	cmp	r3, r2
 80059c4:	d1eb      	bne.n	800599e <DEV_TransferPacket+0x26>
             (ptRecvPkt->tHeader.ulSrc   == ptSendPkt->tHeader.ulSrc)    &&
 80059c6:	6862      	ldr	r2, [r4, #4]
 80059c8:	6873      	ldr	r3, [r6, #4]
        if(  ((LE32_TO_HOST(ptRecvPkt->tHeader.ulCmd) & ~HIL_MSK_PACKET_ANSWER) == LE32_TO_HOST(ptSendPkt->tHeader.ulCmd))  &&
 80059ca:	429a      	cmp	r2, r3
 80059cc:	d1e7      	bne.n	800599e <DEV_TransferPacket+0x26>
             (ptRecvPkt->tHeader.ulId    == ptSendPkt->tHeader.ulId)     &&
 80059ce:	6962      	ldr	r2, [r4, #20]
 80059d0:	6973      	ldr	r3, [r6, #20]
             (ptRecvPkt->tHeader.ulSrc   == ptSendPkt->tHeader.ulSrc)    &&
 80059d2:	429a      	cmp	r2, r3
 80059d4:	d1e3      	bne.n	800599e <DEV_TransferPacket+0x26>
             (ptRecvPkt->tHeader.ulSrcId == ptSendPkt->tHeader.ulSrcId)  )
 80059d6:	68e2      	ldr	r2, [r4, #12]
 80059d8:	68f3      	ldr	r3, [r6, #12]
             (ptRecvPkt->tHeader.ulId    == ptSendPkt->tHeader.ulId)     &&
 80059da:	429a      	cmp	r2, r3
 80059dc:	d1df      	bne.n	800599e <DEV_TransferPacket+0x26>
      if( (lRet = DEV_GetPacket(ptChannel, ptRecvPkt, ulRecvBufferSize, ulTimeout)) == CIFX_NO_ERROR)
 80059de:	4605      	mov	r5, r0
  return lRet;
 80059e0:	e7da      	b.n	8005998 <DEV_TransferPacket+0x20>
        lRet = CIFX_DEV_GET_TIMEOUT;
 80059e2:	4d02      	ldr	r5, [pc, #8]	; (80059ec <DEV_TransferPacket+0x74>)
 80059e4:	e7d8      	b.n	8005998 <DEV_TransferPacket+0x20>
      if( (lRet = DEV_GetPacket(ptChannel, ptRecvPkt, ulRecvBufferSize, ulTimeout)) == CIFX_NO_ERROR)
 80059e6:	4605      	mov	r5, r0
 80059e8:	e7d6      	b.n	8005998 <DEV_TransferPacket+0x20>
 80059ea:	bf00      	nop
 80059ec:	800c0018 	.word	0x800c0018

080059f0 <DEV_WaitForNotReady_Poll>:
{
 80059f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80059f4:	4604      	mov	r4, r0
 80059f6:	460e      	mov	r6, r1
  int32_t  lStartTime   = (int32_t)OS_GetMilliSecCounter();
 80059f8:	f7fd f8ab 	bl	8002b52 <OS_GetMilliSecCounter>
  if( ulTimeout == 0)
 80059fc:	2e00      	cmp	r6, #0
 80059fe:	d047      	beq.n	8005a90 <DEV_WaitForNotReady_Poll+0xa0>
 8005a00:	4607      	mov	r7, r0
  if(ptChannel->fIsSysDevice)
 8005a02:	f8d4 8020 	ldr.w	r8, [r4, #32]
 8005a06:	f1b8 0f00 	cmp.w	r8, #0
 8005a0a:	d024      	beq.n	8005a56 <DEV_WaitForNotReady_Poll+0x66>
      DEVICEINSTANCE* ptDevInstance  = (DEVICEINSTANCE*)ptChannel->pvDeviceInstance;
 8005a0c:	6825      	ldr	r5, [r4, #0]
      if( (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptDevInstance->tSystemDevice.ptHandshakeCell->ulValue)) == CIFX_DPM_INVALID_CONTENT)     ||
 8005a0e:	f8d5 11e8 	ldr.w	r1, [r5, #488]	; 0x1e8
 8005a12:	4628      	mov	r0, r5
 8005a14:	f7ff fc71 	bl	80052fa <HwIfRead32>
 8005a18:	f1b0 3fff 	cmp.w	r0, #4294967295
 8005a1c:	d03d      	beq.n	8005a9a <DEV_WaitForNotReady_Poll+0xaa>
          (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptDevInstance->tSystemDevice.ptHandshakeCell->ulValue)) == CIFX_DPM_NO_MEMORY_ASSIGNED)  ||
 8005a1e:	f8d5 11e8 	ldr.w	r1, [r5, #488]	; 0x1e8
 8005a22:	6820      	ldr	r0, [r4, #0]
 8005a24:	f7ff fc69 	bl	80052fa <HwIfRead32>
      if( (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptDevInstance->tSystemDevice.ptHandshakeCell->ulValue)) == CIFX_DPM_INVALID_CONTENT)     ||
 8005a28:	4b25      	ldr	r3, [pc, #148]	; (8005ac0 <DEV_WaitForNotReady_Poll+0xd0>)
 8005a2a:	4298      	cmp	r0, r3
 8005a2c:	d038      	beq.n	8005aa0 <DEV_WaitForNotReady_Poll+0xb0>
          (0 == (HWIF_READ8(ptChannel->pvDeviceInstance, ptDevInstance->tSystemDevice.ptHandshakeCell->t8Bit.bNetxFlags) & NSF_READY))     )
 8005a2e:	f8d5 11e8 	ldr.w	r1, [r5, #488]	; 0x1e8
 8005a32:	3102      	adds	r1, #2
 8005a34:	6820      	ldr	r0, [r4, #0]
 8005a36:	f7ff fc1f 	bl	8005278 <HwIfRead8>
          (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptDevInstance->tSystemDevice.ptHandshakeCell->ulValue)) == CIFX_DPM_NO_MEMORY_ASSIGNED)  ||
 8005a3a:	f010 0f01 	tst.w	r0, #1
 8005a3e:	d032      	beq.n	8005aa6 <DEV_WaitForNotReady_Poll+0xb6>
      ulDiffTime = OS_GetMilliSecCounter() - lStartTime;
 8005a40:	f7fd f887 	bl	8002b52 <OS_GetMilliSecCounter>
 8005a44:	1bc5      	subs	r5, r0, r7
      OS_Sleep(0);
 8005a46:	2000      	movs	r0, #0
 8005a48:	f7fd f888 	bl	8002b5c <OS_Sleep>
    } while (ulDiffTime < ulTimeout);
 8005a4c:	42ae      	cmp	r6, r5
 8005a4e:	d8dd      	bhi.n	8005a0c <DEV_WaitForNotReady_Poll+0x1c>
  int      iActualState = 0;
 8005a50:	f04f 0800 	mov.w	r8, #0
 8005a54:	e01e      	b.n	8005a94 <DEV_WaitForNotReady_Poll+0xa4>
      if( (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptChannel->ptCommonStatusBlock->ulCommunicationCOS)) == CIFX_DPM_INVALID_CONTENT)     ||
 8005a56:	f8d4 10dc 	ldr.w	r1, [r4, #220]	; 0xdc
 8005a5a:	6820      	ldr	r0, [r4, #0]
 8005a5c:	f7ff fc4d 	bl	80052fa <HwIfRead32>
 8005a60:	f1b0 3fff 	cmp.w	r0, #4294967295
 8005a64:	d022      	beq.n	8005aac <DEV_WaitForNotReady_Poll+0xbc>
          (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptChannel->ptCommonStatusBlock->ulCommunicationCOS)) == CIFX_DPM_NO_MEMORY_ASSIGNED)  ||
 8005a66:	f8d4 10dc 	ldr.w	r1, [r4, #220]	; 0xdc
 8005a6a:	6820      	ldr	r0, [r4, #0]
 8005a6c:	f7ff fc45 	bl	80052fa <HwIfRead32>
      if( (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptChannel->ptCommonStatusBlock->ulCommunicationCOS)) == CIFX_DPM_INVALID_CONTENT)     ||
 8005a70:	4b13      	ldr	r3, [pc, #76]	; (8005ac0 <DEV_WaitForNotReady_Poll+0xd0>)
 8005a72:	4298      	cmp	r0, r3
 8005a74:	d01d      	beq.n	8005ab2 <DEV_WaitForNotReady_Poll+0xc2>
          (!DEV_IsReady(ptChannel))                                                            )
 8005a76:	4620      	mov	r0, r4
 8005a78:	f7ff fdb0 	bl	80055dc <DEV_IsReady>
          (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptChannel->ptCommonStatusBlock->ulCommunicationCOS)) == CIFX_DPM_NO_MEMORY_ASSIGNED)  ||
 8005a7c:	b1e0      	cbz	r0, 8005ab8 <DEV_WaitForNotReady_Poll+0xc8>
      ulDiffTime = OS_GetMilliSecCounter() - lStartTime;
 8005a7e:	f7fd f868 	bl	8002b52 <OS_GetMilliSecCounter>
 8005a82:	1bc5      	subs	r5, r0, r7
      OS_Sleep(1);
 8005a84:	2001      	movs	r0, #1
 8005a86:	f7fd f869 	bl	8002b5c <OS_Sleep>
    } while (ulDiffTime < ulTimeout);
 8005a8a:	42ae      	cmp	r6, r5
 8005a8c:	d8e3      	bhi.n	8005a56 <DEV_WaitForNotReady_Poll+0x66>
 8005a8e:	e001      	b.n	8005a94 <DEV_WaitForNotReady_Poll+0xa4>
    return iActualState;
 8005a90:	f04f 0800 	mov.w	r8, #0
}
 8005a94:	4640      	mov	r0, r8
 8005a96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        iActualState = 1;
 8005a9a:	f04f 0801 	mov.w	r8, #1
 8005a9e:	e7f9      	b.n	8005a94 <DEV_WaitForNotReady_Poll+0xa4>
 8005aa0:	f04f 0801 	mov.w	r8, #1
 8005aa4:	e7f6      	b.n	8005a94 <DEV_WaitForNotReady_Poll+0xa4>
 8005aa6:	f04f 0801 	mov.w	r8, #1
 8005aaa:	e7f3      	b.n	8005a94 <DEV_WaitForNotReady_Poll+0xa4>
        iActualState = 1;
 8005aac:	f04f 0801 	mov.w	r8, #1
 8005ab0:	e7f0      	b.n	8005a94 <DEV_WaitForNotReady_Poll+0xa4>
 8005ab2:	f04f 0801 	mov.w	r8, #1
 8005ab6:	e7ed      	b.n	8005a94 <DEV_WaitForNotReady_Poll+0xa4>
 8005ab8:	f04f 0801 	mov.w	r8, #1
 8005abc:	e7ea      	b.n	8005a94 <DEV_WaitForNotReady_Poll+0xa4>
 8005abe:	bf00      	nop
 8005ac0:	0bad0bad 	.word	0x0bad0bad

08005ac4 <DEV_Reset_Execute>:
{
 8005ac4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005ac8:	b084      	sub	sp, #16
 8005aca:	4604      	mov	r4, r0
 8005acc:	460f      	mov	r7, r1
 8005ace:	4616      	mov	r6, r2
  PCHANNELINSTANCE          ptSysDevice  = &ptDevInstance->tSystemDevice;
 8005ad0:	f100 08f4 	add.w	r8, r0, #244	; 0xf4
  HIL_DPM_SYSTEM_CHANNEL_T* ptSysChannel = (HIL_DPM_SYSTEM_CHANNEL_T*)ptSysDevice->pbDPMChannelStart;
 8005ad4:	f8d0 90fc 	ldr.w	r9, [r0, #252]	; 0xfc
  uint8_t                   bHostFlags   = HWIF_READ8(ptDevInstance, ptSysDevice->ptHandshakeCell->t8Bit.bHostFlags);
 8005ad8:	f8d0 11e8 	ldr.w	r1, [r0, #488]	; 0x1e8
 8005adc:	3103      	adds	r1, #3
 8005ade:	f7ff fbcb 	bl	8005278 <HwIfRead8>
 8005ae2:	4682      	mov	sl, r0
  OS_EnterLock(ptSysDevice->pvLock);
 8005ae4:	f8d4 010c 	ldr.w	r0, [r4, #268]	; 0x10c
 8005ae8:	f7fd f85a 	bl	8002ba0 <OS_EnterLock>
  HWIF_WRITE32(ptDevInstance, ptSysChannel->tSystemControl.ulSystemCommandCOS, HOST_TO_LE32(HIL_SYS_RESET_COOKIE));
 8005aec:	4b16      	ldr	r3, [pc, #88]	; (8005b48 <DEV_Reset_Execute+0x84>)
 8005aee:	9303      	str	r3, [sp, #12]
 8005af0:	2304      	movs	r3, #4
 8005af2:	9300      	str	r3, [sp, #0]
 8005af4:	ab03      	add	r3, sp, #12
 8005af6:	f109 02b8 	add.w	r2, r9, #184	; 0xb8
 8005afa:	4621      	mov	r1, r4
 8005afc:	2001      	movs	r0, #1
 8005afe:	f8d4 52c8 	ldr.w	r5, [r4, #712]	; 0x2c8
 8005b02:	47a8      	blx	r5
  HWIF_WRITE8(ptDevInstance, ptSysDevice->ptHandshakeCell->t8Bit.bHostFlags, (bHostFlags | bHostFlagsChange));
 8005b04:	ea4a 0507 	orr.w	r5, sl, r7
 8005b08:	f88d 500c 	strb.w	r5, [sp, #12]
 8005b0c:	f8d4 52c8 	ldr.w	r5, [r4, #712]	; 0x2c8
 8005b10:	f8d4 21e8 	ldr.w	r2, [r4, #488]	; 0x1e8
 8005b14:	2001      	movs	r0, #1
 8005b16:	9000      	str	r0, [sp, #0]
 8005b18:	ab03      	add	r3, sp, #12
 8005b1a:	3203      	adds	r2, #3
 8005b1c:	4621      	mov	r1, r4
 8005b1e:	47a8      	blx	r5
  OS_LeaveLock(ptSysDevice->pvLock);
 8005b20:	f8d4 010c 	ldr.w	r0, [r4, #268]	; 0x10c
 8005b24:	f7fd f848 	bl	8002bb8 <OS_LeaveLock>
  if( fWaitOnDevice)
 8005b28:	b91e      	cbnz	r6, 8005b32 <DEV_Reset_Execute+0x6e>
  int32_t                   lRet         = CIFX_NO_ERROR;
 8005b2a:	2000      	movs	r0, #0
}
 8005b2c:	b004      	add	sp, #16
 8005b2e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( !DEV_WaitForNotReady_Poll( ptSysDevice, CIFX_TO_WAIT_HW_RESET_ACTIVE))
 8005b32:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8005b36:	4640      	mov	r0, r8
 8005b38:	f7ff ff5a 	bl	80059f0 <DEV_WaitForNotReady_Poll>
 8005b3c:	b108      	cbz	r0, 8005b42 <DEV_Reset_Execute+0x7e>
  int32_t                   lRet         = CIFX_NO_ERROR;
 8005b3e:	2000      	movs	r0, #0
 8005b40:	e7f4      	b.n	8005b2c <DEV_Reset_Execute+0x68>
      lRet = CIFX_DEV_RESET_TIMEOUT;
 8005b42:	4802      	ldr	r0, [pc, #8]	; (8005b4c <DEV_Reset_Execute+0x88>)
  return lRet;
 8005b44:	e7f2      	b.n	8005b2c <DEV_Reset_Execute+0x68>
 8005b46:	bf00      	nop
 8005b48:	55aa55aa 	.word	0x55aa55aa
 8005b4c:	800c0020 	.word	0x800c0020

08005b50 <DEV_WaitForReady_Poll>:
{
 8005b50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005b54:	b084      	sub	sp, #16
 8005b56:	4605      	mov	r5, r0
 8005b58:	460e      	mov	r6, r1
  int32_t  lStartTime   = (int32_t)OS_GetMilliSecCounter();
 8005b5a:	f7fc fffa 	bl	8002b52 <OS_GetMilliSecCounter>
  if( ulTimeout == 0)
 8005b5e:	2e00      	cmp	r6, #0
 8005b60:	d062      	beq.n	8005c28 <DEV_WaitForReady_Poll+0xd8>
 8005b62:	4607      	mov	r7, r0
  if(ptChannel->fIsSysDevice)
 8005b64:	6a2b      	ldr	r3, [r5, #32]
 8005b66:	b98b      	cbnz	r3, 8005b8c <DEV_WaitForReady_Poll+0x3c>
    if( ptChannel->fIsChannel)
 8005b68:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8005b6a:	2c00      	cmp	r4, #0
 8005b6c:	d05d      	beq.n	8005c2a <DEV_WaitForReady_Poll+0xda>
        OS_Sleep( 1);
 8005b6e:	2001      	movs	r0, #1
 8005b70:	f7fc fff4 	bl	8002b5c <OS_Sleep>
        if( DEV_IsReady(ptChannel))
 8005b74:	4628      	mov	r0, r5
 8005b76:	f7ff fd31 	bl	80055dc <DEV_IsReady>
 8005b7a:	4604      	mov	r4, r0
 8005b7c:	2800      	cmp	r0, #0
 8005b7e:	d14d      	bne.n	8005c1c <DEV_WaitForReady_Poll+0xcc>
        ulDiffTime = OS_GetMilliSecCounter() - lStartTime;
 8005b80:	f7fc ffe7 	bl	8002b52 <OS_GetMilliSecCounter>
 8005b84:	1bc0      	subs	r0, r0, r7
      } while ( ulDiffTime < ulTimeout);
 8005b86:	4286      	cmp	r6, r0
 8005b88:	d8f1      	bhi.n	8005b6e <DEV_WaitForReady_Poll+0x1e>
 8005b8a:	e04e      	b.n	8005c2a <DEV_WaitForReady_Poll+0xda>
    OS_Sleep( 10);
 8005b8c:	200a      	movs	r0, #10
 8005b8e:	f7fc ffe5 	bl	8002b5c <OS_Sleep>
 8005b92:	e00f      	b.n	8005bb4 <DEV_WaitForReady_Poll+0x64>
        if( (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptDevInstance->tSystemDevice.ptHandshakeCell->ulValue)) != CIFX_DPM_INVALID_CONTENT) &&
 8005b94:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
 8005b98:	6828      	ldr	r0, [r5, #0]
 8005b9a:	f7ff fbae 	bl	80052fa <HwIfRead32>
 8005b9e:	f1b0 3fff 	cmp.w	r0, #4294967295
 8005ba2:	d121      	bne.n	8005be8 <DEV_WaitForReady_Poll+0x98>
      ulDiffTime = OS_GetMilliSecCounter() - lStartTime;
 8005ba4:	f7fc ffd5 	bl	8002b52 <OS_GetMilliSecCounter>
 8005ba8:	1bc4      	subs	r4, r0, r7
      OS_Sleep(1);
 8005baa:	2001      	movs	r0, #1
 8005bac:	f7fc ffd6 	bl	8002b5c <OS_Sleep>
    } while ( ulDiffTime < ulTimeout);
 8005bb0:	42a6      	cmp	r6, r4
 8005bb2:	d931      	bls.n	8005c18 <DEV_WaitForReady_Poll+0xc8>
      DEVICEINSTANCE* ptDevInstance  = (DEVICEINSTANCE*)ptChannel->pvDeviceInstance;
 8005bb4:	682c      	ldr	r4, [r5, #0]
      char            szCookie[5]    = {0};
 8005bb6:	2000      	movs	r0, #0
 8005bb8:	9002      	str	r0, [sp, #8]
 8005bba:	f88d 000c 	strb.w	r0, [sp, #12]
      HWIF_READN(ptDevInstance, szCookie, ptDevInstance->pbDPM, 4);
 8005bbe:	f8d4 82c4 	ldr.w	r8, [r4, #708]	; 0x2c4
 8005bc2:	6a22      	ldr	r2, [r4, #32]
 8005bc4:	2304      	movs	r3, #4
 8005bc6:	9300      	str	r3, [sp, #0]
 8005bc8:	ab02      	add	r3, sp, #8
 8005bca:	4621      	mov	r1, r4
 8005bcc:	47c0      	blx	r8
      if ( (0 == OS_Strcmp( szCookie, CIFX_DPMSIGNATURE_BSL_STR)) ||
 8005bce:	4919      	ldr	r1, [pc, #100]	; (8005c34 <DEV_WaitForReady_Poll+0xe4>)
 8005bd0:	a802      	add	r0, sp, #8
 8005bd2:	f7fd f885 	bl	8002ce0 <OS_Strcmp>
 8005bd6:	2800      	cmp	r0, #0
 8005bd8:	d0dc      	beq.n	8005b94 <DEV_WaitForReady_Poll+0x44>
           (0 == OS_Strcmp( szCookie, CIFX_DPMSIGNATURE_FW_STR)) )
 8005bda:	4917      	ldr	r1, [pc, #92]	; (8005c38 <DEV_WaitForReady_Poll+0xe8>)
 8005bdc:	a802      	add	r0, sp, #8
 8005bde:	f7fd f87f 	bl	8002ce0 <OS_Strcmp>
      if ( (0 == OS_Strcmp( szCookie, CIFX_DPMSIGNATURE_BSL_STR)) ||
 8005be2:	2800      	cmp	r0, #0
 8005be4:	d1de      	bne.n	8005ba4 <DEV_WaitForReady_Poll+0x54>
 8005be6:	e7d5      	b.n	8005b94 <DEV_WaitForReady_Poll+0x44>
            (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptDevInstance->tSystemDevice.ptHandshakeCell->ulValue)) != CIFX_DPM_NO_MEMORY_ASSIGNED)  )
 8005be8:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
 8005bec:	6828      	ldr	r0, [r5, #0]
 8005bee:	f7ff fb84 	bl	80052fa <HwIfRead32>
        if( (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptDevInstance->tSystemDevice.ptHandshakeCell->ulValue)) != CIFX_DPM_INVALID_CONTENT) &&
 8005bf2:	4b12      	ldr	r3, [pc, #72]	; (8005c3c <DEV_WaitForReady_Poll+0xec>)
 8005bf4:	4298      	cmp	r0, r3
 8005bf6:	d0d5      	beq.n	8005ba4 <DEV_WaitForReady_Poll+0x54>
          if(HWIF_READ8(ptChannel->pvDeviceInstance, ptDevInstance->tSystemDevice.ptHandshakeCell->t8Bit.bNetxFlags) & NSF_READY)
 8005bf8:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
 8005bfc:	3102      	adds	r1, #2
 8005bfe:	6828      	ldr	r0, [r5, #0]
 8005c00:	f7ff fb3a 	bl	8005278 <HwIfRead8>
 8005c04:	f010 0f01 	tst.w	r0, #1
 8005c08:	d0cc      	beq.n	8005ba4 <DEV_WaitForReady_Poll+0x54>
            DEV_ReadHostFlags(&ptDevInstance->tSystemDevice, 0);
 8005c0a:	2100      	movs	r1, #0
 8005c0c:	f104 00f4 	add.w	r0, r4, #244	; 0xf4
 8005c10:	f7ff fb83 	bl	800531a <DEV_ReadHostFlags>
            iActualState = 1;
 8005c14:	2401      	movs	r4, #1
 8005c16:	e008      	b.n	8005c2a <DEV_WaitForReady_Poll+0xda>
  int      iActualState = 0;
 8005c18:	2400      	movs	r4, #0
 8005c1a:	e006      	b.n	8005c2a <DEV_WaitForReady_Poll+0xda>
          DEV_ReadHostFlags(ptChannel, 0);
 8005c1c:	2100      	movs	r1, #0
 8005c1e:	4628      	mov	r0, r5
 8005c20:	f7ff fb7b 	bl	800531a <DEV_ReadHostFlags>
          iActualState = 1;
 8005c24:	2401      	movs	r4, #1
          break;
 8005c26:	e000      	b.n	8005c2a <DEV_WaitForReady_Poll+0xda>
    return iActualState;
 8005c28:	2400      	movs	r4, #0
}
 8005c2a:	4620      	mov	r0, r4
 8005c2c:	b004      	add	sp, #16
 8005c2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005c32:	bf00      	nop
 8005c34:	0800a754 	.word	0x0800a754
 8005c38:	0800a75c 	.word	0x0800a75c
 8005c3c:	0bad0bad 	.word	0x0bad0bad

08005c40 <DEV_DoChannelInit>:
{
 8005c40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005c44:	b082      	sub	sp, #8
 8005c46:	4604      	mov	r4, r0
 8005c48:	460f      	mov	r7, r1
  PDEVICEINSTANCE ptDevInst   = (PDEVICEINSTANCE)ptChannel->pvDeviceInstance;
 8005c4a:	f8d0 8000 	ldr.w	r8, [r0]
  int             fRunning    = DEV_IsRunning(ptChannel);
 8005c4e:	f7ff fdab 	bl	80057a8 <DEV_IsRunning>
 8005c52:	4606      	mov	r6, r0
  if(!OS_WaitMutex(ptChannel->pvInitMutex, CIFX_TO_WAIT_COS_CMD))
 8005c54:	2114      	movs	r1, #20
 8005c56:	6860      	ldr	r0, [r4, #4]
 8005c58:	f7fc ffc4 	bl	8002be4 <OS_WaitMutex>
 8005c5c:	b980      	cbnz	r0, 8005c80 <DEV_DoChannelInit+0x40>
    if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8005c5e:	4b35      	ldr	r3, [pc, #212]	; (8005d34 <DEV_DoChannelInit+0xf4>)
 8005c60:	681b      	ldr	r3, [r3, #0]
 8005c62:	f013 0f08 	tst.w	r3, #8
 8005c66:	d104      	bne.n	8005c72 <DEV_DoChannelInit+0x32>
    lRet = CIFX_DRV_CMD_ACTIVE;
 8005c68:	4d33      	ldr	r5, [pc, #204]	; (8005d38 <DEV_DoChannelInit+0xf8>)
}
 8005c6a:	4628      	mov	r0, r5
 8005c6c:	b002      	add	sp, #8
 8005c6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      USER_Trace(ptDevInst,
 8005c72:	4a32      	ldr	r2, [pc, #200]	; (8005d3c <DEV_DoChannelInit+0xfc>)
 8005c74:	2108      	movs	r1, #8
 8005c76:	4640      	mov	r0, r8
 8005c78:	f003 fce2 	bl	8009640 <USER_Trace>
    lRet = CIFX_DRV_CMD_ACTIVE;
 8005c7c:	4d2e      	ldr	r5, [pc, #184]	; (8005d38 <DEV_DoChannelInit+0xf8>)
 8005c7e:	e7f4      	b.n	8005c6a <DEV_DoChannelInit+0x2a>
    lRet = DEV_DoHostCOSChange(ptChannel,
 8005c80:	2314      	movs	r3, #20
 8005c82:	9301      	str	r3, [sp, #4]
 8005c84:	4b2e      	ldr	r3, [pc, #184]	; (8005d40 <DEV_DoChannelInit+0x100>)
 8005c86:	9300      	str	r3, [sp, #0]
 8005c88:	2310      	movs	r3, #16
 8005c8a:	2200      	movs	r2, #0
 8005c8c:	2118      	movs	r1, #24
 8005c8e:	4620      	mov	r0, r4
 8005c90:	f7ff fc40 	bl	8005514 <DEV_DoHostCOSChange>
    if(CIFX_NO_ERROR == lRet)
 8005c94:	4605      	mov	r5, r0
 8005c96:	b9d0      	cbnz	r0, 8005cce <DEV_DoChannelInit+0x8e>
      if(fRunning)
 8005c98:	b176      	cbz	r6, 8005cb8 <DEV_DoChannelInit+0x78>
        if( (0 == (ptChannel->ulDeviceCOSFlags & HIL_COMM_COS_RUN)) ||
 8005c9a:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 8005c9e:	f013 0f02 	tst.w	r3, #2
 8005ca2:	d004      	beq.n	8005cae <DEV_DoChannelInit+0x6e>
              (ptChannel->ulDeviceCOSFlagsChanged & HIL_COMM_COS_RUN) ) )
 8005ca4:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
        if( (0 == (ptChannel->ulDeviceCOSFlags & HIL_COMM_COS_RUN)) ||
 8005ca8:	f013 0f02 	tst.w	r3, #2
 8005cac:	d019      	beq.n	8005ce2 <DEV_DoChannelInit+0xa2>
          if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8005cae:	4b21      	ldr	r3, [pc, #132]	; (8005d34 <DEV_DoChannelInit+0xf4>)
 8005cb0:	681b      	ldr	r3, [r3, #0]
 8005cb2:	f013 0f01 	tst.w	r3, #1
 8005cb6:	d10e      	bne.n	8005cd6 <DEV_DoChannelInit+0x96>
        if( DEV_WaitForNotReady_Poll( ptChannel, ulTempTimeout) )
 8005cb8:	4639      	mov	r1, r7
 8005cba:	f5b7 6ffa 	cmp.w	r7, #2000	; 0x7d0
 8005cbe:	bf28      	it	cs
 8005cc0:	f44f 61fa 	movcs.w	r1, #2000	; 0x7d0
 8005cc4:	4620      	mov	r0, r4
 8005cc6:	f7ff fe93 	bl	80059f0 <DEV_WaitForNotReady_Poll>
 8005cca:	b100      	cbz	r0, 8005cce <DEV_DoChannelInit+0x8e>
          if( 0 != ulTimeout)
 8005ccc:	b9f7      	cbnz	r7, 8005d0c <DEV_DoChannelInit+0xcc>
    OS_ReleaseMutex(ptChannel->pvInitMutex);
 8005cce:	6860      	ldr	r0, [r4, #4]
 8005cd0:	f7fc ff94 	bl	8002bfc <OS_ReleaseMutex>
 8005cd4:	e7c9      	b.n	8005c6a <DEV_DoChannelInit+0x2a>
            USER_Trace(ptDevInst,
 8005cd6:	4a1b      	ldr	r2, [pc, #108]	; (8005d44 <DEV_DoChannelInit+0x104>)
 8005cd8:	2101      	movs	r1, #1
 8005cda:	4640      	mov	r0, r8
 8005cdc:	f003 fcb0 	bl	8009640 <USER_Trace>
 8005ce0:	e7ea      	b.n	8005cb8 <DEV_DoChannelInit+0x78>
        } else if( !DEV_WaitForNotRunning_Poll( ptChannel, CIFX_TO_WAIT_HW_RESET_ACTIVE))
 8005ce2:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8005ce6:	4620      	mov	r0, r4
 8005ce8:	f7ff fd74 	bl	80057d4 <DEV_WaitForNotRunning_Poll>
 8005cec:	2800      	cmp	r0, #0
 8005cee:	d1e3      	bne.n	8005cb8 <DEV_DoChannelInit+0x78>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8005cf0:	4b10      	ldr	r3, [pc, #64]	; (8005d34 <DEV_DoChannelInit+0xf4>)
 8005cf2:	681b      	ldr	r3, [r3, #0]
 8005cf4:	f013 0f08 	tst.w	r3, #8
 8005cf8:	d101      	bne.n	8005cfe <DEV_DoChannelInit+0xbe>
          lRet = CIFX_DEV_RESET_TIMEOUT;
 8005cfa:	4d13      	ldr	r5, [pc, #76]	; (8005d48 <DEV_DoChannelInit+0x108>)
 8005cfc:	e7e7      	b.n	8005cce <DEV_DoChannelInit+0x8e>
            USER_Trace(ptDevInst,
 8005cfe:	4a13      	ldr	r2, [pc, #76]	; (8005d4c <DEV_DoChannelInit+0x10c>)
 8005d00:	2108      	movs	r1, #8
 8005d02:	4640      	mov	r0, r8
 8005d04:	f003 fc9c 	bl	8009640 <USER_Trace>
          lRet = CIFX_DEV_RESET_TIMEOUT;
 8005d08:	4d0f      	ldr	r5, [pc, #60]	; (8005d48 <DEV_DoChannelInit+0x108>)
 8005d0a:	e7e0      	b.n	8005cce <DEV_DoChannelInit+0x8e>
            if( !DEV_WaitForReady_Poll( ptChannel, ulTimeout) )
 8005d0c:	4639      	mov	r1, r7
 8005d0e:	4620      	mov	r0, r4
 8005d10:	f7ff ff1e 	bl	8005b50 <DEV_WaitForReady_Poll>
 8005d14:	2800      	cmp	r0, #0
 8005d16:	d1da      	bne.n	8005cce <DEV_DoChannelInit+0x8e>
              if(g_ulTraceLevel & TRACE_LEVEL_WARNING)
 8005d18:	4b06      	ldr	r3, [pc, #24]	; (8005d34 <DEV_DoChannelInit+0xf4>)
 8005d1a:	681b      	ldr	r3, [r3, #0]
 8005d1c:	f013 0f04 	tst.w	r3, #4
 8005d20:	d101      	bne.n	8005d26 <DEV_DoChannelInit+0xe6>
              lRet = CIFX_DEV_NOT_READY;
 8005d22:	4d0b      	ldr	r5, [pc, #44]	; (8005d50 <DEV_DoChannelInit+0x110>)
 8005d24:	e7d3      	b.n	8005cce <DEV_DoChannelInit+0x8e>
                USER_Trace((PDEVICEINSTANCE)(ptChannel->pvDeviceInstance),
 8005d26:	4a0b      	ldr	r2, [pc, #44]	; (8005d54 <DEV_DoChannelInit+0x114>)
 8005d28:	2104      	movs	r1, #4
 8005d2a:	6820      	ldr	r0, [r4, #0]
 8005d2c:	f003 fc88 	bl	8009640 <USER_Trace>
              lRet = CIFX_DEV_NOT_READY;
 8005d30:	4d07      	ldr	r5, [pc, #28]	; (8005d50 <DEV_DoChannelInit+0x110>)
 8005d32:	e7cc      	b.n	8005cce <DEV_DoChannelInit+0x8e>
 8005d34:	20000038 	.word	0x20000038
 8005d38:	800b0004 	.word	0x800b0004
 8005d3c:	0800afbc 	.word	0x0800afbc
 8005d40:	800c0025 	.word	0x800c0025
 8005d44:	0800b00c 	.word	0x0800b00c
 8005d48:	800c0020 	.word	0x800c0020
 8005d4c:	0800b070 	.word	0x0800b070
 8005d50:	800c0011 	.word	0x800c0011
 8005d54:	0800b0b8 	.word	0x0800b0b8

08005d58 <DEV_BusState>:
{
 8005d58:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005d5a:	b085      	sub	sp, #20
 8005d5c:	460d      	mov	r5, r1
  int32_t lRet = CIFX_NO_ERROR;
 8005d5e:	2100      	movs	r1, #0
 8005d60:	9103      	str	r1, [sp, #12]
  if( NULL == pulState) return CIFX_INVALID_POINTER;
 8005d62:	2a00      	cmp	r2, #0
 8005d64:	f000 808a 	beq.w	8005e7c <DEV_BusState+0x124>
 8005d68:	4604      	mov	r4, r0
 8005d6a:	461f      	mov	r7, r3
 8005d6c:	4616      	mov	r6, r2
  *pulState = (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptChannel->ptCommonStatusBlock->ulCommunicationCOS)) & HIL_COMM_COS_BUS_ON) ? CIFX_BUS_STATE_ON : CIFX_BUS_STATE_OFF;
 8005d6e:	f8d0 10dc 	ldr.w	r1, [r0, #220]	; 0xdc
 8005d72:	6800      	ldr	r0, [r0, #0]
 8005d74:	f7ff fac1 	bl	80052fa <HwIfRead32>
 8005d78:	f3c0 0080 	ubfx	r0, r0, #2, #1
 8005d7c:	6030      	str	r0, [r6, #0]
  switch (ulCmd)
 8005d7e:	2d01      	cmp	r5, #1
 8005d80:	d008      	beq.n	8005d94 <DEV_BusState+0x3c>
 8005d82:	2d02      	cmp	r5, #2
 8005d84:	d072      	beq.n	8005e6c <DEV_BusState+0x114>
 8005d86:	2d00      	cmp	r5, #0
 8005d88:	d036      	beq.n	8005df8 <DEV_BusState+0xa0>
      lRet = CIFX_INVALID_COMMAND;
 8005d8a:	4b3d      	ldr	r3, [pc, #244]	; (8005e80 <DEV_BusState+0x128>)
 8005d8c:	9303      	str	r3, [sp, #12]
  return lRet;
 8005d8e:	9803      	ldr	r0, [sp, #12]
}
 8005d90:	b005      	add	sp, #20
 8005d92:	bdf0      	pop	{r4, r5, r6, r7, pc}
      (void)DEV_IsCommunicating(ptChannel, &lRet); /* lRet evaluated */
 8005d94:	a903      	add	r1, sp, #12
 8005d96:	4620      	mov	r0, r4
 8005d98:	f7ff fc7a 	bl	8005690 <DEV_IsCommunicating>
      if( !*pulState &&
 8005d9c:	6833      	ldr	r3, [r6, #0]
 8005d9e:	b91b      	cbnz	r3, 8005da8 <DEV_BusState+0x50>
 8005da0:	9a03      	ldr	r2, [sp, #12]
 8005da2:	4b38      	ldr	r3, [pc, #224]	; (8005e84 <DEV_BusState+0x12c>)
 8005da4:	429a      	cmp	r2, r3
 8005da6:	d017      	beq.n	8005dd8 <DEV_BusState+0x80>
      if(ulTimeout && (CIFX_DEV_NO_COM_FLAG == lRet))
 8005da8:	2f00      	cmp	r7, #0
 8005daa:	d0f0      	beq.n	8005d8e <DEV_BusState+0x36>
 8005dac:	9a03      	ldr	r2, [sp, #12]
 8005dae:	4b35      	ldr	r3, [pc, #212]	; (8005e84 <DEV_BusState+0x12c>)
 8005db0:	429a      	cmp	r2, r3
 8005db2:	d1ec      	bne.n	8005d8e <DEV_BusState+0x36>
        if (DEV_WaitForBitState( ptChannel, NCF_COMMUNICATING_BIT_NO, HIL_FLAGS_SET, ulTimeout))
 8005db4:	463b      	mov	r3, r7
 8005db6:	2203      	movs	r2, #3
 8005db8:	2100      	movs	r1, #0
 8005dba:	4620      	mov	r0, r4
 8005dbc:	f7ff fb9f 	bl	80054fe <DEV_WaitForBitState>
 8005dc0:	b1b8      	cbz	r0, 8005df2 <DEV_BusState+0x9a>
          lRet = CIFX_NO_ERROR;
 8005dc2:	2300      	movs	r3, #0
 8005dc4:	9303      	str	r3, [sp, #12]
        *pulState = (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptChannel->ptCommonStatusBlock->ulCommunicationCOS)) & HIL_COMM_COS_BUS_ON) ?
 8005dc6:	f8d4 10dc 	ldr.w	r1, [r4, #220]	; 0xdc
 8005dca:	6820      	ldr	r0, [r4, #0]
 8005dcc:	f7ff fa95 	bl	80052fa <HwIfRead32>
                     CIFX_BUS_STATE_ON : CIFX_BUS_STATE_OFF;
 8005dd0:	f3c0 0080 	ubfx	r0, r0, #2, #1
        *pulState = (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptChannel->ptCommonStatusBlock->ulCommunicationCOS)) & HIL_COMM_COS_BUS_ON) ?
 8005dd4:	6030      	str	r0, [r6, #0]
 8005dd6:	e7da      	b.n	8005d8e <DEV_BusState+0x36>
        int32_t lTemp = DEV_DoHostCOSChange(ptChannel,
 8005dd8:	9701      	str	r7, [sp, #4]
 8005dda:	330d      	adds	r3, #13
 8005ddc:	9300      	str	r3, [sp, #0]
 8005dde:	2304      	movs	r3, #4
 8005de0:	2200      	movs	r2, #0
 8005de2:	2106      	movs	r1, #6
 8005de4:	4620      	mov	r0, r4
 8005de6:	f7ff fb95 	bl	8005514 <DEV_DoHostCOSChange>
        if(lTemp != CIFX_NO_ERROR)
 8005dea:	2800      	cmp	r0, #0
 8005dec:	d0dc      	beq.n	8005da8 <DEV_BusState+0x50>
          lRet = lTemp;
 8005dee:	9003      	str	r0, [sp, #12]
 8005df0:	e7da      	b.n	8005da8 <DEV_BusState+0x50>
          lRet = CIFX_DEV_NO_COM_FLAG;
 8005df2:	4b24      	ldr	r3, [pc, #144]	; (8005e84 <DEV_BusState+0x12c>)
 8005df4:	9303      	str	r3, [sp, #12]
 8005df6:	e7e6      	b.n	8005dc6 <DEV_BusState+0x6e>
      if(!DEV_IsReady(ptChannel))
 8005df8:	4620      	mov	r0, r4
 8005dfa:	f7ff fbef 	bl	80055dc <DEV_IsReady>
 8005dfe:	4603      	mov	r3, r0
 8005e00:	b9b8      	cbnz	r0, 8005e32 <DEV_BusState+0xda>
        lRet = CIFX_DEV_NOT_READY;
 8005e02:	4a21      	ldr	r2, [pc, #132]	; (8005e88 <DEV_BusState+0x130>)
 8005e04:	9203      	str	r2, [sp, #12]
      if(ulTimeout && fWaitCommFlag)
 8005e06:	2f00      	cmp	r7, #0
 8005e08:	bf18      	it	ne
 8005e0a:	2b00      	cmpne	r3, #0
 8005e0c:	d0bf      	beq.n	8005d8e <DEV_BusState+0x36>
        if(DEV_WaitForBitState(ptChannel, NCF_COMMUNICATING_BIT_NO, HIL_FLAGS_CLEAR, ulTimeout))
 8005e0e:	463b      	mov	r3, r7
 8005e10:	2202      	movs	r2, #2
 8005e12:	2100      	movs	r1, #0
 8005e14:	4620      	mov	r0, r4
 8005e16:	f7ff fb72 	bl	80054fe <DEV_WaitForBitState>
 8005e1a:	b320      	cbz	r0, 8005e66 <DEV_BusState+0x10e>
          lRet = CIFX_NO_ERROR;
 8005e1c:	2300      	movs	r3, #0
 8005e1e:	9303      	str	r3, [sp, #12]
        *pulState = (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptChannel->ptCommonStatusBlock->ulCommunicationCOS)) & HIL_COMM_COS_BUS_ON) ?
 8005e20:	f8d4 10dc 	ldr.w	r1, [r4, #220]	; 0xdc
 8005e24:	6820      	ldr	r0, [r4, #0]
 8005e26:	f7ff fa68 	bl	80052fa <HwIfRead32>
                     CIFX_BUS_STATE_ON : CIFX_BUS_STATE_OFF;
 8005e2a:	f3c0 0080 	ubfx	r0, r0, #2, #1
        *pulState = (LE32_TO_HOST(HWIF_READ32(ptChannel->pvDeviceInstance, ptChannel->ptCommonStatusBlock->ulCommunicationCOS)) & HIL_COMM_COS_BUS_ON) ?
 8005e2e:	6030      	str	r0, [r6, #0]
 8005e30:	e7ad      	b.n	8005d8e <DEV_BusState+0x36>
      } else if(*pulState || DEV_IsCommunicating(ptChannel, &lRet))
 8005e32:	6833      	ldr	r3, [r6, #0]
 8005e34:	b923      	cbnz	r3, 8005e40 <DEV_BusState+0xe8>
 8005e36:	a903      	add	r1, sp, #12
 8005e38:	4620      	mov	r0, r4
 8005e3a:	f7ff fc29 	bl	8005690 <DEV_IsCommunicating>
 8005e3e:	b170      	cbz	r0, 8005e5e <DEV_BusState+0x106>
        lRet = DEV_DoHostCOSChange(ptChannel,
 8005e40:	9701      	str	r7, [sp, #4]
 8005e42:	4b12      	ldr	r3, [pc, #72]	; (8005e8c <DEV_BusState+0x134>)
 8005e44:	9300      	str	r3, [sp, #0]
 8005e46:	2304      	movs	r3, #4
 8005e48:	2202      	movs	r2, #2
 8005e4a:	4619      	mov	r1, r3
 8005e4c:	4620      	mov	r0, r4
 8005e4e:	f7ff fb61 	bl	8005514 <DEV_DoHostCOSChange>
 8005e52:	9003      	str	r0, [sp, #12]
        if(CIFX_DEV_FUNCTION_FAILED == lRet)
 8005e54:	4b0e      	ldr	r3, [pc, #56]	; (8005e90 <DEV_BusState+0x138>)
 8005e56:	4298      	cmp	r0, r3
 8005e58:	d003      	beq.n	8005e62 <DEV_BusState+0x10a>
      int fWaitCommFlag = 1;
 8005e5a:	2301      	movs	r3, #1
 8005e5c:	e7d3      	b.n	8005e06 <DEV_BusState+0xae>
 8005e5e:	2301      	movs	r3, #1
 8005e60:	e7d1      	b.n	8005e06 <DEV_BusState+0xae>
          fWaitCommFlag = 0;
 8005e62:	2300      	movs	r3, #0
 8005e64:	e7cf      	b.n	8005e06 <DEV_BusState+0xae>
          lRet = CIFX_DEV_BUS_STATE_OFF_TIMEOUT;
 8005e66:	4b09      	ldr	r3, [pc, #36]	; (8005e8c <DEV_BusState+0x134>)
 8005e68:	9303      	str	r3, [sp, #12]
 8005e6a:	e7d9      	b.n	8005e20 <DEV_BusState+0xc8>
      if (0 == DEV_IsRunning(ptChannel))
 8005e6c:	4620      	mov	r0, r4
 8005e6e:	f7ff fc9b 	bl	80057a8 <DEV_IsRunning>
 8005e72:	2800      	cmp	r0, #0
 8005e74:	d18b      	bne.n	8005d8e <DEV_BusState+0x36>
        lRet = CIFX_DEV_NOT_RUNNING;
 8005e76:	4b07      	ldr	r3, [pc, #28]	; (8005e94 <DEV_BusState+0x13c>)
 8005e78:	9303      	str	r3, [sp, #12]
 8005e7a:	e788      	b.n	8005d8e <DEV_BusState+0x36>
  if( NULL == pulState) return CIFX_INVALID_POINTER;
 8005e7c:	4806      	ldr	r0, [pc, #24]	; (8005e98 <DEV_BusState+0x140>)
 8005e7e:	e787      	b.n	8005d90 <DEV_BusState+0x38>
 8005e80:	800a0006 	.word	0x800a0006
 8005e84:	800c0021 	.word	0x800c0021
 8005e88:	800c0011 	.word	0x800c0011
 8005e8c:	800c002f 	.word	0x800c002f
 8005e90:	800c0025 	.word	0x800c0025
 8005e94:	800c0012 	.word	0x800c0012
 8005e98:	800a0001 	.word	0x800a0001

08005e9c <DEV_DoSystemStart>:
{
 8005e9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005ea0:	b086      	sub	sp, #24
 8005ea2:	460f      	mov	r7, r1
 8005ea4:	4616      	mov	r6, r2
  PDEVICEINSTANCE           ptDevInstance   = (PDEVICEINSTANCE)ptChannel->pvDeviceInstance;
 8005ea6:	6804      	ldr	r4, [r0, #0]
  PCHANNELINSTANCE          ptSysDevice     = &ptDevInstance->tSystemDevice;
 8005ea8:	f104 0af4 	add.w	sl, r4, #244	; 0xf4
  HIL_DPM_SYSTEM_CHANNEL_T* ptSysChannel    = (HIL_DPM_SYSTEM_CHANNEL_T*)ptSysDevice->pbDPMChannelStart;
 8005eac:	f8d4 80fc 	ldr.w	r8, [r4, #252]	; 0xfc
  uint32_t                  ulSystemStatus  = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysChannel->tSystemState.ulSystemStatus));
 8005eb0:	f108 09c4 	add.w	r9, r8, #196	; 0xc4
 8005eb4:	4649      	mov	r1, r9
 8005eb6:	4620      	mov	r0, r4
 8005eb8:	f7ff fa1f 	bl	80052fa <HwIfRead32>
 8005ebc:	4605      	mov	r5, r0
  if(!DEV_IsReady(ptSysDevice))
 8005ebe:	4650      	mov	r0, sl
 8005ec0:	f7ff fb8c 	bl	80055dc <DEV_IsReady>
 8005ec4:	2800      	cmp	r0, #0
 8005ec6:	f000 80b3 	beq.w	8006030 <DEV_DoSystemStart+0x194>
  if(!OS_WaitMutex(ptDevInstance->tSystemDevice.pvInitMutex, CIFX_TO_WAIT_COS_CMD))
 8005eca:	2114      	movs	r1, #20
 8005ecc:	f8d4 00f8 	ldr.w	r0, [r4, #248]	; 0xf8
 8005ed0:	f7fc fe88 	bl	8002be4 <OS_WaitMutex>
 8005ed4:	b968      	cbnz	r0, 8005ef2 <DEV_DoSystemStart+0x56>
    if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8005ed6:	4b57      	ldr	r3, [pc, #348]	; (8006034 <DEV_DoSystemStart+0x198>)
 8005ed8:	681b      	ldr	r3, [r3, #0]
 8005eda:	f013 0f08 	tst.w	r3, #8
 8005ede:	d101      	bne.n	8005ee4 <DEV_DoSystemStart+0x48>
    lRet = CIFX_DRV_INIT_STATE_ERROR;
 8005ee0:	4d55      	ldr	r5, [pc, #340]	; (8006038 <DEV_DoSystemStart+0x19c>)
 8005ee2:	e08f      	b.n	8006004 <DEV_DoSystemStart+0x168>
      USER_Trace(ptDevInstance,
 8005ee4:	4a55      	ldr	r2, [pc, #340]	; (800603c <DEV_DoSystemStart+0x1a0>)
 8005ee6:	2108      	movs	r1, #8
 8005ee8:	4620      	mov	r0, r4
 8005eea:	f003 fba9 	bl	8009640 <USER_Trace>
    lRet = CIFX_DRV_INIT_STATE_ERROR;
 8005eee:	4d52      	ldr	r5, [pc, #328]	; (8006038 <DEV_DoSystemStart+0x19c>)
 8005ef0:	e088      	b.n	8006004 <DEV_DoSystemStart+0x168>
    uint32_t ulSystemControl = HIL_SYS_CONTROL_RESET_MODE_COLDSTART | (ulParam & HIL_SYS_CONTROL_RESET_PARAM_FLAG_MASK);
 8005ef2:	f026 060f 	bic.w	r6, r6, #15
    HWIF_WRITE32(ptDevInstance, ptSysChannel->tSystemControl.ulSystemControl, HOST_TO_LE32((ulSystemControl)));
 8005ef6:	9604      	str	r6, [sp, #16]
 8005ef8:	f8d4 62c8 	ldr.w	r6, [r4, #712]	; 0x2c8
 8005efc:	2304      	movs	r3, #4
 8005efe:	9300      	str	r3, [sp, #0]
 8005f00:	ab04      	add	r3, sp, #16
 8005f02:	f108 02bc 	add.w	r2, r8, #188	; 0xbc
 8005f06:	4621      	mov	r1, r4
 8005f08:	2001      	movs	r0, #1
 8005f0a:	47b0      	blx	r6
    if ( HIL_SYS_STATUS_IDPM == (HIL_SYS_STATUS_IDPM & ulSystemStatus) &&
 8005f0c:	f405 0540 	and.w	r5, r5, #12582912	; 0xc00000
 8005f10:	f5b5 0f40 	cmp.w	r5, #12582912	; 0xc00000
 8005f14:	d06c      	beq.n	8005ff0 <DEV_DoSystemStart+0x154>
      DEV_Reset_Prepare(ptDevInstance);
 8005f16:	4620      	mov	r0, r4
 8005f18:	f7ff f8e6 	bl	80050e8 <DEV_Reset_Prepare>
      lRet = DEV_Reset_Execute(ptDevInstance, HSF_RESET, 1);
 8005f1c:	2201      	movs	r2, #1
 8005f1e:	4611      	mov	r1, r2
 8005f20:	4620      	mov	r0, r4
 8005f22:	f7ff fdcf 	bl	8005ac4 <DEV_Reset_Execute>
      if((CIFX_NO_ERROR != lRet) && (g_ulTraceLevel & TRACE_LEVEL_ERROR))
 8005f26:	4605      	mov	r5, r0
 8005f28:	b120      	cbz	r0, 8005f34 <DEV_DoSystemStart+0x98>
 8005f2a:	4b42      	ldr	r3, [pc, #264]	; (8006034 <DEV_DoSystemStart+0x198>)
 8005f2c:	681b      	ldr	r3, [r3, #0]
 8005f2e:	f013 0f08 	tst.w	r3, #8
 8005f32:	d16b      	bne.n	800600c <DEV_DoSystemStart+0x170>
      if(CIFX_NO_ERROR == lRet)
 8005f34:	b9c5      	cbnz	r5, 8005f68 <DEV_DoSystemStart+0xcc>
        if( (ptDevInstance->fPCICard) &&
 8005f36:	68e3      	ldr	r3, [r4, #12]
 8005f38:	b12b      	cbz	r3, 8005f46 <DEV_DoSystemStart+0xaa>
            (( eCHIP_TYPE_NETX4000 == ptDevInstance->eChipType) ||
 8005f3a:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8005f3e:	3b07      	subs	r3, #7
 8005f40:	b2db      	uxtb	r3, r3
        if( (ptDevInstance->fPCICard) &&
 8005f42:	2b01      	cmp	r3, #1
 8005f44:	d968      	bls.n	8006018 <DEV_DoSystemStart+0x17c>
        if( !DEV_WaitForReady_Poll( ptSysDevice, ( 0 == ulTimeout) ? CIFX_TO_WAIT_HW : ulTimeout) )
 8005f46:	b90f      	cbnz	r7, 8005f4c <DEV_DoSystemStart+0xb0>
 8005f48:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
 8005f4c:	4639      	mov	r1, r7
 8005f4e:	4650      	mov	r0, sl
 8005f50:	f7ff fdfe 	bl	8005b50 <DEV_WaitForReady_Poll>
 8005f54:	b928      	cbnz	r0, 8005f62 <DEV_DoSystemStart+0xc6>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8005f56:	4b37      	ldr	r3, [pc, #220]	; (8006034 <DEV_DoSystemStart+0x198>)
 8005f58:	681b      	ldr	r3, [r3, #0]
 8005f5a:	f013 0f08 	tst.w	r3, #8
 8005f5e:	d160      	bne.n	8006022 <DEV_DoSystemStart+0x186>
          lRet = CIFX_DEV_NOT_READY;
 8005f60:	4d37      	ldr	r5, [pc, #220]	; (8006040 <DEV_DoSystemStart+0x1a4>)
        DEV_Reset_Finish(ptDevInstance);
 8005f62:	4620      	mov	r0, r4
 8005f64:	f7ff fc78 	bl	8005858 <DEV_Reset_Finish>
      if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8005f68:	4b32      	ldr	r3, [pc, #200]	; (8006034 <DEV_DoSystemStart+0x198>)
 8005f6a:	681b      	ldr	r3, [r3, #0]
 8005f6c:	f013 0f01 	tst.w	r3, #1
 8005f70:	d044      	beq.n	8005ffc <DEV_DoSystemStart+0x160>
        HWIF_READN(ptDevInstance, szCookie, ptDevInstance->pbDPM, 4);
 8005f72:	f8d4 62c4 	ldr.w	r6, [r4, #708]	; 0x2c4
 8005f76:	6a22      	ldr	r2, [r4, #32]
 8005f78:	2304      	movs	r3, #4
 8005f7a:	9300      	str	r3, [sp, #0]
 8005f7c:	ab04      	add	r3, sp, #16
 8005f7e:	4621      	mov	r1, r4
 8005f80:	2000      	movs	r0, #0
 8005f82:	47b0      	blx	r6
        USER_Trace(ptDevInstance, TRACE_LEVEL_DEBUG, "DEV_DoSystemStart(): (system status after reset)");
 8005f84:	4a2f      	ldr	r2, [pc, #188]	; (8006044 <DEV_DoSystemStart+0x1a8>)
 8005f86:	2101      	movs	r1, #1
 8005f88:	4620      	mov	r0, r4
 8005f8a:	f003 fb59 	bl	8009640 <USER_Trace>
                   szCookie[1],
 8005f8e:	f89d 3011 	ldrb.w	r3, [sp, #17]
                   szCookie[2],
 8005f92:	f89d 2012 	ldrb.w	r2, [sp, #18]
                   szCookie[3]);
 8005f96:	f89d 1013 	ldrb.w	r1, [sp, #19]
        USER_Trace(ptDevInstance, TRACE_LEVEL_DEBUG, " -DPM-Cookie    : '%02X','%02X','%02X','%02X'",
 8005f9a:	9102      	str	r1, [sp, #8]
 8005f9c:	9201      	str	r2, [sp, #4]
 8005f9e:	9300      	str	r3, [sp, #0]
 8005fa0:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8005fa4:	4a28      	ldr	r2, [pc, #160]	; (8006048 <DEV_DoSystemStart+0x1ac>)
 8005fa6:	2101      	movs	r1, #1
 8005fa8:	4620      	mov	r0, r4
 8005faa:	f003 fb49 	bl	8009640 <USER_Trace>
        USER_Trace(ptDevInstance, TRACE_LEVEL_DEBUG, " -System Status : 0x%X",
 8005fae:	4649      	mov	r1, r9
 8005fb0:	4620      	mov	r0, r4
 8005fb2:	f7ff f9a2 	bl	80052fa <HwIfRead32>
 8005fb6:	4603      	mov	r3, r0
 8005fb8:	4a24      	ldr	r2, [pc, #144]	; (800604c <DEV_DoSystemStart+0x1b0>)
 8005fba:	2101      	movs	r1, #1
 8005fbc:	4620      	mov	r0, r4
 8005fbe:	f003 fb3f 	bl	8009640 <USER_Trace>
        USER_Trace(ptDevInstance, TRACE_LEVEL_DEBUG, " -System Error  : 0x%X",
 8005fc2:	f108 01c8 	add.w	r1, r8, #200	; 0xc8
 8005fc6:	4620      	mov	r0, r4
 8005fc8:	f7ff f997 	bl	80052fa <HwIfRead32>
 8005fcc:	4603      	mov	r3, r0
 8005fce:	4a20      	ldr	r2, [pc, #128]	; (8006050 <DEV_DoSystemStart+0x1b4>)
 8005fd0:	2101      	movs	r1, #1
 8005fd2:	4620      	mov	r0, r4
 8005fd4:	f003 fb34 	bl	8009640 <USER_Trace>
        USER_Trace(ptDevInstance, TRACE_LEVEL_DEBUG, " -Boot Error    : 0x%X",
 8005fd8:	f108 01cc 	add.w	r1, r8, #204	; 0xcc
 8005fdc:	4620      	mov	r0, r4
 8005fde:	f7ff f98c 	bl	80052fa <HwIfRead32>
 8005fe2:	4603      	mov	r3, r0
 8005fe4:	4a1b      	ldr	r2, [pc, #108]	; (8006054 <DEV_DoSystemStart+0x1b8>)
 8005fe6:	2101      	movs	r1, #1
 8005fe8:	4620      	mov	r0, r4
 8005fea:	f003 fb29 	bl	8009640 <USER_Trace>
 8005fee:	e005      	b.n	8005ffc <DEV_DoSystemStart+0x160>
      lRet = DEV_Reset_Execute(ptDevInstance, HSF_RESET, 0 );
 8005ff0:	2200      	movs	r2, #0
 8005ff2:	2101      	movs	r1, #1
 8005ff4:	4620      	mov	r0, r4
 8005ff6:	f7ff fd65 	bl	8005ac4 <DEV_Reset_Execute>
 8005ffa:	4605      	mov	r5, r0
    OS_ReleaseMutex(ptDevInstance->tSystemDevice.pvInitMutex);
 8005ffc:	f8d4 00f8 	ldr.w	r0, [r4, #248]	; 0xf8
 8006000:	f7fc fdfc 	bl	8002bfc <OS_ReleaseMutex>
}
 8006004:	4628      	mov	r0, r5
 8006006:	b006      	add	sp, #24
 8006008:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        USER_Trace(ptDevInstance,
 800600c:	4a12      	ldr	r2, [pc, #72]	; (8006058 <DEV_DoSystemStart+0x1bc>)
 800600e:	2108      	movs	r1, #8
 8006010:	4620      	mov	r0, r4
 8006012:	f003 fb15 	bl	8009640 <USER_Trace>
 8006016:	e78d      	b.n	8005f34 <DEV_DoSystemStart+0x98>
          OS_Sleep(1000);
 8006018:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800601c:	f7fc fd9e 	bl	8002b5c <OS_Sleep>
 8006020:	e791      	b.n	8005f46 <DEV_DoSystemStart+0xaa>
            USER_Trace(ptDevInstance,
 8006022:	4a0e      	ldr	r2, [pc, #56]	; (800605c <DEV_DoSystemStart+0x1c0>)
 8006024:	2108      	movs	r1, #8
 8006026:	4620      	mov	r0, r4
 8006028:	f003 fb0a 	bl	8009640 <USER_Trace>
          lRet = CIFX_DEV_NOT_READY;
 800602c:	4d04      	ldr	r5, [pc, #16]	; (8006040 <DEV_DoSystemStart+0x1a4>)
 800602e:	e798      	b.n	8005f62 <DEV_DoSystemStart+0xc6>
    return CIFX_DEV_NOT_READY;
 8006030:	4d03      	ldr	r5, [pc, #12]	; (8006040 <DEV_DoSystemStart+0x1a4>)
 8006032:	e7e7      	b.n	8006004 <DEV_DoSystemStart+0x168>
 8006034:	20000038 	.word	0x20000038
 8006038:	800b0002 	.word	0x800b0002
 800603c:	0800b100 	.word	0x0800b100
 8006040:	800c0011 	.word	0x800c0011
 8006044:	0800b1bc 	.word	0x0800b1bc
 8006048:	0800b1f0 	.word	0x0800b1f0
 800604c:	0800b220 	.word	0x0800b220
 8006050:	0800b238 	.word	0x0800b238
 8006054:	0800b250 	.word	0x0800b250
 8006058:	0800b138 	.word	0x0800b138
 800605c:	0800b17c 	.word	0x0800b17c

08006060 <cifXStartFlashDevice>:
  ptDevInstance = ptDevInstance;

  /* Note: Checks already done in cifXEvaluateDeviveType() */

  return CIFX_NO_ERROR;
}
 8006060:	2000      	movs	r0, #0
 8006062:	4770      	bx	lr

08006064 <cifXEvaluateDeviceType>:
/*! Evaluate device type
*   \param ptDevInstance Instance to start up
*   \return SUCCESS_HIL_OK if device type is OK                              */
/*****************************************************************************/
static int32_t cifXEvaluateDeviceType(PDEVICEINSTANCE ptDevInstance)
{
 8006064:	b570      	push	{r4, r5, r6, lr}
 8006066:	b086      	sub	sp, #24
 8006068:	4604      	mov	r4, r0
  /*-----------------------------------------------------------*/
  /* Check for FLASH based device                              */
  /* and                                                       */
  /* Check for DON'T TOUCH device                              */
  /*-----------------------------------------------------------*/
  if( (eCIFX_DEVICE_FLASH_BASED == ptDevInstance->eDeviceType) ||
 800606a:	7d02      	ldrb	r2, [r0, #20]
 800606c:	1ed3      	subs	r3, r2, #3
 800606e:	b2db      	uxtb	r3, r3
 8006070:	2b01      	cmp	r3, #1
 8006072:	d912      	bls.n	800609a <cifXEvaluateDeviceType+0x36>
    }

  /*-----------------------------------------------------------*/
  /* Check for RAM based device                              */
  /*-----------------------------------------------------------*/
  }else if( eCIFX_DEVICE_RAM_BASED == ptDevInstance->eDeviceType)
 8006074:	2a02      	cmp	r2, #2
 8006076:	d051      	beq.n	800611c <cifXEvaluateDeviceType+0xb8>
    lRet = CIFX_NO_ERROR;

  /*-----------------------------------------------------------*/
  /* Try to autodetect the device type                         */
  /*-----------------------------------------------------------*/
  }else if( eCIFX_DEVICE_AUTODETECT == ptDevInstance->eDeviceType)
 8006078:	2a00      	cmp	r2, #0
 800607a:	f040 80be 	bne.w	80061fa <cifXEvaluateDeviceType+0x196>
  {
    /* Check for PCI hardware first */
    if(ptDevInstance->fPCICard)
 800607e:	68c5      	ldr	r5, [r0, #12]
 8006080:	2d00      	cmp	r5, #0
 8006082:	d05d      	beq.n	8006140 <cifXEvaluateDeviceType+0xdc>
    {
      /* All current PCI cards are RAM based, so default to RAM
         NOTE: If the user builds a flash based PCI card, he must pass
               eCIFX_DEVICE_AUTODETECT */

      if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8006084:	4b5e      	ldr	r3, [pc, #376]	; (8006200 <cifXEvaluateDeviceType+0x19c>)
 8006086:	681b      	ldr	r3, [r3, #0]
 8006088:	f013 0f01 	tst.w	r3, #1
 800608c:	d153      	bne.n	8006136 <cifXEvaluateDeviceType+0xd2>
                   TRACE_LEVEL_DEBUG,
                   "Device Type autodetection: RAM Based Device found!");
      }

      /* Evaluation OK */
      ptDevInstance->eDeviceType = eCIFX_DEVICE_RAM_BASED;
 800608e:	2302      	movs	r3, #2
 8006090:	7523      	strb	r3, [r4, #20]
      lRet = CIFX_NO_ERROR;
 8006092:	2500      	movs	r5, #0
      }
    }
  }

  return lRet;
}
 8006094:	4628      	mov	r0, r5
 8006096:	b006      	add	sp, #24
 8006098:	bd70      	pop	{r4, r5, r6, pc}
    OS_Memset(szCookie, 0, sizeof(szCookie));
 800609a:	2205      	movs	r2, #5
 800609c:	2100      	movs	r1, #0
 800609e:	a804      	add	r0, sp, #16
 80060a0:	f7fc fd3d 	bl	8002b1e <OS_Memset>
    HWIF_READN(ptDevInstance, szCookie, ptDevInstance->pbDPM, 4);
 80060a4:	f8d4 52c4 	ldr.w	r5, [r4, #708]	; 0x2c4
 80060a8:	2304      	movs	r3, #4
 80060aa:	9300      	str	r3, [sp, #0]
 80060ac:	ab04      	add	r3, sp, #16
 80060ae:	6a22      	ldr	r2, [r4, #32]
 80060b0:	4621      	mov	r1, r4
 80060b2:	2000      	movs	r0, #0
 80060b4:	47a8      	blx	r5
    if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 80060b6:	4b52      	ldr	r3, [pc, #328]	; (8006200 <cifXEvaluateDeviceType+0x19c>)
 80060b8:	681b      	ldr	r3, [r3, #0]
 80060ba:	f013 0f01 	tst.w	r3, #1
 80060be:	d007      	beq.n	80060d0 <cifXEvaluateDeviceType+0x6c>
      if(eCIFX_DEVICE_FLASH_BASED == ptDevInstance->eDeviceType)
 80060c0:	7d23      	ldrb	r3, [r4, #20]
 80060c2:	2b03      	cmp	r3, #3
 80060c4:	d024      	beq.n	8006110 <cifXEvaluateDeviceType+0xac>
        USER_Trace(ptDevInstance,
 80060c6:	4a4f      	ldr	r2, [pc, #316]	; (8006204 <cifXEvaluateDeviceType+0x1a0>)
 80060c8:	2101      	movs	r1, #1
 80060ca:	4620      	mov	r0, r4
 80060cc:	f003 fab8 	bl	8009640 <USER_Trace>
    if( (0 == OS_Strcmp( szCookie, CIFX_DPMSIGNATURE_BSL_STR)) ||
 80060d0:	494d      	ldr	r1, [pc, #308]	; (8006208 <cifXEvaluateDeviceType+0x1a4>)
 80060d2:	a804      	add	r0, sp, #16
 80060d4:	f7fc fe04 	bl	8002ce0 <OS_Strcmp>
 80060d8:	4605      	mov	r5, r0
 80060da:	2800      	cmp	r0, #0
 80060dc:	d0da      	beq.n	8006094 <cifXEvaluateDeviceType+0x30>
        (0 == OS_Strcmp( szCookie, CIFX_DPMSIGNATURE_FW_STR)) )
 80060de:	494b      	ldr	r1, [pc, #300]	; (800620c <cifXEvaluateDeviceType+0x1a8>)
 80060e0:	a804      	add	r0, sp, #16
 80060e2:	f7fc fdfd 	bl	8002ce0 <OS_Strcmp>
    if( (0 == OS_Strcmp( szCookie, CIFX_DPMSIGNATURE_BSL_STR)) ||
 80060e6:	4605      	mov	r5, r0
 80060e8:	2800      	cmp	r0, #0
 80060ea:	d0d3      	beq.n	8006094 <cifXEvaluateDeviceType+0x30>
            szCookie[1],
 80060ec:	f89d 3011 	ldrb.w	r3, [sp, #17]
            szCookie[2],
 80060f0:	f89d 2012 	ldrb.w	r2, [sp, #18]
            szCookie[3]);
 80060f4:	f89d 1013 	ldrb.w	r1, [sp, #19]
      USER_Trace( ptDevInstance,
 80060f8:	9102      	str	r1, [sp, #8]
 80060fa:	9201      	str	r2, [sp, #4]
 80060fc:	9300      	str	r3, [sp, #0]
 80060fe:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8006102:	4a43      	ldr	r2, [pc, #268]	; (8006210 <cifXEvaluateDeviceType+0x1ac>)
 8006104:	2108      	movs	r1, #8
 8006106:	4620      	mov	r0, r4
 8006108:	f003 fa9a 	bl	8009640 <USER_Trace>
  int32_t lRet = CIFX_INVALID_BOARD;
 800610c:	4d41      	ldr	r5, [pc, #260]	; (8006214 <cifXEvaluateDeviceType+0x1b0>)
 800610e:	e7c1      	b.n	8006094 <cifXEvaluateDeviceType+0x30>
        USER_Trace(ptDevInstance,
 8006110:	4a41      	ldr	r2, [pc, #260]	; (8006218 <cifXEvaluateDeviceType+0x1b4>)
 8006112:	2101      	movs	r1, #1
 8006114:	4620      	mov	r0, r4
 8006116:	f003 fa93 	bl	8009640 <USER_Trace>
 800611a:	e7d9      	b.n	80060d0 <cifXEvaluateDeviceType+0x6c>
    if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 800611c:	4b38      	ldr	r3, [pc, #224]	; (8006200 <cifXEvaluateDeviceType+0x19c>)
 800611e:	681b      	ldr	r3, [r3, #0]
 8006120:	f013 0f01 	tst.w	r3, #1
 8006124:	d101      	bne.n	800612a <cifXEvaluateDeviceType+0xc6>
    lRet = CIFX_NO_ERROR;
 8006126:	2500      	movs	r5, #0
 8006128:	e7b4      	b.n	8006094 <cifXEvaluateDeviceType+0x30>
      USER_Trace(ptDevInstance,
 800612a:	4a3c      	ldr	r2, [pc, #240]	; (800621c <cifXEvaluateDeviceType+0x1b8>)
 800612c:	2101      	movs	r1, #1
 800612e:	f003 fa87 	bl	8009640 <USER_Trace>
    lRet = CIFX_NO_ERROR;
 8006132:	2500      	movs	r5, #0
 8006134:	e7ae      	b.n	8006094 <cifXEvaluateDeviceType+0x30>
        USER_Trace(ptDevInstance,
 8006136:	4a3a      	ldr	r2, [pc, #232]	; (8006220 <cifXEvaluateDeviceType+0x1bc>)
 8006138:	2101      	movs	r1, #1
 800613a:	f003 fa81 	bl	8009640 <USER_Trace>
 800613e:	e7a6      	b.n	800608e <cifXEvaluateDeviceType+0x2a>
      OS_Memset(szCookie, 0, sizeof(szCookie));
 8006140:	2205      	movs	r2, #5
 8006142:	2100      	movs	r1, #0
 8006144:	a804      	add	r0, sp, #16
 8006146:	f7fc fcea 	bl	8002b1e <OS_Memset>
      HWIF_READN(ptDevInstance, szCookie, ptDevInstance->pbDPM, 4);
 800614a:	2304      	movs	r3, #4
 800614c:	9300      	str	r3, [sp, #0]
 800614e:	ab04      	add	r3, sp, #16
 8006150:	6a22      	ldr	r2, [r4, #32]
 8006152:	4621      	mov	r1, r4
 8006154:	2000      	movs	r0, #0
 8006156:	f8d4 62c4 	ldr.w	r6, [r4, #708]	; 0x2c4
 800615a:	47b0      	blx	r6
      if( (0 == OS_Strcmp( szCookie, CIFX_DPMSIGNATURE_BSL_STR)) ||
 800615c:	492a      	ldr	r1, [pc, #168]	; (8006208 <cifXEvaluateDeviceType+0x1a4>)
 800615e:	a804      	add	r0, sp, #16
 8006160:	f7fc fdbe 	bl	8002ce0 <OS_Strcmp>
 8006164:	b938      	cbnz	r0, 8006176 <cifXEvaluateDeviceType+0x112>
        if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8006166:	4b26      	ldr	r3, [pc, #152]	; (8006200 <cifXEvaluateDeviceType+0x19c>)
 8006168:	681b      	ldr	r3, [r3, #0]
 800616a:	f013 0f01 	tst.w	r3, #1
 800616e:	d118      	bne.n	80061a2 <cifXEvaluateDeviceType+0x13e>
        ptDevInstance->eDeviceType = eCIFX_DEVICE_FLASH_BASED;
 8006170:	2303      	movs	r3, #3
 8006172:	7523      	strb	r3, [r4, #20]
        lRet = CIFX_NO_ERROR;
 8006174:	e78e      	b.n	8006094 <cifXEvaluateDeviceType+0x30>
          (0 == OS_Strcmp( szCookie, CIFX_DPMSIGNATURE_FW_STR)) )
 8006176:	4925      	ldr	r1, [pc, #148]	; (800620c <cifXEvaluateDeviceType+0x1a8>)
 8006178:	a804      	add	r0, sp, #16
 800617a:	f7fc fdb1 	bl	8002ce0 <OS_Strcmp>
      if( (0 == OS_Strcmp( szCookie, CIFX_DPMSIGNATURE_BSL_STR)) ||
 800617e:	2800      	cmp	r0, #0
 8006180:	d0f1      	beq.n	8006166 <cifXEvaluateDeviceType+0x102>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006182:	4b1f      	ldr	r3, [pc, #124]	; (8006200 <cifXEvaluateDeviceType+0x19c>)
 8006184:	681b      	ldr	r3, [r3, #0]
 8006186:	f013 0f08 	tst.w	r3, #8
 800618a:	d110      	bne.n	80061ae <cifXEvaluateDeviceType+0x14a>
        if(ptDevInstance->ulDPMSize < NETX_DPM_MEMORY_SIZE)
 800618c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800618e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8006192:	d224      	bcs.n	80061de <cifXEvaluateDeviceType+0x17a>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006194:	4b1a      	ldr	r3, [pc, #104]	; (8006200 <cifXEvaluateDeviceType+0x19c>)
 8006196:	681b      	ldr	r3, [r3, #0]
 8006198:	f013 0f08 	tst.w	r3, #8
 800619c:	d118      	bne.n	80061d0 <cifXEvaluateDeviceType+0x16c>
  int32_t lRet = CIFX_INVALID_BOARD;
 800619e:	4d1d      	ldr	r5, [pc, #116]	; (8006214 <cifXEvaluateDeviceType+0x1b0>)
 80061a0:	e778      	b.n	8006094 <cifXEvaluateDeviceType+0x30>
          USER_Trace(ptDevInstance,
 80061a2:	4a20      	ldr	r2, [pc, #128]	; (8006224 <cifXEvaluateDeviceType+0x1c0>)
 80061a4:	2101      	movs	r1, #1
 80061a6:	4620      	mov	r0, r4
 80061a8:	f003 fa4a 	bl	8009640 <USER_Trace>
 80061ac:	e7e0      	b.n	8006170 <cifXEvaluateDeviceType+0x10c>
                     szCookie[1],
 80061ae:	f89d 3011 	ldrb.w	r3, [sp, #17]
                     szCookie[2],
 80061b2:	f89d 2012 	ldrb.w	r2, [sp, #18]
                     szCookie[3]);
 80061b6:	f89d 1013 	ldrb.w	r1, [sp, #19]
          USER_Trace(ptDevInstance,
 80061ba:	9102      	str	r1, [sp, #8]
 80061bc:	9201      	str	r2, [sp, #4]
 80061be:	9300      	str	r3, [sp, #0]
 80061c0:	f89d 3010 	ldrb.w	r3, [sp, #16]
 80061c4:	4a18      	ldr	r2, [pc, #96]	; (8006228 <cifXEvaluateDeviceType+0x1c4>)
 80061c6:	2108      	movs	r1, #8
 80061c8:	4620      	mov	r0, r4
 80061ca:	f003 fa39 	bl	8009640 <USER_Trace>
 80061ce:	e7dd      	b.n	800618c <cifXEvaluateDeviceType+0x128>
            USER_Trace(ptDevInstance,
 80061d0:	4a16      	ldr	r2, [pc, #88]	; (800622c <cifXEvaluateDeviceType+0x1c8>)
 80061d2:	2108      	movs	r1, #8
 80061d4:	4620      	mov	r0, r4
 80061d6:	f003 fa33 	bl	8009640 <USER_Trace>
  int32_t lRet = CIFX_INVALID_BOARD;
 80061da:	4d0e      	ldr	r5, [pc, #56]	; (8006214 <cifXEvaluateDeviceType+0x1b0>)
 80061dc:	e75a      	b.n	8006094 <cifXEvaluateDeviceType+0x30>
          if(g_ulTraceLevel & TRACE_LEVEL_INFO)
 80061de:	4b08      	ldr	r3, [pc, #32]	; (8006200 <cifXEvaluateDeviceType+0x19c>)
 80061e0:	681b      	ldr	r3, [r3, #0]
 80061e2:	f013 0f02 	tst.w	r3, #2
 80061e6:	d102      	bne.n	80061ee <cifXEvaluateDeviceType+0x18a>
          ptDevInstance->eDeviceType = eCIFX_DEVICE_RAM_BASED;
 80061e8:	2302      	movs	r3, #2
 80061ea:	7523      	strb	r3, [r4, #20]
          lRet = CIFX_NO_ERROR;
 80061ec:	e752      	b.n	8006094 <cifXEvaluateDeviceType+0x30>
            USER_Trace(ptDevInstance,
 80061ee:	4a10      	ldr	r2, [pc, #64]	; (8006230 <cifXEvaluateDeviceType+0x1cc>)
 80061f0:	2102      	movs	r1, #2
 80061f2:	4620      	mov	r0, r4
 80061f4:	f003 fa24 	bl	8009640 <USER_Trace>
 80061f8:	e7f6      	b.n	80061e8 <cifXEvaluateDeviceType+0x184>
  int32_t lRet = CIFX_INVALID_BOARD;
 80061fa:	4d06      	ldr	r5, [pc, #24]	; (8006214 <cifXEvaluateDeviceType+0x1b0>)
  return lRet;
 80061fc:	e74a      	b.n	8006094 <cifXEvaluateDeviceType+0x30>
 80061fe:	bf00      	nop
 8006200:	20000038 	.word	0x20000038
 8006204:	0800b2a0 	.word	0x0800b2a0
 8006208:	0800a754 	.word	0x0800a754
 800620c:	0800a75c 	.word	0x0800a75c
 8006210:	0800b2d8 	.word	0x0800b2d8
 8006214:	800a0002 	.word	0x800a0002
 8006218:	0800b268 	.word	0x0800b268
 800621c:	0800b328 	.word	0x0800b328
 8006220:	0800b360 	.word	0x0800b360
 8006224:	0800b394 	.word	0x0800b394
 8006228:	0800b3cc 	.word	0x0800b3cc
 800622c:	0800b460 	.word	0x0800b460
 8006230:	0800b4bc 	.word	0x0800b4bc

08006234 <cifXIsBaseOSModule>:
{
 8006234:	b510      	push	{r4, lr}
 8006236:	4604      	mov	r4, r0
  HIL_DPM_SYSTEM_CHANNEL_T*  ptSystemChannel = (HIL_DPM_SYSTEM_CHANNEL_T*)(ptDevInstance->tSystemDevice.pbDPMChannelStart);
 8006238:	f8d0 10fc 	ldr.w	r1, [r0, #252]	; 0xfc
  ptDevInstance->fModuleLoad = 0;
 800623c:	2300      	movs	r3, #0
 800623e:	6103      	str	r3, [r0, #16]
  if( 0 != (0x80000000 & LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSystemChannel->tSystemState.ulSystemStatus))))
 8006240:	31c4      	adds	r1, #196	; 0xc4
 8006242:	f7ff f85a 	bl	80052fa <HwIfRead32>
 8006246:	2800      	cmp	r0, #0
 8006248:	db01      	blt.n	800624e <cifXIsBaseOSModule+0x1a>
}
 800624a:	2000      	movs	r0, #0
 800624c:	bd10      	pop	{r4, pc}
    ptDevInstance->fModuleLoad = 1;
 800624e:	2301      	movs	r3, #1
 8006250:	6123      	str	r3, [r4, #16]
 8006252:	e7fa      	b.n	800624a <cifXIsBaseOSModule+0x16>

08006254 <cifXRunBootloader>:
{
 8006254:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006258:	b0c7      	sub	sp, #284	; 0x11c
 800625a:	4604      	mov	r4, r0
  uint32_t              ulFileSize  = 0;
 800625c:	2100      	movs	r1, #0
 800625e:	9145      	str	r1, [sp, #276]	; 0x114
  OS_Memset(&tFileInfo, 0, sizeof(tFileInfo));
 8006260:	f44f 728a 	mov.w	r2, #276	; 0x114
 8006264:	4668      	mov	r0, sp
 8006266:	f7fc fc5a 	bl	8002b1e <OS_Memset>
  USER_GetBootloaderFile( ptDevInstance, &tFileInfo);
 800626a:	4669      	mov	r1, sp
 800626c:	4620      	mov	r0, r4
 800626e:	f003 f9df 	bl	8009630 <USER_GetBootloaderFile>
  if(NULL == (pvFile = OS_FileOpen(tFileInfo.szFullFileName, &ulFileSize)))
 8006272:	a945      	add	r1, sp, #276	; 0x114
 8006274:	a804      	add	r0, sp, #16
 8006276:	f7fc fc67 	bl	8002b48 <OS_FileOpen>
 800627a:	b320      	cbz	r0, 80062c6 <cifXRunBootloader+0x72>
 800627c:	4681      	mov	r9, r0
    uint8_t* pbBuffer = (uint8_t*)OS_Memalloc(ulFileSize);
 800627e:	9845      	ldr	r0, [sp, #276]	; 0x114
 8006280:	f7fc fc41 	bl	8002b06 <OS_Memalloc>
 8006284:	4606      	mov	r6, r0
    if(g_ulTraceLevel & TRACE_LEVEL_INFO)
 8006286:	4b71      	ldr	r3, [pc, #452]	; (800644c <cifXRunBootloader+0x1f8>)
 8006288:	681b      	ldr	r3, [r3, #0]
 800628a:	f013 0f02 	tst.w	r3, #2
 800628e:	d12b      	bne.n	80062e8 <cifXRunBootloader+0x94>
    if( NULL == pbBuffer)
 8006290:	b38e      	cbz	r6, 80062f6 <cifXRunBootloader+0xa2>
      if(ulFileSize != OS_FileRead(pvFile, 0, ulFileSize, pbBuffer))
 8006292:	4633      	mov	r3, r6
 8006294:	9a45      	ldr	r2, [sp, #276]	; 0x114
 8006296:	2100      	movs	r1, #0
 8006298:	4648      	mov	r0, r9
 800629a:	f7fc fc57 	bl	8002b4c <OS_FileRead>
 800629e:	9b45      	ldr	r3, [sp, #276]	; 0x114
 80062a0:	4298      	cmp	r0, r3
 80062a2:	d041      	beq.n	8006328 <cifXRunBootloader+0xd4>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80062a4:	4b69      	ldr	r3, [pc, #420]	; (800644c <cifXRunBootloader+0x1f8>)
 80062a6:	681b      	ldr	r3, [r3, #0]
 80062a8:	f013 0f08 	tst.w	r3, #8
 80062ac:	d133      	bne.n	8006316 <cifXRunBootloader+0xc2>
        lRet = CIFX_FILE_READ_ERROR;
 80062ae:	f8df 81d4 	ldr.w	r8, [pc, #468]	; 8006484 <cifXRunBootloader+0x230>
      OS_Memfree(pbBuffer);
 80062b2:	4630      	mov	r0, r6
 80062b4:	f7fc fc2b 	bl	8002b0e <OS_Memfree>
    OS_FileClose(pvFile);
 80062b8:	4648      	mov	r0, r9
 80062ba:	f7fc fc49 	bl	8002b50 <OS_FileClose>
}
 80062be:	4640      	mov	r0, r8
 80062c0:	b047      	add	sp, #284	; 0x11c
 80062c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80062c6:	4b61      	ldr	r3, [pc, #388]	; (800644c <cifXRunBootloader+0x1f8>)
 80062c8:	681b      	ldr	r3, [r3, #0]
 80062ca:	f013 0f08 	tst.w	r3, #8
 80062ce:	d102      	bne.n	80062d6 <cifXRunBootloader+0x82>
    lRet = CIFX_FILE_OPEN_FAILED;
 80062d0:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 8006488 <cifXRunBootloader+0x234>
  return lRet;
 80062d4:	e7f3      	b.n	80062be <cifXRunBootloader+0x6a>
      USER_Trace(ptDevInstance,
 80062d6:	ab04      	add	r3, sp, #16
 80062d8:	4a5d      	ldr	r2, [pc, #372]	; (8006450 <cifXRunBootloader+0x1fc>)
 80062da:	2108      	movs	r1, #8
 80062dc:	4620      	mov	r0, r4
 80062de:	f003 f9af 	bl	8009640 <USER_Trace>
    lRet = CIFX_FILE_OPEN_FAILED;
 80062e2:	f8df 81a4 	ldr.w	r8, [pc, #420]	; 8006488 <cifXRunBootloader+0x234>
 80062e6:	e7ea      	b.n	80062be <cifXRunBootloader+0x6a>
      USER_Trace(ptDevInstance,
 80062e8:	ab04      	add	r3, sp, #16
 80062ea:	4a5a      	ldr	r2, [pc, #360]	; (8006454 <cifXRunBootloader+0x200>)
 80062ec:	2102      	movs	r1, #2
 80062ee:	4620      	mov	r0, r4
 80062f0:	f003 f9a6 	bl	8009640 <USER_Trace>
 80062f4:	e7cc      	b.n	8006290 <cifXRunBootloader+0x3c>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80062f6:	4b55      	ldr	r3, [pc, #340]	; (800644c <cifXRunBootloader+0x1f8>)
 80062f8:	681b      	ldr	r3, [r3, #0]
 80062fa:	f013 0f08 	tst.w	r3, #8
 80062fe:	d102      	bne.n	8006306 <cifXRunBootloader+0xb2>
      lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 8006300:	f8df 8188 	ldr.w	r8, [pc, #392]	; 800648c <cifXRunBootloader+0x238>
 8006304:	e7d8      	b.n	80062b8 <cifXRunBootloader+0x64>
        USER_Trace(ptDevInstance,
 8006306:	4a54      	ldr	r2, [pc, #336]	; (8006458 <cifXRunBootloader+0x204>)
 8006308:	2108      	movs	r1, #8
 800630a:	4620      	mov	r0, r4
 800630c:	f003 f998 	bl	8009640 <USER_Trace>
      lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 8006310:	f8df 8178 	ldr.w	r8, [pc, #376]	; 800648c <cifXRunBootloader+0x238>
 8006314:	e7d0      	b.n	80062b8 <cifXRunBootloader+0x64>
          USER_Trace(ptDevInstance,
 8006316:	ab04      	add	r3, sp, #16
 8006318:	4a50      	ldr	r2, [pc, #320]	; (800645c <cifXRunBootloader+0x208>)
 800631a:	2108      	movs	r1, #8
 800631c:	4620      	mov	r0, r4
 800631e:	f003 f98f 	bl	8009640 <USER_Trace>
        lRet = CIFX_FILE_READ_ERROR;
 8006322:	f8df 8160 	ldr.w	r8, [pc, #352]	; 8006484 <cifXRunBootloader+0x230>
 8006326:	e7c4      	b.n	80062b2 <cifXRunBootloader+0x5e>
        if(ptDevInstance->pfnNotify)
 8006328:	69a3      	ldr	r3, [r4, #24]
 800632a:	b143      	cbz	r3, 800633e <cifXRunBootloader+0xea>
          if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 800632c:	4a47      	ldr	r2, [pc, #284]	; (800644c <cifXRunBootloader+0x1f8>)
 800632e:	6812      	ldr	r2, [r2, #0]
 8006330:	f012 0f01 	tst.w	r2, #1
 8006334:	d118      	bne.n	8006368 <cifXRunBootloader+0x114>
          ptDevInstance->pfnNotify(ptDevInstance, eCIFX_TOOLKIT_EVENT_PRE_BOOTLOADER);
 8006336:	69a3      	ldr	r3, [r4, #24]
 8006338:	2102      	movs	r1, #2
 800633a:	4620      	mov	r0, r4
 800633c:	4798      	blx	r3
        switch(ptDevInstance->eChipType)
 800633e:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8006342:	2b03      	cmp	r3, #3
 8006344:	d01a      	beq.n	800637c <cifXRunBootloader+0x128>
 8006346:	d815      	bhi.n	8006374 <cifXRunBootloader+0x120>
 8006348:	3b01      	subs	r3, #1
 800634a:	b2db      	uxtb	r3, r3
 800634c:	2b01      	cmp	r3, #1
 800634e:	d874      	bhi.n	800643a <cifXRunBootloader+0x1e6>
          lRet = cifXStartBootloader_netX100(ptDevInstance,
 8006350:	9a45      	ldr	r2, [sp, #276]	; 0x114
 8006352:	4631      	mov	r1, r6
 8006354:	4620      	mov	r0, r4
 8006356:	f003 f877 	bl	8009448 <cifXStartBootloader_netX100>
 800635a:	4680      	mov	r8, r0
        if(CIFX_NO_ERROR == lRet)
 800635c:	f1b8 0f00 	cmp.w	r8, #0
 8006360:	d1a7      	bne.n	80062b2 <cifXRunBootloader+0x5e>
 8006362:	4647      	mov	r7, r8
          for(ulIdx = 0; ulIdx < NET_BOOTLOADER_STARTUP_CYCLES; ++ulIdx)
 8006364:	2500      	movs	r5, #0
 8006366:	e01d      	b.n	80063a4 <cifXRunBootloader+0x150>
            USER_Trace(ptDevInstance,
 8006368:	4a3d      	ldr	r2, [pc, #244]	; (8006460 <cifXRunBootloader+0x20c>)
 800636a:	2101      	movs	r1, #1
 800636c:	4620      	mov	r0, r4
 800636e:	f003 f967 	bl	8009640 <USER_Trace>
 8006372:	e7e0      	b.n	8006336 <cifXRunBootloader+0xe2>
        switch(ptDevInstance->eChipType)
 8006374:	3b05      	subs	r3, #5
 8006376:	b2db      	uxtb	r3, r3
 8006378:	2b01      	cmp	r3, #1
 800637a:	d861      	bhi.n	8006440 <cifXRunBootloader+0x1ec>
          lRet = cifXStartBootloader_hboot(ptDevInstance,
 800637c:	9a45      	ldr	r2, [sp, #276]	; 0x114
 800637e:	4631      	mov	r1, r6
 8006380:	4620      	mov	r0, r4
 8006382:	f002 ff59 	bl	8009238 <cifXStartBootloader_hboot>
 8006386:	4680      	mov	r8, r0
          break;
 8006388:	e7e8      	b.n	800635c <cifXRunBootloader+0x108>
              ptDevInstance->pfnNotify(ptDevInstance, eCIFX_TOOLKIT_EVENT_POST_BOOTLOADER);
 800638a:	69a3      	ldr	r3, [r4, #24]
 800638c:	2103      	movs	r1, #3
 800638e:	4620      	mov	r0, r4
 8006390:	4798      	blx	r3
            if( (HWIF_READ32(ptDevInstance, *pulDpmStart) == HOST_TO_LE32(CIFX_DPM_INVALID_CONTENT))   ||
 8006392:	4639      	mov	r1, r7
 8006394:	4620      	mov	r0, r4
 8006396:	f7fe ffb0 	bl	80052fa <HwIfRead32>
 800639a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800639e:	d117      	bne.n	80063d0 <cifXRunBootloader+0x17c>
              lRet = CIFX_MEMORY_MAPPING_FAILED;
 80063a0:	4f30      	ldr	r7, [pc, #192]	; (8006464 <cifXRunBootloader+0x210>)
          for(ulIdx = 0; ulIdx < NET_BOOTLOADER_STARTUP_CYCLES; ++ulIdx)
 80063a2:	3501      	adds	r5, #1
 80063a4:	2d31      	cmp	r5, #49	; 0x31
 80063a6:	d838      	bhi.n	800641a <cifXRunBootloader+0x1c6>
            volatile uint32_t* pulDpmStart = (volatile uint32_t*)ptDevInstance->pbDPM;
 80063a8:	6a27      	ldr	r7, [r4, #32]
            OS_Sleep(NET_BOOTLOADER_STARTUP_WAIT);
 80063aa:	2064      	movs	r0, #100	; 0x64
 80063ac:	f7fc fbd6 	bl	8002b5c <OS_Sleep>
            if( ptDevInstance->pfnNotify && (0 == ulIdx))
 80063b0:	69a3      	ldr	r3, [r4, #24]
 80063b2:	2b00      	cmp	r3, #0
 80063b4:	d0ed      	beq.n	8006392 <cifXRunBootloader+0x13e>
 80063b6:	2d00      	cmp	r5, #0
 80063b8:	d1eb      	bne.n	8006392 <cifXRunBootloader+0x13e>
              if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 80063ba:	4a24      	ldr	r2, [pc, #144]	; (800644c <cifXRunBootloader+0x1f8>)
 80063bc:	6812      	ldr	r2, [r2, #0]
 80063be:	f012 0f01 	tst.w	r2, #1
 80063c2:	d0e2      	beq.n	800638a <cifXRunBootloader+0x136>
                USER_Trace(ptDevInstance,
 80063c4:	4a28      	ldr	r2, [pc, #160]	; (8006468 <cifXRunBootloader+0x214>)
 80063c6:	2101      	movs	r1, #1
 80063c8:	4620      	mov	r0, r4
 80063ca:	f003 f939 	bl	8009640 <USER_Trace>
 80063ce:	e7dc      	b.n	800638a <cifXRunBootloader+0x136>
                (HWIF_READ32(ptDevInstance, *pulDpmStart) == HOST_TO_LE32(CIFX_DPM_NO_MEMORY_ASSIGNED))  )
 80063d0:	4639      	mov	r1, r7
 80063d2:	4620      	mov	r0, r4
 80063d4:	f7fe ff91 	bl	80052fa <HwIfRead32>
            if( (HWIF_READ32(ptDevInstance, *pulDpmStart) == HOST_TO_LE32(CIFX_DPM_INVALID_CONTENT))   ||
 80063d8:	4b24      	ldr	r3, [pc, #144]	; (800646c <cifXRunBootloader+0x218>)
 80063da:	4298      	cmp	r0, r3
 80063dc:	d101      	bne.n	80063e2 <cifXRunBootloader+0x18e>
              lRet = CIFX_MEMORY_MAPPING_FAILED;
 80063de:	4f21      	ldr	r7, [pc, #132]	; (8006464 <cifXRunBootloader+0x210>)
 80063e0:	e7df      	b.n	80063a2 <cifXRunBootloader+0x14e>
              if( (HWIF_READ32(ptDevInstance, *pulDpmStart) != HOST_TO_LE32(CIFX_DPMSIGNATURE_BSL_VAL)) &&
 80063e2:	4639      	mov	r1, r7
 80063e4:	4620      	mov	r0, r4
 80063e6:	f7fe ff88 	bl	80052fa <HwIfRead32>
 80063ea:	4b21      	ldr	r3, [pc, #132]	; (8006470 <cifXRunBootloader+0x21c>)
 80063ec:	4298      	cmp	r0, r3
 80063ee:	d008      	beq.n	8006402 <cifXRunBootloader+0x1ae>
                  (HWIF_READ32(ptDevInstance, *pulDpmStart) != HOST_TO_LE32(CIFX_DPMSIGNATURE_FW_VAL)) )
 80063f0:	4639      	mov	r1, r7
 80063f2:	4620      	mov	r0, r4
 80063f4:	f7fe ff81 	bl	80052fa <HwIfRead32>
              if( (HWIF_READ32(ptDevInstance, *pulDpmStart) != HOST_TO_LE32(CIFX_DPMSIGNATURE_BSL_VAL)) &&
 80063f8:	4b1e      	ldr	r3, [pc, #120]	; (8006474 <cifXRunBootloader+0x220>)
 80063fa:	4298      	cmp	r0, r3
 80063fc:	d001      	beq.n	8006402 <cifXRunBootloader+0x1ae>
                lRet = CIFX_DRV_INIT_STATE_ERROR;
 80063fe:	4f1e      	ldr	r7, [pc, #120]	; (8006478 <cifXRunBootloader+0x224>)
 8006400:	e7cf      	b.n	80063a2 <cifXRunBootloader+0x14e>
                if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8006402:	4b12      	ldr	r3, [pc, #72]	; (800644c <cifXRunBootloader+0x1f8>)
 8006404:	681b      	ldr	r3, [r3, #0]
 8006406:	f013 0f01 	tst.w	r3, #1
 800640a:	f43f af52 	beq.w	80062b2 <cifXRunBootloader+0x5e>
                  USER_Trace(ptDevInstance,
 800640e:	4a1b      	ldr	r2, [pc, #108]	; (800647c <cifXRunBootloader+0x228>)
 8006410:	2101      	movs	r1, #1
 8006412:	4620      	mov	r0, r4
 8006414:	f003 f914 	bl	8009640 <USER_Trace>
          if(CIFX_NO_ERROR != lRet)
 8006418:	e74b      	b.n	80062b2 <cifXRunBootloader+0x5e>
 800641a:	b1a7      	cbz	r7, 8006446 <cifXRunBootloader+0x1f2>
            if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 800641c:	4b0b      	ldr	r3, [pc, #44]	; (800644c <cifXRunBootloader+0x1f8>)
 800641e:	681b      	ldr	r3, [r3, #0]
 8006420:	f013 0f08 	tst.w	r3, #8
 8006424:	d101      	bne.n	800642a <cifXRunBootloader+0x1d6>
 8006426:	46b8      	mov	r8, r7
 8006428:	e743      	b.n	80062b2 <cifXRunBootloader+0x5e>
              USER_Trace(ptDevInstance,
 800642a:	463b      	mov	r3, r7
 800642c:	4a14      	ldr	r2, [pc, #80]	; (8006480 <cifXRunBootloader+0x22c>)
 800642e:	2108      	movs	r1, #8
 8006430:	4620      	mov	r0, r4
 8006432:	f003 f905 	bl	8009640 <USER_Trace>
 8006436:	46b8      	mov	r8, r7
 8006438:	e73b      	b.n	80062b2 <cifXRunBootloader+0x5e>
        switch(ptDevInstance->eChipType)
 800643a:	f8df 803c 	ldr.w	r8, [pc, #60]	; 8006478 <cifXRunBootloader+0x224>
 800643e:	e738      	b.n	80062b2 <cifXRunBootloader+0x5e>
 8006440:	f8df 8034 	ldr.w	r8, [pc, #52]	; 8006478 <cifXRunBootloader+0x224>
 8006444:	e735      	b.n	80062b2 <cifXRunBootloader+0x5e>
 8006446:	46b8      	mov	r8, r7
 8006448:	e733      	b.n	80062b2 <cifXRunBootloader+0x5e>
 800644a:	bf00      	nop
 800644c:	20000038 	.word	0x20000038
 8006450:	0800b53c 	.word	0x0800b53c
 8006454:	0800b560 	.word	0x0800b560
 8006458:	0800b57c 	.word	0x0800b57c
 800645c:	0800b598 	.word	0x0800b598
 8006460:	0800b5bc 	.word	0x0800b5bc
 8006464:	800a0013 	.word	0x800a0013
 8006468:	0800b5fc 	.word	0x0800b5fc
 800646c:	0bad0bad 	.word	0x0bad0bad
 8006470:	544f4f42 	.word	0x544f4f42
 8006474:	5874656e 	.word	0x5874656e
 8006478:	800b0002 	.word	0x800b0002
 800647c:	0800b63c 	.word	0x0800b63c
 8006480:	0800b670 	.word	0x0800b670
 8006484:	800a000e 	.word	0x800a000e
 8006488:	800a000a 	.word	0x800a000a
 800648c:	800a000c 	.word	0x800a000c

08006490 <cifXHandleRAMBaseOSModule>:
{
 8006490:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006494:	b0e6      	sub	sp, #408	; 0x198
 8006496:	4604      	mov	r4, r0
  OS_Memset(&tDevInfo,  0, sizeof(tDevInfo));
 8006498:	2210      	movs	r2, #16
 800649a:	2100      	movs	r1, #0
 800649c:	a862      	add	r0, sp, #392	; 0x188
 800649e:	f7fc fb3e 	bl	8002b1e <OS_Memset>
  OS_Memset(&tFileInfo, 0, sizeof(tFileInfo));
 80064a2:	f44f 728a 	mov.w	r2, #276	; 0x114
 80064a6:	2100      	movs	r1, #0
 80064a8:	a81d      	add	r0, sp, #116	; 0x74
 80064aa:	f7fc fb38 	bl	8002b1e <OS_Memset>
  tDevInfo.ulDeviceNumber   = ptDevInstance->ulDeviceNumber;
 80064ae:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80064b0:	9362      	str	r3, [sp, #392]	; 0x188
  tDevInfo.ulSerialNumber   = ptDevInstance->ulSerialNumber;
 80064b2:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80064b4:	9363      	str	r3, [sp, #396]	; 0x18c
  tDevInfo.ulChannel        = CIFX_SYSTEM_DEVICE;
 80064b6:	f04f 33ff 	mov.w	r3, #4294967295
 80064ba:	9364      	str	r3, [sp, #400]	; 0x190
  tDevInfo.ptDeviceInstance = ptDevInstance;
 80064bc:	9465      	str	r4, [sp, #404]	; 0x194
  if( USER_GetOSFile(&tDevInfo, &tFileInfo))
 80064be:	a91d      	add	r1, sp, #116	; 0x74
 80064c0:	a862      	add	r0, sp, #392	; 0x188
 80064c2:	f003 f8ab 	bl	800961c <USER_GetOSFile>
 80064c6:	4605      	mov	r5, r0
 80064c8:	b340      	cbz	r0, 800651c <cifXHandleRAMBaseOSModule+0x8c>
    uint32_t    ulFileLength  = 0;
 80064ca:	2300      	movs	r3, #0
 80064cc:	9307      	str	r3, [sp, #28]
    CIFXHANDLE  hSysDevice    = (CIFXHANDLE)&ptDevInstance->tSystemDevice;
 80064ce:	f104 07f4 	add.w	r7, r4, #244	; 0xf4
    if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 80064d2:	4b6b      	ldr	r3, [pc, #428]	; (8006680 <cifXHandleRAMBaseOSModule+0x1f0>)
 80064d4:	681b      	ldr	r3, [r3, #0]
 80064d6:	f013 0f01 	tst.w	r3, #1
 80064da:	d123      	bne.n	8006524 <cifXHandleRAMBaseOSModule+0x94>
    if(NULL == (pvFile  = OS_FileOpen(tFileInfo.szFullFileName, &ulFileLength)))
 80064dc:	a907      	add	r1, sp, #28
 80064de:	a821      	add	r0, sp, #132	; 0x84
 80064e0:	f7fc fb32 	bl	8002b48 <OS_FileOpen>
 80064e4:	4606      	mov	r6, r0
 80064e6:	b320      	cbz	r0, 8006532 <cifXHandleRAMBaseOSModule+0xa2>
      void* pbBuffer = OS_Memalloc(ulFileLength);
 80064e8:	9807      	ldr	r0, [sp, #28]
 80064ea:	f7fc fb0c 	bl	8002b06 <OS_Memalloc>
      if (NULL == pbBuffer)
 80064ee:	4680      	mov	r8, r0
 80064f0:	b370      	cbz	r0, 8006550 <cifXHandleRAMBaseOSModule+0xc0>
        if(ulFileLength != OS_FileRead(pvFile, 0, ulFileLength, pbBuffer))
 80064f2:	4603      	mov	r3, r0
 80064f4:	9a07      	ldr	r2, [sp, #28]
 80064f6:	2100      	movs	r1, #0
 80064f8:	4630      	mov	r0, r6
 80064fa:	f7fc fb27 	bl	8002b4c <OS_FileRead>
 80064fe:	9b07      	ldr	r3, [sp, #28]
 8006500:	4298      	cmp	r0, r3
 8006502:	d03b      	beq.n	800657c <cifXHandleRAMBaseOSModule+0xec>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006504:	4b5e      	ldr	r3, [pc, #376]	; (8006680 <cifXHandleRAMBaseOSModule+0x1f0>)
 8006506:	681b      	ldr	r3, [r3, #0]
 8006508:	f013 0f08 	tst.w	r3, #8
 800650c:	d12e      	bne.n	800656c <cifXHandleRAMBaseOSModule+0xdc>
          lRet = CIFX_FILE_READ_ERROR;
 800650e:	4d5d      	ldr	r5, [pc, #372]	; (8006684 <cifXHandleRAMBaseOSModule+0x1f4>)
        OS_Memfree(pbBuffer);
 8006510:	4640      	mov	r0, r8
 8006512:	f7fc fafc 	bl	8002b0e <OS_Memfree>
      OS_FileClose(pvFile);
 8006516:	4630      	mov	r0, r6
 8006518:	f7fc fb1a 	bl	8002b50 <OS_FileClose>
}
 800651c:	4628      	mov	r0, r5
 800651e:	b066      	add	sp, #408	; 0x198
 8006520:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      USER_Trace( ptDevInstance,
 8006524:	ab1d      	add	r3, sp, #116	; 0x74
 8006526:	4a58      	ldr	r2, [pc, #352]	; (8006688 <cifXHandleRAMBaseOSModule+0x1f8>)
 8006528:	2104      	movs	r1, #4
 800652a:	4620      	mov	r0, r4
 800652c:	f003 f888 	bl	8009640 <USER_Trace>
 8006530:	e7d4      	b.n	80064dc <cifXHandleRAMBaseOSModule+0x4c>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006532:	4b53      	ldr	r3, [pc, #332]	; (8006680 <cifXHandleRAMBaseOSModule+0x1f0>)
 8006534:	681b      	ldr	r3, [r3, #0]
 8006536:	f013 0f08 	tst.w	r3, #8
 800653a:	d101      	bne.n	8006540 <cifXHandleRAMBaseOSModule+0xb0>
      lRet = CIFX_FILE_OPEN_FAILED;
 800653c:	4d53      	ldr	r5, [pc, #332]	; (800668c <cifXHandleRAMBaseOSModule+0x1fc>)
  return lRet;
 800653e:	e7ed      	b.n	800651c <cifXHandleRAMBaseOSModule+0x8c>
        USER_Trace( ptDevInstance,
 8006540:	ab21      	add	r3, sp, #132	; 0x84
 8006542:	4a53      	ldr	r2, [pc, #332]	; (8006690 <cifXHandleRAMBaseOSModule+0x200>)
 8006544:	2108      	movs	r1, #8
 8006546:	4620      	mov	r0, r4
 8006548:	f003 f87a 	bl	8009640 <USER_Trace>
      lRet = CIFX_FILE_OPEN_FAILED;
 800654c:	4d4f      	ldr	r5, [pc, #316]	; (800668c <cifXHandleRAMBaseOSModule+0x1fc>)
 800654e:	e7e5      	b.n	800651c <cifXHandleRAMBaseOSModule+0x8c>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006550:	4b4b      	ldr	r3, [pc, #300]	; (8006680 <cifXHandleRAMBaseOSModule+0x1f0>)
 8006552:	681b      	ldr	r3, [r3, #0]
 8006554:	f013 0f08 	tst.w	r3, #8
 8006558:	d101      	bne.n	800655e <cifXHandleRAMBaseOSModule+0xce>
        lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 800655a:	4d4e      	ldr	r5, [pc, #312]	; (8006694 <cifXHandleRAMBaseOSModule+0x204>)
 800655c:	e7db      	b.n	8006516 <cifXHandleRAMBaseOSModule+0x86>
          USER_Trace(ptDevInstance,
 800655e:	4a4e      	ldr	r2, [pc, #312]	; (8006698 <cifXHandleRAMBaseOSModule+0x208>)
 8006560:	2108      	movs	r1, #8
 8006562:	4620      	mov	r0, r4
 8006564:	f003 f86c 	bl	8009640 <USER_Trace>
        lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 8006568:	4d4a      	ldr	r5, [pc, #296]	; (8006694 <cifXHandleRAMBaseOSModule+0x204>)
 800656a:	e7d4      	b.n	8006516 <cifXHandleRAMBaseOSModule+0x86>
            USER_Trace( ptDevInstance,
 800656c:	ab21      	add	r3, sp, #132	; 0x84
 800656e:	4a4b      	ldr	r2, [pc, #300]	; (800669c <cifXHandleRAMBaseOSModule+0x20c>)
 8006570:	2108      	movs	r1, #8
 8006572:	4620      	mov	r0, r4
 8006574:	f003 f864 	bl	8009640 <USER_Trace>
          lRet = CIFX_FILE_READ_ERROR;
 8006578:	4d42      	ldr	r5, [pc, #264]	; (8006684 <cifXHandleRAMBaseOSModule+0x1f4>)
 800657a:	e7c9      	b.n	8006510 <cifXHandleRAMBaseOSModule+0x80>
        } else if(CIFX_NO_ERROR != (lRet = xSysdeviceDownload(hSysDevice,
 800657c:	2100      	movs	r1, #0
 800657e:	9104      	str	r1, [sp, #16]
 8006580:	9103      	str	r1, [sp, #12]
 8006582:	9102      	str	r1, [sp, #8]
 8006584:	9301      	str	r3, [sp, #4]
 8006586:	f8cd 8000 	str.w	r8, [sp]
 800658a:	ab1d      	add	r3, sp, #116	; 0x74
 800658c:	2201      	movs	r2, #1
 800658e:	4638      	mov	r0, r7
 8006590:	f7fe f8bc 	bl	800470c <xSysdeviceDownload>
 8006594:	4605      	mov	r5, r0
 8006596:	b160      	cbz	r0, 80065b2 <cifXHandleRAMBaseOSModule+0x122>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006598:	4b39      	ldr	r3, [pc, #228]	; (8006680 <cifXHandleRAMBaseOSModule+0x1f0>)
 800659a:	681b      	ldr	r3, [r3, #0]
 800659c:	f013 0f08 	tst.w	r3, #8
 80065a0:	d0b6      	beq.n	8006510 <cifXHandleRAMBaseOSModule+0x80>
            USER_Trace( ptDevInstance,
 80065a2:	9000      	str	r0, [sp, #0]
 80065a4:	ab21      	add	r3, sp, #132	; 0x84
 80065a6:	4a3e      	ldr	r2, [pc, #248]	; (80066a0 <cifXHandleRAMBaseOSModule+0x210>)
 80065a8:	2108      	movs	r1, #8
 80065aa:	4620      	mov	r0, r4
 80065ac:	f003 f848 	bl	8009640 <USER_Trace>
 80065b0:	e7ae      	b.n	8006510 <cifXHandleRAMBaseOSModule+0x80>
          OS_Memset(&tSendPkt, 0, sizeof(tSendPkt));
 80065b2:	222c      	movs	r2, #44	; 0x2c
 80065b4:	2100      	movs	r1, #0
 80065b6:	a812      	add	r0, sp, #72	; 0x48
 80065b8:	f7fc fab1 	bl	8002b1e <OS_Memset>
          OS_Memset(&tRecvPkt, 0, sizeof(tRecvPkt));
 80065bc:	2228      	movs	r2, #40	; 0x28
 80065be:	2100      	movs	r1, #0
 80065c0:	a808      	add	r0, sp, #32
 80065c2:	f7fc faac 	bl	8002b1e <OS_Memset>
          if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 80065c6:	4b2e      	ldr	r3, [pc, #184]	; (8006680 <cifXHandleRAMBaseOSModule+0x1f0>)
 80065c8:	681b      	ldr	r3, [r3, #0]
 80065ca:	f013 0f01 	tst.w	r3, #1
 80065ce:	d124      	bne.n	800661a <cifXHandleRAMBaseOSModule+0x18a>
          tSendPkt.tHead.ulDest      = HOST_TO_LE32(HIL_PACKET_DEST_SYSTEM);
 80065d0:	2300      	movs	r3, #0
 80065d2:	9312      	str	r3, [sp, #72]	; 0x48
          tSendPkt.tHead.ulLen       = HOST_TO_LE32(sizeof(HIL_CHANNEL_INSTANTIATE_REQ_DATA_T));
 80065d4:	2204      	movs	r2, #4
 80065d6:	9216      	str	r2, [sp, #88]	; 0x58
          tSendPkt.tHead.ulCmd       = HOST_TO_LE32(HIL_CHANNEL_INSTANTIATE_REQ);
 80065d8:	f641 62c4 	movw	r2, #7876	; 0x1ec4
 80065dc:	9219      	str	r2, [sp, #100]	; 0x64
          tSendPkt.tData.ulChannelNo = HOST_TO_LE32(CIFX_SYSTEM_DEVICE);
 80065de:	f04f 32ff 	mov.w	r2, #4294967295
 80065e2:	921c      	str	r2, [sp, #112]	; 0x70
          lRet = DEV_TransferPacket( &ptDevInstance->tSystemDevice,
 80065e4:	9302      	str	r3, [sp, #8]
 80065e6:	9301      	str	r3, [sp, #4]
 80065e8:	f241 3388 	movw	r3, #5000	; 0x1388
 80065ec:	9300      	str	r3, [sp, #0]
 80065ee:	2328      	movs	r3, #40	; 0x28
 80065f0:	aa08      	add	r2, sp, #32
 80065f2:	a912      	add	r1, sp, #72	; 0x48
 80065f4:	4638      	mov	r0, r7
 80065f6:	f7ff f9bf 	bl	8005978 <DEV_TransferPacket>
          if( (CIFX_NO_ERROR  != lRet) ||
 80065fa:	4605      	mov	r5, r0
 80065fc:	b908      	cbnz	r0, 8006602 <cifXHandleRAMBaseOSModule+0x172>
              (SUCCESS_HIL_OK != (lRet = LE32_TO_HOST(tRecvPkt.tHead.ulSta))) )
 80065fe:	9d0e      	ldr	r5, [sp, #56]	; 0x38
          if( (CIFX_NO_ERROR  != lRet) ||
 8006600:	b195      	cbz	r5, 8006628 <cifXHandleRAMBaseOSModule+0x198>
            if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006602:	4b1f      	ldr	r3, [pc, #124]	; (8006680 <cifXHandleRAMBaseOSModule+0x1f0>)
 8006604:	681b      	ldr	r3, [r3, #0]
 8006606:	f013 0f08 	tst.w	r3, #8
 800660a:	d081      	beq.n	8006510 <cifXHandleRAMBaseOSModule+0x80>
              USER_Trace(ptDevInstance,
 800660c:	462b      	mov	r3, r5
 800660e:	4a25      	ldr	r2, [pc, #148]	; (80066a4 <cifXHandleRAMBaseOSModule+0x214>)
 8006610:	2108      	movs	r1, #8
 8006612:	4620      	mov	r0, r4
 8006614:	f003 f814 	bl	8009640 <USER_Trace>
 8006618:	e77a      	b.n	8006510 <cifXHandleRAMBaseOSModule+0x80>
            USER_Trace( ptDevInstance,
 800661a:	ab21      	add	r3, sp, #132	; 0x84
 800661c:	4a22      	ldr	r2, [pc, #136]	; (80066a8 <cifXHandleRAMBaseOSModule+0x218>)
 800661e:	2101      	movs	r1, #1
 8006620:	4620      	mov	r0, r4
 8006622:	f003 f80d 	bl	8009640 <USER_Trace>
 8006626:	e7d3      	b.n	80065d0 <cifXHandleRAMBaseOSModule+0x140>
            if (!DEV_WaitForNotReady_Poll( &ptDevInstance->tSystemDevice, CIFX_TO_FIRMWARE_START))
 8006628:	f644 6120 	movw	r1, #20000	; 0x4e20
 800662c:	4638      	mov	r0, r7
 800662e:	f7ff f9df 	bl	80059f0 <DEV_WaitForNotReady_Poll>
 8006632:	b970      	cbnz	r0, 8006652 <cifXHandleRAMBaseOSModule+0x1c2>
              if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006634:	4b12      	ldr	r3, [pc, #72]	; (8006680 <cifXHandleRAMBaseOSModule+0x1f0>)
 8006636:	681b      	ldr	r3, [r3, #0]
 8006638:	f013 0f08 	tst.w	r3, #8
 800663c:	d101      	bne.n	8006642 <cifXHandleRAMBaseOSModule+0x1b2>
              lRet = CIFX_DEV_RESET_TIMEOUT;
 800663e:	4d1b      	ldr	r5, [pc, #108]	; (80066ac <cifXHandleRAMBaseOSModule+0x21c>)
 8006640:	e766      	b.n	8006510 <cifXHandleRAMBaseOSModule+0x80>
                USER_Trace(ptDevInstance,
 8006642:	4d1a      	ldr	r5, [pc, #104]	; (80066ac <cifXHandleRAMBaseOSModule+0x21c>)
 8006644:	462b      	mov	r3, r5
 8006646:	4a1a      	ldr	r2, [pc, #104]	; (80066b0 <cifXHandleRAMBaseOSModule+0x220>)
 8006648:	2108      	movs	r1, #8
 800664a:	4620      	mov	r0, r4
 800664c:	f002 fff8 	bl	8009640 <USER_Trace>
 8006650:	e75e      	b.n	8006510 <cifXHandleRAMBaseOSModule+0x80>
              if (!DEV_WaitForReady_Poll( &ptDevInstance->tSystemDevice, CIFX_TO_FIRMWARE_START))
 8006652:	f644 6120 	movw	r1, #20000	; 0x4e20
 8006656:	4638      	mov	r0, r7
 8006658:	f7ff fa7a 	bl	8005b50 <DEV_WaitForReady_Poll>
 800665c:	2800      	cmp	r0, #0
 800665e:	f47f af57 	bne.w	8006510 <cifXHandleRAMBaseOSModule+0x80>
                if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006662:	4b07      	ldr	r3, [pc, #28]	; (8006680 <cifXHandleRAMBaseOSModule+0x1f0>)
 8006664:	681b      	ldr	r3, [r3, #0]
 8006666:	f013 0f08 	tst.w	r3, #8
 800666a:	d101      	bne.n	8006670 <cifXHandleRAMBaseOSModule+0x1e0>
                lRet = CIFX_DEV_NOT_READY;
 800666c:	4d11      	ldr	r5, [pc, #68]	; (80066b4 <cifXHandleRAMBaseOSModule+0x224>)
 800666e:	e74f      	b.n	8006510 <cifXHandleRAMBaseOSModule+0x80>
                  USER_Trace(ptDevInstance,
 8006670:	4d10      	ldr	r5, [pc, #64]	; (80066b4 <cifXHandleRAMBaseOSModule+0x224>)
 8006672:	462b      	mov	r3, r5
 8006674:	4a10      	ldr	r2, [pc, #64]	; (80066b8 <cifXHandleRAMBaseOSModule+0x228>)
 8006676:	2108      	movs	r1, #8
 8006678:	4620      	mov	r0, r4
 800667a:	f002 ffe1 	bl	8009640 <USER_Trace>
 800667e:	e747      	b.n	8006510 <cifXHandleRAMBaseOSModule+0x80>
 8006680:	20000038 	.word	0x20000038
 8006684:	800a000e 	.word	0x800a000e
 8006688:	0800b6ac 	.word	0x0800b6ac
 800668c:	800a000a 	.word	0x800a000a
 8006690:	0800b6e8 	.word	0x0800b6e8
 8006694:	800a000c 	.word	0x800a000c
 8006698:	0800b57c 	.word	0x0800b57c
 800669c:	0800b704 	.word	0x0800b704
 80066a0:	0800b72c 	.word	0x0800b72c
 80066a4:	0800b794 	.word	0x0800b794
 80066a8:	0800b768 	.word	0x0800b768
 80066ac:	800c0020 	.word	0x800c0020
 80066b0:	0800b7d0 	.word	0x0800b7d0
 80066b4:	800c0011 	.word	0x800c0011
 80066b8:	0800b810 	.word	0x0800b810

080066bc <cifXHandleFlashBaseOSModule>:
{
 80066bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80066c0:	b0d2      	sub	sp, #328	; 0x148
 80066c2:	4604      	mov	r4, r0
  OS_Memset(&tDevInfo,  0, sizeof(tDevInfo));
 80066c4:	2210      	movs	r2, #16
 80066c6:	2100      	movs	r1, #0
 80066c8:	a84e      	add	r0, sp, #312	; 0x138
 80066ca:	f7fc fa28 	bl	8002b1e <OS_Memset>
  OS_Memset(&tFileInfo, 0, sizeof(tFileInfo));
 80066ce:	f44f 728a 	mov.w	r2, #276	; 0x114
 80066d2:	2100      	movs	r1, #0
 80066d4:	a809      	add	r0, sp, #36	; 0x24
 80066d6:	f7fc fa22 	bl	8002b1e <OS_Memset>
  tDevInfo.ulDeviceNumber   = ptDevInstance->ulDeviceNumber;
 80066da:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80066dc:	934e      	str	r3, [sp, #312]	; 0x138
  tDevInfo.ulSerialNumber   = ptDevInstance->ulSerialNumber;
 80066de:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80066e0:	934f      	str	r3, [sp, #316]	; 0x13c
  tDevInfo.ulChannel        = CIFX_SYSTEM_DEVICE;
 80066e2:	f04f 33ff 	mov.w	r3, #4294967295
 80066e6:	9350      	str	r3, [sp, #320]	; 0x140
  tDevInfo.ptDeviceInstance = ptDevInstance;
 80066e8:	9451      	str	r4, [sp, #324]	; 0x144
  if(USER_GetOSFile(&tDevInfo, &tFileInfo))
 80066ea:	a909      	add	r1, sp, #36	; 0x24
 80066ec:	a84e      	add	r0, sp, #312	; 0x138
 80066ee:	f002 ff95 	bl	800961c <USER_GetOSFile>
 80066f2:	4605      	mov	r5, r0
 80066f4:	b340      	cbz	r0, 8006748 <cifXHandleFlashBaseOSModule+0x8c>
    uint32_t  ulFileLength  = 0;
 80066f6:	2300      	movs	r3, #0
 80066f8:	9307      	str	r3, [sp, #28]
    CIFXHANDLE hSysDevice = (CIFXHANDLE)&ptDevInstance->tSystemDevice;
 80066fa:	f104 07f4 	add.w	r7, r4, #244	; 0xf4
    if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 80066fe:	4b66      	ldr	r3, [pc, #408]	; (8006898 <cifXHandleFlashBaseOSModule+0x1dc>)
 8006700:	681b      	ldr	r3, [r3, #0]
 8006702:	f013 0f01 	tst.w	r3, #1
 8006706:	d123      	bne.n	8006750 <cifXHandleFlashBaseOSModule+0x94>
    if(NULL == (pvFile = OS_FileOpen( tFileInfo.szFullFileName, &ulFileLength)))
 8006708:	a907      	add	r1, sp, #28
 800670a:	a80d      	add	r0, sp, #52	; 0x34
 800670c:	f7fc fa1c 	bl	8002b48 <OS_FileOpen>
 8006710:	4606      	mov	r6, r0
 8006712:	b320      	cbz	r0, 800675e <cifXHandleFlashBaseOSModule+0xa2>
      uint8_t* pbBuffer = (uint8_t*)OS_Memalloc(ulFileLength);
 8006714:	9807      	ldr	r0, [sp, #28]
 8006716:	f7fc f9f6 	bl	8002b06 <OS_Memalloc>
      if (NULL == pbBuffer)
 800671a:	4680      	mov	r8, r0
 800671c:	b370      	cbz	r0, 800677c <cifXHandleFlashBaseOSModule+0xc0>
        if(ulFileLength != OS_FileRead(pvFile, 0, ulFileLength, pbBuffer))
 800671e:	4603      	mov	r3, r0
 8006720:	9a07      	ldr	r2, [sp, #28]
 8006722:	2100      	movs	r1, #0
 8006724:	4630      	mov	r0, r6
 8006726:	f7fc fa11 	bl	8002b4c <OS_FileRead>
 800672a:	9b07      	ldr	r3, [sp, #28]
 800672c:	4298      	cmp	r0, r3
 800672e:	d03b      	beq.n	80067a8 <cifXHandleFlashBaseOSModule+0xec>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006730:	4b59      	ldr	r3, [pc, #356]	; (8006898 <cifXHandleFlashBaseOSModule+0x1dc>)
 8006732:	681b      	ldr	r3, [r3, #0]
 8006734:	f013 0f08 	tst.w	r3, #8
 8006738:	d12e      	bne.n	8006798 <cifXHandleFlashBaseOSModule+0xdc>
          lRet = CIFX_FILE_READ_ERROR;
 800673a:	4d58      	ldr	r5, [pc, #352]	; (800689c <cifXHandleFlashBaseOSModule+0x1e0>)
        OS_Memfree(pbBuffer);
 800673c:	4640      	mov	r0, r8
 800673e:	f7fc f9e6 	bl	8002b0e <OS_Memfree>
      OS_FileClose(pvFile);
 8006742:	4630      	mov	r0, r6
 8006744:	f7fc fa04 	bl	8002b50 <OS_FileClose>
}
 8006748:	4628      	mov	r0, r5
 800674a:	b052      	add	sp, #328	; 0x148
 800674c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      USER_Trace(ptDevInstance,
 8006750:	ab09      	add	r3, sp, #36	; 0x24
 8006752:	4a53      	ldr	r2, [pc, #332]	; (80068a0 <cifXHandleFlashBaseOSModule+0x1e4>)
 8006754:	2104      	movs	r1, #4
 8006756:	4620      	mov	r0, r4
 8006758:	f002 ff72 	bl	8009640 <USER_Trace>
 800675c:	e7d4      	b.n	8006708 <cifXHandleFlashBaseOSModule+0x4c>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 800675e:	4b4e      	ldr	r3, [pc, #312]	; (8006898 <cifXHandleFlashBaseOSModule+0x1dc>)
 8006760:	681b      	ldr	r3, [r3, #0]
 8006762:	f013 0f08 	tst.w	r3, #8
 8006766:	d101      	bne.n	800676c <cifXHandleFlashBaseOSModule+0xb0>
      lRet = CIFX_FILE_OPEN_FAILED;
 8006768:	4d4e      	ldr	r5, [pc, #312]	; (80068a4 <cifXHandleFlashBaseOSModule+0x1e8>)
  return lRet;
 800676a:	e7ed      	b.n	8006748 <cifXHandleFlashBaseOSModule+0x8c>
        USER_Trace(ptDevInstance,
 800676c:	ab0d      	add	r3, sp, #52	; 0x34
 800676e:	4a4e      	ldr	r2, [pc, #312]	; (80068a8 <cifXHandleFlashBaseOSModule+0x1ec>)
 8006770:	2108      	movs	r1, #8
 8006772:	4620      	mov	r0, r4
 8006774:	f002 ff64 	bl	8009640 <USER_Trace>
      lRet = CIFX_FILE_OPEN_FAILED;
 8006778:	4d4a      	ldr	r5, [pc, #296]	; (80068a4 <cifXHandleFlashBaseOSModule+0x1e8>)
 800677a:	e7e5      	b.n	8006748 <cifXHandleFlashBaseOSModule+0x8c>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 800677c:	4b46      	ldr	r3, [pc, #280]	; (8006898 <cifXHandleFlashBaseOSModule+0x1dc>)
 800677e:	681b      	ldr	r3, [r3, #0]
 8006780:	f013 0f08 	tst.w	r3, #8
 8006784:	d101      	bne.n	800678a <cifXHandleFlashBaseOSModule+0xce>
        lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 8006786:	4d49      	ldr	r5, [pc, #292]	; (80068ac <cifXHandleFlashBaseOSModule+0x1f0>)
 8006788:	e7db      	b.n	8006742 <cifXHandleFlashBaseOSModule+0x86>
          USER_Trace(ptDevInstance,
 800678a:	4a49      	ldr	r2, [pc, #292]	; (80068b0 <cifXHandleFlashBaseOSModule+0x1f4>)
 800678c:	2108      	movs	r1, #8
 800678e:	4620      	mov	r0, r4
 8006790:	f002 ff56 	bl	8009640 <USER_Trace>
        lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 8006794:	4d45      	ldr	r5, [pc, #276]	; (80068ac <cifXHandleFlashBaseOSModule+0x1f0>)
 8006796:	e7d4      	b.n	8006742 <cifXHandleFlashBaseOSModule+0x86>
            USER_Trace( ptDevInstance,
 8006798:	ab0d      	add	r3, sp, #52	; 0x34
 800679a:	4a46      	ldr	r2, [pc, #280]	; (80068b4 <cifXHandleFlashBaseOSModule+0x1f8>)
 800679c:	2108      	movs	r1, #8
 800679e:	4620      	mov	r0, r4
 80067a0:	f002 ff4e 	bl	8009640 <USER_Trace>
          lRet = CIFX_FILE_READ_ERROR;
 80067a4:	4d3d      	ldr	r5, [pc, #244]	; (800689c <cifXHandleFlashBaseOSModule+0x1e0>)
 80067a6:	e7c9      	b.n	800673c <cifXHandleFlashBaseOSModule+0x80>
          int fDownload = 0;
 80067a8:	2100      	movs	r1, #0
 80067aa:	9108      	str	r1, [sp, #32]
          if ( CIFX_NO_ERROR != (lRet = DEV_CheckForDownload( hSysDevice,
 80067ac:	9104      	str	r1, [sp, #16]
 80067ae:	9103      	str	r1, [sp, #12]
 80067b0:	4a41      	ldr	r2, [pc, #260]	; (80068b8 <cifXHandleFlashBaseOSModule+0x1fc>)
 80067b2:	9202      	str	r2, [sp, #8]
 80067b4:	9301      	str	r3, [sp, #4]
 80067b6:	f8cd 8000 	str.w	r8, [sp]
 80067ba:	ab09      	add	r3, sp, #36	; 0x24
 80067bc:	aa08      	add	r2, sp, #32
 80067be:	4638      	mov	r0, r7
 80067c0:	f7fd fb7c 	bl	8003ebc <DEV_CheckForDownload>
 80067c4:	4605      	mov	r5, r0
 80067c6:	b158      	cbz	r0, 80067e0 <cifXHandleFlashBaseOSModule+0x124>
            if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80067c8:	4b33      	ldr	r3, [pc, #204]	; (8006898 <cifXHandleFlashBaseOSModule+0x1dc>)
 80067ca:	681b      	ldr	r3, [r3, #0]
 80067cc:	f013 0f08 	tst.w	r3, #8
 80067d0:	d0b4      	beq.n	800673c <cifXHandleFlashBaseOSModule+0x80>
              USER_Trace( ptDevInstance,
 80067d2:	ab0d      	add	r3, sp, #52	; 0x34
 80067d4:	4a39      	ldr	r2, [pc, #228]	; (80068bc <cifXHandleFlashBaseOSModule+0x200>)
 80067d6:	2108      	movs	r1, #8
 80067d8:	4620      	mov	r0, r4
 80067da:	f002 ff31 	bl	8009640 <USER_Trace>
 80067de:	e7ad      	b.n	800673c <cifXHandleFlashBaseOSModule+0x80>
          } else if (!fDownload)
 80067e0:	9b08      	ldr	r3, [sp, #32]
 80067e2:	2b00      	cmp	r3, #0
 80067e4:	d133      	bne.n	800684e <cifXHandleFlashBaseOSModule+0x192>
            if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 80067e6:	4b2c      	ldr	r3, [pc, #176]	; (8006898 <cifXHandleFlashBaseOSModule+0x1dc>)
 80067e8:	681b      	ldr	r3, [r3, #0]
 80067ea:	f013 0f01 	tst.w	r3, #1
 80067ee:	d0a5      	beq.n	800673c <cifXHandleFlashBaseOSModule+0x80>
              USER_Trace( ptDevInstance,
 80067f0:	ab0d      	add	r3, sp, #52	; 0x34
 80067f2:	4a33      	ldr	r2, [pc, #204]	; (80068c0 <cifXHandleFlashBaseOSModule+0x204>)
 80067f4:	2101      	movs	r1, #1
 80067f6:	4620      	mov	r0, r4
 80067f8:	f002 ff22 	bl	8009640 <USER_Trace>
 80067fc:	e79e      	b.n	800673c <cifXHandleFlashBaseOSModule+0x80>
              (void)DEV_RemoveChannelFiles( (PCHANNELINSTANCE)hSysDevice, ulChNum, DEV_TransferPacket, NULL, NULL, NULL);
 80067fe:	2300      	movs	r3, #0
 8006800:	9301      	str	r3, [sp, #4]
 8006802:	9300      	str	r3, [sp, #0]
 8006804:	4a2c      	ldr	r2, [pc, #176]	; (80068b8 <cifXHandleFlashBaseOSModule+0x1fc>)
 8006806:	4629      	mov	r1, r5
 8006808:	4638      	mov	r0, r7
 800680a:	f7fd fa97 	bl	8003d3c <DEV_RemoveChannelFiles>
            for ( ulChNum = 0; ulChNum < CIFX_MAX_NUMBER_OF_CHANNELS; ulChNum++)
 800680e:	3501      	adds	r5, #1
 8006810:	2d05      	cmp	r5, #5
 8006812:	d9f4      	bls.n	80067fe <cifXHandleFlashBaseOSModule+0x142>
            lRet = xSysdeviceDownload(hSysDevice,
 8006814:	2100      	movs	r1, #0
 8006816:	9104      	str	r1, [sp, #16]
 8006818:	9103      	str	r1, [sp, #12]
 800681a:	9102      	str	r1, [sp, #8]
 800681c:	9b07      	ldr	r3, [sp, #28]
 800681e:	9301      	str	r3, [sp, #4]
 8006820:	f8cd 8000 	str.w	r8, [sp]
 8006824:	ab09      	add	r3, sp, #36	; 0x24
 8006826:	2201      	movs	r2, #1
 8006828:	4638      	mov	r0, r7
 800682a:	f7fd ff6f 	bl	800470c <xSysdeviceDownload>
            if(CIFX_NO_ERROR != lRet)
 800682e:	4605      	mov	r5, r0
 8006830:	b178      	cbz	r0, 8006852 <cifXHandleFlashBaseOSModule+0x196>
              if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006832:	4b19      	ldr	r3, [pc, #100]	; (8006898 <cifXHandleFlashBaseOSModule+0x1dc>)
 8006834:	681b      	ldr	r3, [r3, #0]
 8006836:	f013 0f08 	tst.w	r3, #8
 800683a:	f43f af7f 	beq.w	800673c <cifXHandleFlashBaseOSModule+0x80>
                USER_Trace( ptDevInstance,
 800683e:	9000      	str	r0, [sp, #0]
 8006840:	ab0d      	add	r3, sp, #52	; 0x34
 8006842:	4a20      	ldr	r2, [pc, #128]	; (80068c4 <cifXHandleFlashBaseOSModule+0x208>)
 8006844:	2108      	movs	r1, #8
 8006846:	4620      	mov	r0, r4
 8006848:	f002 fefa 	bl	8009640 <USER_Trace>
 800684c:	e776      	b.n	800673c <cifXHandleFlashBaseOSModule+0x80>
            for ( ulChNum = 0; ulChNum < CIFX_MAX_NUMBER_OF_CHANNELS; ulChNum++)
 800684e:	2500      	movs	r5, #0
 8006850:	e7de      	b.n	8006810 <cifXHandleFlashBaseOSModule+0x154>
              if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8006852:	4b11      	ldr	r3, [pc, #68]	; (8006898 <cifXHandleFlashBaseOSModule+0x1dc>)
 8006854:	681b      	ldr	r3, [r3, #0]
 8006856:	f013 0f01 	tst.w	r3, #1
 800685a:	d116      	bne.n	800688a <cifXHandleFlashBaseOSModule+0x1ce>
              if ( CIFX_NO_ERROR != (lRet = DEV_DoSystemStart( &ptDevInstance->tSystemDevice, CIFX_TO_FIRMWARE_START, 0)))
 800685c:	2200      	movs	r2, #0
 800685e:	f644 6120 	movw	r1, #20000	; 0x4e20
 8006862:	4638      	mov	r0, r7
 8006864:	f7ff fb1a 	bl	8005e9c <DEV_DoSystemStart>
 8006868:	4605      	mov	r5, r0
 800686a:	2800      	cmp	r0, #0
 800686c:	f43f af66 	beq.w	800673c <cifXHandleFlashBaseOSModule+0x80>
                if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006870:	4b09      	ldr	r3, [pc, #36]	; (8006898 <cifXHandleFlashBaseOSModule+0x1dc>)
 8006872:	681b      	ldr	r3, [r3, #0]
 8006874:	f013 0f08 	tst.w	r3, #8
 8006878:	f43f af60 	beq.w	800673c <cifXHandleFlashBaseOSModule+0x80>
                  USER_Trace(ptDevInstance,
 800687c:	4603      	mov	r3, r0
 800687e:	4a12      	ldr	r2, [pc, #72]	; (80068c8 <cifXHandleFlashBaseOSModule+0x20c>)
 8006880:	2108      	movs	r1, #8
 8006882:	4620      	mov	r0, r4
 8006884:	f002 fedc 	bl	8009640 <USER_Trace>
 8006888:	e758      	b.n	800673c <cifXHandleFlashBaseOSModule+0x80>
                USER_Trace( ptDevInstance,
 800688a:	ab0d      	add	r3, sp, #52	; 0x34
 800688c:	4a0f      	ldr	r2, [pc, #60]	; (80068cc <cifXHandleFlashBaseOSModule+0x210>)
 800688e:	2101      	movs	r1, #1
 8006890:	4620      	mov	r0, r4
 8006892:	f002 fed5 	bl	8009640 <USER_Trace>
 8006896:	e7e1      	b.n	800685c <cifXHandleFlashBaseOSModule+0x1a0>
 8006898:	20000038 	.word	0x20000038
 800689c:	800a000e 	.word	0x800a000e
 80068a0:	0800b6ac 	.word	0x0800b6ac
 80068a4:	800a000a 	.word	0x800a000a
 80068a8:	0800b6e8 	.word	0x0800b6e8
 80068ac:	800a000c 	.word	0x800a000c
 80068b0:	0800b57c 	.word	0x0800b57c
 80068b4:	0800b704 	.word	0x0800b704
 80068b8:	08005979 	.word	0x08005979
 80068bc:	0800ae78 	.word	0x0800ae78
 80068c0:	0800ae9c 	.word	0x0800ae9c
 80068c4:	0800b72c 	.word	0x0800b72c
 80068c8:	0800b848 	.word	0x0800b848
 80068cc:	0800b768 	.word	0x0800b768

080068d0 <cifXDownloadFWFiles>:
{
 80068d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80068d4:	b0d5      	sub	sp, #340	; 0x154
 80068d6:	4606      	mov	r6, r0
 80068d8:	468b      	mov	fp, r1
  for(ulChannel = 0; ulChannel < CIFX_MAX_NUMBER_OF_CHANNELS; ++ulChannel)
 80068da:	2700      	movs	r7, #0
  int32_t  lRet        = CIFX_NO_ERROR;
 80068dc:	46ba      	mov	sl, r7
  for(ulChannel = 0; ulChannel < CIFX_MAX_NUMBER_OF_CHANNELS; ++ulChannel)
 80068de:	e0b2      	b.n	8006a46 <cifXDownloadFWFiles+0x176>
      USER_Trace(ptDevInstance,
 80068e0:	9000      	str	r0, [sp, #0]
 80068e2:	463b      	mov	r3, r7
 80068e4:	4a66      	ldr	r2, [pc, #408]	; (8006a80 <cifXDownloadFWFiles+0x1b0>)
 80068e6:	2102      	movs	r1, #2
 80068e8:	4630      	mov	r0, r6
 80068ea:	f002 fea9 	bl	8009640 <USER_Trace>
 80068ee:	e0c1      	b.n	8006a74 <cifXDownloadFWFiles+0x1a4>
        uint32_t  ulFileLength = 0;
 80068f0:	2300      	movs	r3, #0
 80068f2:	930a      	str	r3, [sp, #40]	; 0x28
        void*     pvFile = OS_FileOpen(tFileInfo.szFullFileName, &ulFileLength);
 80068f4:	a90a      	add	r1, sp, #40	; 0x28
 80068f6:	a813      	add	r0, sp, #76	; 0x4c
 80068f8:	f7fc f926 	bl	8002b48 <OS_FileOpen>
        if(NULL == pvFile)
 80068fc:	4680      	mov	r8, r0
 80068fe:	2800      	cmp	r0, #0
 8006900:	d036      	beq.n	8006970 <cifXDownloadFWFiles+0xa0>
          uint8_t* pbBuffer = (uint8_t*)OS_Memalloc(ulFileLength);
 8006902:	980a      	ldr	r0, [sp, #40]	; 0x28
 8006904:	f7fc f8ff 	bl	8002b06 <OS_Memalloc>
          if (NULL == pbBuffer)
 8006908:	4681      	mov	r9, r0
 800690a:	2800      	cmp	r0, #0
 800690c:	d03c      	beq.n	8006988 <cifXDownloadFWFiles+0xb8>
            if(ulFileLength != OS_FileRead(pvFile, 0, ulFileLength, pbBuffer))
 800690e:	4603      	mov	r3, r0
 8006910:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8006912:	2100      	movs	r1, #0
 8006914:	4640      	mov	r0, r8
 8006916:	f7fc f919 	bl	8002b4c <OS_FileRead>
 800691a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800691c:	4298      	cmp	r0, r3
 800691e:	d04a      	beq.n	80069b6 <cifXDownloadFWFiles+0xe6>
              if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006920:	4b58      	ldr	r3, [pc, #352]	; (8006a84 <cifXDownloadFWFiles+0x1b4>)
 8006922:	681b      	ldr	r3, [r3, #0]
 8006924:	f013 0f08 	tst.w	r3, #8
 8006928:	d13e      	bne.n	80069a8 <cifXDownloadFWFiles+0xd8>
            OS_Memfree(pbBuffer);
 800692a:	4648      	mov	r0, r9
 800692c:	f7fc f8ef 	bl	8002b0e <OS_Memfree>
          OS_FileClose(pvFile);
 8006930:	4640      	mov	r0, r8
 8006932:	f7fc f90d 	bl	8002b50 <OS_FileClose>
    for(ulIdx = 0; ulIdx < ulFirmwareCnt; ++ulIdx)
 8006936:	3401      	adds	r4, #1
 8006938:	42ac      	cmp	r4, r5
 800693a:	f080 8083 	bcs.w	8006a44 <cifXDownloadFWFiles+0x174>
      OS_Memset(&tFileInfo, 0, sizeof(tFileInfo));
 800693e:	f44f 728a 	mov.w	r2, #276	; 0x114
 8006942:	2100      	movs	r1, #0
 8006944:	a80f      	add	r0, sp, #60	; 0x3c
 8006946:	f7fc f8ea 	bl	8002b1e <OS_Memset>
      if(!USER_GetFirmwareFile(&tDevInfo, ulIdx, &tFileInfo))
 800694a:	aa0f      	add	r2, sp, #60	; 0x3c
 800694c:	4621      	mov	r1, r4
 800694e:	a80b      	add	r0, sp, #44	; 0x2c
 8006950:	f002 fe68 	bl	8009624 <USER_GetFirmwareFile>
 8006954:	2800      	cmp	r0, #0
 8006956:	d1cb      	bne.n	80068f0 <cifXDownloadFWFiles+0x20>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006958:	4b4a      	ldr	r3, [pc, #296]	; (8006a84 <cifXDownloadFWFiles+0x1b4>)
 800695a:	681b      	ldr	r3, [r3, #0]
 800695c:	f013 0f08 	tst.w	r3, #8
 8006960:	d0e9      	beq.n	8006936 <cifXDownloadFWFiles+0x66>
          USER_Trace(ptDevInstance,
 8006962:	4623      	mov	r3, r4
 8006964:	4a48      	ldr	r2, [pc, #288]	; (8006a88 <cifXDownloadFWFiles+0x1b8>)
 8006966:	2108      	movs	r1, #8
 8006968:	4630      	mov	r0, r6
 800696a:	f002 fe69 	bl	8009640 <USER_Trace>
 800696e:	e7e2      	b.n	8006936 <cifXDownloadFWFiles+0x66>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006970:	4b44      	ldr	r3, [pc, #272]	; (8006a84 <cifXDownloadFWFiles+0x1b4>)
 8006972:	681b      	ldr	r3, [r3, #0]
 8006974:	f013 0f08 	tst.w	r3, #8
 8006978:	d0dd      	beq.n	8006936 <cifXDownloadFWFiles+0x66>
            USER_Trace(ptDevInstance,
 800697a:	ab13      	add	r3, sp, #76	; 0x4c
 800697c:	4a43      	ldr	r2, [pc, #268]	; (8006a8c <cifXDownloadFWFiles+0x1bc>)
 800697e:	2108      	movs	r1, #8
 8006980:	4630      	mov	r0, r6
 8006982:	f002 fe5d 	bl	8009640 <USER_Trace>
 8006986:	e7d6      	b.n	8006936 <cifXDownloadFWFiles+0x66>
            if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006988:	4b3e      	ldr	r3, [pc, #248]	; (8006a84 <cifXDownloadFWFiles+0x1b4>)
 800698a:	681b      	ldr	r3, [r3, #0]
 800698c:	f013 0f08 	tst.w	r3, #8
 8006990:	d102      	bne.n	8006998 <cifXDownloadFWFiles+0xc8>
            lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 8006992:	f8df a108 	ldr.w	sl, [pc, #264]	; 8006a9c <cifXDownloadFWFiles+0x1cc>
 8006996:	e7cb      	b.n	8006930 <cifXDownloadFWFiles+0x60>
              USER_Trace(ptDevInstance,
 8006998:	4a3d      	ldr	r2, [pc, #244]	; (8006a90 <cifXDownloadFWFiles+0x1c0>)
 800699a:	2108      	movs	r1, #8
 800699c:	4630      	mov	r0, r6
 800699e:	f002 fe4f 	bl	8009640 <USER_Trace>
            lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 80069a2:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 8006a9c <cifXDownloadFWFiles+0x1cc>
 80069a6:	e7c3      	b.n	8006930 <cifXDownloadFWFiles+0x60>
                USER_Trace(ptDevInstance,
 80069a8:	ab13      	add	r3, sp, #76	; 0x4c
 80069aa:	4a3a      	ldr	r2, [pc, #232]	; (8006a94 <cifXDownloadFWFiles+0x1c4>)
 80069ac:	2108      	movs	r1, #8
 80069ae:	4630      	mov	r0, r6
 80069b0:	f002 fe46 	bl	8009640 <USER_Trace>
 80069b4:	e7b9      	b.n	800692a <cifXDownloadFWFiles+0x5a>
              uint8_t bLoadState = CIFXTKIT_DOWNLOAD_NONE;
 80069b6:	f10d 0127 	add.w	r1, sp, #39	; 0x27
 80069ba:	2200      	movs	r2, #0
 80069bc:	f88d 2027 	strb.w	r2, [sp, #39]	; 0x27
              if( CIFX_NO_ERROR == (lRet = DEV_ProcessFWDownload( ptDevInstance,
 80069c0:	9206      	str	r2, [sp, #24]
 80069c2:	9205      	str	r2, [sp, #20]
 80069c4:	9204      	str	r2, [sp, #16]
 80069c6:	4a34      	ldr	r2, [pc, #208]	; (8006a98 <cifXDownloadFWFiles+0x1c8>)
 80069c8:	9203      	str	r2, [sp, #12]
 80069ca:	9102      	str	r1, [sp, #8]
 80069cc:	f8cd 9004 	str.w	r9, [sp, #4]
 80069d0:	9300      	str	r3, [sp, #0]
 80069d2:	ab0f      	add	r3, sp, #60	; 0x3c
 80069d4:	aa13      	add	r2, sp, #76	; 0x4c
 80069d6:	4639      	mov	r1, r7
 80069d8:	4630      	mov	r0, r6
 80069da:	f7fd fcdd 	bl	8004398 <DEV_ProcessFWDownload>
 80069de:	4682      	mov	sl, r0
 80069e0:	2800      	cmp	r0, #0
 80069e2:	d1a2      	bne.n	800692a <cifXDownloadFWFiles+0x5a>
                switch(bLoadState & ~CIFXTKIT_DOWNLOAD_EXECUTED)
 80069e4:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
 80069e8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80069ec:	2b01      	cmp	r3, #1
 80069ee:	d014      	beq.n	8006a1a <cifXDownloadFWFiles+0x14a>
 80069f0:	2b02      	cmp	r3, #2
 80069f2:	d19a      	bne.n	800692a <cifXDownloadFWFiles+0x5a>
                    (void)OS_Strncpy(ptDevChannelCfg->atChannelData[ulChannel].szFileName,
 80069f4:	ebc7 00c7 	rsb	r0, r7, r7, lsl #3
 80069f8:	0080      	lsls	r0, r0, #2
 80069fa:	3008      	adds	r0, #8
 80069fc:	4458      	add	r0, fp
 80069fe:	2210      	movs	r2, #16
 8006a00:	a90f      	add	r1, sp, #60	; 0x3c
 8006a02:	3004      	adds	r0, #4
 8006a04:	f7fc f978 	bl	8002cf8 <OS_Strncpy>
                    ptDevChannelCfg->atChannelData[ulChannel].fModuleLoaded = 1;
 8006a08:	00fb      	lsls	r3, r7, #3
 8006a0a:	1bdb      	subs	r3, r3, r7
 8006a0c:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 8006a10:	2201      	movs	r2, #1
 8006a12:	605a      	str	r2, [r3, #4]
                    ptDevChannelCfg->atChannelData[ulChannel].ulFileSize    = ulFileLength;
 8006a14:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8006a16:	61da      	str	r2, [r3, #28]
                  break;
 8006a18:	e787      	b.n	800692a <cifXDownloadFWFiles+0x5a>
                    OS_Memset(ptDevChannelCfg->atChannelData, 0, sizeof(ptDevChannelCfg->atChannelData));
 8006a1a:	22a8      	movs	r2, #168	; 0xa8
 8006a1c:	2100      	movs	r1, #0
 8006a1e:	f10b 0004 	add.w	r0, fp, #4
 8006a22:	f7fc f87c 	bl	8002b1e <OS_Memset>
                    if( bLoadState & CIFXTKIT_DOWNLOAD_EXECUTED)
 8006a26:	f99d 3027 	ldrsb.w	r3, [sp, #39]	; 0x27
 8006a2a:	2b00      	cmp	r3, #0
 8006a2c:	db06      	blt.n	8006a3c <cifXDownloadFWFiles+0x16c>
                    ptDevChannelCfg->atChannelData[ulChannel].ulFileSize = ulFileLength;
 8006a2e:	ebc7 03c7 	rsb	r3, r7, r7, lsl #3
 8006a32:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 8006a36:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8006a38:	61da      	str	r2, [r3, #28]
                  break;
 8006a3a:	e776      	b.n	800692a <cifXDownloadFWFiles+0x5a>
                      ptDevChannelCfg->fFWLoaded = 1;
 8006a3c:	2301      	movs	r3, #1
 8006a3e:	f8cb 3000 	str.w	r3, [fp]
 8006a42:	e7f4      	b.n	8006a2e <cifXDownloadFWFiles+0x15e>
  for(ulChannel = 0; ulChannel < CIFX_MAX_NUMBER_OF_CHANNELS; ++ulChannel)
 8006a44:	3701      	adds	r7, #1
 8006a46:	2f05      	cmp	r7, #5
 8006a48:	d816      	bhi.n	8006a78 <cifXDownloadFWFiles+0x1a8>
    OS_Memset(&tDevInfo, 0, sizeof(tDevInfo));
 8006a4a:	2210      	movs	r2, #16
 8006a4c:	2100      	movs	r1, #0
 8006a4e:	a80b      	add	r0, sp, #44	; 0x2c
 8006a50:	f7fc f865 	bl	8002b1e <OS_Memset>
    tDevInfo.ulDeviceNumber   = ptDevInstance->ulDeviceNumber;
 8006a54:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8006a56:	930b      	str	r3, [sp, #44]	; 0x2c
    tDevInfo.ulSerialNumber   = ptDevInstance->ulSerialNumber;
 8006a58:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8006a5a:	930c      	str	r3, [sp, #48]	; 0x30
    tDevInfo.ulChannel        = ulChannel;
 8006a5c:	970d      	str	r7, [sp, #52]	; 0x34
    tDevInfo.ptDeviceInstance = ptDevInstance;
 8006a5e:	960e      	str	r6, [sp, #56]	; 0x38
    ulFirmwareCnt = USER_GetFirmwareFileCount(&tDevInfo);
 8006a60:	a80b      	add	r0, sp, #44	; 0x2c
 8006a62:	f002 fddd 	bl	8009620 <USER_GetFirmwareFileCount>
 8006a66:	4605      	mov	r5, r0
    if(g_ulTraceLevel & TRACE_LEVEL_INFO)
 8006a68:	4b06      	ldr	r3, [pc, #24]	; (8006a84 <cifXDownloadFWFiles+0x1b4>)
 8006a6a:	681b      	ldr	r3, [r3, #0]
 8006a6c:	f013 0f02 	tst.w	r3, #2
 8006a70:	f47f af36 	bne.w	80068e0 <cifXDownloadFWFiles+0x10>
            lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 8006a74:	2400      	movs	r4, #0
 8006a76:	e75f      	b.n	8006938 <cifXDownloadFWFiles+0x68>
}
 8006a78:	4650      	mov	r0, sl
 8006a7a:	b055      	add	sp, #340	; 0x154
 8006a7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006a80:	0800b888 	.word	0x0800b888
 8006a84:	20000038 	.word	0x20000038
 8006a88:	0800b8c8 	.word	0x0800b8c8
 8006a8c:	0800b910 	.word	0x0800b910
 8006a90:	0800b57c 	.word	0x0800b57c
 8006a94:	0800b934 	.word	0x0800b934
 8006a98:	08005979 	.word	0x08005979
 8006a9c:	800a000c 	.word	0x800a000c

08006aa0 <cifXDownloadCNFFiles>:
{
 8006aa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006aa4:	b0d5      	sub	sp, #340	; 0x154
 8006aa6:	4606      	mov	r6, r0
 8006aa8:	9107      	str	r1, [sp, #28]
  CIFXHANDLE hSysDevice  = (CIFXHANDLE)&ptDevInstance->tSystemDevice;
 8006aaa:	f100 0bf4 	add.w	fp, r0, #244	; 0xf4
  for(ulChannel = 0; ulChannel < CIFX_MAX_NUMBER_OF_CHANNELS; ++ulChannel)
 8006aae:	2700      	movs	r7, #0
  int32_t    lRet        = CIFX_NO_ERROR;
 8006ab0:	46ba      	mov	sl, r7
  for(ulChannel = 0; ulChannel < CIFX_MAX_NUMBER_OF_CHANNELS; ++ulChannel)
 8006ab2:	e0c8      	b.n	8006c46 <cifXDownloadCNFFiles+0x1a6>
      USER_Trace(ptDevInstance,
 8006ab4:	9000      	str	r0, [sp, #0]
 8006ab6:	463b      	mov	r3, r7
 8006ab8:	4a71      	ldr	r2, [pc, #452]	; (8006c80 <cifXDownloadCNFFiles+0x1e0>)
 8006aba:	2102      	movs	r1, #2
 8006abc:	4630      	mov	r0, r6
 8006abe:	f002 fdbf 	bl	8009640 <USER_Trace>
 8006ac2:	e0d7      	b.n	8006c74 <cifXDownloadCNFFiles+0x1d4>
        uint32_t   ulFileLength = 0;
 8006ac4:	2300      	movs	r3, #0
 8006ac6:	9309      	str	r3, [sp, #36]	; 0x24
        void*      pvFile       = OS_FileOpen(tFileInfo.szFullFileName, &ulFileLength);
 8006ac8:	a909      	add	r1, sp, #36	; 0x24
 8006aca:	a813      	add	r0, sp, #76	; 0x4c
 8006acc:	f7fc f83c 	bl	8002b48 <OS_FileOpen>
        if(NULL == pvFile)
 8006ad0:	4680      	mov	r8, r0
 8006ad2:	2800      	cmp	r0, #0
 8006ad4:	d036      	beq.n	8006b44 <cifXDownloadCNFFiles+0xa4>
          uint8_t*  pbBuffer = (uint8_t*)OS_Memalloc(ulFileLength);
 8006ad6:	9809      	ldr	r0, [sp, #36]	; 0x24
 8006ad8:	f7fc f815 	bl	8002b06 <OS_Memalloc>
          if (NULL == pbBuffer)
 8006adc:	4681      	mov	r9, r0
 8006ade:	2800      	cmp	r0, #0
 8006ae0:	d03c      	beq.n	8006b5c <cifXDownloadCNFFiles+0xbc>
            if( ulFileLength != OS_FileRead(pvFile, 0, ulFileLength, pbBuffer))
 8006ae2:	4603      	mov	r3, r0
 8006ae4:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8006ae6:	2100      	movs	r1, #0
 8006ae8:	4640      	mov	r0, r8
 8006aea:	f7fc f82f 	bl	8002b4c <OS_FileRead>
 8006aee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006af0:	4298      	cmp	r0, r3
 8006af2:	d04a      	beq.n	8006b8a <cifXDownloadCNFFiles+0xea>
              if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006af4:	4b63      	ldr	r3, [pc, #396]	; (8006c84 <cifXDownloadCNFFiles+0x1e4>)
 8006af6:	681b      	ldr	r3, [r3, #0]
 8006af8:	f013 0f08 	tst.w	r3, #8
 8006afc:	d13e      	bne.n	8006b7c <cifXDownloadCNFFiles+0xdc>
            OS_Memfree(pbBuffer);
 8006afe:	4648      	mov	r0, r9
 8006b00:	f7fc f805 	bl	8002b0e <OS_Memfree>
          OS_FileClose(pvFile);
 8006b04:	4640      	mov	r0, r8
 8006b06:	f7fc f823 	bl	8002b50 <OS_FileClose>
    for(ulIdx = 0; ulIdx < ulConfigCnt; ++ulIdx)
 8006b0a:	3401      	adds	r4, #1
 8006b0c:	42ac      	cmp	r4, r5
 8006b0e:	f080 8099 	bcs.w	8006c44 <cifXDownloadCNFFiles+0x1a4>
      OS_Memset(&tFileInfo, 0, sizeof(tFileInfo));
 8006b12:	f44f 728a 	mov.w	r2, #276	; 0x114
 8006b16:	2100      	movs	r1, #0
 8006b18:	a80f      	add	r0, sp, #60	; 0x3c
 8006b1a:	f7fc f800 	bl	8002b1e <OS_Memset>
      if(!USER_GetConfigurationFile(&tDevInfo, ulIdx, &tFileInfo))
 8006b1e:	aa0f      	add	r2, sp, #60	; 0x3c
 8006b20:	4621      	mov	r1, r4
 8006b22:	a80b      	add	r0, sp, #44	; 0x2c
 8006b24:	f002 fd82 	bl	800962c <USER_GetConfigurationFile>
 8006b28:	2800      	cmp	r0, #0
 8006b2a:	d1cb      	bne.n	8006ac4 <cifXDownloadCNFFiles+0x24>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006b2c:	4b55      	ldr	r3, [pc, #340]	; (8006c84 <cifXDownloadCNFFiles+0x1e4>)
 8006b2e:	681b      	ldr	r3, [r3, #0]
 8006b30:	f013 0f08 	tst.w	r3, #8
 8006b34:	d0e9      	beq.n	8006b0a <cifXDownloadCNFFiles+0x6a>
          USER_Trace(ptDevInstance,
 8006b36:	4623      	mov	r3, r4
 8006b38:	4a53      	ldr	r2, [pc, #332]	; (8006c88 <cifXDownloadCNFFiles+0x1e8>)
 8006b3a:	2108      	movs	r1, #8
 8006b3c:	4630      	mov	r0, r6
 8006b3e:	f002 fd7f 	bl	8009640 <USER_Trace>
 8006b42:	e7e2      	b.n	8006b0a <cifXDownloadCNFFiles+0x6a>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006b44:	4b4f      	ldr	r3, [pc, #316]	; (8006c84 <cifXDownloadCNFFiles+0x1e4>)
 8006b46:	681b      	ldr	r3, [r3, #0]
 8006b48:	f013 0f08 	tst.w	r3, #8
 8006b4c:	d0dd      	beq.n	8006b0a <cifXDownloadCNFFiles+0x6a>
            USER_Trace(ptDevInstance,
 8006b4e:	ab13      	add	r3, sp, #76	; 0x4c
 8006b50:	4a4e      	ldr	r2, [pc, #312]	; (8006c8c <cifXDownloadCNFFiles+0x1ec>)
 8006b52:	2108      	movs	r1, #8
 8006b54:	4630      	mov	r0, r6
 8006b56:	f002 fd73 	bl	8009640 <USER_Trace>
 8006b5a:	e7d6      	b.n	8006b0a <cifXDownloadCNFFiles+0x6a>
            if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006b5c:	4b49      	ldr	r3, [pc, #292]	; (8006c84 <cifXDownloadCNFFiles+0x1e4>)
 8006b5e:	681b      	ldr	r3, [r3, #0]
 8006b60:	f013 0f08 	tst.w	r3, #8
 8006b64:	d102      	bne.n	8006b6c <cifXDownloadCNFFiles+0xcc>
            lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 8006b66:	f8df a144 	ldr.w	sl, [pc, #324]	; 8006cac <cifXDownloadCNFFiles+0x20c>
 8006b6a:	e7cb      	b.n	8006b04 <cifXDownloadCNFFiles+0x64>
              USER_Trace(ptDevInstance,
 8006b6c:	4a48      	ldr	r2, [pc, #288]	; (8006c90 <cifXDownloadCNFFiles+0x1f0>)
 8006b6e:	2108      	movs	r1, #8
 8006b70:	4630      	mov	r0, r6
 8006b72:	f002 fd65 	bl	8009640 <USER_Trace>
            lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 8006b76:	f8df a134 	ldr.w	sl, [pc, #308]	; 8006cac <cifXDownloadCNFFiles+0x20c>
 8006b7a:	e7c3      	b.n	8006b04 <cifXDownloadCNFFiles+0x64>
                USER_Trace(ptDevInstance,
 8006b7c:	ab13      	add	r3, sp, #76	; 0x4c
 8006b7e:	4a45      	ldr	r2, [pc, #276]	; (8006c94 <cifXDownloadCNFFiles+0x1f4>)
 8006b80:	2108      	movs	r1, #8
 8006b82:	4630      	mov	r0, r6
 8006b84:	f002 fd5c 	bl	8009640 <USER_Trace>
 8006b88:	e7b9      	b.n	8006afe <cifXDownloadCNFFiles+0x5e>
              int fDownload = 0;
 8006b8a:	2200      	movs	r2, #0
 8006b8c:	920a      	str	r2, [sp, #40]	; 0x28
              if ( CIFX_NO_ERROR != (lRet = DEV_CheckForDownload( hSysDevice,
 8006b8e:	9204      	str	r2, [sp, #16]
 8006b90:	9203      	str	r2, [sp, #12]
 8006b92:	4a41      	ldr	r2, [pc, #260]	; (8006c98 <cifXDownloadCNFFiles+0x1f8>)
 8006b94:	9202      	str	r2, [sp, #8]
 8006b96:	9301      	str	r3, [sp, #4]
 8006b98:	f8cd 9000 	str.w	r9, [sp]
 8006b9c:	ab0f      	add	r3, sp, #60	; 0x3c
 8006b9e:	aa0a      	add	r2, sp, #40	; 0x28
 8006ba0:	4639      	mov	r1, r7
 8006ba2:	4658      	mov	r0, fp
 8006ba4:	f7fd f98a 	bl	8003ebc <DEV_CheckForDownload>
 8006ba8:	4682      	mov	sl, r0
 8006baa:	b158      	cbz	r0, 8006bc4 <cifXDownloadCNFFiles+0x124>
                if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006bac:	4b35      	ldr	r3, [pc, #212]	; (8006c84 <cifXDownloadCNFFiles+0x1e4>)
 8006bae:	681b      	ldr	r3, [r3, #0]
 8006bb0:	f013 0f08 	tst.w	r3, #8
 8006bb4:	d0a3      	beq.n	8006afe <cifXDownloadCNFFiles+0x5e>
                  USER_Trace(ptDevInstance,
 8006bb6:	ab13      	add	r3, sp, #76	; 0x4c
 8006bb8:	4a38      	ldr	r2, [pc, #224]	; (8006c9c <cifXDownloadCNFFiles+0x1fc>)
 8006bba:	2108      	movs	r1, #8
 8006bbc:	4630      	mov	r0, r6
 8006bbe:	f002 fd3f 	bl	8009640 <USER_Trace>
 8006bc2:	e79c      	b.n	8006afe <cifXDownloadCNFFiles+0x5e>
              } else if(!fDownload)
 8006bc4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8006bc6:	b95b      	cbnz	r3, 8006be0 <cifXDownloadCNFFiles+0x140>
                if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8006bc8:	4b2e      	ldr	r3, [pc, #184]	; (8006c84 <cifXDownloadCNFFiles+0x1e4>)
 8006bca:	681b      	ldr	r3, [r3, #0]
 8006bcc:	f013 0f01 	tst.w	r3, #1
 8006bd0:	d095      	beq.n	8006afe <cifXDownloadCNFFiles+0x5e>
                  USER_Trace(ptDevInstance,
 8006bd2:	ab13      	add	r3, sp, #76	; 0x4c
 8006bd4:	4a32      	ldr	r2, [pc, #200]	; (8006ca0 <cifXDownloadCNFFiles+0x200>)
 8006bd6:	2101      	movs	r1, #1
 8006bd8:	4630      	mov	r0, r6
 8006bda:	f002 fd31 	bl	8009640 <USER_Trace>
 8006bde:	e78e      	b.n	8006afe <cifXDownloadCNFFiles+0x5e>
                lRet = xSysdeviceDownload(hSysDevice,
 8006be0:	2300      	movs	r3, #0
 8006be2:	9304      	str	r3, [sp, #16]
 8006be4:	9303      	str	r3, [sp, #12]
 8006be6:	9302      	str	r3, [sp, #8]
 8006be8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006bea:	9301      	str	r3, [sp, #4]
 8006bec:	f8cd 9000 	str.w	r9, [sp]
 8006bf0:	ab0f      	add	r3, sp, #60	; 0x3c
 8006bf2:	2202      	movs	r2, #2
 8006bf4:	4639      	mov	r1, r7
 8006bf6:	4658      	mov	r0, fp
 8006bf8:	f7fd fd88 	bl	800470c <xSysdeviceDownload>
                if(CIFX_NO_ERROR != lRet)
 8006bfc:	4682      	mov	sl, r0
 8006bfe:	b168      	cbz	r0, 8006c1c <cifXDownloadCNFFiles+0x17c>
                  if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006c00:	4b20      	ldr	r3, [pc, #128]	; (8006c84 <cifXDownloadCNFFiles+0x1e4>)
 8006c02:	681b      	ldr	r3, [r3, #0]
 8006c04:	f013 0f08 	tst.w	r3, #8
 8006c08:	f43f af79 	beq.w	8006afe <cifXDownloadCNFFiles+0x5e>
                    USER_Trace(ptDevInstance,
 8006c0c:	9000      	str	r0, [sp, #0]
 8006c0e:	ab13      	add	r3, sp, #76	; 0x4c
 8006c10:	4a24      	ldr	r2, [pc, #144]	; (8006ca4 <cifXDownloadCNFFiles+0x204>)
 8006c12:	2108      	movs	r1, #8
 8006c14:	4630      	mov	r0, r6
 8006c16:	f002 fd13 	bl	8009640 <USER_Trace>
 8006c1a:	e770      	b.n	8006afe <cifXDownloadCNFFiles+0x5e>
                  ptDevChannelCfg->atChannelData[ulChannel].fCNFLoaded = 1;
 8006c1c:	ebc7 03c7 	rsb	r3, r7, r7, lsl #3
 8006c20:	9a07      	ldr	r2, [sp, #28]
 8006c22:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8006c26:	2201      	movs	r2, #1
 8006c28:	609a      	str	r2, [r3, #8]
                  if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8006c2a:	4b16      	ldr	r3, [pc, #88]	; (8006c84 <cifXDownloadCNFFiles+0x1e4>)
 8006c2c:	681b      	ldr	r3, [r3, #0]
 8006c2e:	f013 0f01 	tst.w	r3, #1
 8006c32:	f43f af64 	beq.w	8006afe <cifXDownloadCNFFiles+0x5e>
                    USER_Trace(ptDevInstance,
 8006c36:	ab13      	add	r3, sp, #76	; 0x4c
 8006c38:	4a1b      	ldr	r2, [pc, #108]	; (8006ca8 <cifXDownloadCNFFiles+0x208>)
 8006c3a:	2101      	movs	r1, #1
 8006c3c:	4630      	mov	r0, r6
 8006c3e:	f002 fcff 	bl	8009640 <USER_Trace>
 8006c42:	e75c      	b.n	8006afe <cifXDownloadCNFFiles+0x5e>
  for(ulChannel = 0; ulChannel < CIFX_MAX_NUMBER_OF_CHANNELS; ++ulChannel)
 8006c44:	3701      	adds	r7, #1
 8006c46:	2f05      	cmp	r7, #5
 8006c48:	d816      	bhi.n	8006c78 <cifXDownloadCNFFiles+0x1d8>
    OS_Memset(&tDevInfo, 0, sizeof(tDevInfo));
 8006c4a:	2210      	movs	r2, #16
 8006c4c:	2100      	movs	r1, #0
 8006c4e:	a80b      	add	r0, sp, #44	; 0x2c
 8006c50:	f7fb ff65 	bl	8002b1e <OS_Memset>
    tDevInfo.ulDeviceNumber   = ptDevInstance->ulDeviceNumber;
 8006c54:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8006c56:	930b      	str	r3, [sp, #44]	; 0x2c
    tDevInfo.ulSerialNumber   = ptDevInstance->ulSerialNumber;
 8006c58:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8006c5a:	930c      	str	r3, [sp, #48]	; 0x30
    tDevInfo.ulChannel        = ulChannel;
 8006c5c:	970d      	str	r7, [sp, #52]	; 0x34
    tDevInfo.ptDeviceInstance = ptDevInstance;
 8006c5e:	960e      	str	r6, [sp, #56]	; 0x38
    ulConfigCnt   = USER_GetConfigurationFileCount(&tDevInfo);
 8006c60:	a80b      	add	r0, sp, #44	; 0x2c
 8006c62:	f002 fce1 	bl	8009628 <USER_GetConfigurationFileCount>
 8006c66:	4605      	mov	r5, r0
    if(g_ulTraceLevel & TRACE_LEVEL_INFO)
 8006c68:	4b06      	ldr	r3, [pc, #24]	; (8006c84 <cifXDownloadCNFFiles+0x1e4>)
 8006c6a:	681b      	ldr	r3, [r3, #0]
 8006c6c:	f013 0f02 	tst.w	r3, #2
 8006c70:	f47f af20 	bne.w	8006ab4 <cifXDownloadCNFFiles+0x14>
            lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 8006c74:	2400      	movs	r4, #0
 8006c76:	e749      	b.n	8006b0c <cifXDownloadCNFFiles+0x6c>
}
 8006c78:	4650      	mov	r0, sl
 8006c7a:	b055      	add	sp, #340	; 0x154
 8006c7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006c80:	0800b960 	.word	0x0800b960
 8006c84:	20000038 	.word	0x20000038
 8006c88:	0800b9a8 	.word	0x0800b9a8
 8006c8c:	0800b9f8 	.word	0x0800b9f8
 8006c90:	0800b57c 	.word	0x0800b57c
 8006c94:	0800ba20 	.word	0x0800ba20
 8006c98:	08005979 	.word	0x08005979
 8006c9c:	0800ae78 	.word	0x0800ae78
 8006ca0:	0800ae9c 	.word	0x0800ae9c
 8006ca4:	0800ba54 	.word	0x0800ba54
 8006ca8:	0800ba94 	.word	0x0800ba94
 8006cac:	800a000c 	.word	0x800a000c

08006cb0 <cifXReadChannelLayout>:
{
 8006cb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006cb4:	b0a3      	sub	sp, #140	; 0x8c
 8006cb6:	4680      	mov	r8, r0
 8006cb8:	460e      	mov	r6, r1
 8006cba:	4691      	mov	r9, r2
  OS_Memset(&tSendPkt, 0, sizeof(tSendPkt));
 8006cbc:	2230      	movs	r2, #48	; 0x30
 8006cbe:	2100      	movs	r1, #0
 8006cc0:	a816      	add	r0, sp, #88	; 0x58
 8006cc2:	f7fb ff2c 	bl	8002b1e <OS_Memset>
  OS_Memset(&tRecvPkt, 0, sizeof(tRecvPkt));
 8006cc6:	2244      	movs	r2, #68	; 0x44
 8006cc8:	2100      	movs	r1, #0
 8006cca:	a805      	add	r0, sp, #20
 8006ccc:	f7fb ff27 	bl	8002b1e <OS_Memset>
  if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8006cd0:	4baa      	ldr	r3, [pc, #680]	; (8006f7c <cifXReadChannelLayout+0x2cc>)
 8006cd2:	681b      	ldr	r3, [r3, #0]
 8006cd4:	f013 0f01 	tst.w	r3, #1
 8006cd8:	d10c      	bne.n	8006cf4 <cifXReadChannelLayout+0x44>
  tSendPkt.tHead.ulSrc  = HOST_TO_LE32(ptDevInstance->ulPhysicalAddress);
 8006cda:	f8d8 3000 	ldr.w	r3, [r8]
 8006cde:	9317      	str	r3, [sp, #92]	; 0x5c
  tSendPkt.tHead.ulDest = HOST_TO_LE32(HIL_PACKET_DEST_SYSTEM);
 8006ce0:	2700      	movs	r7, #0
 8006ce2:	9716      	str	r7, [sp, #88]	; 0x58
  tSendPkt.tHead.ulLen  = HOST_TO_LE32(sizeof(tSendPkt.tData));
 8006ce4:	2308      	movs	r3, #8
 8006ce6:	931a      	str	r3, [sp, #104]	; 0x68
  tSendPkt.tHead.ulCmd  = HOST_TO_LE32(HIL_DPM_GET_BLOCK_INFO_REQ);
 8006ce8:	f641 63f8 	movw	r3, #7928	; 0x1ef8
 8006cec:	931d      	str	r3, [sp, #116]	; 0x74
  uint32_t ulPacketIdx = 0;
 8006cee:	463d      	mov	r5, r7
  for ( ulIdx = 0; ulIdx < ulNumOfBlocks; ulIdx++)
 8006cf0:	463c      	mov	r4, r7
 8006cf2:	e01b      	b.n	8006d2c <cifXReadChannelLayout+0x7c>
                (uint32_t)(ptChannel->pbDPMChannelStart - ptDevInstance->pbDPM),
 8006cf4:	68b3      	ldr	r3, [r6, #8]
 8006cf6:	f8d8 2020 	ldr.w	r2, [r8, #32]
 8006cfa:	1a9b      	subs	r3, r3, r2
    USER_Trace(ptDevInstance,
 8006cfc:	68f2      	ldr	r2, [r6, #12]
 8006cfe:	9201      	str	r2, [sp, #4]
 8006d00:	9300      	str	r3, [sp, #0]
 8006d02:	6933      	ldr	r3, [r6, #16]
 8006d04:	4a9e      	ldr	r2, [pc, #632]	; (8006f80 <cifXReadChannelLayout+0x2d0>)
 8006d06:	2101      	movs	r1, #1
 8006d08:	4640      	mov	r0, r8
 8006d0a:	f002 fc99 	bl	8009640 <USER_Trace>
    USER_Trace(ptDevInstance,
 8006d0e:	4a9d      	ldr	r2, [pc, #628]	; (8006f84 <cifXReadChannelLayout+0x2d4>)
 8006d10:	2101      	movs	r1, #1
 8006d12:	4640      	mov	r0, r8
 8006d14:	f002 fc94 	bl	8009640 <USER_Trace>
 8006d18:	e7df      	b.n	8006cda <cifXReadChannelLayout+0x2a>
    } else if ( SUCCESS_HIL_OK != LE32_TO_HOST(tRecvPkt.tHead.ulSta))
 8006d1a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8006d1c:	2b00      	cmp	r3, #0
 8006d1e:	d037      	beq.n	8006d90 <cifXReadChannelLayout+0xe0>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006d20:	4a96      	ldr	r2, [pc, #600]	; (8006f7c <cifXReadChannelLayout+0x2cc>)
 8006d22:	6812      	ldr	r2, [r2, #0]
 8006d24:	f012 0f08 	tst.w	r2, #8
 8006d28:	d128      	bne.n	8006d7c <cifXReadChannelLayout+0xcc>
  for ( ulIdx = 0; ulIdx < ulNumOfBlocks; ulIdx++)
 8006d2a:	3401      	adds	r4, #1
 8006d2c:	454c      	cmp	r4, r9
 8006d2e:	f080 82e8 	bcs.w	8007302 <cifXReadChannelLayout+0x652>
    ++ulPacketIdx;
 8006d32:	3501      	adds	r5, #1
    tSendPkt.tHead.ulId             = HOST_TO_LE32(ulPacketIdx);            /* Insert Packet number */
 8006d34:	951b      	str	r5, [sp, #108]	; 0x6c
    tSendPkt.tData.ulAreaIndex      = HOST_TO_LE32(ptChannel->ulBlockID);
 8006d36:	6973      	ldr	r3, [r6, #20]
 8006d38:	9320      	str	r3, [sp, #128]	; 0x80
    tSendPkt.tData.ulSubblockIndex  = HOST_TO_LE32(ulIdx);                  /* Insert Block index into packet */
 8006d3a:	9421      	str	r4, [sp, #132]	; 0x84
    if ( (lRet = DEV_TransferPacket( &ptDevInstance->tSystemDevice,
 8006d3c:	2300      	movs	r3, #0
 8006d3e:	9302      	str	r3, [sp, #8]
 8006d40:	9301      	str	r3, [sp, #4]
 8006d42:	f241 3388 	movw	r3, #5000	; 0x1388
 8006d46:	9300      	str	r3, [sp, #0]
 8006d48:	2344      	movs	r3, #68	; 0x44
 8006d4a:	aa05      	add	r2, sp, #20
 8006d4c:	a916      	add	r1, sp, #88	; 0x58
 8006d4e:	f108 00f4 	add.w	r0, r8, #244	; 0xf4
 8006d52:	f7fe fe11 	bl	8005978 <DEV_TransferPacket>
 8006d56:	4607      	mov	r7, r0
 8006d58:	2800      	cmp	r0, #0
 8006d5a:	d0de      	beq.n	8006d1a <cifXReadChannelLayout+0x6a>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006d5c:	4b87      	ldr	r3, [pc, #540]	; (8006f7c <cifXReadChannelLayout+0x2cc>)
 8006d5e:	681b      	ldr	r3, [r3, #0]
 8006d60:	f013 0f08 	tst.w	r3, #8
 8006d64:	d0e1      	beq.n	8006d2a <cifXReadChannelLayout+0x7a>
        USER_Trace(ptDevInstance,
 8006d66:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8006d68:	9301      	str	r3, [sp, #4]
 8006d6a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8006d6c:	9300      	str	r3, [sp, #0]
 8006d6e:	4603      	mov	r3, r0
 8006d70:	4a85      	ldr	r2, [pc, #532]	; (8006f88 <cifXReadChannelLayout+0x2d8>)
 8006d72:	2108      	movs	r1, #8
 8006d74:	4640      	mov	r0, r8
 8006d76:	f002 fc63 	bl	8009640 <USER_Trace>
 8006d7a:	e7d6      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
        USER_Trace(ptDevInstance,
 8006d7c:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8006d7e:	9201      	str	r2, [sp, #4]
 8006d80:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8006d82:	9200      	str	r2, [sp, #0]
 8006d84:	4a81      	ldr	r2, [pc, #516]	; (8006f8c <cifXReadChannelLayout+0x2dc>)
 8006d86:	2108      	movs	r1, #8
 8006d88:	4640      	mov	r0, r8
 8006d8a:	f002 fc59 	bl	8009640 <USER_Trace>
 8006d8e:	e7cc      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
      switch(LE32_TO_HOST(tRecvPkt.tData.ulType) & HIL_BLOCK_MASK)
 8006d90:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8006d92:	b2d3      	uxtb	r3, r2
 8006d94:	2b08      	cmp	r3, #8
 8006d96:	f200 82a0 	bhi.w	80072da <cifXReadChannelLayout+0x62a>
 8006d9a:	e8df f013 	tbh	[pc, r3, lsl #1]
 8006d9e:	0009      	.short	0x0009
 8006da0:	00180009 	.word	0x00180009
 8006da4:	01510018 	.word	0x01510018
 8006da8:	01ed01d0 	.word	0x01ed01d0
 8006dac:	0227020a 	.word	0x0227020a
        if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8006db0:	4b72      	ldr	r3, [pc, #456]	; (8006f7c <cifXReadChannelLayout+0x2cc>)
 8006db2:	681b      	ldr	r3, [r3, #0]
 8006db4:	f013 0f01 	tst.w	r3, #1
 8006db8:	d0b7      	beq.n	8006d2a <cifXReadChannelLayout+0x7a>
          USER_Trace(ptDevInstance,
 8006dba:	9201      	str	r2, [sp, #4]
 8006dbc:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8006dbe:	9300      	str	r3, [sp, #0]
 8006dc0:	6933      	ldr	r3, [r6, #16]
 8006dc2:	4a73      	ldr	r2, [pc, #460]	; (8006f90 <cifXReadChannelLayout+0x2e0>)
 8006dc4:	2101      	movs	r1, #1
 8006dc6:	4640      	mov	r0, r8
 8006dc8:	f002 fc3a 	bl	8009640 <USER_Trace>
 8006dcc:	e7ad      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
          switch(LE16_TO_HOST(tRecvPkt.tData.usFlags) & HIL_DIRECTION_MASK)
 8006dce:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
 8006dd2:	f003 030f 	and.w	r3, r3, #15
 8006dd6:	2b01      	cmp	r3, #1
 8006dd8:	f000 8087 	beq.w	8006eea <cifXReadChannelLayout+0x23a>
 8006ddc:	2b02      	cmp	r3, #2
 8006dde:	f040 811f 	bne.w	8007020 <cifXReadChannelLayout+0x370>
              PIOINSTANCE ptIOOutputInstance = (PIOINSTANCE)OS_Memalloc(sizeof(*ptIOOutputInstance));
 8006de2:	2020      	movs	r0, #32
 8006de4:	f7fb fe8f 	bl	8002b06 <OS_Memalloc>
              if (NULL == ptIOOutputInstance           ||
 8006de8:	4682      	mov	sl, r0
 8006dea:	b348      	cbz	r0, 8006e40 <cifXReadChannelLayout+0x190>
                  NULL == (pvMutex = OS_CreateMutex()) )
 8006dec:	f7fb fef3 	bl	8002bd6 <OS_CreateMutex>
              if (NULL == ptIOOutputInstance           ||
 8006df0:	4683      	mov	fp, r0
 8006df2:	b330      	cbz	r0, 8006e42 <cifXReadChannelLayout+0x192>
                OS_Memset(ptIOOutputInstance, 0, sizeof(*ptIOOutputInstance));
 8006df4:	2220      	movs	r2, #32
 8006df6:	2100      	movs	r1, #0
 8006df8:	4650      	mov	r0, sl
 8006dfa:	f7fb fe90 	bl	8002b1e <OS_Memset>
                ptIOOutputInstance->pbDPMAreaStart  = ptChannel->pbDPMChannelStart + LE32_TO_HOST(tRecvPkt.tData.ulOffset);
 8006dfe:	68b3      	ldr	r3, [r6, #8]
 8006e00:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8006e02:	4413      	add	r3, r2
 8006e04:	f8ca 3000 	str.w	r3, [sl]
                ptIOOutputInstance->ulDPMAreaLength = LE32_TO_HOST(tRecvPkt.tData.ulSize);
 8006e08:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8006e0a:	f8ca 3004 	str.w	r3, [sl, #4]
                ptIOOutputInstance->bHandshakeBit   = (uint8_t)LE16_TO_HOST(tRecvPkt.tData.usHandshakeBit);
 8006e0e:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 8006e12:	f88a 3008 	strb.w	r3, [sl, #8]
                ptIOOutputInstance->usHandshakeMode = LE16_TO_HOST(tRecvPkt.tData.usHandshakeMode);
 8006e16:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
 8006e1a:	f8aa 300a 	strh.w	r3, [sl, #10]
                if((LE32_TO_HOST(tRecvPkt.tData.ulType) & HIL_BLOCK_MASK) == HIL_BLOCK_DATA_IMAGE)
 8006e1e:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
 8006e22:	2a02      	cmp	r2, #2
 8006e24:	d021      	beq.n	8006e6a <cifXReadChannelLayout+0x1ba>
                  ptIOOutputInstance->ulNotifyEvent = CIFX_NOTIFY_PD1_OUT;
 8006e26:	2206      	movs	r2, #6
 8006e28:	f8ca 2014 	str.w	r2, [sl, #20]
                ptIOOutputInstance->pvMutex = pvMutex;
 8006e2c:	f8ca b010 	str.w	fp, [sl, #16]
                switch(ptIOOutputInstance->usHandshakeMode)
 8006e30:	2b02      	cmp	r3, #2
 8006e32:	d01e      	beq.n	8006e72 <cifXReadChannelLayout+0x1c2>
 8006e34:	2b04      	cmp	r3, #4
 8006e36:	d046      	beq.n	8006ec6 <cifXReadChannelLayout+0x216>
                    ptIOOutputInstance->bHandshakeBitState = HIL_FLAGS_NONE;
 8006e38:	23ff      	movs	r3, #255	; 0xff
 8006e3a:	f88a 300c 	strb.w	r3, [sl, #12]
                  break;
 8006e3e:	e01b      	b.n	8006e78 <cifXReadChannelLayout+0x1c8>
              void*       pvMutex            = NULL;
 8006e40:	4683      	mov	fp, r0
                OS_Memfree(ptIOOutputInstance);
 8006e42:	4650      	mov	r0, sl
 8006e44:	f7fb fe63 	bl	8002b0e <OS_Memfree>
                OS_DeleteMutex(pvMutex);
 8006e48:	4658      	mov	r0, fp
 8006e4a:	f7fb fee5 	bl	8002c18 <OS_DeleteMutex>
                if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006e4e:	4b4b      	ldr	r3, [pc, #300]	; (8006f7c <cifXReadChannelLayout+0x2cc>)
 8006e50:	681b      	ldr	r3, [r3, #0]
 8006e52:	f013 0f08 	tst.w	r3, #8
 8006e56:	d101      	bne.n	8006e5c <cifXReadChannelLayout+0x1ac>
                lRet = CIFX_INVALID_POINTER;
 8006e58:	4f4e      	ldr	r7, [pc, #312]	; (8006f94 <cifXReadChannelLayout+0x2e4>)
 8006e5a:	e766      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                  USER_Trace(ptDevInstance,
 8006e5c:	4a4e      	ldr	r2, [pc, #312]	; (8006f98 <cifXReadChannelLayout+0x2e8>)
 8006e5e:	2108      	movs	r1, #8
 8006e60:	4640      	mov	r0, r8
 8006e62:	f002 fbed 	bl	8009640 <USER_Trace>
                lRet = CIFX_INVALID_POINTER;
 8006e66:	4f4b      	ldr	r7, [pc, #300]	; (8006f94 <cifXReadChannelLayout+0x2e4>)
 8006e68:	e75f      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                  ptIOOutputInstance->ulNotifyEvent = CIFX_NOTIFY_PD0_OUT;
 8006e6a:	2205      	movs	r2, #5
 8006e6c:	f8ca 2014 	str.w	r2, [sl, #20]
 8006e70:	e7dc      	b.n	8006e2c <cifXReadChannelLayout+0x17c>
                    ptIOOutputInstance->bHandshakeBitState = HIL_FLAGS_NOT_EQUAL;
 8006e72:	2301      	movs	r3, #1
 8006e74:	f88a 300c 	strb.w	r3, [sl, #12]
                ++ptChannel->ulIOOutputAreas;
 8006e78:	f8d6 1148 	ldr.w	r1, [r6, #328]	; 0x148
 8006e7c:	3101      	adds	r1, #1
 8006e7e:	f8c6 1148 	str.w	r1, [r6, #328]	; 0x148
                ptChannel->pptIOOutputAreas = (PIOINSTANCE*)OS_Memrealloc(ptChannel->pptIOOutputAreas,
 8006e82:	0089      	lsls	r1, r1, #2
 8006e84:	f8d6 0144 	ldr.w	r0, [r6, #324]	; 0x144
 8006e88:	f7fb fe45 	bl	8002b16 <OS_Memrealloc>
 8006e8c:	f8c6 0144 	str.w	r0, [r6, #324]	; 0x144
                if (NULL == ptChannel->pptIOOutputAreas)
 8006e90:	b1e8      	cbz	r0, 8006ece <cifXReadChannelLayout+0x21e>
                  ptChannel->pptIOOutputAreas[ptChannel->ulIOOutputAreas - 1] = ptIOOutputInstance;
 8006e92:	f8d6 2148 	ldr.w	r2, [r6, #328]	; 0x148
 8006e96:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 8006e9a:	4413      	add	r3, r2
 8006e9c:	f840 a023 	str.w	sl, [r0, r3, lsl #2]
                  if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8006ea0:	4b36      	ldr	r3, [pc, #216]	; (8006f7c <cifXReadChannelLayout+0x2cc>)
 8006ea2:	681b      	ldr	r3, [r3, #0]
 8006ea4:	f013 0f01 	tst.w	r3, #1
 8006ea8:	f43f af3f 	beq.w	8006d2a <cifXReadChannelLayout+0x7a>
                    USER_Trace(ptDevInstance,
 8006eac:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8006eae:	9302      	str	r3, [sp, #8]
 8006eb0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006eb2:	9301      	str	r3, [sp, #4]
 8006eb4:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8006eb6:	9300      	str	r3, [sp, #0]
 8006eb8:	6933      	ldr	r3, [r6, #16]
 8006eba:	4a38      	ldr	r2, [pc, #224]	; (8006f9c <cifXReadChannelLayout+0x2ec>)
 8006ebc:	2101      	movs	r1, #1
 8006ebe:	4640      	mov	r0, r8
 8006ec0:	f002 fbbe 	bl	8009640 <USER_Trace>
 8006ec4:	e731      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                    ptIOOutputInstance->bHandshakeBitState = HIL_FLAGS_EQUAL;
 8006ec6:	2300      	movs	r3, #0
 8006ec8:	f88a 300c 	strb.w	r3, [sl, #12]
                  break;
 8006ecc:	e7d4      	b.n	8006e78 <cifXReadChannelLayout+0x1c8>
                  if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006ece:	4b2b      	ldr	r3, [pc, #172]	; (8006f7c <cifXReadChannelLayout+0x2cc>)
 8006ed0:	681b      	ldr	r3, [r3, #0]
 8006ed2:	f013 0f08 	tst.w	r3, #8
 8006ed6:	d101      	bne.n	8006edc <cifXReadChannelLayout+0x22c>
                  lRet = CIFX_INVALID_POINTER;
 8006ed8:	4f2e      	ldr	r7, [pc, #184]	; (8006f94 <cifXReadChannelLayout+0x2e4>)
 8006eda:	e726      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                    USER_Trace(ptDevInstance,
 8006edc:	4a30      	ldr	r2, [pc, #192]	; (8006fa0 <cifXReadChannelLayout+0x2f0>)
 8006ede:	2108      	movs	r1, #8
 8006ee0:	4640      	mov	r0, r8
 8006ee2:	f002 fbad 	bl	8009640 <USER_Trace>
                  lRet = CIFX_INVALID_POINTER;
 8006ee6:	4f2b      	ldr	r7, [pc, #172]	; (8006f94 <cifXReadChannelLayout+0x2e4>)
 8006ee8:	e71f      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
              PIOINSTANCE ptIOInputInstance = (PIOINSTANCE)OS_Memalloc(sizeof(*ptIOInputInstance));
 8006eea:	2020      	movs	r0, #32
 8006eec:	f7fb fe0b 	bl	8002b06 <OS_Memalloc>
              if (NULL == ptIOInputInstance            ||
 8006ef0:	4682      	mov	sl, r0
 8006ef2:	b348      	cbz	r0, 8006f48 <cifXReadChannelLayout+0x298>
                  NULL == (pvMutex = OS_CreateMutex()) )
 8006ef4:	f7fb fe6f 	bl	8002bd6 <OS_CreateMutex>
              if (NULL == ptIOInputInstance            ||
 8006ef8:	4683      	mov	fp, r0
 8006efa:	b330      	cbz	r0, 8006f4a <cifXReadChannelLayout+0x29a>
                OS_Memset(ptIOInputInstance, 0, sizeof(*ptIOInputInstance));
 8006efc:	2220      	movs	r2, #32
 8006efe:	2100      	movs	r1, #0
 8006f00:	4650      	mov	r0, sl
 8006f02:	f7fb fe0c 	bl	8002b1e <OS_Memset>
                ptIOInputInstance->pbDPMAreaStart  = ptChannel->pbDPMChannelStart + LE32_TO_HOST(tRecvPkt.tData.ulOffset);
 8006f06:	68b3      	ldr	r3, [r6, #8]
 8006f08:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8006f0a:	4413      	add	r3, r2
 8006f0c:	f8ca 3000 	str.w	r3, [sl]
                ptIOInputInstance->ulDPMAreaLength = LE32_TO_HOST(tRecvPkt.tData.ulSize);
 8006f10:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8006f12:	f8ca 3004 	str.w	r3, [sl, #4]
                ptIOInputInstance->bHandshakeBit   = (uint8_t)LE16_TO_HOST(tRecvPkt.tData.usHandshakeBit);
 8006f16:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 8006f1a:	f88a 3008 	strb.w	r3, [sl, #8]
                ptIOInputInstance->usHandshakeMode = LE16_TO_HOST(tRecvPkt.tData.usHandshakeMode);
 8006f1e:	f8bd 3052 	ldrh.w	r3, [sp, #82]	; 0x52
 8006f22:	f8aa 300a 	strh.w	r3, [sl, #10]
                if((LE32_TO_HOST(tRecvPkt.tData.ulType) & HIL_BLOCK_MASK) == HIL_BLOCK_DATA_IMAGE)
 8006f26:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
 8006f2a:	2a02      	cmp	r2, #2
 8006f2c:	d021      	beq.n	8006f72 <cifXReadChannelLayout+0x2c2>
                  ptIOInputInstance->ulNotifyEvent = CIFX_NOTIFY_PD1_IN;
 8006f2e:	2204      	movs	r2, #4
 8006f30:	f8ca 2014 	str.w	r2, [sl, #20]
                ptIOInputInstance->pvMutex = pvMutex;
 8006f34:	f8ca b010 	str.w	fp, [sl, #16]
                switch(ptIOInputInstance->usHandshakeMode)
 8006f38:	2b02      	cmp	r3, #2
 8006f3a:	d035      	beq.n	8006fa8 <cifXReadChannelLayout+0x2f8>
 8006f3c:	2b04      	cmp	r3, #4
 8006f3e:	d05d      	beq.n	8006ffc <cifXReadChannelLayout+0x34c>
                    ptIOInputInstance->bHandshakeBitState = HIL_FLAGS_NONE;
 8006f40:	23ff      	movs	r3, #255	; 0xff
 8006f42:	f88a 300c 	strb.w	r3, [sl, #12]
                  break;
 8006f46:	e032      	b.n	8006fae <cifXReadChannelLayout+0x2fe>
              void*       pvMutex           = NULL;
 8006f48:	4683      	mov	fp, r0
                OS_Memfree(ptIOInputInstance);
 8006f4a:	4650      	mov	r0, sl
 8006f4c:	f7fb fddf 	bl	8002b0e <OS_Memfree>
                OS_DeleteMutex(pvMutex);
 8006f50:	4658      	mov	r0, fp
 8006f52:	f7fb fe61 	bl	8002c18 <OS_DeleteMutex>
                if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8006f56:	4b09      	ldr	r3, [pc, #36]	; (8006f7c <cifXReadChannelLayout+0x2cc>)
 8006f58:	681b      	ldr	r3, [r3, #0]
 8006f5a:	f013 0f08 	tst.w	r3, #8
 8006f5e:	d101      	bne.n	8006f64 <cifXReadChannelLayout+0x2b4>
                lRet = CIFX_INVALID_POINTER;
 8006f60:	4f0c      	ldr	r7, [pc, #48]	; (8006f94 <cifXReadChannelLayout+0x2e4>)
 8006f62:	e6e2      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                  USER_Trace(ptDevInstance,
 8006f64:	4a0f      	ldr	r2, [pc, #60]	; (8006fa4 <cifXReadChannelLayout+0x2f4>)
 8006f66:	2108      	movs	r1, #8
 8006f68:	4640      	mov	r0, r8
 8006f6a:	f002 fb69 	bl	8009640 <USER_Trace>
                lRet = CIFX_INVALID_POINTER;
 8006f6e:	4f09      	ldr	r7, [pc, #36]	; (8006f94 <cifXReadChannelLayout+0x2e4>)
 8006f70:	e6db      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                  ptIOInputInstance->ulNotifyEvent = CIFX_NOTIFY_PD0_IN;
 8006f72:	2203      	movs	r2, #3
 8006f74:	f8ca 2014 	str.w	r2, [sl, #20]
 8006f78:	e7dc      	b.n	8006f34 <cifXReadChannelLayout+0x284>
 8006f7a:	bf00      	nop
 8006f7c:	20000038 	.word	0x20000038
 8006f80:	0800bad0 	.word	0x0800bad0
 8006f84:	0800bb1c 	.word	0x0800bb1c
 8006f88:	0800bb68 	.word	0x0800bb68
 8006f8c:	0800bbbc 	.word	0x0800bbbc
 8006f90:	0800bc28 	.word	0x0800bc28
 8006f94:	800a0001 	.word	0x800a0001
 8006f98:	0800bc6c 	.word	0x0800bc6c
 8006f9c:	0800bcc0 	.word	0x0800bcc0
 8006fa0:	0800bc98 	.word	0x0800bc98
 8006fa4:	0800bd10 	.word	0x0800bd10
                    ptIOInputInstance->bHandshakeBitState = HIL_FLAGS_NOT_EQUAL;
 8006fa8:	2301      	movs	r3, #1
 8006faa:	f88a 300c 	strb.w	r3, [sl, #12]
                ++ptChannel->ulIOInputAreas;
 8006fae:	f8d6 1140 	ldr.w	r1, [r6, #320]	; 0x140
 8006fb2:	3101      	adds	r1, #1
 8006fb4:	f8c6 1140 	str.w	r1, [r6, #320]	; 0x140
                ptChannel->pptIOInputAreas = (PIOINSTANCE*)OS_Memrealloc(ptChannel->pptIOInputAreas,
 8006fb8:	0089      	lsls	r1, r1, #2
 8006fba:	f8d6 013c 	ldr.w	r0, [r6, #316]	; 0x13c
 8006fbe:	f7fb fdaa 	bl	8002b16 <OS_Memrealloc>
 8006fc2:	f8c6 013c 	str.w	r0, [r6, #316]	; 0x13c
                if (NULL == ptChannel->pptIOInputAreas)
 8006fc6:	b1e8      	cbz	r0, 8007004 <cifXReadChannelLayout+0x354>
                  ptChannel->pptIOInputAreas[ptChannel->ulIOInputAreas- 1] = ptIOInputInstance;
 8006fc8:	f8d6 2140 	ldr.w	r2, [r6, #320]	; 0x140
 8006fcc:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 8006fd0:	4413      	add	r3, r2
 8006fd2:	f840 a023 	str.w	sl, [r0, r3, lsl #2]
                  if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8006fd6:	4ba9      	ldr	r3, [pc, #676]	; (800727c <cifXReadChannelLayout+0x5cc>)
 8006fd8:	681b      	ldr	r3, [r3, #0]
 8006fda:	f013 0f01 	tst.w	r3, #1
 8006fde:	f43f aea4 	beq.w	8006d2a <cifXReadChannelLayout+0x7a>
                    USER_Trace(ptDevInstance,
 8006fe2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8006fe4:	9302      	str	r3, [sp, #8]
 8006fe6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8006fe8:	9301      	str	r3, [sp, #4]
 8006fea:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8006fec:	9300      	str	r3, [sp, #0]
 8006fee:	6933      	ldr	r3, [r6, #16]
 8006ff0:	4aa3      	ldr	r2, [pc, #652]	; (8007280 <cifXReadChannelLayout+0x5d0>)
 8006ff2:	2101      	movs	r1, #1
 8006ff4:	4640      	mov	r0, r8
 8006ff6:	f002 fb23 	bl	8009640 <USER_Trace>
 8006ffa:	e696      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                    ptIOInputInstance->bHandshakeBitState = HIL_FLAGS_EQUAL;
 8006ffc:	2300      	movs	r3, #0
 8006ffe:	f88a 300c 	strb.w	r3, [sl, #12]
                  break;
 8007002:	e7d4      	b.n	8006fae <cifXReadChannelLayout+0x2fe>
                  if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007004:	4b9d      	ldr	r3, [pc, #628]	; (800727c <cifXReadChannelLayout+0x5cc>)
 8007006:	681b      	ldr	r3, [r3, #0]
 8007008:	f013 0f08 	tst.w	r3, #8
 800700c:	d101      	bne.n	8007012 <cifXReadChannelLayout+0x362>
                  lRet = CIFX_INVALID_POINTER;
 800700e:	4f9d      	ldr	r7, [pc, #628]	; (8007284 <cifXReadChannelLayout+0x5d4>)
 8007010:	e68b      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                    USER_Trace(ptDevInstance,
 8007012:	4a9d      	ldr	r2, [pc, #628]	; (8007288 <cifXReadChannelLayout+0x5d8>)
 8007014:	2108      	movs	r1, #8
 8007016:	4640      	mov	r0, r8
 8007018:	f002 fb12 	bl	8009640 <USER_Trace>
                  lRet = CIFX_INVALID_POINTER;
 800701c:	4f99      	ldr	r7, [pc, #612]	; (8007284 <cifXReadChannelLayout+0x5d4>)
 800701e:	e684      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
              if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007020:	4a96      	ldr	r2, [pc, #600]	; (800727c <cifXReadChannelLayout+0x5cc>)
 8007022:	6812      	ldr	r2, [r2, #0]
 8007024:	f012 0f08 	tst.w	r2, #8
 8007028:	f43f ae7f 	beq.w	8006d2a <cifXReadChannelLayout+0x7a>
                USER_Trace(ptDevInstance,
 800702c:	9301      	str	r3, [sp, #4]
 800702e:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8007030:	9300      	str	r3, [sp, #0]
 8007032:	6933      	ldr	r3, [r6, #16]
 8007034:	4a95      	ldr	r2, [pc, #596]	; (800728c <cifXReadChannelLayout+0x5dc>)
 8007036:	2108      	movs	r1, #8
 8007038:	4640      	mov	r0, r8
 800703a:	f002 fb01 	bl	8009640 <USER_Trace>
 800703e:	e674      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
          switch(LE16_TO_HOST(tRecvPkt.tData.usFlags) & HIL_DIRECTION_MASK)
 8007040:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
 8007044:	f003 030f 	and.w	r3, r3, #15
 8007048:	2b01      	cmp	r3, #1
 800704a:	d033      	beq.n	80070b4 <cifXReadChannelLayout+0x404>
 800704c:	2b02      	cmp	r3, #2
 800704e:	d166      	bne.n	800711e <cifXReadChannelLayout+0x46e>
              if (NULL == (ptChannel->tSendMbx.pvSendMBXMutex = OS_CreateMutex()))
 8007050:	f7fb fdc1 	bl	8002bd6 <OS_CreateMutex>
 8007054:	f8c6 0084 	str.w	r0, [r6, #132]	; 0x84
 8007058:	b1f0      	cbz	r0, 8007098 <cifXReadChannelLayout+0x3e8>
                ptChannel->tSendMbx.ptSendMailboxStart   = (HIL_DPM_SEND_MAILBOX_BLOCK_T*)( ptChannel->pbDPMChannelStart +
 800705a:	68b3      	ldr	r3, [r6, #8]
                                                                                            LE32_TO_HOST(tRecvPkt.tData.ulOffset));
 800705c:	9912      	ldr	r1, [sp, #72]	; 0x48
                ptChannel->tSendMbx.ptSendMailboxStart   = (HIL_DPM_SEND_MAILBOX_BLOCK_T*)( ptChannel->pbDPMChannelStart +
 800705e:	440b      	add	r3, r1
 8007060:	6773      	str	r3, [r6, #116]	; 0x74
                ptChannel->tSendMbx.ulSendMailboxLength  = LE32_TO_HOST(tRecvPkt.tData.ulSize) -
 8007062:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8007064:	1f03      	subs	r3, r0, #4
 8007066:	67b3      	str	r3, [r6, #120]	; 0x78
                ptChannel->tSendMbx.bSendCMDBitoffset    = (uint8_t)LE16_TO_HOST(tRecvPkt.tData.usHandshakeBit);
 8007068:	f89d 2054 	ldrb.w	r2, [sp, #84]	; 0x54
 800706c:	f886 2080 	strb.w	r2, [r6, #128]	; 0x80
                ptChannel->tSendMbx.ulSendCMDBitmask     = (1 << ptChannel->tSendMbx.bSendCMDBitoffset);
 8007070:	2301      	movs	r3, #1
 8007072:	4093      	lsls	r3, r2
 8007074:	67f3      	str	r3, [r6, #124]	; 0x7c
                if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8007076:	4b81      	ldr	r3, [pc, #516]	; (800727c <cifXReadChannelLayout+0x5cc>)
 8007078:	681b      	ldr	r3, [r3, #0]
 800707a:	f013 0f01 	tst.w	r3, #1
 800707e:	f43f ae54 	beq.w	8006d2a <cifXReadChannelLayout+0x7a>
                  USER_Trace(ptDevInstance,
 8007082:	9002      	str	r0, [sp, #8]
 8007084:	9101      	str	r1, [sp, #4]
 8007086:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8007088:	9300      	str	r3, [sp, #0]
 800708a:	6933      	ldr	r3, [r6, #16]
 800708c:	4a80      	ldr	r2, [pc, #512]	; (8007290 <cifXReadChannelLayout+0x5e0>)
 800708e:	2101      	movs	r1, #1
 8007090:	4640      	mov	r0, r8
 8007092:	f002 fad5 	bl	8009640 <USER_Trace>
 8007096:	e648      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007098:	4b78      	ldr	r3, [pc, #480]	; (800727c <cifXReadChannelLayout+0x5cc>)
 800709a:	681b      	ldr	r3, [r3, #0]
 800709c:	f013 0f08 	tst.w	r3, #8
 80070a0:	d101      	bne.n	80070a6 <cifXReadChannelLayout+0x3f6>
                lRet = CIFX_INVALID_POINTER;
 80070a2:	4f78      	ldr	r7, [pc, #480]	; (8007284 <cifXReadChannelLayout+0x5d4>)
 80070a4:	e641      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                  USER_Trace(ptDevInstance,
 80070a6:	4a7b      	ldr	r2, [pc, #492]	; (8007294 <cifXReadChannelLayout+0x5e4>)
 80070a8:	2108      	movs	r1, #8
 80070aa:	4640      	mov	r0, r8
 80070ac:	f002 fac8 	bl	8009640 <USER_Trace>
                lRet = CIFX_INVALID_POINTER;
 80070b0:	4f74      	ldr	r7, [pc, #464]	; (8007284 <cifXReadChannelLayout+0x5d4>)
 80070b2:	e63a      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
              if (NULL == (ptChannel->tRecvMbx.pvRecvMBXMutex = OS_CreateMutex()))
 80070b4:	f7fb fd8f 	bl	8002bd6 <OS_CreateMutex>
 80070b8:	f8c6 00a4 	str.w	r0, [r6, #164]	; 0xa4
 80070bc:	b308      	cbz	r0, 8007102 <cifXReadChannelLayout+0x452>
                ptChannel->tRecvMbx.ptRecvMailboxStart  = (HIL_DPM_RECV_MAILBOX_BLOCK_T*)( ptChannel->pbDPMChannelStart +
 80070be:	68b3      	ldr	r3, [r6, #8]
                                                                                           LE32_TO_HOST(tRecvPkt.tData.ulOffset));
 80070c0:	9912      	ldr	r1, [sp, #72]	; 0x48
                ptChannel->tRecvMbx.ptRecvMailboxStart  = (HIL_DPM_RECV_MAILBOX_BLOCK_T*)( ptChannel->pbDPMChannelStart +
 80070c2:	440b      	add	r3, r1
 80070c4:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
                ptChannel->tRecvMbx.ulRecvMailboxLength = LE32_TO_HOST(tRecvPkt.tData.ulSize) -
 80070c8:	9813      	ldr	r0, [sp, #76]	; 0x4c
 80070ca:	1f03      	subs	r3, r0, #4
 80070cc:	f8c6 3098 	str.w	r3, [r6, #152]	; 0x98
                ptChannel->tRecvMbx.bRecvACKBitoffset   = (uint8_t)LE16_TO_HOST(tRecvPkt.tData.usHandshakeBit);
 80070d0:	f89d 2054 	ldrb.w	r2, [sp, #84]	; 0x54
 80070d4:	f886 20a0 	strb.w	r2, [r6, #160]	; 0xa0
                ptChannel->tRecvMbx.ulRecvACKBitmask    = (1 << ptChannel->tRecvMbx.bRecvACKBitoffset);
 80070d8:	2301      	movs	r3, #1
 80070da:	4093      	lsls	r3, r2
 80070dc:	f8c6 309c 	str.w	r3, [r6, #156]	; 0x9c
                if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 80070e0:	4b66      	ldr	r3, [pc, #408]	; (800727c <cifXReadChannelLayout+0x5cc>)
 80070e2:	681b      	ldr	r3, [r3, #0]
 80070e4:	f013 0f01 	tst.w	r3, #1
 80070e8:	f43f ae1f 	beq.w	8006d2a <cifXReadChannelLayout+0x7a>
                  USER_Trace(ptDevInstance,
 80070ec:	9002      	str	r0, [sp, #8]
 80070ee:	9101      	str	r1, [sp, #4]
 80070f0:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80070f2:	9300      	str	r3, [sp, #0]
 80070f4:	6933      	ldr	r3, [r6, #16]
 80070f6:	4a68      	ldr	r2, [pc, #416]	; (8007298 <cifXReadChannelLayout+0x5e8>)
 80070f8:	2101      	movs	r1, #1
 80070fa:	4640      	mov	r0, r8
 80070fc:	f002 faa0 	bl	8009640 <USER_Trace>
 8007100:	e613      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007102:	4b5e      	ldr	r3, [pc, #376]	; (800727c <cifXReadChannelLayout+0x5cc>)
 8007104:	681b      	ldr	r3, [r3, #0]
 8007106:	f013 0f08 	tst.w	r3, #8
 800710a:	d101      	bne.n	8007110 <cifXReadChannelLayout+0x460>
                lRet = CIFX_INVALID_POINTER;
 800710c:	4f5d      	ldr	r7, [pc, #372]	; (8007284 <cifXReadChannelLayout+0x5d4>)
 800710e:	e60c      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                  USER_Trace(ptDevInstance,
 8007110:	4a62      	ldr	r2, [pc, #392]	; (800729c <cifXReadChannelLayout+0x5ec>)
 8007112:	2108      	movs	r1, #8
 8007114:	4640      	mov	r0, r8
 8007116:	f002 fa93 	bl	8009640 <USER_Trace>
                lRet = CIFX_INVALID_POINTER;
 800711a:	4f5a      	ldr	r7, [pc, #360]	; (8007284 <cifXReadChannelLayout+0x5d4>)
 800711c:	e605      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
              if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 800711e:	4a57      	ldr	r2, [pc, #348]	; (800727c <cifXReadChannelLayout+0x5cc>)
 8007120:	6812      	ldr	r2, [r2, #0]
 8007122:	f012 0f08 	tst.w	r2, #8
 8007126:	f43f ae00 	beq.w	8006d2a <cifXReadChannelLayout+0x7a>
                USER_Trace(ptDevInstance,
 800712a:	9301      	str	r3, [sp, #4]
 800712c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800712e:	9300      	str	r3, [sp, #0]
 8007130:	6933      	ldr	r3, [r6, #16]
 8007132:	4a5b      	ldr	r2, [pc, #364]	; (80072a0 <cifXReadChannelLayout+0x5f0>)
 8007134:	2108      	movs	r1, #8
 8007136:	4640      	mov	r0, r8
 8007138:	f002 fa82 	bl	8009640 <USER_Trace>
 800713c:	e5f5      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
          ptChannel->ptControlBlock     = (HIL_DPM_CONTROL_BLOCK_T*)( ptChannel->pbDPMChannelStart +
 800713e:	68b3      	ldr	r3, [r6, #8]
                                                                      LE32_TO_HOST(tRecvPkt.tData.ulOffset));
 8007140:	9a12      	ldr	r2, [sp, #72]	; 0x48
          ptChannel->ptControlBlock     = (HIL_DPM_CONTROL_BLOCK_T*)( ptChannel->pbDPMChannelStart +
 8007142:	4413      	add	r3, r2
 8007144:	f8c6 30d0 	str.w	r3, [r6, #208]	; 0xd0
          ptChannel->bControlBlockBit   = (uint8_t)LE16_TO_HOST(tRecvPkt.tData.usHandshakeBit);
 8007148:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 800714c:	f886 30d4 	strb.w	r3, [r6, #212]	; 0xd4
          ptChannel->ulControlBlockSize = LE32_TO_HOST(tRecvPkt.tData.ulSize);
 8007150:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8007152:	f8c6 30d8 	str.w	r3, [r6, #216]	; 0xd8
          if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8007156:	4949      	ldr	r1, [pc, #292]	; (800727c <cifXReadChannelLayout+0x5cc>)
 8007158:	6809      	ldr	r1, [r1, #0]
 800715a:	f011 0f01 	tst.w	r1, #1
 800715e:	f43f ade4 	beq.w	8006d2a <cifXReadChannelLayout+0x7a>
            USER_Trace(ptDevInstance,
 8007162:	9302      	str	r3, [sp, #8]
 8007164:	9201      	str	r2, [sp, #4]
 8007166:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8007168:	9300      	str	r3, [sp, #0]
 800716a:	6933      	ldr	r3, [r6, #16]
 800716c:	4a4d      	ldr	r2, [pc, #308]	; (80072a4 <cifXReadChannelLayout+0x5f4>)
 800716e:	2101      	movs	r1, #1
 8007170:	4640      	mov	r0, r8
 8007172:	f002 fa65 	bl	8009640 <USER_Trace>
 8007176:	e5d8      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
          ptChannel->ptCommonStatusBlock = (HIL_DPM_COMMON_STATUS_BLOCK_T*)(ptChannel->pbDPMChannelStart +
 8007178:	68b3      	ldr	r3, [r6, #8]
                                                                            LE32_TO_HOST(tRecvPkt.tData.ulOffset));
 800717a:	9a12      	ldr	r2, [sp, #72]	; 0x48
          ptChannel->ptCommonStatusBlock = (HIL_DPM_COMMON_STATUS_BLOCK_T*)(ptChannel->pbDPMChannelStart +
 800717c:	4413      	add	r3, r2
 800717e:	f8c6 30dc 	str.w	r3, [r6, #220]	; 0xdc
          ptChannel->bCommonStatusBit    = (uint8_t)LE16_TO_HOST(tRecvPkt.tData.usHandshakeBit);
 8007182:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 8007186:	f886 30e0 	strb.w	r3, [r6, #224]	; 0xe0
          ptChannel->ulCommonStatusSize  = LE32_TO_HOST(tRecvPkt.tData.ulSize);
 800718a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800718c:	f8c6 30e4 	str.w	r3, [r6, #228]	; 0xe4
          if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8007190:	493a      	ldr	r1, [pc, #232]	; (800727c <cifXReadChannelLayout+0x5cc>)
 8007192:	6809      	ldr	r1, [r1, #0]
 8007194:	f011 0f01 	tst.w	r1, #1
 8007198:	f43f adc7 	beq.w	8006d2a <cifXReadChannelLayout+0x7a>
            USER_Trace(ptDevInstance,
 800719c:	9302      	str	r3, [sp, #8]
 800719e:	9201      	str	r2, [sp, #4]
 80071a0:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80071a2:	9300      	str	r3, [sp, #0]
 80071a4:	6933      	ldr	r3, [r6, #16]
 80071a6:	4a40      	ldr	r2, [pc, #256]	; (80072a8 <cifXReadChannelLayout+0x5f8>)
 80071a8:	2101      	movs	r1, #1
 80071aa:	4640      	mov	r0, r8
 80071ac:	f002 fa48 	bl	8009640 <USER_Trace>
 80071b0:	e5bb      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
          ptChannel->ptExtendedStatusBlock = (HIL_DPM_EXTENDED_STATUS_BLOCK_T*)(ptChannel->pbDPMChannelStart +
 80071b2:	68b3      	ldr	r3, [r6, #8]
                                                                                LE32_TO_HOST(tRecvPkt.tData.ulOffset));
 80071b4:	9a12      	ldr	r2, [sp, #72]	; 0x48
          ptChannel->ptExtendedStatusBlock = (HIL_DPM_EXTENDED_STATUS_BLOCK_T*)(ptChannel->pbDPMChannelStart +
 80071b6:	4413      	add	r3, r2
 80071b8:	f8c6 30e8 	str.w	r3, [r6, #232]	; 0xe8
          ptChannel->bExtendedStatusBit    = (uint8_t)LE16_TO_HOST(tRecvPkt.tData.usHandshakeBit);
 80071bc:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 80071c0:	f886 30ec 	strb.w	r3, [r6, #236]	; 0xec
          ptChannel->ulExtendedStatusSize  = LE32_TO_HOST(tRecvPkt.tData.ulSize);
 80071c4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80071c6:	f8c6 30f0 	str.w	r3, [r6, #240]	; 0xf0
          if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 80071ca:	492c      	ldr	r1, [pc, #176]	; (800727c <cifXReadChannelLayout+0x5cc>)
 80071cc:	6809      	ldr	r1, [r1, #0]
 80071ce:	f011 0f01 	tst.w	r1, #1
 80071d2:	f43f adaa 	beq.w	8006d2a <cifXReadChannelLayout+0x7a>
            USER_Trace(ptDevInstance,
 80071d6:	9302      	str	r3, [sp, #8]
 80071d8:	9201      	str	r2, [sp, #4]
 80071da:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80071dc:	9300      	str	r3, [sp, #0]
 80071de:	6933      	ldr	r3, [r6, #16]
 80071e0:	4a32      	ldr	r2, [pc, #200]	; (80072ac <cifXReadChannelLayout+0x5fc>)
 80071e2:	2101      	movs	r1, #1
 80071e4:	4640      	mov	r0, r8
 80071e6:	f002 fa2b 	bl	8009640 <USER_Trace>
 80071ea:	e59e      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
          PUSERINSTANCE ptUserInstance = (PUSERINSTANCE)OS_Memalloc(sizeof(*ptUserInstance));
 80071ec:	2008      	movs	r0, #8
 80071ee:	f7fb fc8a 	bl	8002b06 <OS_Memalloc>
          if (NULL == ptUserInstance)
 80071f2:	4682      	mov	sl, r0
 80071f4:	2800      	cmp	r0, #0
 80071f6:	d033      	beq.n	8007260 <cifXReadChannelLayout+0x5b0>
            OS_Memset(ptUserInstance, 0, sizeof(*ptUserInstance));
 80071f8:	2208      	movs	r2, #8
 80071fa:	2100      	movs	r1, #0
 80071fc:	f7fb fc8f 	bl	8002b1e <OS_Memset>
            ptUserInstance->pbUserBlockStart  = ptChannel->pbDPMChannelStart +
 8007200:	68b3      	ldr	r3, [r6, #8]
                                                LE32_TO_HOST(tRecvPkt.tData.ulOffset);
 8007202:	9a12      	ldr	r2, [sp, #72]	; 0x48
            ptUserInstance->pbUserBlockStart  = ptChannel->pbDPMChannelStart +
 8007204:	4413      	add	r3, r2
 8007206:	f8ca 3000 	str.w	r3, [sl]
            ptUserInstance->ulUserBlockLength = LE32_TO_HOST(tRecvPkt.tData.ulSize);
 800720a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800720c:	f8ca 3004 	str.w	r3, [sl, #4]
            ++ptChannel->ulUserAreas;
 8007210:	f8d6 1150 	ldr.w	r1, [r6, #336]	; 0x150
 8007214:	3101      	adds	r1, #1
 8007216:	f8c6 1150 	str.w	r1, [r6, #336]	; 0x150
            ptChannel->pptUserAreas = (PUSERINSTANCE*)OS_Memrealloc(ptChannel->pptUserAreas,
 800721a:	0089      	lsls	r1, r1, #2
 800721c:	f8d6 014c 	ldr.w	r0, [r6, #332]	; 0x14c
 8007220:	f7fb fc79 	bl	8002b16 <OS_Memrealloc>
 8007224:	f8c6 014c 	str.w	r0, [r6, #332]	; 0x14c
            if (NULL == ptChannel->pptUserAreas)
 8007228:	2800      	cmp	r0, #0
 800722a:	d045      	beq.n	80072b8 <cifXReadChannelLayout+0x608>
              ptChannel->pptUserAreas[ptChannel->ulUserAreas- 1] = ptUserInstance;
 800722c:	f8d6 2150 	ldr.w	r2, [r6, #336]	; 0x150
 8007230:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 8007234:	4413      	add	r3, r2
 8007236:	f840 a023 	str.w	sl, [r0, r3, lsl #2]
              if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 800723a:	4b10      	ldr	r3, [pc, #64]	; (800727c <cifXReadChannelLayout+0x5cc>)
 800723c:	681b      	ldr	r3, [r3, #0]
 800723e:	f013 0f01 	tst.w	r3, #1
 8007242:	f43f ad72 	beq.w	8006d2a <cifXReadChannelLayout+0x7a>
                USER_Trace(ptDevInstance,
 8007246:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8007248:	9302      	str	r3, [sp, #8]
 800724a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800724c:	9301      	str	r3, [sp, #4]
 800724e:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8007250:	9300      	str	r3, [sp, #0]
 8007252:	6933      	ldr	r3, [r6, #16]
 8007254:	4a16      	ldr	r2, [pc, #88]	; (80072b0 <cifXReadChannelLayout+0x600>)
 8007256:	2101      	movs	r1, #1
 8007258:	4640      	mov	r0, r8
 800725a:	f002 f9f1 	bl	8009640 <USER_Trace>
 800725e:	e564      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
            if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007260:	4b06      	ldr	r3, [pc, #24]	; (800727c <cifXReadChannelLayout+0x5cc>)
 8007262:	681b      	ldr	r3, [r3, #0]
 8007264:	f013 0f08 	tst.w	r3, #8
 8007268:	d101      	bne.n	800726e <cifXReadChannelLayout+0x5be>
            lRet = CIFX_INVALID_POINTER;
 800726a:	4f06      	ldr	r7, [pc, #24]	; (8007284 <cifXReadChannelLayout+0x5d4>)
 800726c:	e55d      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
              USER_Trace(ptDevInstance,
 800726e:	4a11      	ldr	r2, [pc, #68]	; (80072b4 <cifXReadChannelLayout+0x604>)
 8007270:	2108      	movs	r1, #8
 8007272:	4640      	mov	r0, r8
 8007274:	f002 f9e4 	bl	8009640 <USER_Trace>
            lRet = CIFX_INVALID_POINTER;
 8007278:	4f02      	ldr	r7, [pc, #8]	; (8007284 <cifXReadChannelLayout+0x5d4>)
 800727a:	e556      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
 800727c:	20000038 	.word	0x20000038
 8007280:	0800bd64 	.word	0x0800bd64
 8007284:	800a0001 	.word	0x800a0001
 8007288:	0800bd3c 	.word	0x0800bd3c
 800728c:	0800bdb4 	.word	0x0800bdb4
 8007290:	0800be1c 	.word	0x0800be1c
 8007294:	0800bdf4 	.word	0x0800bdf4
 8007298:	0800be94 	.word	0x0800be94
 800729c:	0800be6c 	.word	0x0800be6c
 80072a0:	0800bee4 	.word	0x0800bee4
 80072a4:	0800bf28 	.word	0x0800bf28
 80072a8:	0800bf78 	.word	0x0800bf78
 80072ac:	0800bfc8 	.word	0x0800bfc8
 80072b0:	0800c068 	.word	0x0800c068
 80072b4:	0800c018 	.word	0x0800c018
              OS_Memfree(ptUserInstance);
 80072b8:	4650      	mov	r0, sl
 80072ba:	f7fb fc28 	bl	8002b0e <OS_Memfree>
              if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80072be:	4b18      	ldr	r3, [pc, #96]	; (8007320 <cifXReadChannelLayout+0x670>)
 80072c0:	681b      	ldr	r3, [r3, #0]
 80072c2:	f013 0f08 	tst.w	r3, #8
 80072c6:	d101      	bne.n	80072cc <cifXReadChannelLayout+0x61c>
              lRet = CIFX_INVALID_POINTER;
 80072c8:	4f16      	ldr	r7, [pc, #88]	; (8007324 <cifXReadChannelLayout+0x674>)
 80072ca:	e52e      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
                USER_Trace(ptDevInstance,
 80072cc:	4a16      	ldr	r2, [pc, #88]	; (8007328 <cifXReadChannelLayout+0x678>)
 80072ce:	2108      	movs	r1, #8
 80072d0:	4640      	mov	r0, r8
 80072d2:	f002 f9b5 	bl	8009640 <USER_Trace>
              lRet = CIFX_INVALID_POINTER;
 80072d6:	4f13      	ldr	r7, [pc, #76]	; (8007324 <cifXReadChannelLayout+0x674>)
 80072d8:	e527      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80072da:	4a11      	ldr	r2, [pc, #68]	; (8007320 <cifXReadChannelLayout+0x670>)
 80072dc:	6812      	ldr	r2, [r2, #0]
 80072de:	f012 0f08 	tst.w	r2, #8
 80072e2:	f43f ad22 	beq.w	8006d2a <cifXReadChannelLayout+0x7a>
            USER_Trace(ptDevInstance,
 80072e6:	9303      	str	r3, [sp, #12]
 80072e8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80072ea:	9302      	str	r3, [sp, #8]
 80072ec:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80072ee:	9301      	str	r3, [sp, #4]
 80072f0:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80072f2:	9300      	str	r3, [sp, #0]
 80072f4:	6933      	ldr	r3, [r6, #16]
 80072f6:	4a0d      	ldr	r2, [pc, #52]	; (800732c <cifXReadChannelLayout+0x67c>)
 80072f8:	2108      	movs	r1, #8
 80072fa:	4640      	mov	r0, r8
 80072fc:	f002 f9a0 	bl	8009640 <USER_Trace>
 8007300:	e513      	b.n	8006d2a <cifXReadChannelLayout+0x7a>
  if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8007302:	4b07      	ldr	r3, [pc, #28]	; (8007320 <cifXReadChannelLayout+0x670>)
 8007304:	681b      	ldr	r3, [r3, #0]
 8007306:	f013 0f01 	tst.w	r3, #1
 800730a:	d103      	bne.n	8007314 <cifXReadChannelLayout+0x664>
}
 800730c:	4638      	mov	r0, r7
 800730e:	b023      	add	sp, #140	; 0x8c
 8007310:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    USER_Trace(ptDevInstance,
 8007314:	4a06      	ldr	r2, [pc, #24]	; (8007330 <cifXReadChannelLayout+0x680>)
 8007316:	2101      	movs	r1, #1
 8007318:	4640      	mov	r0, r8
 800731a:	f002 f991 	bl	8009640 <USER_Trace>
  return lRet;
 800731e:	e7f5      	b.n	800730c <cifXReadChannelLayout+0x65c>
 8007320:	20000038 	.word	0x20000038
 8007324:	800a0001 	.word	0x800a0001
 8007328:	0800c044 	.word	0x0800c044
 800732c:	0800c0b8 	.word	0x0800c0b8
 8007330:	0800bb1c 	.word	0x0800bb1c

08007334 <cifXCreateSystemDevice>:
{
 8007334:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007338:	b08b      	sub	sp, #44	; 0x2c
 800733a:	4604      	mov	r4, r0
  uint8_t*                        pbDpm            = ptDevInstance->pbDPM;
 800733c:	6a07      	ldr	r7, [r0, #32]
  PCHANNELINSTANCE                ptSystemDevice   = &ptDevInstance->tSystemDevice;
 800733e:	f100 0bf4 	add.w	fp, r0, #244	; 0xf4
  if (NULL == (pvSendMBXMutex = OS_CreateMutex()) ||
 8007342:	f7fb fc48 	bl	8002bd6 <OS_CreateMutex>
 8007346:	4605      	mov	r5, r0
 8007348:	2800      	cmp	r0, #0
 800734a:	f000 80a6 	beq.w	800749a <cifXCreateSystemDevice+0x166>
      NULL == (pvRecvMBXMutex = OS_CreateMutex()) ||
 800734e:	f7fb fc42 	bl	8002bd6 <OS_CreateMutex>
  if (NULL == (pvSendMBXMutex = OS_CreateMutex()) ||
 8007352:	4606      	mov	r6, r0
 8007354:	2800      	cmp	r0, #0
 8007356:	f000 80a4 	beq.w	80074a2 <cifXCreateSystemDevice+0x16e>
      NULL == (pvInitMutex    = OS_CreateMutex()) ||
 800735a:	f7fb fc3c 	bl	8002bd6 <OS_CreateMutex>
      NULL == (pvRecvMBXMutex = OS_CreateMutex()) ||
 800735e:	4680      	mov	r8, r0
 8007360:	2800      	cmp	r0, #0
 8007362:	f000 80b6 	beq.w	80074d2 <cifXCreateSystemDevice+0x19e>
      NULL == (pvLock         = OS_CreateLock())  )
 8007366:	f7fb fc38 	bl	8002bda <OS_CreateLock>
      NULL == (pvInitMutex    = OS_CreateMutex()) ||
 800736a:	4681      	mov	r9, r0
 800736c:	2800      	cmp	r0, #0
 800736e:	f000 809a 	beq.w	80074a6 <cifXCreateSystemDevice+0x172>
    OS_Memset(&tDevInfo, 0, sizeof(tDevInfo));
 8007372:	2210      	movs	r2, #16
 8007374:	2100      	movs	r1, #0
 8007376:	a806      	add	r0, sp, #24
 8007378:	f7fb fbd1 	bl	8002b1e <OS_Memset>
    ulMBXSize        = LE16_TO_HOST(HWIF_READ16(ptDevInstance, ptSysChannelInfo->usSizeOfMailbox)) / 2;
 800737c:	f107 0138 	add.w	r1, r7, #56	; 0x38
 8007380:	4620      	mov	r0, r4
 8007382:	f7fd ffa7 	bl	80052d4 <HwIfRead16>
 8007386:	f3c0 034f 	ubfx	r3, r0, #1, #16
 800738a:	9303      	str	r3, [sp, #12]
    ulSysChannelSize = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysChannelInfo->ulSizeOfChannel));
 800738c:	f107 0134 	add.w	r1, r7, #52	; 0x34
 8007390:	4620      	mov	r0, r4
 8007392:	f7fd ffb2 	bl	80052fa <HwIfRead32>
 8007396:	9002      	str	r0, [sp, #8]
    ptDevInstance->ptGlobalRegisters = (PNETX_GLOBAL_REG_BLOCK)(ptDevInstance->pbDPM +
 8007398:	6a23      	ldr	r3, [r4, #32]
                                                                ptDevInstance->ulDPMSize -
 800739a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800739c:	f5a2 7200 	sub.w	r2, r2, #512	; 0x200
 80073a0:	4413      	add	r3, r2
    ptDevInstance->ptGlobalRegisters = (PNETX_GLOBAL_REG_BLOCK)(ptDevInstance->pbDPM +
 80073a2:	6523      	str	r3, [r4, #80]	; 0x50
    ptDevInstance->ulDeviceNumber = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysChannel->tSystemInfo.ulDeviceNumber));
 80073a4:	f107 0108 	add.w	r1, r7, #8
 80073a8:	4620      	mov	r0, r4
 80073aa:	f7fd ffa6 	bl	80052fa <HwIfRead32>
 80073ae:	65a0      	str	r0, [r4, #88]	; 0x58
    ptDevInstance->ulSerialNumber = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysChannel->tSystemInfo.ulSerialNumber));
 80073b0:	f107 010c 	add.w	r1, r7, #12
 80073b4:	4620      	mov	r0, r4
 80073b6:	f7fd ffa0 	bl	80052fa <HwIfRead32>
 80073ba:	6560      	str	r0, [r4, #84]	; 0x54
    ptDevInstance->ulSlotNumber   = HWIF_READ8(ptDevInstance, ptSysChannel->tSystemInfo.bDevIdNumber);
 80073bc:	f107 012c 	add.w	r1, r7, #44	; 0x2c
 80073c0:	4620      	mov	r0, r4
 80073c2:	f7fd ff59 	bl	8005278 <HwIfRead8>
 80073c6:	65e0      	str	r0, [r4, #92]	; 0x5c
    if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 80073c8:	4b84      	ldr	r3, [pc, #528]	; (80075dc <cifXCreateSystemDevice+0x2a8>)
 80073ca:	681b      	ldr	r3, [r3, #0]
 80073cc:	f013 0f01 	tst.w	r3, #1
 80073d0:	f040 8088 	bne.w	80074e4 <cifXCreateSystemDevice+0x1b0>
    tDevInfo.ulDeviceNumber   = ptDevInstance->ulDeviceNumber;
 80073d4:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80073d6:	9306      	str	r3, [sp, #24]
    tDevInfo.ulSerialNumber   = ptDevInstance->ulSerialNumber;
 80073d8:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80073da:	9307      	str	r3, [sp, #28]
    tDevInfo.ptDeviceInstance = ptDevInstance;
 80073dc:	9409      	str	r4, [sp, #36]	; 0x24
    USER_GetAliasName(&tDevInfo, sizeof(ptDevInstance->szAlias), ptDevInstance->szAlias);
 80073de:	f104 0339 	add.w	r3, r4, #57	; 0x39
 80073e2:	469a      	mov	sl, r3
 80073e4:	461a      	mov	r2, r3
 80073e6:	2110      	movs	r1, #16
 80073e8:	a806      	add	r0, sp, #24
 80073ea:	f002 f924 	bl	8009636 <USER_GetAliasName>
    if(OS_Strlen(ptDevInstance->szAlias) > 0)
 80073ee:	f8cd a010 	str.w	sl, [sp, #16]
 80073f2:	4650      	mov	r0, sl
 80073f4:	f7fb fc7c 	bl	8002cf0 <OS_Strlen>
 80073f8:	2800      	cmp	r0, #0
 80073fa:	f300 808b 	bgt.w	8007514 <cifXCreateSystemDevice+0x1e0>
    ptDevInstance->pbHandshakeBlock     = &pbDpm[ulSysChannelSize];
 80073fe:	9b02      	ldr	r3, [sp, #8]
 8007400:	18fb      	adds	r3, r7, r3
 8007402:	6623      	str	r3, [r4, #96]	; 0x60
    ptSystemDevice->ptHandshakeCell     = (HIL_DPM_HANDSHAKE_CELL_T*)ptDevInstance->pbHandshakeBlock;
 8007404:	f8c4 31e8 	str.w	r3, [r4, #488]	; 0x1e8
    ptSystemDevice->pbDPMChannelStart   = pbDpm;
 8007408:	f8c4 70fc 	str.w	r7, [r4, #252]	; 0xfc
    ptSystemDevice->bHandshakeWidth     = HIL_HANDSHAKE_SIZE_8BIT;
 800740c:	f04f 0a01 	mov.w	sl, #1
 8007410:	f884 a1ec 	strb.w	sl, [r4, #492]	; 0x1ec
    ptSystemDevice->tSendMbx.pvSendMBXMutex      = pvSendMBXMutex;
 8007414:	f8c4 5178 	str.w	r5, [r4, #376]	; 0x178
    ptSystemDevice->tSendMbx.bSendCMDBitoffset   = HSF_SEND_MBX_CMD_BIT_NO;
 8007418:	2304      	movs	r3, #4
 800741a:	f884 3174 	strb.w	r3, [r4, #372]	; 0x174
    ptSystemDevice->tSendMbx.ulSendCMDBitmask    = 1 << HSF_SEND_MBX_CMD_BIT_NO;
 800741e:	2310      	movs	r3, #16
 8007420:	f8c4 3170 	str.w	r3, [r4, #368]	; 0x170
                                                   (pbDpm + LE16_TO_HOST(HWIF_READ16(ptDevInstance, ptSysChannelInfo->usMailboxStartOffset)));
 8007424:	f107 013a 	add.w	r1, r7, #58	; 0x3a
 8007428:	4620      	mov	r0, r4
 800742a:	f7fd ff53 	bl	80052d4 <HwIfRead16>
 800742e:	4407      	add	r7, r0
    ptSystemDevice->tSendMbx.ptSendMailboxStart  = (HIL_DPM_SEND_MAILBOX_BLOCK_T*)
 8007430:	f8c4 7168 	str.w	r7, [r4, #360]	; 0x168
    ptSystemDevice->tSendMbx.ulSendMailboxLength = ulMBXSize -
 8007434:	9903      	ldr	r1, [sp, #12]
 8007436:	1f0b      	subs	r3, r1, #4
 8007438:	f8c4 316c 	str.w	r3, [r4, #364]	; 0x16c
    ptSystemDevice->tRecvMbx.pvRecvMBXMutex      = pvRecvMBXMutex;
 800743c:	f8c4 6198 	str.w	r6, [r4, #408]	; 0x198
    ptSystemDevice->tRecvMbx.bRecvACKBitoffset   = HSF_RECV_MBX_ACK_BIT_NO;
 8007440:	2205      	movs	r2, #5
 8007442:	f884 2194 	strb.w	r2, [r4, #404]	; 0x194
    ptSystemDevice->tRecvMbx.ulRecvACKBitmask    = (1 << HSF_RECV_MBX_ACK_BIT_NO);
 8007446:	2220      	movs	r2, #32
 8007448:	f8c4 2190 	str.w	r2, [r4, #400]	; 0x190
    ptSystemDevice->tRecvMbx.ptRecvMailboxStart  = (HIL_DPM_RECV_MAILBOX_BLOCK_T*)( (uint8_t*)(ptSystemDevice->tSendMbx.ptSendMailboxStart) + ulMBXSize);
 800744c:	440f      	add	r7, r1
 800744e:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    ptSystemDevice->tRecvMbx.ulRecvMailboxLength = ulMBXSize -
 8007452:	f8c4 318c 	str.w	r3, [r4, #396]	; 0x18c
    ptSystemDevice->ulDPMChannelLength  = ulSysChannelSize;
 8007456:	9b02      	ldr	r3, [sp, #8]
 8007458:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
    ptSystemDevice->pvLock              = pvLock;
 800745c:	f8c4 910c 	str.w	r9, [r4, #268]	; 0x10c
    ptSystemDevice->pvInitMutex         = pvInitMutex;
 8007460:	f8c4 80f8 	str.w	r8, [r4, #248]	; 0xf8
    ptSystemDevice->pvDeviceInstance    = (void*)ptDevInstance;
 8007464:	f8c4 40f4 	str.w	r4, [r4, #244]	; 0xf4
    ptSystemDevice->fIsSysDevice        = 1;
 8007468:	f8c4 a114 	str.w	sl, [r4, #276]	; 0x114
    DEV_ReadHostFlags(&ptDevInstance->tSystemDevice, 1);
 800746c:	4651      	mov	r1, sl
 800746e:	4658      	mov	r0, fp
 8007470:	f7fd ff53 	bl	800531a <DEV_ReadHostFlags>
    DEV_ReadHandshakeFlags(&ptDevInstance->tSystemDevice, 1, 0);
 8007474:	2200      	movs	r2, #0
 8007476:	4651      	mov	r1, sl
 8007478:	4658      	mov	r0, fp
 800747a:	f7fd ff86 	bl	800538a <DEV_ReadHandshakeFlags>
    if (!DEV_WaitForReady_Poll( &ptDevInstance->tSystemDevice, CIFX_TO_FIRMWARE_START))
 800747e:	f644 6120 	movw	r1, #20000	; 0x4e20
 8007482:	4658      	mov	r0, fp
 8007484:	f7fe fb64 	bl	8005b50 <DEV_WaitForReady_Poll>
 8007488:	2800      	cmp	r0, #0
 800748a:	d17f      	bne.n	800758c <cifXCreateSystemDevice+0x258>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 800748c:	4b53      	ldr	r3, [pc, #332]	; (80075dc <cifXCreateSystemDevice+0x2a8>)
 800748e:	681b      	ldr	r3, [r3, #0]
 8007490:	f013 0f08 	tst.w	r3, #8
 8007494:	d172      	bne.n	800757c <cifXCreateSystemDevice+0x248>
      lRet = CIFX_DEV_NOT_READY;
 8007496:	4d52      	ldr	r5, [pc, #328]	; (80075e0 <cifXCreateSystemDevice+0x2ac>)
 8007498:	e079      	b.n	800758e <cifXCreateSystemDevice+0x25a>
  void*                     pvLock           = NULL;
 800749a:	4681      	mov	r9, r0
  void*                     pvInitMutex      = NULL;
 800749c:	4680      	mov	r8, r0
  void*                     pvRecvMBXMutex   = NULL;
 800749e:	4606      	mov	r6, r0
 80074a0:	e001      	b.n	80074a6 <cifXCreateSystemDevice+0x172>
  void*                     pvLock           = NULL;
 80074a2:	4681      	mov	r9, r0
  void*                     pvInitMutex      = NULL;
 80074a4:	4680      	mov	r8, r0
    OS_DeleteMutex(pvSendMBXMutex);
 80074a6:	4628      	mov	r0, r5
 80074a8:	f7fb fbb6 	bl	8002c18 <OS_DeleteMutex>
    OS_DeleteMutex(pvRecvMBXMutex);
 80074ac:	4630      	mov	r0, r6
 80074ae:	f7fb fbb3 	bl	8002c18 <OS_DeleteMutex>
    OS_DeleteMutex(pvInitMutex);
 80074b2:	4640      	mov	r0, r8
 80074b4:	f7fb fbb0 	bl	8002c18 <OS_DeleteMutex>
    OS_DeleteLock(pvLock);
 80074b8:	4648      	mov	r0, r9
 80074ba:	f7fb fb8b 	bl	8002bd4 <OS_DeleteLock>
    if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80074be:	4b47      	ldr	r3, [pc, #284]	; (80075dc <cifXCreateSystemDevice+0x2a8>)
 80074c0:	681b      	ldr	r3, [r3, #0]
 80074c2:	f013 0f08 	tst.w	r3, #8
 80074c6:	d106      	bne.n	80074d6 <cifXCreateSystemDevice+0x1a2>
    lRet = CIFX_INVALID_POINTER;
 80074c8:	4d46      	ldr	r5, [pc, #280]	; (80075e4 <cifXCreateSystemDevice+0x2b0>)
}
 80074ca:	4628      	mov	r0, r5
 80074cc:	b00b      	add	sp, #44	; 0x2c
 80074ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  void*                     pvLock           = NULL;
 80074d2:	4681      	mov	r9, r0
 80074d4:	e7e7      	b.n	80074a6 <cifXCreateSystemDevice+0x172>
      USER_Trace(ptDevInstance,
 80074d6:	4a44      	ldr	r2, [pc, #272]	; (80075e8 <cifXCreateSystemDevice+0x2b4>)
 80074d8:	2108      	movs	r1, #8
 80074da:	4620      	mov	r0, r4
 80074dc:	f002 f8b0 	bl	8009640 <USER_Trace>
    lRet = CIFX_INVALID_POINTER;
 80074e0:	4d40      	ldr	r5, [pc, #256]	; (80075e4 <cifXCreateSystemDevice+0x2b0>)
 80074e2:	e7f2      	b.n	80074ca <cifXCreateSystemDevice+0x196>
      USER_Trace(ptDevInstance,
 80074e4:	4a41      	ldr	r2, [pc, #260]	; (80075ec <cifXCreateSystemDevice+0x2b8>)
 80074e6:	2101      	movs	r1, #1
 80074e8:	4620      	mov	r0, r4
 80074ea:	f002 f8a9 	bl	8009640 <USER_Trace>
      USER_Trace(ptDevInstance,
 80074ee:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80074f0:	4a3f      	ldr	r2, [pc, #252]	; (80075f0 <cifXCreateSystemDevice+0x2bc>)
 80074f2:	2101      	movs	r1, #1
 80074f4:	4620      	mov	r0, r4
 80074f6:	f002 f8a3 	bl	8009640 <USER_Trace>
      USER_Trace(ptDevInstance,
 80074fa:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80074fc:	4a3d      	ldr	r2, [pc, #244]	; (80075f4 <cifXCreateSystemDevice+0x2c0>)
 80074fe:	2101      	movs	r1, #1
 8007500:	4620      	mov	r0, r4
 8007502:	f002 f89d 	bl	8009640 <USER_Trace>
      USER_Trace(ptDevInstance,
 8007506:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8007508:	4a3b      	ldr	r2, [pc, #236]	; (80075f8 <cifXCreateSystemDevice+0x2c4>)
 800750a:	2101      	movs	r1, #1
 800750c:	4620      	mov	r0, r4
 800750e:	f002 f897 	bl	8009640 <USER_Trace>
 8007512:	e75f      	b.n	80073d4 <cifXCreateSystemDevice+0xa0>
      OS_EnterLock(g_pvTkitLock);
 8007514:	4b39      	ldr	r3, [pc, #228]	; (80075fc <cifXCreateSystemDevice+0x2c8>)
 8007516:	6818      	ldr	r0, [r3, #0]
 8007518:	f7fb fb42 	bl	8002ba0 <OS_EnterLock>
      for(ulDeviceIdx = 0; ulDeviceIdx < g_ulDeviceCount; ++ulDeviceIdx)
 800751c:	f04f 0a00 	mov.w	sl, #0
 8007520:	9605      	str	r6, [sp, #20]
 8007522:	9e04      	ldr	r6, [sp, #16]
 8007524:	e006      	b.n	8007534 <cifXCreateSystemDevice+0x200>
          OS_Memset(ptDevInstance->szAlias, 0, sizeof(ptDevInstance->szAlias));
 8007526:	2210      	movs	r2, #16
 8007528:	2100      	movs	r1, #0
 800752a:	4630      	mov	r0, r6
 800752c:	f7fb faf7 	bl	8002b1e <OS_Memset>
      for(ulDeviceIdx = 0; ulDeviceIdx < g_ulDeviceCount; ++ulDeviceIdx)
 8007530:	f10a 0a01 	add.w	sl, sl, #1
 8007534:	4b32      	ldr	r3, [pc, #200]	; (8007600 <cifXCreateSystemDevice+0x2cc>)
 8007536:	681b      	ldr	r3, [r3, #0]
 8007538:	4553      	cmp	r3, sl
 800753a:	d919      	bls.n	8007570 <cifXCreateSystemDevice+0x23c>
        if(OS_Strcmp(g_pptDevices[ulDeviceIdx]->szAlias,
 800753c:	4b31      	ldr	r3, [pc, #196]	; (8007604 <cifXCreateSystemDevice+0x2d0>)
 800753e:	681b      	ldr	r3, [r3, #0]
 8007540:	f853 002a 	ldr.w	r0, [r3, sl, lsl #2]
 8007544:	4631      	mov	r1, r6
 8007546:	3039      	adds	r0, #57	; 0x39
 8007548:	f7fb fbca 	bl	8002ce0 <OS_Strcmp>
 800754c:	2800      	cmp	r0, #0
 800754e:	d1ef      	bne.n	8007530 <cifXCreateSystemDevice+0x1fc>
          if(g_ulTraceLevel & TRACE_LEVEL_WARNING)
 8007550:	4b22      	ldr	r3, [pc, #136]	; (80075dc <cifXCreateSystemDevice+0x2a8>)
 8007552:	681b      	ldr	r3, [r3, #0]
 8007554:	f013 0f04 	tst.w	r3, #4
 8007558:	d0e5      	beq.n	8007526 <cifXCreateSystemDevice+0x1f2>
            USER_Trace(ptDevInstance,
 800755a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800755c:	9301      	str	r3, [sp, #4]
 800755e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007560:	9300      	str	r3, [sp, #0]
 8007562:	4633      	mov	r3, r6
 8007564:	4a28      	ldr	r2, [pc, #160]	; (8007608 <cifXCreateSystemDevice+0x2d4>)
 8007566:	2104      	movs	r1, #4
 8007568:	4620      	mov	r0, r4
 800756a:	f002 f869 	bl	8009640 <USER_Trace>
 800756e:	e7da      	b.n	8007526 <cifXCreateSystemDevice+0x1f2>
      OS_LeaveLock(g_pvTkitLock);
 8007570:	9e05      	ldr	r6, [sp, #20]
 8007572:	4b22      	ldr	r3, [pc, #136]	; (80075fc <cifXCreateSystemDevice+0x2c8>)
 8007574:	6818      	ldr	r0, [r3, #0]
 8007576:	f7fb fb1f 	bl	8002bb8 <OS_LeaveLock>
 800757a:	e740      	b.n	80073fe <cifXCreateSystemDevice+0xca>
        USER_Trace(ptDevInstance,
 800757c:	4d18      	ldr	r5, [pc, #96]	; (80075e0 <cifXCreateSystemDevice+0x2ac>)
 800757e:	462b      	mov	r3, r5
 8007580:	4a22      	ldr	r2, [pc, #136]	; (800760c <cifXCreateSystemDevice+0x2d8>)
 8007582:	2108      	movs	r1, #8
 8007584:	4620      	mov	r0, r4
 8007586:	f002 f85b 	bl	8009640 <USER_Trace>
 800758a:	e000      	b.n	800758e <cifXCreateSystemDevice+0x25a>
  int32_t lRet = CIFX_NO_ERROR;
 800758c:	2500      	movs	r5, #0
    if( ptDevInstance->tSystemDevice.usNetxFlags & NSF_ERROR)
 800758e:	f8b4 31b2 	ldrh.w	r3, [r4, #434]	; 0x1b2
 8007592:	f013 0f02 	tst.w	r3, #2
 8007596:	d098      	beq.n	80074ca <cifXCreateSystemDevice+0x196>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007598:	4b10      	ldr	r3, [pc, #64]	; (80075dc <cifXCreateSystemDevice+0x2a8>)
 800759a:	681b      	ldr	r3, [r3, #0]
 800759c:	f013 0f08 	tst.w	r3, #8
 80075a0:	d093      	beq.n	80074ca <cifXCreateSystemDevice+0x196>
        HIL_DPM_SYSTEM_CHANNEL_T* ptSysCh = (HIL_DPM_SYSTEM_CHANNEL_T*)ptDevInstance->tSystemDevice.pbDPMChannelStart;
 80075a2:	f8d4 60fc 	ldr.w	r6, [r4, #252]	; 0xfc
        if(0 != (ulError = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysCh->tSystemState.ulSystemError))))
 80075a6:	f106 01c8 	add.w	r1, r6, #200	; 0xc8
 80075aa:	4620      	mov	r0, r4
 80075ac:	f7fd fea5 	bl	80052fa <HwIfRead32>
 80075b0:	4603      	mov	r3, r0
 80075b2:	b968      	cbnz	r0, 80075d0 <cifXCreateSystemDevice+0x29c>
        if( 0 != (ulError = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysCh->tSystemState.ulSystemStatus))))
 80075b4:	f106 01c4 	add.w	r1, r6, #196	; 0xc4
 80075b8:	4620      	mov	r0, r4
 80075ba:	f7fd fe9e 	bl	80052fa <HwIfRead32>
 80075be:	4603      	mov	r3, r0
 80075c0:	2800      	cmp	r0, #0
 80075c2:	d082      	beq.n	80074ca <cifXCreateSystemDevice+0x196>
          USER_Trace(ptDevInstance,
 80075c4:	4a12      	ldr	r2, [pc, #72]	; (8007610 <cifXCreateSystemDevice+0x2dc>)
 80075c6:	2108      	movs	r1, #8
 80075c8:	4620      	mov	r0, r4
 80075ca:	f002 f839 	bl	8009640 <USER_Trace>
 80075ce:	e77c      	b.n	80074ca <cifXCreateSystemDevice+0x196>
          USER_Trace(ptDevInstance,
 80075d0:	4a10      	ldr	r2, [pc, #64]	; (8007614 <cifXCreateSystemDevice+0x2e0>)
 80075d2:	2108      	movs	r1, #8
 80075d4:	4620      	mov	r0, r4
 80075d6:	f002 f833 	bl	8009640 <USER_Trace>
 80075da:	e7eb      	b.n	80075b4 <cifXCreateSystemDevice+0x280>
 80075dc:	20000038 	.word	0x20000038
 80075e0:	800c0011 	.word	0x800c0011
 80075e4:	800a0001 	.word	0x800a0001
 80075e8:	0800c118 	.word	0x0800c118
 80075ec:	0800c144 	.word	0x0800c144
 80075f0:	0800c154 	.word	0x0800c154
 80075f4:	0800c16c 	.word	0x0800c16c
 80075f8:	0800c184 	.word	0x0800c184
 80075fc:	20000210 	.word	0x20000210
 8007600:	2000021c 	.word	0x2000021c
 8007604:	2000020c 	.word	0x2000020c
 8007608:	0800c19c 	.word	0x0800c19c
 800760c:	0800b810 	.word	0x0800b810
 8007610:	0800c218 	.word	0x0800c218
 8007614:	0800c1e8 	.word	0x0800c1e8

08007618 <cifXDeleteChannelInstance>:
{
 8007618:	b570      	push	{r4, r5, r6, lr}
 800761a:	4604      	mov	r4, r0
  for(ulTemp = 0; ulTemp < sizeof(ptChannelInst->ahHandshakeBitEvents) / sizeof(ptChannelInst->ahHandshakeBitEvents[0]); ++ulTemp)
 800761c:	2500      	movs	r5, #0
 800761e:	e000      	b.n	8007622 <cifXDeleteChannelInstance+0xa>
 8007620:	3501      	adds	r5, #1
 8007622:	2d0f      	cmp	r5, #15
 8007624:	d80f      	bhi.n	8007646 <cifXDeleteChannelInstance+0x2e>
    if(NULL != ptChannelInst->ahHandshakeBitEvents[ulTemp])
 8007626:	f105 033e 	add.w	r3, r5, #62	; 0x3e
 800762a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 800762e:	6858      	ldr	r0, [r3, #4]
 8007630:	2800      	cmp	r0, #0
 8007632:	d0f5      	beq.n	8007620 <cifXDeleteChannelInstance+0x8>
      OS_DeleteEvent(ptChannelInst->ahHandshakeBitEvents[ulTemp]);
 8007634:	f7fb fb1c 	bl	8002c70 <OS_DeleteEvent>
      ptChannelInst->ahHandshakeBitEvents[ulTemp] = NULL;
 8007638:	f105 033e 	add.w	r3, r5, #62	; 0x3e
 800763c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8007640:	2200      	movs	r2, #0
 8007642:	605a      	str	r2, [r3, #4]
 8007644:	e7ec      	b.n	8007620 <cifXDeleteChannelInstance+0x8>
  if(NULL != ptChannelInst->pptIOInputAreas)
 8007646:	f8d4 313c 	ldr.w	r3, [r4, #316]	; 0x13c
 800764a:	b1fb      	cbz	r3, 800768c <cifXDeleteChannelInstance+0x74>
    for(ulTemp = 0; ulTemp < ptChannelInst->ulIOInputAreas; ++ulTemp)
 800764c:	2500      	movs	r5, #0
 800764e:	e000      	b.n	8007652 <cifXDeleteChannelInstance+0x3a>
 8007650:	3501      	adds	r5, #1
 8007652:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 8007656:	42ab      	cmp	r3, r5
 8007658:	d911      	bls.n	800767e <cifXDeleteChannelInstance+0x66>
      PIOINSTANCE ptIoInst = ptChannelInst->pptIOInputAreas[ulTemp];
 800765a:	f8d4 313c 	ldr.w	r3, [r4, #316]	; 0x13c
 800765e:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
      if(NULL != ptIoInst)
 8007662:	2e00      	cmp	r6, #0
 8007664:	d0f4      	beq.n	8007650 <cifXDeleteChannelInstance+0x38>
        OS_DeleteMutex(ptIoInst->pvMutex);
 8007666:	6930      	ldr	r0, [r6, #16]
 8007668:	f7fb fad6 	bl	8002c18 <OS_DeleteMutex>
        OS_Memfree(ptIoInst);
 800766c:	4630      	mov	r0, r6
 800766e:	f7fb fa4e 	bl	8002b0e <OS_Memfree>
        ptChannelInst->pptIOInputAreas[ulTemp] = NULL;
 8007672:	f8d4 313c 	ldr.w	r3, [r4, #316]	; 0x13c
 8007676:	2200      	movs	r2, #0
 8007678:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 800767c:	e7e8      	b.n	8007650 <cifXDeleteChannelInstance+0x38>
    OS_Memfree(ptChannelInst->pptIOInputAreas);
 800767e:	f8d4 013c 	ldr.w	r0, [r4, #316]	; 0x13c
 8007682:	f7fb fa44 	bl	8002b0e <OS_Memfree>
    ptChannelInst->pptIOInputAreas = NULL;
 8007686:	2300      	movs	r3, #0
 8007688:	f8c4 313c 	str.w	r3, [r4, #316]	; 0x13c
  if(NULL != ptChannelInst->pptIOOutputAreas)
 800768c:	f8d4 3144 	ldr.w	r3, [r4, #324]	; 0x144
 8007690:	b1fb      	cbz	r3, 80076d2 <cifXDeleteChannelInstance+0xba>
    for(ulTemp = 0; ulTemp < ptChannelInst->ulIOOutputAreas; ++ulTemp)
 8007692:	2500      	movs	r5, #0
 8007694:	e000      	b.n	8007698 <cifXDeleteChannelInstance+0x80>
 8007696:	3501      	adds	r5, #1
 8007698:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
 800769c:	42ab      	cmp	r3, r5
 800769e:	d911      	bls.n	80076c4 <cifXDeleteChannelInstance+0xac>
      PIOINSTANCE ptIoInst = ptChannelInst->pptIOOutputAreas[ulTemp];
 80076a0:	f8d4 3144 	ldr.w	r3, [r4, #324]	; 0x144
 80076a4:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
      if(NULL!= ptIoInst)
 80076a8:	2e00      	cmp	r6, #0
 80076aa:	d0f4      	beq.n	8007696 <cifXDeleteChannelInstance+0x7e>
        OS_DeleteMutex(ptIoInst->pvMutex);
 80076ac:	6930      	ldr	r0, [r6, #16]
 80076ae:	f7fb fab3 	bl	8002c18 <OS_DeleteMutex>
        OS_Memfree(ptIoInst);
 80076b2:	4630      	mov	r0, r6
 80076b4:	f7fb fa2b 	bl	8002b0e <OS_Memfree>
        ptChannelInst->pptIOOutputAreas[ulTemp] = NULL;
 80076b8:	f8d4 3144 	ldr.w	r3, [r4, #324]	; 0x144
 80076bc:	2200      	movs	r2, #0
 80076be:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 80076c2:	e7e8      	b.n	8007696 <cifXDeleteChannelInstance+0x7e>
    OS_Memfree(ptChannelInst->pptIOOutputAreas);
 80076c4:	f8d4 0144 	ldr.w	r0, [r4, #324]	; 0x144
 80076c8:	f7fb fa21 	bl	8002b0e <OS_Memfree>
    ptChannelInst->pptIOOutputAreas = NULL;
 80076cc:	2300      	movs	r3, #0
 80076ce:	f8c4 3144 	str.w	r3, [r4, #324]	; 0x144
  if(NULL != ptChannelInst->pptUserAreas)
 80076d2:	f8d4 314c 	ldr.w	r3, [r4, #332]	; 0x14c
 80076d6:	b1c3      	cbz	r3, 800770a <cifXDeleteChannelInstance+0xf2>
    for(ulTemp = 0; ulTemp < ptChannelInst->ulUserAreas; ++ulTemp)
 80076d8:	2500      	movs	r5, #0
 80076da:	e00b      	b.n	80076f4 <cifXDeleteChannelInstance+0xdc>
      OS_Memfree(ptChannelInst->pptUserAreas[ulTemp]);
 80076dc:	f8d4 314c 	ldr.w	r3, [r4, #332]	; 0x14c
 80076e0:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 80076e4:	f7fb fa13 	bl	8002b0e <OS_Memfree>
      ptChannelInst->pptUserAreas[ulTemp] = NULL;
 80076e8:	f8d4 314c 	ldr.w	r3, [r4, #332]	; 0x14c
 80076ec:	2200      	movs	r2, #0
 80076ee:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
    for(ulTemp = 0; ulTemp < ptChannelInst->ulUserAreas; ++ulTemp)
 80076f2:	3501      	adds	r5, #1
 80076f4:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
 80076f8:	42ab      	cmp	r3, r5
 80076fa:	d8ef      	bhi.n	80076dc <cifXDeleteChannelInstance+0xc4>
    OS_Memfree(ptChannelInst->pptUserAreas);
 80076fc:	f8d4 014c 	ldr.w	r0, [r4, #332]	; 0x14c
 8007700:	f7fb fa05 	bl	8002b0e <OS_Memfree>
    ptChannelInst->pptUserAreas = NULL;
 8007704:	2300      	movs	r3, #0
 8007706:	f8c4 314c 	str.w	r3, [r4, #332]	; 0x14c
  if(NULL != ptChannelInst->tSendMbx.pvSendMBXMutex)
 800770a:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 800770e:	b108      	cbz	r0, 8007714 <cifXDeleteChannelInstance+0xfc>
    OS_DeleteMutex(ptChannelInst->tSendMbx.pvSendMBXMutex);
 8007710:	f7fb fa82 	bl	8002c18 <OS_DeleteMutex>
  if(NULL != ptChannelInst->tRecvMbx.pvRecvMBXMutex)
 8007714:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
 8007718:	b108      	cbz	r0, 800771e <cifXDeleteChannelInstance+0x106>
    OS_DeleteMutex(ptChannelInst->tRecvMbx.pvRecvMBXMutex);
 800771a:	f7fb fa7d 	bl	8002c18 <OS_DeleteMutex>
  if(NULL != ptChannelInst->pvLock)
 800771e:	69a0      	ldr	r0, [r4, #24]
 8007720:	b108      	cbz	r0, 8007726 <cifXDeleteChannelInstance+0x10e>
    OS_DeleteLock(ptChannelInst->pvLock);
 8007722:	f7fb fa57 	bl	8002bd4 <OS_DeleteLock>
  if(NULL != ptChannelInst->pvInitMutex)
 8007726:	6860      	ldr	r0, [r4, #4]
 8007728:	b108      	cbz	r0, 800772e <cifXDeleteChannelInstance+0x116>
    OS_DeleteMutex(ptChannelInst->pvInitMutex);
 800772a:	f7fb fa75 	bl	8002c18 <OS_DeleteMutex>
  OS_Memfree(ptChannelInst);
 800772e:	4620      	mov	r0, r4
 8007730:	f7fb f9ed 	bl	8002b0e <OS_Memfree>
}
 8007734:	bd70      	pop	{r4, r5, r6, pc}
	...

08007738 <cifXStartFlashConfiguration>:
  if(!ptDevChannelCfg->fFWLoaded)
 8007738:	680b      	ldr	r3, [r1, #0]
 800773a:	b383      	cbz	r3, 800779e <cifXStartFlashConfiguration+0x66>
}
 800773c:	2000      	movs	r0, #0
 800773e:	4770      	bx	lr
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007740:	4a1b      	ldr	r2, [pc, #108]	; (80077b0 <cifXStartFlashConfiguration+0x78>)
 8007742:	6812      	ldr	r2, [r2, #0]
 8007744:	f012 0f08 	tst.w	r2, #8
 8007748:	d121      	bne.n	800778e <cifXStartFlashConfiguration+0x56>
    for(ulChannel = 0; ulChannel < ptDevInstance->ulCommChannelCount; ++ulChannel)
 800774a:	3401      	adds	r4, #1
 800774c:	f8d5 3260 	ldr.w	r3, [r5, #608]	; 0x260
 8007750:	42a3      	cmp	r3, r4
 8007752:	d92a      	bls.n	80077aa <cifXStartFlashConfiguration+0x72>
      if ( ptDevChannelCfg->atChannelData[ulChannel].fCNFLoaded)
 8007754:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 8007758:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800775c:	689b      	ldr	r3, [r3, #8]
 800775e:	2b00      	cmp	r3, #0
 8007760:	d0f3      	beq.n	800774a <cifXStartFlashConfiguration+0x12>
        lChannelRet = DEV_DoChannelInit(ptDevInstance->pptCommChannels[ulChannel], CIFX_TO_SEND_PACKET);
 8007762:	f8d5 3264 	ldr.w	r3, [r5, #612]	; 0x264
 8007766:	f241 3188 	movw	r1, #5000	; 0x1388
 800776a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800776e:	f7fe fa67 	bl	8005c40 <DEV_DoChannelInit>
        if(CIFX_NO_ERROR == lChannelRet)
 8007772:	2800      	cmp	r0, #0
 8007774:	d1e4      	bne.n	8007740 <cifXStartFlashConfiguration+0x8>
          if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8007776:	4b0e      	ldr	r3, [pc, #56]	; (80077b0 <cifXStartFlashConfiguration+0x78>)
 8007778:	681b      	ldr	r3, [r3, #0]
 800777a:	f013 0f01 	tst.w	r3, #1
 800777e:	d0e4      	beq.n	800774a <cifXStartFlashConfiguration+0x12>
            USER_Trace(ptDevInstance,
 8007780:	4623      	mov	r3, r4
 8007782:	4a0c      	ldr	r2, [pc, #48]	; (80077b4 <cifXStartFlashConfiguration+0x7c>)
 8007784:	2101      	movs	r1, #1
 8007786:	4628      	mov	r0, r5
 8007788:	f001 ff5a 	bl	8009640 <USER_Trace>
 800778c:	e7dd      	b.n	800774a <cifXStartFlashConfiguration+0x12>
            USER_Trace(ptDevInstance,
 800778e:	9000      	str	r0, [sp, #0]
 8007790:	4623      	mov	r3, r4
 8007792:	4a09      	ldr	r2, [pc, #36]	; (80077b8 <cifXStartFlashConfiguration+0x80>)
 8007794:	2108      	movs	r1, #8
 8007796:	4628      	mov	r0, r5
 8007798:	f001 ff52 	bl	8009640 <USER_Trace>
 800779c:	e7d5      	b.n	800774a <cifXStartFlashConfiguration+0x12>
{
 800779e:	b570      	push	{r4, r5, r6, lr}
 80077a0:	b082      	sub	sp, #8
 80077a2:	4605      	mov	r5, r0
 80077a4:	460e      	mov	r6, r1
    for(ulChannel = 0; ulChannel < ptDevInstance->ulCommChannelCount; ++ulChannel)
 80077a6:	2400      	movs	r4, #0
 80077a8:	e7d0      	b.n	800774c <cifXStartFlashConfiguration+0x14>
}
 80077aa:	2000      	movs	r0, #0
 80077ac:	b002      	add	sp, #8
 80077ae:	bd70      	pop	{r4, r5, r6, pc}
 80077b0:	20000038 	.word	0x20000038
 80077b4:	0800c248 	.word	0x0800c248
 80077b8:	0800c27c 	.word	0x0800c27c

080077bc <cifXHandleWarmstartParameter>:
{
 80077bc:	b570      	push	{r4, r5, r6, lr}
 80077be:	f6ad 4d98 	subw	sp, sp, #3224	; 0xc98
 80077c2:	4604      	mov	r4, r0
  OS_Memset(&tPacket,     0, sizeof(tPacket));
 80077c4:	f240 623c 	movw	r2, #1596	; 0x63c
 80077c8:	2100      	movs	r1, #0
 80077ca:	f20d 605c 	addw	r0, sp, #1628	; 0x65c
 80077ce:	f7fb f9a6 	bl	8002b1e <OS_Memset>
  OS_Memset(&tRecvPacket, 0, sizeof(tRecvPacket));
 80077d2:	f240 623c 	movw	r2, #1596	; 0x63c
 80077d6:	2100      	movs	r1, #0
 80077d8:	a808      	add	r0, sp, #32
 80077da:	f7fb f9a0 	bl	8002b1e <OS_Memset>
  for(ulBlockID = 0; ulBlockID < ptDevInstance->ulCommChannelCount; ++ulBlockID)
 80077de:	2500      	movs	r5, #0
 80077e0:	e018      	b.n	8007814 <cifXHandleWarmstartParameter+0x58>
      int32_t lChannelError = DEV_TransferPacket( ptChannelInst,
 80077e2:	2300      	movs	r3, #0
 80077e4:	9302      	str	r3, [sp, #8]
 80077e6:	9301      	str	r3, [sp, #4]
 80077e8:	f241 3388 	movw	r3, #5000	; 0x1388
 80077ec:	9300      	str	r3, [sp, #0]
 80077ee:	f240 633c 	movw	r3, #1596	; 0x63c
 80077f2:	aa08      	add	r2, sp, #32
 80077f4:	f20d 615c 	addw	r1, sp, #1628	; 0x65c
 80077f8:	4630      	mov	r0, r6
 80077fa:	f7fe f8bd 	bl	8005978 <DEV_TransferPacket>
      if( (CIFX_NO_ERROR  != lChannelError) ||
 80077fe:	4603      	mov	r3, r0
 8007800:	b910      	cbnz	r0, 8007808 <cifXHandleWarmstartParameter+0x4c>
          (SUCCESS_HIL_OK != LE32_TO_HOST(tRecvPacket.tHeader.ulState)) )
 8007802:	9a0e      	ldr	r2, [sp, #56]	; 0x38
      if( (CIFX_NO_ERROR  != lChannelError) ||
 8007804:	2a00      	cmp	r2, #0
 8007806:	d03c      	beq.n	8007882 <cifXHandleWarmstartParameter+0xc6>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007808:	4a2e      	ldr	r2, [pc, #184]	; (80078c4 <cifXHandleWarmstartParameter+0x108>)
 800780a:	6812      	ldr	r2, [r2, #0]
 800780c:	f012 0f08 	tst.w	r2, #8
 8007810:	d12e      	bne.n	8007870 <cifXHandleWarmstartParameter+0xb4>
  for(ulBlockID = 0; ulBlockID < ptDevInstance->ulCommChannelCount; ++ulBlockID)
 8007812:	3501      	adds	r5, #1
 8007814:	f8d4 3260 	ldr.w	r3, [r4, #608]	; 0x260
 8007818:	42ab      	cmp	r3, r5
 800781a:	d94f      	bls.n	80078bc <cifXHandleWarmstartParameter+0x100>
    PCHANNELINSTANCE ptChannelInst = (PCHANNELINSTANCE)ptDevInstance->pptCommChannels[ulBlockID];
 800781c:	f8d4 3264 	ldr.w	r3, [r4, #612]	; 0x264
 8007820:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    OS_Memset(&tDevInfo, 0, sizeof(tDevInfo));
 8007824:	2210      	movs	r2, #16
 8007826:	2100      	movs	r1, #0
 8007828:	eb0d 0002 	add.w	r0, sp, r2
 800782c:	f7fb f977 	bl	8002b1e <OS_Memset>
    tDevInfo.ulChannel        = ptChannelInst->ulChannelNumber;
 8007830:	6933      	ldr	r3, [r6, #16]
 8007832:	9306      	str	r3, [sp, #24]
    tDevInfo.ulDeviceNumber   = ptDevInstance->ulDeviceNumber;
 8007834:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007836:	9304      	str	r3, [sp, #16]
    tDevInfo.ulSerialNumber   = ptDevInstance->ulSerialNumber;
 8007838:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800783a:	9305      	str	r3, [sp, #20]
    tDevInfo.ptDeviceInstance = ptDevInstance;
 800783c:	9407      	str	r4, [sp, #28]
    OS_Memset( &tPacket, 0, sizeof(tPacket));
 800783e:	f240 623c 	movw	r2, #1596	; 0x63c
 8007842:	2100      	movs	r1, #0
 8007844:	f20d 605c 	addw	r0, sp, #1628	; 0x65c
 8007848:	f7fb f969 	bl	8002b1e <OS_Memset>
    if ( !USER_GetWarmstartParameters( &tDevInfo, &tPacket))
 800784c:	f20d 615c 	addw	r1, sp, #1628	; 0x65c
 8007850:	a804      	add	r0, sp, #16
 8007852:	f001 feee 	bl	8009632 <USER_GetWarmstartParameters>
 8007856:	2800      	cmp	r0, #0
 8007858:	d1c3      	bne.n	80077e2 <cifXHandleWarmstartParameter+0x26>
      if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 800785a:	4b1a      	ldr	r3, [pc, #104]	; (80078c4 <cifXHandleWarmstartParameter+0x108>)
 800785c:	681b      	ldr	r3, [r3, #0]
 800785e:	f013 0f01 	tst.w	r3, #1
 8007862:	d0d6      	beq.n	8007812 <cifXHandleWarmstartParameter+0x56>
        USER_Trace(ptDevInstance,
 8007864:	4a18      	ldr	r2, [pc, #96]	; (80078c8 <cifXHandleWarmstartParameter+0x10c>)
 8007866:	2101      	movs	r1, #1
 8007868:	4620      	mov	r0, r4
 800786a:	f001 fee9 	bl	8009640 <USER_Trace>
 800786e:	e7d0      	b.n	8007812 <cifXHandleWarmstartParameter+0x56>
          USER_Trace(ptDevInstance,
 8007870:	f8dd 2674 	ldr.w	r2, [sp, #1652]	; 0x674
 8007874:	9200      	str	r2, [sp, #0]
 8007876:	4a15      	ldr	r2, [pc, #84]	; (80078cc <cifXHandleWarmstartParameter+0x110>)
 8007878:	2108      	movs	r1, #8
 800787a:	4620      	mov	r0, r4
 800787c:	f001 fee0 	bl	8009640 <USER_Trace>
 8007880:	e7c7      	b.n	8007812 <cifXHandleWarmstartParameter+0x56>
        if (DEV_WaitForRunning_Poll( ptChannelInst, CIFX_TO_FIRMWARE_START))
 8007882:	f644 6120 	movw	r1, #20000	; 0x4e20
 8007886:	4630      	mov	r0, r6
 8007888:	f7fd ffc5 	bl	8005816 <DEV_WaitForRunning_Poll>
 800788c:	b158      	cbz	r0, 80078a6 <cifXHandleWarmstartParameter+0xea>
          if(g_ulTraceLevel & TRACE_LEVEL_INFO)
 800788e:	4b0d      	ldr	r3, [pc, #52]	; (80078c4 <cifXHandleWarmstartParameter+0x108>)
 8007890:	681b      	ldr	r3, [r3, #0]
 8007892:	f013 0f02 	tst.w	r3, #2
 8007896:	d0bc      	beq.n	8007812 <cifXHandleWarmstartParameter+0x56>
            USER_Trace(ptDevInstance,
 8007898:	462b      	mov	r3, r5
 800789a:	4a0d      	ldr	r2, [pc, #52]	; (80078d0 <cifXHandleWarmstartParameter+0x114>)
 800789c:	2102      	movs	r1, #2
 800789e:	4620      	mov	r0, r4
 80078a0:	f001 fece 	bl	8009640 <USER_Trace>
 80078a4:	e7b5      	b.n	8007812 <cifXHandleWarmstartParameter+0x56>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80078a6:	4b07      	ldr	r3, [pc, #28]	; (80078c4 <cifXHandleWarmstartParameter+0x108>)
 80078a8:	681b      	ldr	r3, [r3, #0]
 80078aa:	f013 0f08 	tst.w	r3, #8
 80078ae:	d0b0      	beq.n	8007812 <cifXHandleWarmstartParameter+0x56>
            USER_Trace(ptDevInstance,
 80078b0:	4a08      	ldr	r2, [pc, #32]	; (80078d4 <cifXHandleWarmstartParameter+0x118>)
 80078b2:	2108      	movs	r1, #8
 80078b4:	4620      	mov	r0, r4
 80078b6:	f001 fec3 	bl	8009640 <USER_Trace>
 80078ba:	e7aa      	b.n	8007812 <cifXHandleWarmstartParameter+0x56>
}
 80078bc:	2000      	movs	r0, #0
 80078be:	f60d 4d98 	addw	sp, sp, #3224	; 0xc98
 80078c2:	bd70      	pop	{r4, r5, r6, pc}
 80078c4:	20000038 	.word	0x20000038
 80078c8:	0800c2b8 	.word	0x0800c2b8
 80078cc:	0800c2e4 	.word	0x0800c2e4
 80078d0:	0800c338 	.word	0x0800c338
 80078d4:	0800c370 	.word	0x0800c370

080078d8 <cifXCheckCachedBufferEnable>:
{
 80078d8:	b510      	push	{r4, lr}
 80078da:	b084      	sub	sp, #16
 80078dc:	4604      	mov	r4, r0
  OS_Memset(&tDevInfo, 0, sizeof(tDevInfo));
 80078de:	2210      	movs	r2, #16
 80078e0:	2100      	movs	r1, #0
 80078e2:	4668      	mov	r0, sp
 80078e4:	f7fb f91b 	bl	8002b1e <OS_Memset>
  tDevInfo.ulDeviceNumber   = ptDevInstance->ulDeviceNumber;
 80078e8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80078ea:	9300      	str	r3, [sp, #0]
  tDevInfo.ulSerialNumber   = ptDevInstance->ulSerialNumber;
 80078ec:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80078ee:	9301      	str	r3, [sp, #4]
  tDevInfo.ulChannel        = CIFX_SYSTEM_DEVICE;
 80078f0:	f04f 33ff 	mov.w	r3, #4294967295
 80078f4:	9302      	str	r3, [sp, #8]
  tDevInfo.ptDeviceInstance = ptDevInstance;
 80078f6:	9403      	str	r4, [sp, #12]
  iCachedState = USER_GetCachedIOBufferMode(&tDevInfo);
 80078f8:	4668      	mov	r0, sp
 80078fa:	f001 fe9f 	bl	800963c <USER_GetCachedIOBufferMode>
  switch (iCachedState)
 80078fe:	2801      	cmp	r0, #1
 8007900:	d906      	bls.n	8007910 <cifXCheckCachedBufferEnable+0x38>
      if (g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007902:	4b09      	ldr	r3, [pc, #36]	; (8007928 <cifXCheckCachedBufferEnable+0x50>)
 8007904:	681b      	ldr	r3, [r3, #0]
 8007906:	f013 0f08 	tst.w	r3, #8
 800790a:	d106      	bne.n	800791a <cifXCheckCachedBufferEnable+0x42>
      lRet = CIFX_INVALID_PARAMETER;
 800790c:	4807      	ldr	r0, [pc, #28]	; (800792c <cifXCheckCachedBufferEnable+0x54>)
  return lRet;
 800790e:	e002      	b.n	8007916 <cifXCheckCachedBufferEnable+0x3e>
      ptDevInstance->fCachedMemAccess = iCachedState;
 8007910:	f8c4 0268 	str.w	r0, [r4, #616]	; 0x268
  int32_t                 lRet = CIFX_NO_ERROR;
 8007914:	2000      	movs	r0, #0
}
 8007916:	b004      	add	sp, #16
 8007918:	bd10      	pop	{r4, pc}
        USER_Trace(ptDevInstance,
 800791a:	4a05      	ldr	r2, [pc, #20]	; (8007930 <cifXCheckCachedBufferEnable+0x58>)
 800791c:	2108      	movs	r1, #8
 800791e:	4620      	mov	r0, r4
 8007920:	f001 fe8e 	bl	8009640 <USER_Trace>
      lRet = CIFX_INVALID_PARAMETER;
 8007924:	4801      	ldr	r0, [pc, #4]	; (800792c <cifXCheckCachedBufferEnable+0x54>)
 8007926:	e7f6      	b.n	8007916 <cifXCheckCachedBufferEnable+0x3e>
 8007928:	20000038 	.word	0x20000038
 800792c:	800a0005 	.word	0x800a0005
 8007930:	0800c3a8 	.word	0x0800c3a8

08007934 <cifXCheckIRQEnable>:
{
 8007934:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007938:	b084      	sub	sp, #16
 800793a:	4605      	mov	r5, r0
  OS_Memset(&tDevInfo, 0, sizeof(tDevInfo));
 800793c:	2210      	movs	r2, #16
 800793e:	2100      	movs	r1, #0
 8007940:	4668      	mov	r0, sp
 8007942:	f7fb f8ec 	bl	8002b1e <OS_Memset>
  tDevInfo.ulDeviceNumber   = ptDevInstance->ulDeviceNumber;
 8007946:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8007948:	9300      	str	r3, [sp, #0]
  tDevInfo.ulSerialNumber   = ptDevInstance->ulSerialNumber;
 800794a:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 800794c:	9301      	str	r3, [sp, #4]
  tDevInfo.ulChannel        = CIFX_SYSTEM_DEVICE;
 800794e:	f04f 33ff 	mov.w	r3, #4294967295
 8007952:	9302      	str	r3, [sp, #8]
  tDevInfo.ptDeviceInstance = ptDevInstance;
 8007954:	9503      	str	r5, [sp, #12]
  if(0 != (ptDevInstance->fIrqEnabled = USER_GetInterruptEnable(&tDevInfo)))
 8007956:	4668      	mov	r0, sp
 8007958:	f001 fe6e 	bl	8009638 <USER_GetInterruptEnable>
 800795c:	60a8      	str	r0, [r5, #8]
 800795e:	2800      	cmp	r0, #0
 8007960:	d038      	beq.n	80079d4 <cifXCheckIRQEnable+0xa0>
    PCHANNELINSTANCE ptChannelInst = &ptDevInstance->tSystemDevice;
 8007962:	f105 06f4 	add.w	r6, r5, #244	; 0xf4
    for(ulSync = 0; ulSync < sizeof(ptDevInstance->tSyncData.ahSyncBitEvents) / sizeof(ptDevInstance->tSyncData.ahSyncBitEvents[0]); ++ulSync)
 8007966:	2400      	movs	r4, #0
 8007968:	2c0f      	cmp	r4, #15
 800796a:	d817      	bhi.n	800799c <cifXCheckIRQEnable+0x68>
      if (NULL == (ptDevInstance->tSyncData.ahSyncBitEvents[ulSync] = OS_CreateEvent()))
 800796c:	f7fb f956 	bl	8002c1c <OS_CreateEvent>
 8007970:	f104 039c 	add.w	r3, r4, #156	; 0x9c
 8007974:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8007978:	6098      	str	r0, [r3, #8]
 800797a:	b108      	cbz	r0, 8007980 <cifXCheckIRQEnable+0x4c>
    for(ulSync = 0; ulSync < sizeof(ptDevInstance->tSyncData.ahSyncBitEvents) / sizeof(ptDevInstance->tSyncData.ahSyncBitEvents[0]); ++ulSync)
 800797c:	3401      	adds	r4, #1
 800797e:	e7f3      	b.n	8007968 <cifXCheckIRQEnable+0x34>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007980:	4b21      	ldr	r3, [pc, #132]	; (8007a08 <cifXCheckIRQEnable+0xd4>)
 8007982:	681b      	ldr	r3, [r3, #0]
 8007984:	f013 0f08 	tst.w	r3, #8
 8007988:	d101      	bne.n	800798e <cifXCheckIRQEnable+0x5a>
        lRet = CIFX_INVALID_POINTER;
 800798a:	4820      	ldr	r0, [pc, #128]	; (8007a0c <cifXCheckIRQEnable+0xd8>)
 800798c:	e022      	b.n	80079d4 <cifXCheckIRQEnable+0xa0>
          USER_Trace(ptDevInstance,
 800798e:	4a20      	ldr	r2, [pc, #128]	; (8007a10 <cifXCheckIRQEnable+0xdc>)
 8007990:	2108      	movs	r1, #8
 8007992:	4628      	mov	r0, r5
 8007994:	f001 fe54 	bl	8009640 <USER_Trace>
        lRet = CIFX_INVALID_POINTER;
 8007998:	481c      	ldr	r0, [pc, #112]	; (8007a0c <cifXCheckIRQEnable+0xd8>)
 800799a:	e01b      	b.n	80079d4 <cifXCheckIRQEnable+0xa0>
    uint32_t         ulChannel     = 0;
 800799c:	f04f 0800 	mov.w	r8, #0
        if(ptChannelInst->bHandshakeWidth == HIL_HANDSHAKE_SIZE_16BIT)
 80079a0:	f896 30f8 	ldrb.w	r3, [r6, #248]	; 0xf8
 80079a4:	2b02      	cmp	r3, #2
 80079a6:	d00d      	beq.n	80079c4 <cifXCheckIRQEnable+0x90>
        uint32_t ulHandshakeWidth = 8;
 80079a8:	2708      	movs	r7, #8
        for(ulIdx = 0; ulIdx < ulHandshakeWidth; ++ulIdx)
 80079aa:	2400      	movs	r4, #0
 80079ac:	42a7      	cmp	r7, r4
 80079ae:	d91b      	bls.n	80079e8 <cifXCheckIRQEnable+0xb4>
          if (NULL == (ptChannelInst->ahHandshakeBitEvents[ulIdx] = OS_CreateEvent()))
 80079b0:	f7fb f934 	bl	8002c1c <OS_CreateEvent>
 80079b4:	f104 033e 	add.w	r3, r4, #62	; 0x3e
 80079b8:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 80079bc:	6058      	str	r0, [r3, #4]
 80079be:	b118      	cbz	r0, 80079c8 <cifXCheckIRQEnable+0x94>
        for(ulIdx = 0; ulIdx < ulHandshakeWidth; ++ulIdx)
 80079c0:	3401      	adds	r4, #1
 80079c2:	e7f3      	b.n	80079ac <cifXCheckIRQEnable+0x78>
          ulHandshakeWidth = 16;
 80079c4:	2710      	movs	r7, #16
 80079c6:	e7f0      	b.n	80079aa <cifXCheckIRQEnable+0x76>
            if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80079c8:	4b0f      	ldr	r3, [pc, #60]	; (8007a08 <cifXCheckIRQEnable+0xd4>)
 80079ca:	681b      	ldr	r3, [r3, #0]
 80079cc:	f013 0f08 	tst.w	r3, #8
 80079d0:	d103      	bne.n	80079da <cifXCheckIRQEnable+0xa6>
            lRet = CIFX_INVALID_POINTER;
 80079d2:	480e      	ldr	r0, [pc, #56]	; (8007a0c <cifXCheckIRQEnable+0xd8>)
}
 80079d4:	b004      	add	sp, #16
 80079d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
              USER_Trace(ptDevInstance,
 80079da:	4a0e      	ldr	r2, [pc, #56]	; (8007a14 <cifXCheckIRQEnable+0xe0>)
 80079dc:	2108      	movs	r1, #8
 80079de:	4628      	mov	r0, r5
 80079e0:	f001 fe2e 	bl	8009640 <USER_Trace>
            lRet = CIFX_INVALID_POINTER;
 80079e4:	4809      	ldr	r0, [pc, #36]	; (8007a0c <cifXCheckIRQEnable+0xd8>)
 80079e6:	e7f5      	b.n	80079d4 <cifXCheckIRQEnable+0xa0>
        if(ulChannel < ptDevInstance->ulCommChannelCount)
 80079e8:	f8d5 3260 	ldr.w	r3, [r5, #608]	; 0x260
 80079ec:	4543      	cmp	r3, r8
 80079ee:	d903      	bls.n	80079f8 <cifXCheckIRQEnable+0xc4>
          ptChannelInst = ptDevInstance->pptCommChannels[ulChannel];
 80079f0:	f8d5 2264 	ldr.w	r2, [r5, #612]	; 0x264
 80079f4:	f852 6028 	ldr.w	r6, [r2, r8, lsl #2]
      } while(ulChannel++ < ptDevInstance->ulCommChannelCount);
 80079f8:	f108 0201 	add.w	r2, r8, #1
 80079fc:	4543      	cmp	r3, r8
 80079fe:	d901      	bls.n	8007a04 <cifXCheckIRQEnable+0xd0>
 8007a00:	4690      	mov	r8, r2
 8007a02:	e7cd      	b.n	80079a0 <cifXCheckIRQEnable+0x6c>
 8007a04:	2000      	movs	r0, #0
 8007a06:	e7e5      	b.n	80079d4 <cifXCheckIRQEnable+0xa0>
 8007a08:	20000038 	.word	0x20000038
 8007a0c:	800a0001 	.word	0x800a0001
 8007a10:	0800c3e4 	.word	0x0800c3e4
 8007a14:	0800c408 	.word	0x0800c408

08007a18 <cifXStopDevice>:
*            in an access violation/undefined behavious
*   \param ptDevInstance Instance to clean up
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
static int32_t cifXStopDevice(PDEVICEINSTANCE ptDevInstance)
{
 8007a18:	b538      	push	{r3, r4, r5, lr}
 8007a1a:	4604      	mov	r4, r0
  int32_t          lRet = CIFX_NO_ERROR;
  uint32_t         ulIdx          = 0;
  PCHANNELINSTANCE ptSystemDevice = &ptDevInstance->tSystemDevice;

  /* Process all created communication channels */
  for(ulIdx = 0; ulIdx < ptDevInstance->ulCommChannelCount; ++ulIdx)
 8007a1c:	2500      	movs	r5, #0
 8007a1e:	f8d4 3260 	ldr.w	r3, [r4, #608]	; 0x260
 8007a22:	42ab      	cmp	r3, r5
 8007a24:	d907      	bls.n	8007a36 <cifXStopDevice+0x1e>
  {
    PCHANNELINSTANCE ptChannelInst = ptDevInstance->pptCommChannels[ulIdx];
 8007a26:	f8d4 3264 	ldr.w	r3, [r4, #612]	; 0x264

    cifXDeleteChannelInstance(ptChannelInst);
 8007a2a:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8007a2e:	f7ff fdf3 	bl	8007618 <cifXDeleteChannelInstance>
  for(ulIdx = 0; ulIdx < ptDevInstance->ulCommChannelCount; ++ulIdx)
 8007a32:	3501      	adds	r5, #1
 8007a34:	e7f3      	b.n	8007a1e <cifXStopDevice+0x6>

  /*-------------------------------------------------*/
  /* Delete system channel objects                   */
  /*-------------------------------------------------*/
  /* Clean up all interrupt events */
  for( ulIdx = 0; ulIdx < sizeof(ptSystemDevice->ahHandshakeBitEvents) / sizeof(ptSystemDevice->ahHandshakeBitEvents[0]); ++ulIdx)
 8007a36:	2500      	movs	r5, #0
 8007a38:	e000      	b.n	8007a3c <cifXStopDevice+0x24>
 8007a3a:	3501      	adds	r5, #1
 8007a3c:	2d0f      	cmp	r5, #15
 8007a3e:	d811      	bhi.n	8007a64 <cifXStopDevice+0x4c>
  {
    if(NULL != ptSystemDevice->ahHandshakeBitEvents[ulIdx])
 8007a40:	f105 033e 	add.w	r3, r5, #62	; 0x3e
 8007a44:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8007a48:	f8d3 00f8 	ldr.w	r0, [r3, #248]	; 0xf8
 8007a4c:	2800      	cmp	r0, #0
 8007a4e:	d0f4      	beq.n	8007a3a <cifXStopDevice+0x22>
    {
      OS_DeleteEvent(ptSystemDevice->ahHandshakeBitEvents[ulIdx]);
 8007a50:	f7fb f90e 	bl	8002c70 <OS_DeleteEvent>
      ptSystemDevice->ahHandshakeBitEvents[ulIdx] = NULL;
 8007a54:	f105 033e 	add.w	r3, r5, #62	; 0x3e
 8007a58:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8007a5c:	2200      	movs	r2, #0
 8007a5e:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
 8007a62:	e7ea      	b.n	8007a3a <cifXStopDevice+0x22>
    }
  }

  OS_DeleteLock(ptSystemDevice->pvLock);
 8007a64:	f8d4 010c 	ldr.w	r0, [r4, #268]	; 0x10c
 8007a68:	f7fb f8b4 	bl	8002bd4 <OS_DeleteLock>
  ptSystemDevice->pvLock = NULL;
 8007a6c:	2500      	movs	r5, #0
 8007a6e:	f8c4 510c 	str.w	r5, [r4, #268]	; 0x10c
  OS_DeleteMutex(ptSystemDevice->pvInitMutex);
 8007a72:	f8d4 00f8 	ldr.w	r0, [r4, #248]	; 0xf8
 8007a76:	f7fb f8cf 	bl	8002c18 <OS_DeleteMutex>
  ptSystemDevice->pvInitMutex = NULL;
 8007a7a:	f8c4 50f8 	str.w	r5, [r4, #248]	; 0xf8
  OS_DeleteMutex(ptSystemDevice->tRecvMbx.pvRecvMBXMutex);
 8007a7e:	f8d4 0198 	ldr.w	r0, [r4, #408]	; 0x198
 8007a82:	f7fb f8c9 	bl	8002c18 <OS_DeleteMutex>
  ptSystemDevice->tRecvMbx.pvRecvMBXMutex = NULL;
 8007a86:	f8c4 5198 	str.w	r5, [r4, #408]	; 0x198
  OS_DeleteMutex(ptSystemDevice->tSendMbx.pvSendMBXMutex);
 8007a8a:	f8d4 0178 	ldr.w	r0, [r4, #376]	; 0x178
 8007a8e:	f7fb f8c3 	bl	8002c18 <OS_DeleteMutex>
  ptSystemDevice->tSendMbx.pvSendMBXMutex = NULL;
 8007a92:	f8c4 5178 	str.w	r5, [r4, #376]	; 0x178

  /*-------------------------------------------------*/
  /* Delete Communication channel array              */
  /*-------------------------------------------------*/
  OS_Memfree(ptDevInstance->pptCommChannels);
 8007a96:	f8d4 0264 	ldr.w	r0, [r4, #612]	; 0x264
 8007a9a:	f7fb f838 	bl	8002b0e <OS_Memfree>
  ptDevInstance->pptCommChannels    = NULL;
 8007a9e:	f8c4 5264 	str.w	r5, [r4, #612]	; 0x264
  ptDevInstance->ulCommChannelCount = 0;
 8007aa2:	f8c4 5260 	str.w	r5, [r4, #608]	; 0x260

  /* Remove sync resources */
  for(ulIdx = 0; ulIdx < sizeof(ptDevInstance->tSyncData.ahSyncBitEvents) / sizeof(ptDevInstance->tSyncData.ahSyncBitEvents[0]); ++ulIdx)
 8007aa6:	e000      	b.n	8007aaa <cifXStopDevice+0x92>
 8007aa8:	3501      	adds	r5, #1
 8007aaa:	2d0f      	cmp	r5, #15
 8007aac:	d80f      	bhi.n	8007ace <cifXStopDevice+0xb6>
  {
    if(NULL != ptDevInstance->tSyncData.ahSyncBitEvents[ulIdx])
 8007aae:	f105 039c 	add.w	r3, r5, #156	; 0x9c
 8007ab2:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8007ab6:	6898      	ldr	r0, [r3, #8]
 8007ab8:	2800      	cmp	r0, #0
 8007aba:	d0f5      	beq.n	8007aa8 <cifXStopDevice+0x90>
    {
      OS_DeleteEvent(ptDevInstance->tSyncData.ahSyncBitEvents[ulIdx]);
 8007abc:	f7fb f8d8 	bl	8002c70 <OS_DeleteEvent>
      ptDevInstance->tSyncData.ahSyncBitEvents[ulIdx] = NULL;
 8007ac0:	f105 039c 	add.w	r3, r5, #156	; 0x9c
 8007ac4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8007ac8:	2200      	movs	r2, #0
 8007aca:	609a      	str	r2, [r3, #8]
 8007acc:	e7ec      	b.n	8007aa8 <cifXStopDevice+0x90>
    }
  }
  OS_DeleteLock(ptDevInstance->tSyncData.pvLock);
 8007ace:	f8d4 026c 	ldr.w	r0, [r4, #620]	; 0x26c
 8007ad2:	f7fb f87f 	bl	8002bd4 <OS_DeleteLock>
  ptDevInstance->tSyncData.pvLock = NULL;
 8007ad6:	2300      	movs	r3, #0
 8007ad8:	f8c4 326c 	str.w	r3, [r4, #620]	; 0x26c

  /*-------------------------------------------------*/
  /* Remove Device instance from active devices list */
  /*-------------------------------------------------*/
  for(ulIdx = 0; ulIdx < g_ulDeviceCount; ++ulIdx)
 8007adc:	4a1d      	ldr	r2, [pc, #116]	; (8007b54 <cifXStopDevice+0x13c>)
 8007ade:	6812      	ldr	r2, [r2, #0]
 8007ae0:	429a      	cmp	r2, r3
 8007ae2:	d915      	bls.n	8007b10 <cifXStopDevice+0xf8>
  {
    if(g_pptDevices[ulIdx] == ptDevInstance)
 8007ae4:	491c      	ldr	r1, [pc, #112]	; (8007b58 <cifXStopDevice+0x140>)
 8007ae6:	6809      	ldr	r1, [r1, #0]
 8007ae8:	eb01 0083 	add.w	r0, r1, r3, lsl #2
 8007aec:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
 8007af0:	42a5      	cmp	r5, r4
 8007af2:	d001      	beq.n	8007af8 <cifXStopDevice+0xe0>
  for(ulIdx = 0; ulIdx < g_ulDeviceCount; ++ulIdx)
 8007af4:	3301      	adds	r3, #1
 8007af6:	e7f1      	b.n	8007adc <cifXStopDevice+0xc4>
    {
      OS_Memmove(&g_pptDevices[ulIdx],
                 &g_pptDevices[ulIdx + 1],
 8007af8:	1c5d      	adds	r5, r3, #1
                 (g_ulDeviceCount - ulIdx - 1) * (uint32_t)sizeof(*g_pptDevices));
 8007afa:	1ad2      	subs	r2, r2, r3
 8007afc:	3a01      	subs	r2, #1
      OS_Memmove(&g_pptDevices[ulIdx],
 8007afe:	0092      	lsls	r2, r2, #2
 8007b00:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 8007b04:	f7fb f817 	bl	8002b36 <OS_Memmove>
      --g_ulDeviceCount;
 8007b08:	4a12      	ldr	r2, [pc, #72]	; (8007b54 <cifXStopDevice+0x13c>)
 8007b0a:	6813      	ldr	r3, [r2, #0]
 8007b0c:	3b01      	subs	r3, #1
 8007b0e:	6013      	str	r3, [r2, #0]
  }

  /*-------------------------------------------------*/
  /* Check if we have removed the last device        */
  /*-------------------------------------------------*/
  if(0 == g_ulDeviceCount)
 8007b10:	4b10      	ldr	r3, [pc, #64]	; (8007b54 <cifXStopDevice+0x13c>)
 8007b12:	6819      	ldr	r1, [r3, #0]
 8007b14:	b931      	cbnz	r1, 8007b24 <cifXStopDevice+0x10c>
  {
    /* No more devices available */
    OS_Memfree(g_pptDevices);
 8007b16:	4c10      	ldr	r4, [pc, #64]	; (8007b58 <cifXStopDevice+0x140>)
 8007b18:	6820      	ldr	r0, [r4, #0]
 8007b1a:	f7fa fff8 	bl	8002b0e <OS_Memfree>
    g_pptDevices = NULL;
 8007b1e:	2000      	movs	r0, #0
 8007b20:	6020      	str	r0, [r4, #0]
      }
    }
  }

  return lRet;
}
 8007b22:	bd38      	pop	{r3, r4, r5, pc}
    g_pptDevices = (PDEVICEINSTANCE*)OS_Memrealloc(g_pptDevices, g_ulDeviceCount * (uint32_t)sizeof(*g_pptDevices));
 8007b24:	4d0c      	ldr	r5, [pc, #48]	; (8007b58 <cifXStopDevice+0x140>)
 8007b26:	0089      	lsls	r1, r1, #2
 8007b28:	6828      	ldr	r0, [r5, #0]
 8007b2a:	f7fa fff4 	bl	8002b16 <OS_Memrealloc>
 8007b2e:	6028      	str	r0, [r5, #0]
    if (NULL == g_pptDevices)
 8007b30:	b108      	cbz	r0, 8007b36 <cifXStopDevice+0x11e>
  int32_t          lRet = CIFX_NO_ERROR;
 8007b32:	2000      	movs	r0, #0
 8007b34:	e7f5      	b.n	8007b22 <cifXStopDevice+0x10a>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007b36:	4b09      	ldr	r3, [pc, #36]	; (8007b5c <cifXStopDevice+0x144>)
 8007b38:	681b      	ldr	r3, [r3, #0]
 8007b3a:	f013 0f08 	tst.w	r3, #8
 8007b3e:	d101      	bne.n	8007b44 <cifXStopDevice+0x12c>
      lRet = CIFX_INVALID_POINTER;
 8007b40:	4807      	ldr	r0, [pc, #28]	; (8007b60 <cifXStopDevice+0x148>)
  return lRet;
 8007b42:	e7ee      	b.n	8007b22 <cifXStopDevice+0x10a>
        USER_Trace(ptDevInstance,
 8007b44:	4a07      	ldr	r2, [pc, #28]	; (8007b64 <cifXStopDevice+0x14c>)
 8007b46:	2108      	movs	r1, #8
 8007b48:	4620      	mov	r0, r4
 8007b4a:	f001 fd79 	bl	8009640 <USER_Trace>
      lRet = CIFX_INVALID_POINTER;
 8007b4e:	4804      	ldr	r0, [pc, #16]	; (8007b60 <cifXStopDevice+0x148>)
 8007b50:	e7e7      	b.n	8007b22 <cifXStopDevice+0x10a>
 8007b52:	bf00      	nop
 8007b54:	2000021c 	.word	0x2000021c
 8007b58:	2000020c 	.word	0x2000020c
 8007b5c:	20000038 	.word	0x20000038
 8007b60:	800a0001 	.word	0x800a0001
 8007b64:	0800c430 	.word	0x0800c430

08007b68 <cifXDetectChipTypebyROMLoader>:
{
 8007b68:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007b6a:	b085      	sub	sp, #20
 8007b6c:	4604      	mov	r4, r0
 8007b6e:	460e      	mov	r6, r1
  uint32_t ulCookie = 0;
 8007b70:	2000      	movs	r0, #0
 8007b72:	9003      	str	r0, [sp, #12]
  ptDevInstance->eChipType = eCHIP_TYPE_UNKNOWN;
 8007b74:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
  HWIF_READN(ptDevInstance, &ulCookie, ptDevInstance->pbDPM, sizeof(ulCookie));
 8007b78:	f8d4 52c4 	ldr.w	r5, [r4, #708]	; 0x2c4
 8007b7c:	2304      	movs	r3, #4
 8007b7e:	9300      	str	r3, [sp, #0]
 8007b80:	ab03      	add	r3, sp, #12
 8007b82:	6a22      	ldr	r2, [r4, #32]
 8007b84:	4621      	mov	r1, r4
 8007b86:	47a8      	blx	r5
  if(ulCookie == HOST_TO_LE32(NETX50_BOOTID_DPM))
 8007b88:	9a03      	ldr	r2, [sp, #12]
 8007b8a:	4b1a      	ldr	r3, [pc, #104]	; (8007bf4 <cifXDetectChipTypebyROMLoader+0x8c>)
 8007b8c:	429a      	cmp	r2, r3
 8007b8e:	d10b      	bne.n	8007ba8 <cifXDetectChipTypebyROMLoader+0x40>
    ptDevInstance->eChipType = eCHIP_TYPE_NETX50;
 8007b90:	2303      	movs	r3, #3
 8007b92:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    lRet = CIFX_NO_ERROR;
 8007b96:	2500      	movs	r5, #0
  if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8007b98:	4b17      	ldr	r3, [pc, #92]	; (8007bf8 <cifXDetectChipTypebyROMLoader+0x90>)
 8007b9a:	681b      	ldr	r3, [r3, #0]
 8007b9c:	f013 0f01 	tst.w	r3, #1
 8007ba0:	d120      	bne.n	8007be4 <cifXDetectChipTypebyROMLoader+0x7c>
}
 8007ba2:	4628      	mov	r0, r5
 8007ba4:	b005      	add	sp, #20
 8007ba6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  } else if(IsNetX51or52ROM(ptDevInstance))
 8007ba8:	4620      	mov	r0, r4
 8007baa:	f001 fb0d 	bl	80091c8 <IsNetX51or52ROM>
 8007bae:	4605      	mov	r5, r0
 8007bb0:	b108      	cbz	r0, 8007bb6 <cifXDetectChipTypebyROMLoader+0x4e>
    lRet = CIFX_NO_ERROR;
 8007bb2:	2500      	movs	r5, #0
 8007bb4:	e7f0      	b.n	8007b98 <cifXDetectChipTypebyROMLoader+0x30>
  } else if(IsNetX4x00ROM(ptDevInstance))
 8007bb6:	4620      	mov	r0, r4
 8007bb8:	f001 fcce 	bl	8009558 <IsNetX4x00ROM>
 8007bbc:	4607      	mov	r7, r0
 8007bbe:	2800      	cmp	r0, #0
 8007bc0:	d1ea      	bne.n	8007b98 <cifXDetectChipTypebyROMLoader+0x30>
  } else if(IsNetX90ROM(ptDevInstance))
 8007bc2:	4620      	mov	r0, r4
 8007bc4:	f001 fcfc 	bl	80095c0 <IsNetX90ROM>
 8007bc8:	4605      	mov	r5, r0
 8007bca:	b938      	cbnz	r0, 8007bdc <cifXDetectChipTypebyROMLoader+0x74>
  } else if( (ulActDPMState & (MSK_SYSSTA_BOOT_ACTIVE | MSK_SYSSTA_LED_READY)) == (MSK_SYSSTA_BOOT_ACTIVE | MSK_SYSSTA_LED_READY) )
 8007bcc:	f006 0109 	and.w	r1, r6, #9
 8007bd0:	2909      	cmp	r1, #9
 8007bd2:	d105      	bne.n	8007be0 <cifXDetectChipTypebyROMLoader+0x78>
    ptDevInstance->eChipType = eCHIP_TYPE_NETX500;
 8007bd4:	2301      	movs	r3, #1
 8007bd6:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    lRet = CIFX_NO_ERROR;
 8007bda:	e7dd      	b.n	8007b98 <cifXDetectChipTypebyROMLoader+0x30>
    lRet = CIFX_NO_ERROR;
 8007bdc:	463d      	mov	r5, r7
 8007bde:	e7db      	b.n	8007b98 <cifXDetectChipTypebyROMLoader+0x30>
  int32_t  lRet     = CIFX_DRV_INIT_STATE_ERROR;
 8007be0:	4d06      	ldr	r5, [pc, #24]	; (8007bfc <cifXDetectChipTypebyROMLoader+0x94>)
 8007be2:	e7d9      	b.n	8007b98 <cifXDetectChipTypebyROMLoader+0x30>
    USER_Trace( ptDevInstance,
 8007be4:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8007be8:	4a05      	ldr	r2, [pc, #20]	; (8007c00 <cifXDetectChipTypebyROMLoader+0x98>)
 8007bea:	2101      	movs	r1, #1
 8007bec:	4620      	mov	r0, r4
 8007bee:	f001 fd27 	bl	8009640 <USER_Trace>
  return lRet;
 8007bf2:	e7d6      	b.n	8007ba2 <cifXDetectChipTypebyROMLoader+0x3a>
 8007bf4:	4c42584e 	.word	0x4c42584e
 8007bf8:	20000038 	.word	0x20000038
 8007bfc:	800b0002 	.word	0x800b0002
 8007c00:	0800c450 	.word	0x0800c450

08007c04 <cifXHardwareReset>:
{
 8007c04:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8007c08:	b085      	sub	sp, #20
 8007c0a:	4604      	mov	r4, r0
  volatile uint32_t*      pulHostReset   = &ptDevInstance->ptGlobalRegisters->ulHostReset;
 8007c0c:	6d06      	ldr	r6, [r0, #80]	; 0x50
 8007c0e:	f506 77ee 	add.w	r7, r6, #476	; 0x1dc
  volatile uint32_t*      pulSystemState = &ptDevInstance->ptGlobalRegisters->ulSystemState;
 8007c12:	f506 79ec 	add.w	r9, r6, #472	; 0x1d8
  if(ptDevInstance->fPCICard)
 8007c16:	68c3      	ldr	r3, [r0, #12]
 8007c18:	b963      	cbnz	r3, 8007c34 <cifXHardwareReset+0x30>
  void*                   pvPCIConfig    = NULL;
 8007c1a:	f04f 0800 	mov.w	r8, #0
  if( IsNetX51or52ROM(ptDevInstance))
 8007c1e:	4620      	mov	r0, r4
 8007c20:	f001 fad2 	bl	80091c8 <IsNetX51or52ROM>
 8007c24:	b120      	cbz	r0, 8007c30 <cifXHardwareReset+0x2c>
    NETX51_DPM_CONFIG_AREA_T* ptDpmConfig = (NETX51_DPM_CONFIG_AREA_T*)ptDevInstance->pbDPM;
 8007c26:	6a26      	ldr	r6, [r4, #32]
    pulHostReset   = &ptDpmConfig->ulDpmResetRequest;
 8007c28:	f106 07dc 	add.w	r7, r6, #220	; 0xdc
    pulSystemState = &ptDpmConfig->ulDpmSysSta;
 8007c2c:	f106 09d8 	add.w	r9, r6, #216	; 0xd8
  for(ulIdx = 0; ulIdx < sizeof(s_aulResetSequence) / sizeof(s_aulResetSequence[0]); ++ulIdx)
 8007c30:	2500      	movs	r5, #0
 8007c32:	e012      	b.n	8007c5a <cifXHardwareReset+0x56>
    pvPCIConfig = OS_ReadPCIConfig(ptDevInstance->pvOSDependent);
 8007c34:	69c0      	ldr	r0, [r0, #28]
 8007c36:	f7fa ff82 	bl	8002b3e <OS_ReadPCIConfig>
 8007c3a:	4680      	mov	r8, r0
 8007c3c:	e7ef      	b.n	8007c1e <cifXHardwareReset+0x1a>
    HWIF_WRITE32(ptDevInstance, *pulHostReset, HOST_TO_LE32(s_aulResetSequence[ulIdx]));
 8007c3e:	4b2c      	ldr	r3, [pc, #176]	; (8007cf0 <cifXHardwareReset+0xec>)
 8007c40:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8007c44:	9303      	str	r3, [sp, #12]
 8007c46:	2304      	movs	r3, #4
 8007c48:	9300      	str	r3, [sp, #0]
 8007c4a:	ab03      	add	r3, sp, #12
 8007c4c:	463a      	mov	r2, r7
 8007c4e:	4621      	mov	r1, r4
 8007c50:	2001      	movs	r0, #1
 8007c52:	f8d4 62c8 	ldr.w	r6, [r4, #712]	; 0x2c8
 8007c56:	47b0      	blx	r6
  for(ulIdx = 0; ulIdx < sizeof(s_aulResetSequence) / sizeof(s_aulResetSequence[0]); ++ulIdx)
 8007c58:	3501      	adds	r5, #1
 8007c5a:	2d08      	cmp	r5, #8
 8007c5c:	d9ef      	bls.n	8007c3e <cifXHardwareReset+0x3a>
  OS_Sleep(NET_BOOTLOADER_RESET_TIME);
 8007c5e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8007c62:	f7fa ff7b 	bl	8002b5c <OS_Sleep>
  if( ptDevInstance->fPCICard)
 8007c66:	68e3      	ldr	r3, [r4, #12]
 8007c68:	b96b      	cbnz	r3, 8007c86 <cifXHardwareReset+0x82>
  if(ptDevInstance->pfnNotify)
 8007c6a:	69a3      	ldr	r3, [r4, #24]
 8007c6c:	b143      	cbz	r3, 8007c80 <cifXHardwareReset+0x7c>
    if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8007c6e:	4a21      	ldr	r2, [pc, #132]	; (8007cf4 <cifXHardwareReset+0xf0>)
 8007c70:	6812      	ldr	r2, [r2, #0]
 8007c72:	f012 0f01 	tst.w	r2, #1
 8007c76:	d10b      	bne.n	8007c90 <cifXHardwareReset+0x8c>
    ptDevInstance->pfnNotify(ptDevInstance, eCIFX_TOOLKIT_EVENT_POSTRESET);
 8007c78:	69a3      	ldr	r3, [r4, #24]
 8007c7a:	2101      	movs	r1, #1
 8007c7c:	4620      	mov	r0, r4
 8007c7e:	4798      	blx	r3
  for(ulIdx = 0; ulIdx < sizeof(s_aulResetSequence) / sizeof(s_aulResetSequence[0]); ++ulIdx)
 8007c80:	481d      	ldr	r0, [pc, #116]	; (8007cf8 <cifXHardwareReset+0xf4>)
 8007c82:	2500      	movs	r5, #0
 8007c84:	e016      	b.n	8007cb4 <cifXHardwareReset+0xb0>
      OS_WritePCIConfig(ptDevInstance->pvOSDependent, pvPCIConfig);
 8007c86:	4641      	mov	r1, r8
 8007c88:	69e0      	ldr	r0, [r4, #28]
 8007c8a:	f7fa ff5a 	bl	8002b42 <OS_WritePCIConfig>
 8007c8e:	e7ec      	b.n	8007c6a <cifXHardwareReset+0x66>
      USER_Trace(ptDevInstance,
 8007c90:	4a1a      	ldr	r2, [pc, #104]	; (8007cfc <cifXHardwareReset+0xf8>)
 8007c92:	2101      	movs	r1, #1
 8007c94:	4620      	mov	r0, r4
 8007c96:	f001 fcd3 	bl	8009640 <USER_Trace>
 8007c9a:	e7ed      	b.n	8007c78 <cifXHardwareReset+0x74>
        USER_Trace(ptDevInstance,
 8007c9c:	4603      	mov	r3, r0
 8007c9e:	4a18      	ldr	r2, [pc, #96]	; (8007d00 <cifXHardwareReset+0xfc>)
 8007ca0:	2108      	movs	r1, #8
 8007ca2:	4620      	mov	r0, r4
 8007ca4:	f001 fccc 	bl	8009640 <USER_Trace>
      lRet = CIFX_MEMORY_MAPPING_FAILED;
 8007ca8:	4816      	ldr	r0, [pc, #88]	; (8007d04 <cifXHardwareReset+0x100>)
 8007caa:	e01d      	b.n	8007ce8 <cifXHardwareReset+0xe4>
      lRet = cifXDetectChipTypebyROMLoader( ptDevInstance, ulState);
 8007cac:	4620      	mov	r0, r4
 8007cae:	f7ff ff5b 	bl	8007b68 <cifXDetectChipTypebyROMLoader>
  for(ulIdx = 0; (ulIdx < NET_BOOTLOADER_STARTUP_CYCLES) && (lRet != CIFX_NO_ERROR); ++ulIdx)
 8007cb2:	3501      	adds	r5, #1
 8007cb4:	1e03      	subs	r3, r0, #0
 8007cb6:	bf18      	it	ne
 8007cb8:	2301      	movne	r3, #1
 8007cba:	2d31      	cmp	r5, #49	; 0x31
 8007cbc:	d814      	bhi.n	8007ce8 <cifXHardwareReset+0xe4>
 8007cbe:	b19b      	cbz	r3, 8007ce8 <cifXHardwareReset+0xe4>
    OS_Sleep(NET_BOOTLOADER_STARTUP_WAIT);
 8007cc0:	2064      	movs	r0, #100	; 0x64
 8007cc2:	f7fa ff4b 	bl	8002b5c <OS_Sleep>
    ulState = LE32_TO_HOST(HWIF_READ32(ptDevInstance, *pulSystemState)); /*lint !e564 */
 8007cc6:	4649      	mov	r1, r9
 8007cc8:	4620      	mov	r0, r4
 8007cca:	f7fd fb16 	bl	80052fa <HwIfRead32>
 8007cce:	4601      	mov	r1, r0
    if( (ulState == CIFX_DPM_INVALID_CONTENT)   ||
 8007cd0:	4b0d      	ldr	r3, [pc, #52]	; (8007d08 <cifXHardwareReset+0x104>)
 8007cd2:	4298      	cmp	r0, r3
 8007cd4:	bf18      	it	ne
 8007cd6:	f1b0 3fff 	cmpne.w	r0, #4294967295
 8007cda:	d1e7      	bne.n	8007cac <cifXHardwareReset+0xa8>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007cdc:	4b05      	ldr	r3, [pc, #20]	; (8007cf4 <cifXHardwareReset+0xf0>)
 8007cde:	681b      	ldr	r3, [r3, #0]
 8007ce0:	f013 0f08 	tst.w	r3, #8
 8007ce4:	d1da      	bne.n	8007c9c <cifXHardwareReset+0x98>
      lRet = CIFX_MEMORY_MAPPING_FAILED;
 8007ce6:	4807      	ldr	r0, [pc, #28]	; (8007d04 <cifXHardwareReset+0x100>)
}
 8007ce8:	b005      	add	sp, #20
 8007cea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8007cee:	bf00      	nop
 8007cf0:	0800ca6c 	.word	0x0800ca6c
 8007cf4:	20000038 	.word	0x20000038
 8007cf8:	800b0002 	.word	0x800b0002
 8007cfc:	0800c468 	.word	0x0800c468
 8007d00:	0800c4a8 	.word	0x0800c4a8
 8007d04:	800a0013 	.word	0x800a0013
 8007d08:	0bad0bad 	.word	0x0bad0bad

08007d0c <cifXStartRAMDevice>:
{
 8007d0c:	b538      	push	{r3, r4, r5, lr}
 8007d0e:	4604      	mov	r4, r0
  if(ptDevInstance->ulDPMSize < NETX_DPM_MEMORY_SIZE)
 8007d10:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8007d12:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8007d16:	d20d      	bcs.n	8007d34 <cifXStartRAMDevice+0x28>
    if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007d18:	4a25      	ldr	r2, [pc, #148]	; (8007db0 <cifXStartRAMDevice+0xa4>)
 8007d1a:	6812      	ldr	r2, [r2, #0]
 8007d1c:	f012 0f08 	tst.w	r2, #8
 8007d20:	d102      	bne.n	8007d28 <cifXStartRAMDevice+0x1c>
    lRet = CIFX_INVALID_BOARD;
 8007d22:	4d24      	ldr	r5, [pc, #144]	; (8007db4 <cifXStartRAMDevice+0xa8>)
}
 8007d24:	4628      	mov	r0, r5
 8007d26:	bd38      	pop	{r3, r4, r5, pc}
      USER_Trace( ptDevInstance,
 8007d28:	4a23      	ldr	r2, [pc, #140]	; (8007db8 <cifXStartRAMDevice+0xac>)
 8007d2a:	2108      	movs	r1, #8
 8007d2c:	f001 fc88 	bl	8009640 <USER_Trace>
    lRet = CIFX_INVALID_BOARD;
 8007d30:	4d20      	ldr	r5, [pc, #128]	; (8007db4 <cifXStartRAMDevice+0xa8>)
 8007d32:	e7f7      	b.n	8007d24 <cifXStartRAMDevice+0x18>
    if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8007d34:	4b1e      	ldr	r3, [pc, #120]	; (8007db0 <cifXStartRAMDevice+0xa4>)
 8007d36:	681b      	ldr	r3, [r3, #0]
 8007d38:	f013 0f01 	tst.w	r3, #1
 8007d3c:	d11b      	bne.n	8007d76 <cifXStartRAMDevice+0x6a>
    if(ptDevInstance->pfnNotify)
 8007d3e:	69a3      	ldr	r3, [r4, #24]
 8007d40:	b143      	cbz	r3, 8007d54 <cifXStartRAMDevice+0x48>
      if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8007d42:	4a1b      	ldr	r2, [pc, #108]	; (8007db0 <cifXStartRAMDevice+0xa4>)
 8007d44:	6812      	ldr	r2, [r2, #0]
 8007d46:	f012 0f01 	tst.w	r2, #1
 8007d4a:	d119      	bne.n	8007d80 <cifXStartRAMDevice+0x74>
      ptDevInstance->pfnNotify(ptDevInstance, eCIFX_TOOLKIT_EVENT_PRERESET);
 8007d4c:	69a3      	ldr	r3, [r4, #24]
 8007d4e:	2100      	movs	r1, #0
 8007d50:	4620      	mov	r0, r4
 8007d52:	4798      	blx	r3
    if(CIFX_NO_ERROR != (lRet = cifXHardwareReset(ptDevInstance)))
 8007d54:	4620      	mov	r0, r4
 8007d56:	f7ff ff55 	bl	8007c04 <cifXHardwareReset>
 8007d5a:	4605      	mov	r5, r0
 8007d5c:	b1b0      	cbz	r0, 8007d8c <cifXStartRAMDevice+0x80>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007d5e:	4b14      	ldr	r3, [pc, #80]	; (8007db0 <cifXStartRAMDevice+0xa4>)
 8007d60:	681b      	ldr	r3, [r3, #0]
 8007d62:	f013 0f08 	tst.w	r3, #8
 8007d66:	d0dd      	beq.n	8007d24 <cifXStartRAMDevice+0x18>
        USER_Trace( ptDevInstance,
 8007d68:	4603      	mov	r3, r0
 8007d6a:	4a14      	ldr	r2, [pc, #80]	; (8007dbc <cifXStartRAMDevice+0xb0>)
 8007d6c:	2108      	movs	r1, #8
 8007d6e:	4620      	mov	r0, r4
 8007d70:	f001 fc66 	bl	8009640 <USER_Trace>
 8007d74:	e7d6      	b.n	8007d24 <cifXStartRAMDevice+0x18>
      USER_Trace( ptDevInstance,
 8007d76:	4a12      	ldr	r2, [pc, #72]	; (8007dc0 <cifXStartRAMDevice+0xb4>)
 8007d78:	2101      	movs	r1, #1
 8007d7a:	f001 fc61 	bl	8009640 <USER_Trace>
 8007d7e:	e7de      	b.n	8007d3e <cifXStartRAMDevice+0x32>
        USER_Trace( ptDevInstance,
 8007d80:	4a10      	ldr	r2, [pc, #64]	; (8007dc4 <cifXStartRAMDevice+0xb8>)
 8007d82:	2101      	movs	r1, #1
 8007d84:	4620      	mov	r0, r4
 8007d86:	f001 fc5b 	bl	8009640 <USER_Trace>
 8007d8a:	e7df      	b.n	8007d4c <cifXStartRAMDevice+0x40>
    } else if( CIFX_NO_ERROR != (lRet = cifXRunBootloader(ptDevInstance)))
 8007d8c:	4620      	mov	r0, r4
 8007d8e:	f7fe fa61 	bl	8006254 <cifXRunBootloader>
 8007d92:	4605      	mov	r5, r0
 8007d94:	2800      	cmp	r0, #0
 8007d96:	d0c5      	beq.n	8007d24 <cifXStartRAMDevice+0x18>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8007d98:	4b05      	ldr	r3, [pc, #20]	; (8007db0 <cifXStartRAMDevice+0xa4>)
 8007d9a:	681b      	ldr	r3, [r3, #0]
 8007d9c:	f013 0f08 	tst.w	r3, #8
 8007da0:	d0c0      	beq.n	8007d24 <cifXStartRAMDevice+0x18>
        USER_Trace( ptDevInstance,
 8007da2:	4603      	mov	r3, r0
 8007da4:	4a08      	ldr	r2, [pc, #32]	; (8007dc8 <cifXStartRAMDevice+0xbc>)
 8007da6:	2108      	movs	r1, #8
 8007da8:	4620      	mov	r0, r4
 8007daa:	f001 fc49 	bl	8009640 <USER_Trace>
 8007dae:	e7b9      	b.n	8007d24 <cifXStartRAMDevice+0x18>
 8007db0:	20000038 	.word	0x20000038
 8007db4:	800a0002 	.word	0x800a0002
 8007db8:	0800c4d8 	.word	0x0800c4d8
 8007dbc:	0800c5ac 	.word	0x0800c5ac
 8007dc0:	0800c530 	.word	0x0800c530
 8007dc4:	0800c564 	.word	0x0800c564
 8007dc8:	0800c610 	.word	0x0800c610

08007dcc <cifXReadHardwareIdent>:
{
 8007dcc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007dce:	f2ad 6d7c 	subw	sp, sp, #1660	; 0x67c
 8007dd2:	4604      	mov	r4, r0
 8007dd4:	460e      	mov	r6, r1
 8007dd6:	4617      	mov	r7, r2
  PCHANNELINSTANCE ptSystemdevice = &ptDevInstance->tSystemDevice;
 8007dd8:	4605      	mov	r5, r0
  OS_Memset(&tSendPkt, 0, sizeof(tSendPkt));
 8007dda:	2228      	movs	r2, #40	; 0x28
 8007ddc:	2100      	movs	r1, #0
 8007dde:	f50d 60ca 	add.w	r0, sp, #1616	; 0x650
 8007de2:	f7fa fe9c 	bl	8002b1e <OS_Memset>
  OS_Memset(&tRecvPkt, 0, sizeof(tRecvPkt));
 8007de6:	f240 623c 	movw	r2, #1596	; 0x63c
 8007dea:	2100      	movs	r1, #0
 8007dec:	a805      	add	r0, sp, #20
 8007dee:	f7fa fe96 	bl	8002b1e <OS_Memset>
  tSendPkt.tHead.ulDest       = HOST_TO_LE32(HIL_PACKET_DEST_SYSTEM);
 8007df2:	2300      	movs	r3, #0
 8007df4:	f8cd 3650 	str.w	r3, [sp, #1616]	; 0x650
  tSendPkt.tHead.ulSrc        = HOST_TO_LE32(ptDevInstance->ulPhysicalAddress);
 8007df8:	f855 2bf4 	ldr.w	r2, [r5], #244
 8007dfc:	f8cd 2654 	str.w	r2, [sp, #1620]	; 0x654
  tSendPkt.tHead.ulCmd        = HOST_TO_LE32(HIL_HW_IDENTIFY_REQ);
 8007e00:	f641 62b8 	movw	r2, #7864	; 0x1eb8
 8007e04:	f8cd 266c 	str.w	r2, [sp, #1644]	; 0x66c
  tSendPkt.tHead.ulLen        = 0;
 8007e08:	f8cd 3660 	str.w	r3, [sp, #1632]	; 0x660
  lRet = DEV_TransferPacket( ptSystemdevice,
 8007e0c:	9702      	str	r7, [sp, #8]
 8007e0e:	9601      	str	r6, [sp, #4]
 8007e10:	f241 3388 	movw	r3, #5000	; 0x1388
 8007e14:	9300      	str	r3, [sp, #0]
 8007e16:	f240 633c 	movw	r3, #1596	; 0x63c
 8007e1a:	aa05      	add	r2, sp, #20
 8007e1c:	f50d 61ca 	add.w	r1, sp, #1616	; 0x650
 8007e20:	4628      	mov	r0, r5
 8007e22:	f7fd fda9 	bl	8005978 <DEV_TransferPacket>
  if( (CIFX_NO_ERROR  != lRet) ||
 8007e26:	4605      	mov	r5, r0
 8007e28:	b908      	cbnz	r0, 8007e2e <cifXReadHardwareIdent+0x62>
      (SUCCESS_HIL_OK != (lRet = LE32_TO_HOST(tRecvPkt.tHeader.ulState))) )
 8007e2a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  if( (CIFX_NO_ERROR  != lRet) ||
 8007e2c:	b17d      	cbz	r5, 8007e4e <cifXReadHardwareIdent+0x82>
    if(g_ulTraceLevel & TRACE_LEVEL_WARNING)
 8007e2e:	4b0a      	ldr	r3, [pc, #40]	; (8007e58 <cifXReadHardwareIdent+0x8c>)
 8007e30:	681b      	ldr	r3, [r3, #0]
 8007e32:	f013 0f04 	tst.w	r3, #4
 8007e36:	d103      	bne.n	8007e40 <cifXReadHardwareIdent+0x74>
}
 8007e38:	4628      	mov	r0, r5
 8007e3a:	f20d 6d7c 	addw	sp, sp, #1660	; 0x67c
 8007e3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      USER_Trace(ptDevInstance,
 8007e40:	462b      	mov	r3, r5
 8007e42:	4a06      	ldr	r2, [pc, #24]	; (8007e5c <cifXReadHardwareIdent+0x90>)
 8007e44:	2104      	movs	r1, #4
 8007e46:	4620      	mov	r0, r4
 8007e48:	f001 fbfa 	bl	8009640 <USER_Trace>
 8007e4c:	e7f4      	b.n	8007e38 <cifXReadHardwareIdent+0x6c>
    ptDevInstance->eChipType  = (CIFX_TOOLKIT_CHIPTYPE_E)LE32_TO_HOST(ptData->tData.ulChipTyp);
 8007e4e:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 8007e52:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
  return lRet;
 8007e56:	e7ef      	b.n	8007e38 <cifXReadHardwareIdent+0x6c>
 8007e58:	20000038 	.word	0x20000038
 8007e5c:	0800c640 	.word	0x0800c640

08007e60 <cifXReadFirmwareIdent>:
{
 8007e60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007e64:	f5ad 6dcf 	sub.w	sp, sp, #1656	; 0x678
 8007e68:	4604      	mov	r4, r0
 8007e6a:	460d      	mov	r5, r1
 8007e6c:	4616      	mov	r6, r2
 8007e6e:	461f      	mov	r7, r3
  PCHANNELINSTANCE ptChannelInst = ptDevInstance->pptCommChannels[ulChannel];
 8007e70:	f8d0 3264 	ldr.w	r3, [r0, #612]	; 0x264
 8007e74:	f853 8021 	ldr.w	r8, [r3, r1, lsl #2]
  OS_Memset(&tSendPkt, 0, sizeof(tSendPkt));
 8007e78:	222c      	movs	r2, #44	; 0x2c
 8007e7a:	2100      	movs	r1, #0
 8007e7c:	f20d 604c 	addw	r0, sp, #1612	; 0x64c
 8007e80:	f7fa fe4d 	bl	8002b1e <OS_Memset>
  OS_Memset(&tRecvPkt, 0, sizeof(tRecvPkt));
 8007e84:	f240 623c 	movw	r2, #1596	; 0x63c
 8007e88:	2100      	movs	r1, #0
 8007e8a:	a804      	add	r0, sp, #16
 8007e8c:	f7fa fe47 	bl	8002b1e <OS_Memset>
  tSendPkt.tHead.ulDest       = HOST_TO_LE32(HIL_PACKET_DEST_DEFAULT_CHANNEL);
 8007e90:	2320      	movs	r3, #32
 8007e92:	f8cd 364c 	str.w	r3, [sp, #1612]	; 0x64c
  tSendPkt.tHead.ulSrc        = HOST_TO_LE32(ptDevInstance->ulPhysicalAddress);
 8007e96:	6823      	ldr	r3, [r4, #0]
 8007e98:	f8cd 3650 	str.w	r3, [sp, #1616]	; 0x650
  tSendPkt.tHead.ulCmd        = HOST_TO_LE32(HIL_FIRMWARE_IDENTIFY_REQ);
 8007e9c:	f641 63b6 	movw	r3, #7862	; 0x1eb6
 8007ea0:	f8cd 3668 	str.w	r3, [sp, #1640]	; 0x668
  tSendPkt.tHead.ulLen        = HOST_TO_LE32(sizeof(tSendPkt.tData));
 8007ea4:	2304      	movs	r3, #4
 8007ea6:	f8cd 365c 	str.w	r3, [sp, #1628]	; 0x65c
  tSendPkt.tData.ulChannelId  = HOST_TO_LE32(ulChannel);
 8007eaa:	f8cd 5674 	str.w	r5, [sp, #1652]	; 0x674
  lRet = DEV_TransferPacket( ptChannelInst,
 8007eae:	9702      	str	r7, [sp, #8]
 8007eb0:	9601      	str	r6, [sp, #4]
 8007eb2:	f241 3388 	movw	r3, #5000	; 0x1388
 8007eb6:	9300      	str	r3, [sp, #0]
 8007eb8:	f240 633c 	movw	r3, #1596	; 0x63c
 8007ebc:	aa04      	add	r2, sp, #16
 8007ebe:	f20d 614c 	addw	r1, sp, #1612	; 0x64c
 8007ec2:	4640      	mov	r0, r8
 8007ec4:	f7fd fd58 	bl	8005978 <DEV_TransferPacket>
  if( (CIFX_NO_ERROR  != lRet) ||
 8007ec8:	4605      	mov	r5, r0
 8007eca:	b908      	cbnz	r0, 8007ed0 <cifXReadFirmwareIdent+0x70>
      (SUCCESS_HIL_OK != (lRet = LE32_TO_HOST(tRecvPkt.tHeader.ulState))) )
 8007ecc:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  if( (CIFX_NO_ERROR  != lRet) ||
 8007ece:	b185      	cbz	r5, 8007ef2 <cifXReadFirmwareIdent+0x92>
    if(g_ulTraceLevel & TRACE_LEVEL_WARNING)
 8007ed0:	4b10      	ldr	r3, [pc, #64]	; (8007f14 <cifXReadFirmwareIdent+0xb4>)
 8007ed2:	681b      	ldr	r3, [r3, #0]
 8007ed4:	f013 0f04 	tst.w	r3, #4
 8007ed8:	d104      	bne.n	8007ee4 <cifXReadFirmwareIdent+0x84>
}
 8007eda:	4628      	mov	r0, r5
 8007edc:	f50d 6dcf 	add.w	sp, sp, #1656	; 0x678
 8007ee0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      USER_Trace(ptDevInstance,
 8007ee4:	462b      	mov	r3, r5
 8007ee6:	4a0c      	ldr	r2, [pc, #48]	; (8007f18 <cifXReadFirmwareIdent+0xb8>)
 8007ee8:	2104      	movs	r1, #4
 8007eea:	4620      	mov	r0, r4
 8007eec:	f001 fba8 	bl	8009640 <USER_Trace>
 8007ef0:	e7f3      	b.n	8007eda <cifXReadFirmwareIdent+0x7a>
    OS_Memcpy( &ptChannelInst->tFirmwareIdent,
 8007ef2:	f108 0828 	add.w	r8, r8, #40	; 0x28
 8007ef6:	224c      	movs	r2, #76	; 0x4c
 8007ef8:	a90e      	add	r1, sp, #56	; 0x38
 8007efa:	4640      	mov	r0, r8
 8007efc:	f7fa fe13 	bl	8002b26 <OS_Memcpy>
    (void)cifXConvertEndianess(0,
 8007f00:	2302      	movs	r3, #2
 8007f02:	9300      	str	r3, [sp, #0]
 8007f04:	4b05      	ldr	r3, [pc, #20]	; (8007f1c <cifXReadFirmwareIdent+0xbc>)
 8007f06:	224c      	movs	r2, #76	; 0x4c
 8007f08:	4641      	mov	r1, r8
 8007f0a:	2000      	movs	r0, #0
 8007f0c:	f7fc fbba 	bl	8004684 <cifXConvertEndianess>
  return lRet;
 8007f10:	e7e3      	b.n	8007eda <cifXReadFirmwareIdent+0x7a>
 8007f12:	bf00      	nop
 8007f14:	20000038 	.word	0x20000038
 8007f18:	0800c674 	.word	0x0800c674
 8007f1c:	0800ca54 	.word	0x0800ca54

08007f20 <cifXCreateChannels>:
{
 8007f20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007f24:	b089      	sub	sp, #36	; 0x24
 8007f26:	4605      	mov	r5, r0
 8007f28:	9107      	str	r1, [sp, #28]
  HIL_DPM_SYSTEM_CHANNEL_T*         ptSysChannel     = (HIL_DPM_SYSTEM_CHANNEL_T*)ptDevInstance->tSystemDevice.pbDPMChannelStart;
 8007f2a:	f8d0 80fc 	ldr.w	r8, [r0, #252]	; 0xfc
  ulDPMChannelStartAddress  = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysChannelInfo->ulSizeOfChannel)); /* Start behind the system channel */
 8007f2e:	f108 0434 	add.w	r4, r8, #52	; 0x34
 8007f32:	4621      	mov	r1, r4
 8007f34:	f7fd f9e1 	bl	80052fa <HwIfRead32>
 8007f38:	4683      	mov	fp, r0
  ptHskBlock                = (HIL_DPM_HANDSHAKE_ARRAY_T*)(ptDevInstance->pbDPM +
 8007f3a:	6a2e      	ldr	r6, [r5, #32]
                              LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysChannelInfo->ulSizeOfChannel)));
 8007f3c:	4621      	mov	r1, r4
 8007f3e:	4628      	mov	r0, r5
 8007f40:	f7fd f9db 	bl	80052fa <HwIfRead32>
  ptHskBlock                = (HIL_DPM_HANDSHAKE_ARRAY_T*)(ptDevInstance->pbDPM +
 8007f44:	1833      	adds	r3, r6, r0
 8007f46:	9305      	str	r3, [sp, #20]
  if(HWIF_READ8(ptDevInstance, ptHskBlockInfo->bChannelType) == HIL_CHANNEL_TYPE_HANDSHAKE)
 8007f48:	f108 0140 	add.w	r1, r8, #64	; 0x40
 8007f4c:	4628      	mov	r0, r5
 8007f4e:	f7fd f993 	bl	8005278 <HwIfRead8>
 8007f52:	2804      	cmp	r0, #4
 8007f54:	d009      	beq.n	8007f6a <cifXCreateChannels+0x4a>
  uint32_t ulDPMChannelStartIdx      = HIL_DPM_SYSTEM_CHANNEL_INDEX;         /* Start of the communication channel definitions */
 8007f56:	2600      	movs	r6, #0
  ptChannel = &ptSysChannel->atChannelInfo[ulDPMChannelStartIdx];
 8007f58:	1cf4      	adds	r4, r6, #3
 8007f5a:	eb08 1404 	add.w	r4, r8, r4, lsl #4
  uint32_t                          ulChannelID      = 0; /* The dedicated communication channel ID */
 8007f5e:	2300      	movs	r3, #0
 8007f60:	9304      	str	r3, [sp, #16]
  int32_t         lRet     = CIFX_NO_ERROR;
 8007f62:	4699      	mov	r9, r3
 8007f64:	f8cd 8018 	str.w	r8, [sp, #24]
  for(ulBlockID = ulDPMChannelStartIdx; ulBlockID < HIL_DPM_MAX_SUPPORTED_CHANNELS; ++ulBlockID)
 8007f68:	e014      	b.n	8007f94 <cifXCreateChannels+0x74>
    ptDevInstance->pbHandshakeBlock = ptDevInstance->pbDPM + ulDPMChannelStartAddress;
 8007f6a:	6a2b      	ldr	r3, [r5, #32]
 8007f6c:	445b      	add	r3, fp
 8007f6e:	662b      	str	r3, [r5, #96]	; 0x60
    ulDPMChannelStartAddress       += LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptHskBlockInfo->ulSizeOfChannel));
 8007f70:	f108 0144 	add.w	r1, r8, #68	; 0x44
 8007f74:	4628      	mov	r0, r5
 8007f76:	f7fd f9c0 	bl	80052fa <HwIfRead32>
 8007f7a:	4483      	add	fp, r0
    ulDPMChannelStartIdx            = HIL_DPM_COM_CHANNEL_START_INDEX;
 8007f7c:	2602      	movs	r6, #2
 8007f7e:	e7eb      	b.n	8007f58 <cifXCreateChannels+0x38>
        ptDevInstance->pbHandshakeBlock = ptDevInstance->pbDPM + ulDPMChannelStartAddress;
 8007f80:	6a2b      	ldr	r3, [r5, #32]
 8007f82:	445b      	add	r3, fp
 8007f84:	662b      	str	r3, [r5, #96]	; 0x60
    ulDPMChannelStartAddress += LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptChannel->tCom.ulSizeOfChannel));
 8007f86:	1d21      	adds	r1, r4, #4
 8007f88:	4628      	mov	r0, r5
 8007f8a:	f7fd f9b6 	bl	80052fa <HwIfRead32>
 8007f8e:	4483      	add	fp, r0
    ptChannel++;
 8007f90:	3410      	adds	r4, #16
  for(ulBlockID = ulDPMChannelStartIdx; ulBlockID < HIL_DPM_MAX_SUPPORTED_CHANNELS; ++ulBlockID)
 8007f92:	3601      	adds	r6, #1
 8007f94:	2e07      	cmp	r6, #7
 8007f96:	d879      	bhi.n	800808c <cifXCreateChannels+0x16c>
    switch(HWIF_READ8(ptDevInstance, ptChannel->tSystem.bChannelType))
 8007f98:	9403      	str	r4, [sp, #12]
 8007f9a:	4621      	mov	r1, r4
 8007f9c:	4628      	mov	r0, r5
 8007f9e:	f7fd f96b 	bl	8005278 <HwIfRead8>
 8007fa2:	2804      	cmp	r0, #4
 8007fa4:	d0ec      	beq.n	8007f80 <cifXCreateChannels+0x60>
 8007fa6:	d3ee      	bcc.n	8007f86 <cifXCreateChannels+0x66>
 8007fa8:	3805      	subs	r0, #5
 8007faa:	b2c0      	uxtb	r0, r0
 8007fac:	2801      	cmp	r0, #1
 8007fae:	d8ea      	bhi.n	8007f86 <cifXCreateChannels+0x66>
      if( ptDevInstance->ulDPMSize < (LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptChannel->tCom.ulSizeOfChannel)) + ulDPMChannelStartAddress))
 8007fb0:	6a6f      	ldr	r7, [r5, #36]	; 0x24
 8007fb2:	f104 0a04 	add.w	sl, r4, #4
 8007fb6:	4651      	mov	r1, sl
 8007fb8:	4628      	mov	r0, r5
 8007fba:	f7fd f99e 	bl	80052fa <HwIfRead32>
 8007fbe:	4458      	add	r0, fp
 8007fc0:	4287      	cmp	r7, r0
 8007fc2:	d35c      	bcc.n	800807e <cifXCreateChannels+0x15e>
      ptChannelInst = (PCHANNELINSTANCE)OS_Memalloc(sizeof(*ptChannelInst));
 8007fc4:	f44f 70b6 	mov.w	r0, #364	; 0x16c
 8007fc8:	f7fa fd9d 	bl	8002b06 <OS_Memalloc>
      if (NULL == ptChannelInst                    ||
 8007fcc:	4607      	mov	r7, r0
 8007fce:	2800      	cmp	r0, #0
 8007fd0:	d071      	beq.n	80080b6 <cifXCreateChannels+0x196>
          NULL == (pvInitMutex = OS_CreateMutex()) ||
 8007fd2:	f7fa fe00 	bl	8002bd6 <OS_CreateMutex>
      if (NULL == ptChannelInst                    ||
 8007fd6:	4680      	mov	r8, r0
 8007fd8:	2800      	cmp	r0, #0
 8007fda:	d06f      	beq.n	80080bc <cifXCreateChannels+0x19c>
          NULL == (pvLock      = OS_CreateLock())  )
 8007fdc:	f7fa fdfd 	bl	8002bda <OS_CreateLock>
          NULL == (pvInitMutex = OS_CreateMutex()) ||
 8007fe0:	4681      	mov	r9, r0
 8007fe2:	2800      	cmp	r0, #0
 8007fe4:	d06b      	beq.n	80080be <cifXCreateChannels+0x19e>
        OS_Memset(ptChannelInst, 0, sizeof(*ptChannelInst));
 8007fe6:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 8007fea:	2100      	movs	r1, #0
 8007fec:	4638      	mov	r0, r7
 8007fee:	f7fa fd96 	bl	8002b1e <OS_Memset>
        ptChannelInst->ulChannelNumber    = ulChannelID;
 8007ff2:	9b04      	ldr	r3, [sp, #16]
 8007ff4:	613b      	str	r3, [r7, #16]
        ptChannelInst->ulBlockID          = ulBlockID;
 8007ff6:	617e      	str	r6, [r7, #20]
        ptChannelInst->pbDPMChannelStart  = ptDevInstance->pbDPM + ulDPMChannelStartAddress;
 8007ff8:	6a2b      	ldr	r3, [r5, #32]
 8007ffa:	445b      	add	r3, fp
 8007ffc:	60bb      	str	r3, [r7, #8]
        ptChannelInst->ulDPMChannelLength = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptChannel->tCom.ulSizeOfChannel));
 8007ffe:	4651      	mov	r1, sl
 8008000:	4628      	mov	r0, r5
 8008002:	f7fd f97a 	bl	80052fa <HwIfRead32>
 8008006:	60f8      	str	r0, [r7, #12]
        ptChannelInst->pvLock             = pvLock;
 8008008:	f8c7 9018 	str.w	r9, [r7, #24]
        ptChannelInst->pvInitMutex        = pvInitMutex;
 800800c:	f8c7 8004 	str.w	r8, [r7, #4]
        ptChannelInst->pvDeviceInstance   = (void*)ptDevInstance;
 8008010:	603d      	str	r5, [r7, #0]
        ptChannelInst->ptHandshakeCell    = (HIL_DPM_HANDSHAKE_CELL_T*)&ptHskBlock->atHsk[ulBlockID];
 8008012:	9b05      	ldr	r3, [sp, #20]
 8008014:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8008018:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
        if((HWIF_READ8(ptDevInstance, ptChannel->tCom.bSizePositionOfHandshake) & HIL_HANDSHAKE_POSITION_MASK) == HIL_HANDSHAKE_POSITION_BEGINNING)
 800801c:	f104 0802 	add.w	r8, r4, #2
 8008020:	4641      	mov	r1, r8
 8008022:	4628      	mov	r0, r5
 8008024:	f7fd f928 	bl	8005278 <HwIfRead8>
 8008028:	f010 0ff0 	tst.w	r0, #240	; 0xf0
 800802c:	d102      	bne.n	8008034 <cifXCreateChannels+0x114>
          ptChannelInst->ptHandshakeCell  = (HIL_DPM_HANDSHAKE_CELL_T*)ptChannelInst->pbDPMChannelStart;
 800802e:	68bb      	ldr	r3, [r7, #8]
 8008030:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
        ptChannelInst->bHandshakeWidth    = HWIF_READ8(ptDevInstance, ptChannel->tCom.bSizePositionOfHandshake) & HIL_HANDSHAKE_SIZE_MASK;
 8008034:	4641      	mov	r1, r8
 8008036:	4628      	mov	r0, r5
 8008038:	f7fd f91e 	bl	8005278 <HwIfRead8>
 800803c:	f000 000f 	and.w	r0, r0, #15
 8008040:	f887 00f8 	strb.w	r0, [r7, #248]	; 0xf8
        DEV_ReadHostFlags(ptChannelInst, 1);
 8008044:	2101      	movs	r1, #1
 8008046:	4638      	mov	r0, r7
 8008048:	f7fd f967 	bl	800531a <DEV_ReadHostFlags>
        DEV_ReadHandshakeFlags(ptChannelInst, 0, 0);
 800804c:	2200      	movs	r2, #0
 800804e:	4611      	mov	r1, r2
 8008050:	4638      	mov	r0, r7
 8008052:	f7fd f99a 	bl	800538a <DEV_ReadHandshakeFlags>
        if (CIFX_NO_ERROR != (lRet = cifXReadChannelLayout(ptDevInstance, ptChannelInst, HWIF_READ8(ptDevInstance, ptSysChannel->atChannelInfo[ulBlockID].tCom.bNumberOfBlocks))))
 8008056:	1cf1      	adds	r1, r6, #3
 8008058:	9b06      	ldr	r3, [sp, #24]
 800805a:	eb03 1101 	add.w	r1, r3, r1, lsl #4
 800805e:	3103      	adds	r1, #3
 8008060:	4628      	mov	r0, r5
 8008062:	f7fd f909 	bl	8005278 <HwIfRead8>
 8008066:	4602      	mov	r2, r0
 8008068:	4639      	mov	r1, r7
 800806a:	4628      	mov	r0, r5
 800806c:	f7fe fe20 	bl	8006cb0 <cifXReadChannelLayout>
 8008070:	4681      	mov	r9, r0
 8008072:	2800      	cmp	r0, #0
 8008074:	d03c      	beq.n	80080f0 <cifXCreateChannels+0x1d0>
          cifXDeleteChannelInstance(ptChannelInst);
 8008076:	4638      	mov	r0, r7
 8008078:	f7ff face 	bl	8007618 <cifXDeleteChannelInstance>
 800807c:	e783      	b.n	8007f86 <cifXCreateChannels+0x66>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 800807e:	4b71      	ldr	r3, [pc, #452]	; (8008244 <cifXCreateChannels+0x324>)
 8008080:	681b      	ldr	r3, [r3, #0]
 8008082:	f013 0f08 	tst.w	r3, #8
 8008086:	d10f      	bne.n	80080a8 <cifXCreateChannels+0x188>
        ptDevInstance->lInitError = CIFX_DEV_DPMSIZE_MISMATCH;
 8008088:	4b6f      	ldr	r3, [pc, #444]	; (8008248 <cifXCreateChannels+0x328>)
 800808a:	64eb      	str	r3, [r5, #76]	; 0x4c
  if( (g_ulTraceLevel & TRACE_LEVEL_INFO) &&
 800808c:	4b6d      	ldr	r3, [pc, #436]	; (8008244 <cifXCreateChannels+0x324>)
 800808e:	681b      	ldr	r3, [r3, #0]
 8008090:	f013 0f02 	tst.w	r3, #2
 8008094:	d004      	beq.n	80080a0 <cifXCreateChannels+0x180>
      (0 == ptDevInstance->ulCommChannelCount) )
 8008096:	f8d5 3260 	ldr.w	r3, [r5, #608]	; 0x260
  if( (g_ulTraceLevel & TRACE_LEVEL_INFO) &&
 800809a:	2b00      	cmp	r3, #0
 800809c:	f000 80cc 	beq.w	8008238 <cifXCreateChannels+0x318>
}
 80080a0:	4648      	mov	r0, r9
 80080a2:	b009      	add	sp, #36	; 0x24
 80080a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          USER_Trace(ptDevInstance,
 80080a8:	9b04      	ldr	r3, [sp, #16]
 80080aa:	4a68      	ldr	r2, [pc, #416]	; (800824c <cifXCreateChannels+0x32c>)
 80080ac:	2108      	movs	r1, #8
 80080ae:	4628      	mov	r0, r5
 80080b0:	f001 fac6 	bl	8009640 <USER_Trace>
 80080b4:	e7e8      	b.n	8008088 <cifXCreateChannels+0x168>
      void* pvLock      = NULL;
 80080b6:	4681      	mov	r9, r0
      void* pvInitMutex = NULL;
 80080b8:	4680      	mov	r8, r0
 80080ba:	e000      	b.n	80080be <cifXCreateChannels+0x19e>
      void* pvLock      = NULL;
 80080bc:	4681      	mov	r9, r0
        OS_Memfree(ptChannelInst);
 80080be:	4638      	mov	r0, r7
 80080c0:	f7fa fd25 	bl	8002b0e <OS_Memfree>
        OS_DeleteMutex(pvInitMutex);
 80080c4:	4640      	mov	r0, r8
 80080c6:	f7fa fda7 	bl	8002c18 <OS_DeleteMutex>
        OS_DeleteLock(pvLock);
 80080ca:	4648      	mov	r0, r9
 80080cc:	f7fa fd82 	bl	8002bd4 <OS_DeleteLock>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80080d0:	4b5c      	ldr	r3, [pc, #368]	; (8008244 <cifXCreateChannels+0x324>)
 80080d2:	681b      	ldr	r3, [r3, #0]
 80080d4:	f013 0f08 	tst.w	r3, #8
 80080d8:	d102      	bne.n	80080e0 <cifXCreateChannels+0x1c0>
        lRet = CIFX_INVALID_POINTER;
 80080da:	f8df 9190 	ldr.w	r9, [pc, #400]	; 800826c <cifXCreateChannels+0x34c>
 80080de:	e752      	b.n	8007f86 <cifXCreateChannels+0x66>
          USER_Trace(ptDevInstance,
 80080e0:	4a5b      	ldr	r2, [pc, #364]	; (8008250 <cifXCreateChannels+0x330>)
 80080e2:	2108      	movs	r1, #8
 80080e4:	4628      	mov	r0, r5
 80080e6:	f001 faab 	bl	8009640 <USER_Trace>
        lRet = CIFX_INVALID_POINTER;
 80080ea:	f8df 9180 	ldr.w	r9, [pc, #384]	; 800826c <cifXCreateChannels+0x34c>
 80080ee:	e74a      	b.n	8007f86 <cifXCreateChannels+0x66>
          DEV_ReadHostFlags(ptChannelInst, 1);
 80080f0:	2101      	movs	r1, #1
 80080f2:	4638      	mov	r0, r7
 80080f4:	f7fd f911 	bl	800531a <DEV_ReadHostFlags>
          DEV_ReadHandshakeFlags(ptChannelInst, 0, 0);
 80080f8:	2200      	movs	r2, #0
 80080fa:	4611      	mov	r1, r2
 80080fc:	4638      	mov	r0, r7
 80080fe:	f7fd f944 	bl	800538a <DEV_ReadHandshakeFlags>
          if( HIL_CHANNEL_TYPE_COMMUNICATION != HWIF_READ8(ptDevInstance, ptChannel->tSystem.bChannelType))
 8008102:	9903      	ldr	r1, [sp, #12]
 8008104:	4628      	mov	r0, r5
 8008106:	f7fd f8b7 	bl	8005278 <HwIfRead8>
 800810a:	2805      	cmp	r0, #5
 800810c:	d165      	bne.n	80081da <cifXCreateChannels+0x2ba>
            if( (NULL == ptChannelInst->ptCommonStatusBlock) ||
 800810e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8008112:	2b00      	cmp	r3, #0
 8008114:	d05c      	beq.n	80081d0 <cifXCreateChannels+0x2b0>
                (NULL == ptChannelInst->ptControlBlock)      ||
 8008116:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
            if( (NULL == ptChannelInst->ptCommonStatusBlock) ||
 800811a:	2b00      	cmp	r3, #0
 800811c:	d058      	beq.n	80081d0 <cifXCreateChannels+0x2b0>
                (NULL == ptChannelInst->tSendMbx.ptSendMailboxStart)  ||
 800811e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
                (NULL == ptChannelInst->ptControlBlock)      ||
 8008120:	2b00      	cmp	r3, #0
 8008122:	d055      	beq.n	80081d0 <cifXCreateChannels+0x2b0>
                (NULL == ptChannelInst->tRecvMbx.ptRecvMailboxStart) )
 8008124:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
                (NULL == ptChannelInst->tSendMbx.ptSendMailboxStart)  ||
 8008128:	2b00      	cmp	r3, #0
 800812a:	d051      	beq.n	80081d0 <cifXCreateChannels+0x2b0>
              ptChannelInst->fIsChannel = 1;
 800812c:	2301      	movs	r3, #1
 800812e:	627b      	str	r3, [r7, #36]	; 0x24
            if( ptDevChannelCfg->fFWLoaded)
 8008130:	9a07      	ldr	r2, [sp, #28]
 8008132:	6813      	ldr	r3, [r2, #0]
 8008134:	b1a3      	cbz	r3, 8008160 <cifXCreateChannels+0x240>
              if( (ptDevInstance->fModuleLoad) &&
 8008136:	692b      	ldr	r3, [r5, #16]
 8008138:	b133      	cbz	r3, 8008148 <cifXCreateChannels+0x228>
                  !(ptDevChannelCfg->atChannelData[ulChannelID].fModuleLoaded))
 800813a:	9b04      	ldr	r3, [sp, #16]
 800813c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8008140:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008144:	685b      	ldr	r3, [r3, #4]
              if( (ptDevInstance->fModuleLoad) &&
 8008146:	b15b      	cbz	r3, 8008160 <cifXCreateChannels+0x240>
                if (!DEV_WaitForReady_Poll(ptChannelInst, CIFX_TO_FIRMWARE_START))
 8008148:	f644 6120 	movw	r1, #20000	; 0x4e20
 800814c:	4638      	mov	r0, r7
 800814e:	f7fd fcff 	bl	8005b50 <DEV_WaitForReady_Poll>
 8008152:	2800      	cmp	r0, #0
 8008154:	d153      	bne.n	80081fe <cifXCreateChannels+0x2de>
                  if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8008156:	4b3b      	ldr	r3, [pc, #236]	; (8008244 <cifXCreateChannels+0x324>)
 8008158:	681b      	ldr	r3, [r3, #0]
 800815a:	f013 0f08 	tst.w	r3, #8
 800815e:	d147      	bne.n	80081f0 <cifXCreateChannels+0x2d0>
            ++ulChannelID;
 8008160:	9b04      	ldr	r3, [sp, #16]
 8008162:	3301      	adds	r3, #1
 8008164:	9304      	str	r3, [sp, #16]
            ++ptDevInstance->ulCommChannelCount;
 8008166:	f8d5 1260 	ldr.w	r1, [r5, #608]	; 0x260
 800816a:	3101      	adds	r1, #1
 800816c:	f8c5 1260 	str.w	r1, [r5, #608]	; 0x260
            ptDevInstance->pptCommChannels = (PCHANNELINSTANCE*)OS_Memrealloc(ptDevInstance->pptCommChannels, ptDevInstance->ulCommChannelCount * (uint32_t)sizeof(*ptDevInstance->pptCommChannels));
 8008170:	0089      	lsls	r1, r1, #2
 8008172:	f8d5 0264 	ldr.w	r0, [r5, #612]	; 0x264
 8008176:	f7fa fcce 	bl	8002b16 <OS_Memrealloc>
 800817a:	f8c5 0264 	str.w	r0, [r5, #612]	; 0x264
            if (NULL == ptDevInstance->pptCommChannels)
 800817e:	2800      	cmp	r0, #0
 8008180:	d042      	beq.n	8008208 <cifXCreateChannels+0x2e8>
              ptDevInstance->pptCommChannels[ptDevInstance->ulCommChannelCount - 1] = ptChannelInst;
 8008182:	f8d5 2260 	ldr.w	r2, [r5, #608]	; 0x260
 8008186:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 800818a:	4413      	add	r3, r2
 800818c:	f840 7023 	str.w	r7, [r0, r3, lsl #2]
              if( DEV_WaitForReady_Poll(ptChannelInst, 20))
 8008190:	2114      	movs	r1, #20
 8008192:	4638      	mov	r0, r7
 8008194:	f7fd fcdc 	bl	8005b50 <DEV_WaitForReady_Poll>
 8008198:	2800      	cmp	r0, #0
 800819a:	f43f aef4 	beq.w	8007f86 <cifXCreateChannels+0x66>
                if ( CIFX_NO_ERROR != (lTempError = cifXReadFirmwareIdent( ptDevInstance,
 800819e:	2300      	movs	r3, #0
 80081a0:	461a      	mov	r2, r3
 80081a2:	6939      	ldr	r1, [r7, #16]
 80081a4:	4628      	mov	r0, r5
 80081a6:	f7ff fe5b 	bl	8007e60 <cifXReadFirmwareIdent>
 80081aa:	b120      	cbz	r0, 80081b6 <cifXCreateChannels+0x296>
                  if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80081ac:	4b25      	ldr	r3, [pc, #148]	; (8008244 <cifXCreateChannels+0x324>)
 80081ae:	681b      	ldr	r3, [r3, #0]
 80081b0:	f013 0f08 	tst.w	r3, #8
 80081b4:	d138      	bne.n	8008228 <cifXCreateChannels+0x308>
                if(g_ulTraceLevel & TRACE_LEVEL_INFO)
 80081b6:	4b23      	ldr	r3, [pc, #140]	; (8008244 <cifXCreateChannels+0x324>)
 80081b8:	681b      	ldr	r3, [r3, #0]
 80081ba:	f013 0f02 	tst.w	r3, #2
 80081be:	f43f aee2 	beq.w	8007f86 <cifXCreateChannels+0x66>
                  USER_Trace(ptDevInstance,
 80081c2:	693b      	ldr	r3, [r7, #16]
 80081c4:	4a23      	ldr	r2, [pc, #140]	; (8008254 <cifXCreateChannels+0x334>)
 80081c6:	2102      	movs	r1, #2
 80081c8:	4628      	mov	r0, r5
 80081ca:	f001 fa39 	bl	8009640 <USER_Trace>
 80081ce:	e6da      	b.n	8007f86 <cifXCreateChannels+0x66>
              if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80081d0:	4b1c      	ldr	r3, [pc, #112]	; (8008244 <cifXCreateChannels+0x324>)
 80081d2:	681b      	ldr	r3, [r3, #0]
 80081d4:	f013 0f08 	tst.w	r3, #8
 80081d8:	d103      	bne.n	80081e2 <cifXCreateChannels+0x2c2>
            cifXDeleteChannelInstance(ptChannelInst);
 80081da:	4638      	mov	r0, r7
 80081dc:	f7ff fa1c 	bl	8007618 <cifXDeleteChannelInstance>
 80081e0:	e6d1      	b.n	8007f86 <cifXCreateChannels+0x66>
                USER_Trace(ptDevInstance,
 80081e2:	4633      	mov	r3, r6
 80081e4:	4a1c      	ldr	r2, [pc, #112]	; (8008258 <cifXCreateChannels+0x338>)
 80081e6:	2108      	movs	r1, #8
 80081e8:	4628      	mov	r0, r5
 80081ea:	f001 fa29 	bl	8009640 <USER_Trace>
          if(fCreateChannel)
 80081ee:	e7f4      	b.n	80081da <cifXCreateChannels+0x2ba>
                    USER_Trace(ptDevInstance,
 80081f0:	9b04      	ldr	r3, [sp, #16]
 80081f2:	4a1a      	ldr	r2, [pc, #104]	; (800825c <cifXCreateChannels+0x33c>)
 80081f4:	2104      	movs	r1, #4
 80081f6:	4628      	mov	r0, r5
 80081f8:	f001 fa22 	bl	8009640 <USER_Trace>
 80081fc:	e7b0      	b.n	8008160 <cifXCreateChannels+0x240>
                  DEV_ReadHostFlags( ptChannelInst, 1);
 80081fe:	2101      	movs	r1, #1
 8008200:	4638      	mov	r0, r7
 8008202:	f7fd f88a 	bl	800531a <DEV_ReadHostFlags>
 8008206:	e7ab      	b.n	8008160 <cifXCreateChannels+0x240>
              if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8008208:	4b0e      	ldr	r3, [pc, #56]	; (8008244 <cifXCreateChannels+0x324>)
 800820a:	681b      	ldr	r3, [r3, #0]
 800820c:	f013 0f08 	tst.w	r3, #8
 8008210:	d102      	bne.n	8008218 <cifXCreateChannels+0x2f8>
              lRet = CIFX_INVALID_POINTER;
 8008212:	f8df 9058 	ldr.w	r9, [pc, #88]	; 800826c <cifXCreateChannels+0x34c>
 8008216:	e6b6      	b.n	8007f86 <cifXCreateChannels+0x66>
                USER_Trace(ptDevInstance,
 8008218:	4a11      	ldr	r2, [pc, #68]	; (8008260 <cifXCreateChannels+0x340>)
 800821a:	2108      	movs	r1, #8
 800821c:	4628      	mov	r0, r5
 800821e:	f001 fa0f 	bl	8009640 <USER_Trace>
              lRet = CIFX_INVALID_POINTER;
 8008222:	f8df 9048 	ldr.w	r9, [pc, #72]	; 800826c <cifXCreateChannels+0x34c>
 8008226:	e6ae      	b.n	8007f86 <cifXCreateChannels+0x66>
                    USER_Trace(ptDevInstance,
 8008228:	693b      	ldr	r3, [r7, #16]
 800822a:	9000      	str	r0, [sp, #0]
 800822c:	4a0d      	ldr	r2, [pc, #52]	; (8008264 <cifXCreateChannels+0x344>)
 800822e:	2108      	movs	r1, #8
 8008230:	4628      	mov	r0, r5
 8008232:	f001 fa05 	bl	8009640 <USER_Trace>
 8008236:	e7be      	b.n	80081b6 <cifXCreateChannels+0x296>
    USER_Trace(ptDevInstance,
 8008238:	4a0b      	ldr	r2, [pc, #44]	; (8008268 <cifXCreateChannels+0x348>)
 800823a:	2102      	movs	r1, #2
 800823c:	4628      	mov	r0, r5
 800823e:	f001 f9ff 	bl	8009640 <USER_Trace>
  return lRet;
 8008242:	e72d      	b.n	80080a0 <cifXCreateChannels+0x180>
 8008244:	20000038 	.word	0x20000038
 8008248:	800c0026 	.word	0x800c0026
 800824c:	0800c6a8 	.word	0x0800c6a8
 8008250:	0800c6d8 	.word	0x0800c6d8
 8008254:	0800c7e0 	.word	0x0800c7e0
 8008258:	0800c700 	.word	0x0800c700
 800825c:	0800c740 	.word	0x0800c740
 8008260:	0800c768 	.word	0x0800c768
 8008264:	0800c798 	.word	0x0800c798
 8008268:	0800c810 	.word	0x0800c810
 800826c:	800a0001 	.word	0x800a0001

08008270 <cifXStartModule>:
{
 8008270:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008274:	f5ad 6dcf 	sub.w	sp, sp, #1656	; 0x678
 8008278:	4604      	mov	r4, r0
 800827a:	460e      	mov	r6, r1
 800827c:	4617      	mov	r7, r2
 800827e:	461d      	mov	r5, r3
  OS_Memset(&uSendPacket, 0, sizeof(uSendPacket));
 8008280:	f240 623c 	movw	r2, #1596	; 0x63c
 8008284:	2100      	movs	r1, #0
 8008286:	a80f      	add	r0, sp, #60	; 0x3c
 8008288:	f7fa fc49 	bl	8002b1e <OS_Memset>
  OS_Memset(&tRecvPacket, 0, sizeof(tRecvPacket));
 800828c:	2228      	movs	r2, #40	; 0x28
 800828e:	2100      	movs	r1, #0
 8008290:	a805      	add	r0, sp, #20
 8008292:	f7fa fc44 	bl	8002b1e <OS_Memset>
  ulNameLength = OS_Strlen(pszModuleName) + 1;
 8008296:	4638      	mov	r0, r7
 8008298:	f7fa fd2a 	bl	8002cf0 <OS_Strlen>
 800829c:	1c42      	adds	r2, r0, #1
  if( eCIFX_DEVICE_FLASH_BASED == ptDevInstance->eDeviceType)
 800829e:	7d23      	ldrb	r3, [r4, #20]
 80082a0:	2b03      	cmp	r3, #3
 80082a2:	d03f      	beq.n	8008324 <cifXStartModule+0xb4>
    uSendPacket.tPacket.tHeader.ulSrc   = HOST_TO_LE32(ptDevInstance->ulPhysicalAddress);
 80082a4:	6823      	ldr	r3, [r4, #0]
 80082a6:	9310      	str	r3, [sp, #64]	; 0x40
    uSendPacket.tPacket.tHeader.ulDest  = HOST_TO_LE32(HIL_PACKET_DEST_DEFAULT_CHANNEL);
 80082a8:	2320      	movs	r3, #32
 80082aa:	930f      	str	r3, [sp, #60]	; 0x3c
    uSendPacket.tPacket.tHeader.ulCmd   = HOST_TO_LE32(HIL_MODLOAD_CMD_RUN_MODULE_REQ);
 80082ac:	f644 3302 	movw	r3, #19202	; 0x4b02
 80082b0:	9316      	str	r3, [sp, #88]	; 0x58
    uSendPacket.tPacket.tHeader.ulLen   = 0;
 80082b2:	2300      	movs	r3, #0
 80082b4:	9313      	str	r3, [sp, #76]	; 0x4c
    uSendPacket.tPacket.tHeader.ulState = 0;
 80082b6:	9315      	str	r3, [sp, #84]	; 0x54
    uSendPacket.tPacket.tHeader.ulExt   = 0;
 80082b8:	9317      	str	r3, [sp, #92]	; 0x5c
    uSendPacket.tRunReq.tData.ulChannel = HOST_TO_LE32(ulChannelNumber);
 80082ba:	9619      	str	r6, [sp, #100]	; 0x64
    uSendPacket.tPacket.tHeader.ulLen = HOST_TO_LE32( (uint32_t)(sizeof(uSendPacket.tRunReq.tData) + ulNameLength) );
 80082bc:	3005      	adds	r0, #5
 80082be:	9013      	str	r0, [sp, #76]	; 0x4c
    (void)OS_Strncpy( pbCopyPtr, pszModuleName, ulCopySize);
 80082c0:	f5b2 6fc2 	cmp.w	r2, #1552	; 0x610
 80082c4:	bf28      	it	cs
 80082c6:	f44f 62c2 	movcs.w	r2, #1552	; 0x610
 80082ca:	4639      	mov	r1, r7
 80082cc:	a81a      	add	r0, sp, #104	; 0x68
 80082ce:	f7fa fd13 	bl	8002cf8 <OS_Strncpy>
                             (uint32_t)(CIFX_TO_FIRMWARE_START + (ulFileSize / (100 * 1024)) * 1000),
 80082d2:	4b36      	ldr	r3, [pc, #216]	; (80083ac <cifXStartModule+0x13c>)
 80082d4:	fba3 3505 	umull	r3, r5, r3, r5
 80082d8:	0bed      	lsrs	r5, r5, #15
  lRet = DEV_TransferPacket( &ptDevInstance->tSystemDevice,
 80082da:	f8dd 3694 	ldr.w	r3, [sp, #1684]	; 0x694
 80082de:	9302      	str	r3, [sp, #8]
 80082e0:	f8dd 3690 	ldr.w	r3, [sp, #1680]	; 0x690
 80082e4:	9301      	str	r3, [sp, #4]
 80082e6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80082ea:	f644 6320 	movw	r3, #20000	; 0x4e20
 80082ee:	fb02 3305 	mla	r3, r2, r5, r3
 80082f2:	9300      	str	r3, [sp, #0]
 80082f4:	2328      	movs	r3, #40	; 0x28
 80082f6:	aa05      	add	r2, sp, #20
 80082f8:	a90f      	add	r1, sp, #60	; 0x3c
 80082fa:	f104 00f4 	add.w	r0, r4, #244	; 0xf4
 80082fe:	f7fd fb3b 	bl	8005978 <DEV_TransferPacket>
  if ( ( CIFX_NO_ERROR  != lRet) ||
 8008302:	4680      	mov	r8, r0
 8008304:	b920      	cbnz	r0, 8008310 <cifXStartModule+0xa0>
       ( SUCCESS_HIL_OK != (lRet = LE32_TO_HOST(tRecvPacket.ulSta))) )
 8008306:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
  if ( ( CIFX_NO_ERROR  != lRet) ||
 800830a:	f1b8 0f00 	cmp.w	r8, #0
 800830e:	d02b      	beq.n	8008368 <cifXStartModule+0xf8>
    if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8008310:	4b27      	ldr	r3, [pc, #156]	; (80083b0 <cifXStartModule+0x140>)
 8008312:	681b      	ldr	r3, [r3, #0]
 8008314:	f013 0f08 	tst.w	r3, #8
 8008318:	d11c      	bne.n	8008354 <cifXStartModule+0xe4>
}
 800831a:	4640      	mov	r0, r8
 800831c:	f50d 6dcf 	add.w	sp, sp, #1656	; 0x678
 8008320:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uSendPacket.tPacket.tHeader.ulSrc   = HOST_TO_LE32(ptDevInstance->ulPhysicalAddress);
 8008324:	6823      	ldr	r3, [r4, #0]
 8008326:	9310      	str	r3, [sp, #64]	; 0x40
    uSendPacket.tPacket.tHeader.ulDest  = HOST_TO_LE32(HIL_PACKET_DEST_DEFAULT_CHANNEL);
 8008328:	2320      	movs	r3, #32
 800832a:	930f      	str	r3, [sp, #60]	; 0x3c
    uSendPacket.tPacket.tHeader.ulCmd   = HOST_TO_LE32(HIL_MODLOAD_CMD_LOAD_AND_RUN_MODULE_REQ);
 800832c:	f644 3306 	movw	r3, #19206	; 0x4b06
 8008330:	9316      	str	r3, [sp, #88]	; 0x58
    uSendPacket.tPacket.tHeader.ulLen   = 0;
 8008332:	2300      	movs	r3, #0
 8008334:	9313      	str	r3, [sp, #76]	; 0x4c
    uSendPacket.tPacket.tHeader.ulState = 0;
 8008336:	9315      	str	r3, [sp, #84]	; 0x54
    uSendPacket.tPacket.tHeader.ulExt   = 0;
 8008338:	9317      	str	r3, [sp, #92]	; 0x5c
    uSendPacket.tLoadAndRunReq.tData.ulChannel = HOST_TO_LE32(ulChannelNumber);
 800833a:	9619      	str	r6, [sp, #100]	; 0x64
    uSendPacket.tPacket.tHeader.ulLen = HOST_TO_LE32( (uint32_t)(sizeof(uSendPacket.tLoadAndRunReq.tData) + ulNameLength) );
 800833c:	3005      	adds	r0, #5
 800833e:	9013      	str	r0, [sp, #76]	; 0x4c
    (void)OS_Strncpy( pbCopyPtr, pszModuleName, ulCopySize);
 8008340:	f5b2 6fc2 	cmp.w	r2, #1552	; 0x610
 8008344:	bf28      	it	cs
 8008346:	f44f 62c2 	movcs.w	r2, #1552	; 0x610
 800834a:	4639      	mov	r1, r7
 800834c:	a81a      	add	r0, sp, #104	; 0x68
 800834e:	f7fa fcd3 	bl	8002cf8 <OS_Strncpy>
 8008352:	e7be      	b.n	80082d2 <cifXStartModule+0x62>
      USER_Trace(ptDevInstance,
 8008354:	f8cd 8004 	str.w	r8, [sp, #4]
 8008358:	9600      	str	r6, [sp, #0]
 800835a:	463b      	mov	r3, r7
 800835c:	4a15      	ldr	r2, [pc, #84]	; (80083b4 <cifXStartModule+0x144>)
 800835e:	2108      	movs	r1, #8
 8008360:	4620      	mov	r0, r4
 8008362:	f001 f96d 	bl	8009640 <USER_Trace>
 8008366:	e7d8      	b.n	800831a <cifXStartModule+0xaa>
    if( ulChannelNumber < ptDevInstance->ulCommChannelCount)
 8008368:	f8d4 3260 	ldr.w	r3, [r4, #608]	; 0x260
 800836c:	42b3      	cmp	r3, r6
 800836e:	d916      	bls.n	800839e <cifXStartModule+0x12e>
      uint32_t lStartTime   = (int32_t)OS_GetMilliSecCounter();
 8008370:	f7fa fbef 	bl	8002b52 <OS_GetMilliSecCounter>
 8008374:	4607      	mov	r7, r0
        if (DEV_IsReady(ptDevInstance->pptCommChannels[ulChannelNumber]))
 8008376:	f8d4 3264 	ldr.w	r3, [r4, #612]	; 0x264
 800837a:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 800837e:	f7fd f92d 	bl	80055dc <DEV_IsReady>
 8008382:	2800      	cmp	r0, #0
 8008384:	d1c9      	bne.n	800831a <cifXStartModule+0xaa>
        ulDiffTime = OS_GetMilliSecCounter() - lStartTime;
 8008386:	f7fa fbe4 	bl	8002b52 <OS_GetMilliSecCounter>
 800838a:	1bc5      	subs	r5, r0, r7
        OS_Sleep(1);
 800838c:	2001      	movs	r0, #1
 800838e:	f7fa fbe5 	bl	8002b5c <OS_Sleep>
      } while (ulDiffTime < ulTimeout);
 8008392:	f5b5 7f7a 	cmp.w	r5, #1000	; 0x3e8
 8008396:	d3ee      	bcc.n	8008376 <cifXStartModule+0x106>
    lRet = CIFX_DEV_NOT_READY;
 8008398:	f8df 801c 	ldr.w	r8, [pc, #28]	; 80083b8 <cifXStartModule+0x148>
 800839c:	e7bd      	b.n	800831a <cifXStartModule+0xaa>
      OS_Sleep (ulTimeout);
 800839e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80083a2:	f7fa fbdb 	bl	8002b5c <OS_Sleep>
    lRet = CIFX_DEV_NOT_READY;
 80083a6:	f8df 8010 	ldr.w	r8, [pc, #16]	; 80083b8 <cifXStartModule+0x148>
  return lRet;
 80083aa:	e7b6      	b.n	800831a <cifXStartModule+0xaa>
 80083ac:	51eb851f 	.word	0x51eb851f
 80083b0:	20000038 	.word	0x20000038
 80083b4:	0800c844 	.word	0x0800c844
 80083b8:	800c0011 	.word	0x800c0011

080083bc <cifXStartRAMFirmware>:
{
 80083bc:	b570      	push	{r4, r5, r6, lr}
 80083be:	b09a      	sub	sp, #104	; 0x68
 80083c0:	4606      	mov	r6, r0
 80083c2:	460d      	mov	r5, r1
  if( ptDevInstance->fModuleLoad)
 80083c4:	6904      	ldr	r4, [r0, #16]
 80083c6:	bb9c      	cbnz	r4, 8008430 <cifXStartRAMFirmware+0x74>
  } else if(ptDevChannelCfg->fFWLoaded == 1)
 80083c8:	680b      	ldr	r3, [r1, #0]
 80083ca:	2b01      	cmp	r3, #1
 80083cc:	d036      	beq.n	800843c <cifXStartRAMFirmware+0x80>
    if( ptDevInstance->tSystemDevice.usNetxFlags & NSF_ERROR)
 80083ce:	f8b6 31b2 	ldrh.w	r3, [r6, #434]	; 0x1b2
 80083d2:	f013 0f02 	tst.w	r3, #2
 80083d6:	d005      	beq.n	80083e4 <cifXStartRAMFirmware+0x28>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80083d8:	4b57      	ldr	r3, [pc, #348]	; (8008538 <cifXStartRAMFirmware+0x17c>)
 80083da:	681b      	ldr	r3, [r3, #0]
 80083dc:	f013 0f08 	tst.w	r3, #8
 80083e0:	f040 8086 	bne.w	80084f0 <cifXStartRAMFirmware+0x134>
    if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 80083e4:	4b54      	ldr	r3, [pc, #336]	; (8008538 <cifXStartRAMFirmware+0x17c>)
 80083e6:	681b      	ldr	r3, [r3, #0]
 80083e8:	f013 0f01 	tst.w	r3, #1
 80083ec:	f040 809e 	bne.w	800852c <cifXStartRAMFirmware+0x170>
}
 80083f0:	4620      	mov	r0, r4
 80083f2:	b01a      	add	sp, #104	; 0x68
 80083f4:	bd70      	pop	{r4, r5, r6, pc}
    for ( ulChNum = 0; ulChNum < CIFX_MAX_NUMBER_OF_CHANNELS; ulChNum++)
 80083f6:	3401      	adds	r4, #1
 80083f8:	2c05      	cmp	r4, #5
 80083fa:	d81b      	bhi.n	8008434 <cifXStartRAMFirmware+0x78>
      if( ptDevChannelCfg->atChannelData[ulChNum].fModuleLoaded)
 80083fc:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 8008400:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8008404:	685b      	ldr	r3, [r3, #4]
 8008406:	2b00      	cmp	r3, #0
 8008408:	d0f5      	beq.n	80083f6 <cifXStartRAMFirmware+0x3a>
        (void)cifXStartModule( ptDevInstance, ulChNum, ptDevChannelCfg->atChannelData[ulChNum].szFileName,
 800840a:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
 800840e:	0092      	lsls	r2, r2, #2
 8008410:	3208      	adds	r2, #8
 8008412:	442a      	add	r2, r5
 8008414:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 8008418:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800841c:	69db      	ldr	r3, [r3, #28]
 800841e:	2100      	movs	r1, #0
 8008420:	9101      	str	r1, [sp, #4]
 8008422:	9100      	str	r1, [sp, #0]
 8008424:	3204      	adds	r2, #4
 8008426:	4621      	mov	r1, r4
 8008428:	4630      	mov	r0, r6
 800842a:	f7ff ff21 	bl	8008270 <cifXStartModule>
 800842e:	e7e2      	b.n	80083f6 <cifXStartRAMFirmware+0x3a>
    for ( ulChNum = 0; ulChNum < CIFX_MAX_NUMBER_OF_CHANNELS; ulChNum++)
 8008430:	2400      	movs	r4, #0
 8008432:	e7e1      	b.n	80083f8 <cifXStartRAMFirmware+0x3c>
  int32_t lRet = CIFX_NO_ERROR;
 8008434:	2400      	movs	r4, #0
  if (CIFX_NO_ERROR == lRet)
 8008436:	2c00      	cmp	r4, #0
 8008438:	d1da      	bne.n	80083f0 <cifXStartRAMFirmware+0x34>
 800843a:	e7c8      	b.n	80083ce <cifXStartRAMFirmware+0x12>
    OS_Memset(&tSendPkt, 0, sizeof(tSendPkt));
 800843c:	222c      	movs	r2, #44	; 0x2c
 800843e:	2100      	movs	r1, #0
 8008440:	a80f      	add	r0, sp, #60	; 0x3c
 8008442:	f7fa fb6c 	bl	8002b1e <OS_Memset>
    OS_Memset(&tRecvPkt, 0, sizeof(tRecvPkt));
 8008446:	2228      	movs	r2, #40	; 0x28
 8008448:	2100      	movs	r1, #0
 800844a:	a805      	add	r0, sp, #20
 800844c:	f7fa fb67 	bl	8002b1e <OS_Memset>
    tSendPkt.tHead.ulDest      = HOST_TO_LE32(HIL_PACKET_DEST_SYSTEM);
 8008450:	2300      	movs	r3, #0
 8008452:	930f      	str	r3, [sp, #60]	; 0x3c
    tSendPkt.tHead.ulLen       = HOST_TO_LE32(sizeof(HIL_CHANNEL_INSTANTIATE_REQ_DATA_T));
 8008454:	2204      	movs	r2, #4
 8008456:	9213      	str	r2, [sp, #76]	; 0x4c
    tSendPkt.tHead.ulCmd       = HOST_TO_LE32(HIL_CHANNEL_INSTANTIATE_REQ);
 8008458:	f641 62c4 	movw	r2, #7876	; 0x1ec4
 800845c:	9216      	str	r2, [sp, #88]	; 0x58
    tSendPkt.tData.ulChannelNo = HOST_TO_LE32(ulChannel);
 800845e:	9319      	str	r3, [sp, #100]	; 0x64
    lRet = DEV_TransferPacket( &ptDevInstance->tSystemDevice,
 8008460:	f106 05f4 	add.w	r5, r6, #244	; 0xf4
 8008464:	9302      	str	r3, [sp, #8]
 8008466:	9301      	str	r3, [sp, #4]
 8008468:	f241 3388 	movw	r3, #5000	; 0x1388
 800846c:	9300      	str	r3, [sp, #0]
 800846e:	2328      	movs	r3, #40	; 0x28
 8008470:	aa05      	add	r2, sp, #20
 8008472:	a90f      	add	r1, sp, #60	; 0x3c
 8008474:	4628      	mov	r0, r5
 8008476:	f7fd fa7f 	bl	8005978 <DEV_TransferPacket>
    if( (CIFX_NO_ERROR  != lRet)                   ||
 800847a:	4604      	mov	r4, r0
 800847c:	b908      	cbnz	r0, 8008482 <cifXStartRAMFirmware+0xc6>
        (SUCCESS_HIL_OK != (lRet = LE32_TO_HOST(tRecvPkt.tHead.ulSta))) )
 800847e:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    if( (CIFX_NO_ERROR  != lRet)                   ||
 8008480:	b15c      	cbz	r4, 800849a <cifXStartRAMFirmware+0xde>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8008482:	4b2d      	ldr	r3, [pc, #180]	; (8008538 <cifXStartRAMFirmware+0x17c>)
 8008484:	681b      	ldr	r3, [r3, #0]
 8008486:	f013 0f08 	tst.w	r3, #8
 800848a:	d0d4      	beq.n	8008436 <cifXStartRAMFirmware+0x7a>
        USER_Trace(ptDevInstance,
 800848c:	4623      	mov	r3, r4
 800848e:	4a2b      	ldr	r2, [pc, #172]	; (800853c <cifXStartRAMFirmware+0x180>)
 8008490:	2108      	movs	r1, #8
 8008492:	4630      	mov	r0, r6
 8008494:	f001 f8d4 	bl	8009640 <USER_Trace>
 8008498:	e7cd      	b.n	8008436 <cifXStartRAMFirmware+0x7a>
      if (!DEV_WaitForNotReady_Poll( &ptDevInstance->tSystemDevice, CIFX_TO_FIRMWARE_START))
 800849a:	f644 6120 	movw	r1, #20000	; 0x4e20
 800849e:	4628      	mov	r0, r5
 80084a0:	f7fd faa6 	bl	80059f0 <DEV_WaitForNotReady_Poll>
 80084a4:	b970      	cbnz	r0, 80084c4 <cifXStartRAMFirmware+0x108>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80084a6:	4b24      	ldr	r3, [pc, #144]	; (8008538 <cifXStartRAMFirmware+0x17c>)
 80084a8:	681b      	ldr	r3, [r3, #0]
 80084aa:	f013 0f08 	tst.w	r3, #8
 80084ae:	d101      	bne.n	80084b4 <cifXStartRAMFirmware+0xf8>
        lRet = CIFX_DEV_RESET_TIMEOUT;
 80084b0:	4c23      	ldr	r4, [pc, #140]	; (8008540 <cifXStartRAMFirmware+0x184>)
 80084b2:	e79d      	b.n	80083f0 <cifXStartRAMFirmware+0x34>
          USER_Trace(ptDevInstance,
 80084b4:	4c22      	ldr	r4, [pc, #136]	; (8008540 <cifXStartRAMFirmware+0x184>)
 80084b6:	4623      	mov	r3, r4
 80084b8:	4a22      	ldr	r2, [pc, #136]	; (8008544 <cifXStartRAMFirmware+0x188>)
 80084ba:	2108      	movs	r1, #8
 80084bc:	4630      	mov	r0, r6
 80084be:	f001 f8bf 	bl	8009640 <USER_Trace>
  if (CIFX_NO_ERROR == lRet)
 80084c2:	e795      	b.n	80083f0 <cifXStartRAMFirmware+0x34>
        if (!DEV_WaitForReady_Poll( &ptDevInstance->tSystemDevice, CIFX_TO_FIRMWARE_START))
 80084c4:	f644 6120 	movw	r1, #20000	; 0x4e20
 80084c8:	4628      	mov	r0, r5
 80084ca:	f7fd fb41 	bl	8005b50 <DEV_WaitForReady_Poll>
 80084ce:	2800      	cmp	r0, #0
 80084d0:	d1b1      	bne.n	8008436 <cifXStartRAMFirmware+0x7a>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80084d2:	4b19      	ldr	r3, [pc, #100]	; (8008538 <cifXStartRAMFirmware+0x17c>)
 80084d4:	681b      	ldr	r3, [r3, #0]
 80084d6:	f013 0f08 	tst.w	r3, #8
 80084da:	d101      	bne.n	80084e0 <cifXStartRAMFirmware+0x124>
          lRet = CIFX_DEV_NOT_READY;
 80084dc:	4c1a      	ldr	r4, [pc, #104]	; (8008548 <cifXStartRAMFirmware+0x18c>)
 80084de:	e787      	b.n	80083f0 <cifXStartRAMFirmware+0x34>
            USER_Trace(ptDevInstance,
 80084e0:	4c19      	ldr	r4, [pc, #100]	; (8008548 <cifXStartRAMFirmware+0x18c>)
 80084e2:	4623      	mov	r3, r4
 80084e4:	4a19      	ldr	r2, [pc, #100]	; (800854c <cifXStartRAMFirmware+0x190>)
 80084e6:	2108      	movs	r1, #8
 80084e8:	4630      	mov	r0, r6
 80084ea:	f001 f8a9 	bl	8009640 <USER_Trace>
  if (CIFX_NO_ERROR == lRet)
 80084ee:	e77f      	b.n	80083f0 <cifXStartRAMFirmware+0x34>
        HIL_DPM_SYSTEM_CHANNEL_T* ptSysCh = (HIL_DPM_SYSTEM_CHANNEL_T*)ptDevInstance->tSystemDevice.pbDPMChannelStart;
 80084f0:	f8d6 50fc 	ldr.w	r5, [r6, #252]	; 0xfc
        if(0 != (ulError = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysCh->tSystemState.ulSystemError))))
 80084f4:	f105 01c8 	add.w	r1, r5, #200	; 0xc8
 80084f8:	4630      	mov	r0, r6
 80084fa:	f7fc fefe 	bl	80052fa <HwIfRead32>
 80084fe:	4603      	mov	r3, r0
 8008500:	b970      	cbnz	r0, 8008520 <cifXStartRAMFirmware+0x164>
        if( 0 != (ulError = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysCh->tSystemState.ulSystemStatus))))
 8008502:	f105 01c4 	add.w	r1, r5, #196	; 0xc4
 8008506:	4630      	mov	r0, r6
 8008508:	f7fc fef7 	bl	80052fa <HwIfRead32>
 800850c:	4603      	mov	r3, r0
 800850e:	2800      	cmp	r0, #0
 8008510:	f43f af68 	beq.w	80083e4 <cifXStartRAMFirmware+0x28>
          USER_Trace(ptDevInstance,
 8008514:	4a0e      	ldr	r2, [pc, #56]	; (8008550 <cifXStartRAMFirmware+0x194>)
 8008516:	2108      	movs	r1, #8
 8008518:	4630      	mov	r0, r6
 800851a:	f001 f891 	bl	8009640 <USER_Trace>
 800851e:	e761      	b.n	80083e4 <cifXStartRAMFirmware+0x28>
          USER_Trace(ptDevInstance,
 8008520:	4a0c      	ldr	r2, [pc, #48]	; (8008554 <cifXStartRAMFirmware+0x198>)
 8008522:	2108      	movs	r1, #8
 8008524:	4630      	mov	r0, r6
 8008526:	f001 f88b 	bl	8009640 <USER_Trace>
 800852a:	e7ea      	b.n	8008502 <cifXStartRAMFirmware+0x146>
      USER_Trace(ptDevInstance,
 800852c:	4a0a      	ldr	r2, [pc, #40]	; (8008558 <cifXStartRAMFirmware+0x19c>)
 800852e:	2101      	movs	r1, #1
 8008530:	4630      	mov	r0, r6
 8008532:	f001 f885 	bl	8009640 <USER_Trace>
  return lRet;
 8008536:	e75b      	b.n	80083f0 <cifXStartRAMFirmware+0x34>
 8008538:	20000038 	.word	0x20000038
 800853c:	0800c880 	.word	0x0800c880
 8008540:	800c0020 	.word	0x800c0020
 8008544:	0800b7d0 	.word	0x0800b7d0
 8008548:	800c0011 	.word	0x800c0011
 800854c:	0800b810 	.word	0x0800b810
 8008550:	0800c218 	.word	0x0800c218
 8008554:	0800c1e8 	.word	0x0800c1e8
 8008558:	0800c8b8 	.word	0x0800c8b8

0800855c <cifXStartFlashFirmware>:
{
 800855c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008560:	b082      	sub	sp, #8
 8008562:	4606      	mov	r6, r0
 8008564:	460d      	mov	r5, r1
  if( ptDevInstance->fModuleLoad)
 8008566:	6907      	ldr	r7, [r0, #16]
 8008568:	2f00      	cmp	r7, #0
 800856a:	d14d      	bne.n	8008608 <cifXStartFlashFirmware+0xac>
    if(ptDevChannelCfg->fFWLoaded == 1)
 800856c:	680b      	ldr	r3, [r1, #0]
 800856e:	2b01      	cmp	r3, #1
 8008570:	d04e      	beq.n	8008610 <cifXStartFlashFirmware+0xb4>
    if( ptDevInstance->tSystemDevice.usNetxFlags & NSF_ERROR)
 8008572:	f8b6 31b2 	ldrh.w	r3, [r6, #434]	; 0x1b2
 8008576:	f013 0f02 	tst.w	r3, #2
 800857a:	d004      	beq.n	8008586 <cifXStartFlashFirmware+0x2a>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 800857c:	4b47      	ldr	r3, [pc, #284]	; (800869c <cifXStartFlashFirmware+0x140>)
 800857e:	681b      	ldr	r3, [r3, #0]
 8008580:	f013 0f08 	tst.w	r3, #8
 8008584:	d167      	bne.n	8008656 <cifXStartFlashFirmware+0xfa>
    if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8008586:	4b45      	ldr	r3, [pc, #276]	; (800869c <cifXStartFlashFirmware+0x140>)
 8008588:	681b      	ldr	r3, [r3, #0]
 800858a:	f013 0f01 	tst.w	r3, #1
 800858e:	d17f      	bne.n	8008690 <cifXStartFlashFirmware+0x134>
}
 8008590:	4638      	mov	r0, r7
 8008592:	b002      	add	sp, #8
 8008594:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8008598:	4b40      	ldr	r3, [pc, #256]	; (800869c <cifXStartFlashFirmware+0x140>)
 800859a:	681b      	ldr	r3, [r3, #0]
 800859c:	f013 0f08 	tst.w	r3, #8
 80085a0:	d043      	beq.n	800862a <cifXStartFlashFirmware+0xce>
              USER_Trace(ptDevInstance,
 80085a2:	4603      	mov	r3, r0
 80085a4:	4a3e      	ldr	r2, [pc, #248]	; (80086a0 <cifXStartFlashFirmware+0x144>)
 80085a6:	2108      	movs	r1, #8
 80085a8:	4630      	mov	r0, r6
 80085aa:	f001 f849 	bl	8009640 <USER_Trace>
 80085ae:	e03c      	b.n	800862a <cifXStartFlashFirmware+0xce>
        (void)cifXStartModule( ptDevInstance, ulChNum, ptDevChannelCfg->atChannelData[ulChNum].szFileName,
 80085b0:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
 80085b4:	0092      	lsls	r2, r2, #2
 80085b6:	3208      	adds	r2, #8
 80085b8:	442a      	add	r2, r5
 80085ba:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 80085be:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80085c2:	69db      	ldr	r3, [r3, #28]
 80085c4:	2100      	movs	r1, #0
 80085c6:	9101      	str	r1, [sp, #4]
 80085c8:	9100      	str	r1, [sp, #0]
 80085ca:	3204      	adds	r2, #4
 80085cc:	4621      	mov	r1, r4
 80085ce:	4630      	mov	r0, r6
 80085d0:	f7ff fe4e 	bl	8008270 <cifXStartModule>
    for ( ulChNum = 0; ulChNum < CIFX_MAX_NUMBER_OF_CHANNELS; ulChNum++)
 80085d4:	3401      	adds	r4, #1
 80085d6:	2c05      	cmp	r4, #5
 80085d8:	d827      	bhi.n	800862a <cifXStartFlashFirmware+0xce>
      if( ptDevChannelCfg->atChannelData[ulChNum].fModuleLoaded)
 80085da:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 80085de:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80085e2:	685b      	ldr	r3, [r3, #4]
 80085e4:	2b00      	cmp	r3, #0
 80085e6:	d0f5      	beq.n	80085d4 <cifXStartFlashFirmware+0x78>
        if( 0 == fSystemStartDone)
 80085e8:	f1b8 0f00 	cmp.w	r8, #0
 80085ec:	d1e0      	bne.n	80085b0 <cifXStartFlashFirmware+0x54>
          if ( CIFX_NO_ERROR != (lRet = DEV_DoSystemStart( &ptDevInstance->tSystemDevice, CIFX_TO_FIRMWARE_START, 0)))
 80085ee:	2200      	movs	r2, #0
 80085f0:	f644 6120 	movw	r1, #20000	; 0x4e20
 80085f4:	f106 00f4 	add.w	r0, r6, #244	; 0xf4
 80085f8:	f7fd fc50 	bl	8005e9c <DEV_DoSystemStart>
 80085fc:	4607      	mov	r7, r0
 80085fe:	2800      	cmp	r0, #0
 8008600:	d1ca      	bne.n	8008598 <cifXStartFlashFirmware+0x3c>
          fSystemStartDone = 1; /* No more starts necessary */
 8008602:	f04f 0801 	mov.w	r8, #1
 8008606:	e7d3      	b.n	80085b0 <cifXStartFlashFirmware+0x54>
    for ( ulChNum = 0; ulChNum < CIFX_MAX_NUMBER_OF_CHANNELS; ulChNum++)
 8008608:	2400      	movs	r4, #0
    int fSystemStartDone = 0;
 800860a:	46a0      	mov	r8, r4
  int32_t lRet = CIFX_NO_ERROR;
 800860c:	4627      	mov	r7, r4
 800860e:	e7e2      	b.n	80085d6 <cifXStartFlashFirmware+0x7a>
      if ( CIFX_NO_ERROR != (lRet = DEV_DoSystemStart( &ptDevInstance->tSystemDevice, CIFX_TO_FIRMWARE_START, 0)))
 8008610:	2200      	movs	r2, #0
 8008612:	f644 6120 	movw	r1, #20000	; 0x4e20
 8008616:	30f4      	adds	r0, #244	; 0xf4
 8008618:	f7fd fc40 	bl	8005e9c <DEV_DoSystemStart>
 800861c:	4607      	mov	r7, r0
 800861e:	b170      	cbz	r0, 800863e <cifXStartFlashFirmware+0xe2>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8008620:	4b1e      	ldr	r3, [pc, #120]	; (800869c <cifXStartFlashFirmware+0x140>)
 8008622:	681b      	ldr	r3, [r3, #0]
 8008624:	f013 0f08 	tst.w	r3, #8
 8008628:	d102      	bne.n	8008630 <cifXStartFlashFirmware+0xd4>
  if (CIFX_NO_ERROR == lRet)
 800862a:	2f00      	cmp	r7, #0
 800862c:	d1b0      	bne.n	8008590 <cifXStartFlashFirmware+0x34>
 800862e:	e7a0      	b.n	8008572 <cifXStartFlashFirmware+0x16>
          USER_Trace(ptDevInstance,
 8008630:	4603      	mov	r3, r0
 8008632:	4a1b      	ldr	r2, [pc, #108]	; (80086a0 <cifXStartFlashFirmware+0x144>)
 8008634:	2108      	movs	r1, #8
 8008636:	4630      	mov	r0, r6
 8008638:	f001 f802 	bl	8009640 <USER_Trace>
 800863c:	e7f5      	b.n	800862a <cifXStartFlashFirmware+0xce>
        if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 800863e:	4b17      	ldr	r3, [pc, #92]	; (800869c <cifXStartFlashFirmware+0x140>)
 8008640:	681b      	ldr	r3, [r3, #0]
 8008642:	f013 0f01 	tst.w	r3, #1
 8008646:	d0f0      	beq.n	800862a <cifXStartFlashFirmware+0xce>
          USER_Trace(ptDevInstance,
 8008648:	4603      	mov	r3, r0
 800864a:	4a16      	ldr	r2, [pc, #88]	; (80086a4 <cifXStartFlashFirmware+0x148>)
 800864c:	2101      	movs	r1, #1
 800864e:	4630      	mov	r0, r6
 8008650:	f000 fff6 	bl	8009640 <USER_Trace>
 8008654:	e7e9      	b.n	800862a <cifXStartFlashFirmware+0xce>
        HIL_DPM_SYSTEM_CHANNEL_T* ptSysCh = (HIL_DPM_SYSTEM_CHANNEL_T*)ptDevInstance->tSystemDevice.pbDPMChannelStart;
 8008656:	f8d6 40fc 	ldr.w	r4, [r6, #252]	; 0xfc
        if(0 != (ulError = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysCh->tSystemState.ulSystemError))))
 800865a:	f104 01c8 	add.w	r1, r4, #200	; 0xc8
 800865e:	4630      	mov	r0, r6
 8008660:	f7fc fe4b 	bl	80052fa <HwIfRead32>
 8008664:	4603      	mov	r3, r0
 8008666:	b968      	cbnz	r0, 8008684 <cifXStartFlashFirmware+0x128>
        if( 0 != (ulError = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSysCh->tSystemState.ulSystemStatus))))
 8008668:	f104 01c4 	add.w	r1, r4, #196	; 0xc4
 800866c:	4630      	mov	r0, r6
 800866e:	f7fc fe44 	bl	80052fa <HwIfRead32>
 8008672:	4603      	mov	r3, r0
 8008674:	2800      	cmp	r0, #0
 8008676:	d086      	beq.n	8008586 <cifXStartFlashFirmware+0x2a>
          USER_Trace(ptDevInstance,
 8008678:	4a0b      	ldr	r2, [pc, #44]	; (80086a8 <cifXStartFlashFirmware+0x14c>)
 800867a:	2108      	movs	r1, #8
 800867c:	4630      	mov	r0, r6
 800867e:	f000 ffdf 	bl	8009640 <USER_Trace>
 8008682:	e780      	b.n	8008586 <cifXStartFlashFirmware+0x2a>
          USER_Trace(ptDevInstance,
 8008684:	4a09      	ldr	r2, [pc, #36]	; (80086ac <cifXStartFlashFirmware+0x150>)
 8008686:	2108      	movs	r1, #8
 8008688:	4630      	mov	r0, r6
 800868a:	f000 ffd9 	bl	8009640 <USER_Trace>
 800868e:	e7eb      	b.n	8008668 <cifXStartFlashFirmware+0x10c>
      USER_Trace(ptDevInstance,
 8008690:	4a07      	ldr	r2, [pc, #28]	; (80086b0 <cifXStartFlashFirmware+0x154>)
 8008692:	2101      	movs	r1, #1
 8008694:	4630      	mov	r0, r6
 8008696:	f000 ffd3 	bl	8009640 <USER_Trace>
  return lRet;
 800869a:	e779      	b.n	8008590 <cifXStartFlashFirmware+0x34>
 800869c:	20000038 	.word	0x20000038
 80086a0:	0800c8d4 	.word	0x0800c8d4
 80086a4:	0800c900 	.word	0x0800c900
 80086a8:	0800c218 	.word	0x0800c218
 80086ac:	0800c1e8 	.word	0x0800c1e8
 80086b0:	0800c8b8 	.word	0x0800c8b8

080086b4 <cifXStartDevice>:
{
 80086b4:	b570      	push	{r4, r5, r6, lr}
 80086b6:	b0ae      	sub	sp, #184	; 0xb8
 80086b8:	4604      	mov	r4, r0
  OS_Memset(&tDevChannelCfg, 0, sizeof(tDevChannelCfg));
 80086ba:	22ac      	movs	r2, #172	; 0xac
 80086bc:	2100      	movs	r1, #0
 80086be:	a803      	add	r0, sp, #12
 80086c0:	f7fa fa2d 	bl	8002b1e <OS_Memset>
  ptDevInstance->lInitError = CIFX_NO_ERROR;
 80086c4:	2300      	movs	r3, #0
 80086c6:	64e3      	str	r3, [r4, #76]	; 0x4c
  ptDevInstance->ptGlobalRegisters = (PNETX_GLOBAL_REG_BLOCK)(ptDevInstance->pbDPM +
 80086c8:	6a23      	ldr	r3, [r4, #32]
                                                              ptDevInstance->ulDPMSize -
 80086ca:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80086cc:	f5a2 7200 	sub.w	r2, r2, #512	; 0x200
 80086d0:	4413      	add	r3, r2
  ptDevInstance->ptGlobalRegisters = (PNETX_GLOBAL_REG_BLOCK)(ptDevInstance->pbDPM +
 80086d2:	6523      	str	r3, [r4, #80]	; 0x50
  if( CIFX_NO_ERROR == (lRet = cifXEvaluateDeviceType(ptDevInstance)) )
 80086d4:	4620      	mov	r0, r4
 80086d6:	f7fd fcc5 	bl	8006064 <cifXEvaluateDeviceType>
 80086da:	4605      	mov	r5, r0
 80086dc:	b930      	cbnz	r0, 80086ec <cifXStartDevice+0x38>
    switch(ptDevInstance->eDeviceType)
 80086de:	7d23      	ldrb	r3, [r4, #20]
 80086e0:	2b03      	cmp	r3, #3
 80086e2:	d040      	beq.n	8008766 <cifXStartDevice+0xb2>
 80086e4:	2b04      	cmp	r3, #4
 80086e6:	d07f      	beq.n	80087e8 <cifXStartDevice+0x134>
 80086e8:	2b02      	cmp	r3, #2
 80086ea:	d015      	beq.n	8008718 <cifXStartDevice+0x64>
  if(CIFX_NO_ERROR == lRet)
 80086ec:	2d00      	cmp	r5, #0
 80086ee:	f000 8088 	beq.w	8008802 <cifXStartDevice+0x14e>
  if(CIFX_NO_ERROR == lRet)
 80086f2:	b935      	cbnz	r5, 8008702 <cifXStartDevice+0x4e>
    if(eCIFX_DEVICE_FLASH_BASED == ptDevInstance->eDeviceType)
 80086f4:	7d23      	ldrb	r3, [r4, #20]
 80086f6:	2b03      	cmp	r3, #3
 80086f8:	f000 80c8 	beq.w	800888c <cifXStartDevice+0x1d8>
    if(CIFX_NO_ERROR == lRet)
 80086fc:	2d00      	cmp	r5, #0
 80086fe:	f000 80cb 	beq.w	8008898 <cifXStartDevice+0x1e4>
  if (CIFX_NO_ERROR == lRet)
 8008702:	2d00      	cmp	r5, #0
 8008704:	f000 80cd 	beq.w	80088a2 <cifXStartDevice+0x1ee>
  if(CIFX_NO_ERROR == lRet)
 8008708:	2d00      	cmp	r5, #0
 800870a:	f000 80cf 	beq.w	80088ac <cifXStartDevice+0x1f8>
  if(CIFX_NO_ERROR != lRet)
 800870e:	b105      	cbz	r5, 8008712 <cifXStartDevice+0x5e>
    ptDevInstance->lInitError = lRet;
 8008710:	64e5      	str	r5, [r4, #76]	; 0x4c
}
 8008712:	4628      	mov	r0, r5
 8008714:	b02e      	add	sp, #184	; 0xb8
 8008716:	bd70      	pop	{r4, r5, r6, pc}
        if( (CIFX_NO_ERROR == (lRet = cifXStartRAMDevice(ptDevInstance))) &&
 8008718:	4620      	mov	r0, r4
 800871a:	f7ff faf7 	bl	8007d0c <cifXStartRAMDevice>
 800871e:	4605      	mov	r5, r0
 8008720:	2800      	cmp	r0, #0
 8008722:	d1e3      	bne.n	80086ec <cifXStartDevice+0x38>
            (CIFX_NO_ERROR == (lRet = cifXCreateSystemDevice( ptDevInstance)))  )
 8008724:	4620      	mov	r0, r4
 8008726:	f7fe fe05 	bl	8007334 <cifXCreateSystemDevice>
        if( (CIFX_NO_ERROR == (lRet = cifXStartRAMDevice(ptDevInstance))) &&
 800872a:	4605      	mov	r5, r0
 800872c:	2800      	cmp	r0, #0
 800872e:	d1dd      	bne.n	80086ec <cifXStartDevice+0x38>
          lTempResult = cifXHandleRAMBaseOSModule( ptDevInstance);
 8008730:	4620      	mov	r0, r4
 8008732:	f7fd fead 	bl	8006490 <cifXHandleRAMBaseOSModule>
          if( CIFX_NO_ERROR == lTempResult)
 8008736:	4603      	mov	r3, r0
 8008738:	b120      	cbz	r0, 8008744 <cifXStartDevice+0x90>
          if(CIFX_NO_ERROR == ptDevInstance->lInitError)
 800873a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800873c:	2a00      	cmp	r2, #0
 800873e:	d1d5      	bne.n	80086ec <cifXStartDevice+0x38>
            ptDevInstance->lInitError = lTempResult;
 8008740:	64e3      	str	r3, [r4, #76]	; 0x4c
 8008742:	e7d3      	b.n	80086ec <cifXStartDevice+0x38>
            (void)cifXIsBaseOSModule(ptDevInstance);
 8008744:	4620      	mov	r0, r4
 8008746:	f7fd fd75 	bl	8006234 <cifXIsBaseOSModule>
            (void)cifXDownloadFWFiles(ptDevInstance, &tDevChannelCfg);
 800874a:	a903      	add	r1, sp, #12
 800874c:	4620      	mov	r0, r4
 800874e:	f7fe f8bf 	bl	80068d0 <cifXDownloadFWFiles>
            (void)cifXDownloadCNFFiles(ptDevInstance, &tDevChannelCfg);
 8008752:	a903      	add	r1, sp, #12
 8008754:	4620      	mov	r0, r4
 8008756:	f7fe f9a3 	bl	8006aa0 <cifXDownloadCNFFiles>
            lTempResult = cifXStartRAMFirmware(ptDevInstance, &tDevChannelCfg);
 800875a:	a903      	add	r1, sp, #12
 800875c:	4620      	mov	r0, r4
 800875e:	f7ff fe2d 	bl	80083bc <cifXStartRAMFirmware>
 8008762:	4603      	mov	r3, r0
 8008764:	e7e9      	b.n	800873a <cifXStartDevice+0x86>
        if( IsNetX4x00FLASH(ptDevInstance) ||
 8008766:	4620      	mov	r0, r4
 8008768:	f000 fed8 	bl	800951c <IsNetX4x00FLASH>
 800876c:	b180      	cbz	r0, 8008790 <cifXStartDevice+0xdc>
          if( (CIFX_NO_ERROR != (lRet = cifXStartFlashDevice( ptDevInstance)))  ||
 800876e:	4620      	mov	r0, r4
 8008770:	f7fd fc76 	bl	8006060 <cifXStartFlashDevice>
 8008774:	4605      	mov	r5, r0
 8008776:	b928      	cbnz	r0, 8008784 <cifXStartDevice+0xd0>
              (CIFX_NO_ERROR != (lRet = cifXCreateSystemDevice( ptDevInstance))) )
 8008778:	4620      	mov	r0, r4
 800877a:	f7fe fddb 	bl	8007334 <cifXCreateSystemDevice>
          if( (CIFX_NO_ERROR != (lRet = cifXStartFlashDevice( ptDevInstance)))  ||
 800877e:	4605      	mov	r5, r0
 8008780:	2800      	cmp	r0, #0
 8008782:	d0b3      	beq.n	80086ec <cifXStartDevice+0x38>
            USER_Trace(ptDevInstance,
 8008784:	4a4c      	ldr	r2, [pc, #304]	; (80088b8 <cifXStartDevice+0x204>)
 8008786:	2108      	movs	r1, #8
 8008788:	4620      	mov	r0, r4
 800878a:	f000 ff59 	bl	8009640 <USER_Trace>
 800878e:	e7ad      	b.n	80086ec <cifXStartDevice+0x38>
            IsNetX90FLASH(ptDevInstance)    )
 8008790:	4620      	mov	r0, r4
 8008792:	f000 fefd 	bl	8009590 <IsNetX90FLASH>
        if( IsNetX4x00FLASH(ptDevInstance) ||
 8008796:	2800      	cmp	r0, #0
 8008798:	d1e9      	bne.n	800876e <cifXStartDevice+0xba>
        else if( (CIFX_NO_ERROR == (lRet = cifXStartFlashDevice( ptDevInstance)))   &&
 800879a:	4620      	mov	r0, r4
 800879c:	f7fd fc60 	bl	8006060 <cifXStartFlashDevice>
 80087a0:	4605      	mov	r5, r0
 80087a2:	2800      	cmp	r0, #0
 80087a4:	d1a2      	bne.n	80086ec <cifXStartDevice+0x38>
                 (CIFX_NO_ERROR == (lRet = cifXCreateSystemDevice( ptDevInstance)))  )
 80087a6:	4620      	mov	r0, r4
 80087a8:	f7fe fdc4 	bl	8007334 <cifXCreateSystemDevice>
        else if( (CIFX_NO_ERROR == (lRet = cifXStartFlashDevice( ptDevInstance)))   &&
 80087ac:	4605      	mov	r5, r0
 80087ae:	2800      	cmp	r0, #0
 80087b0:	d19c      	bne.n	80086ec <cifXStartDevice+0x38>
          lTempResult = cifXHandleFlashBaseOSModule( ptDevInstance);
 80087b2:	4620      	mov	r0, r4
 80087b4:	f7fd ff82 	bl	80066bc <cifXHandleFlashBaseOSModule>
          if( CIFX_NO_ERROR == lTempResult)
 80087b8:	4603      	mov	r3, r0
 80087ba:	b120      	cbz	r0, 80087c6 <cifXStartDevice+0x112>
          if(CIFX_NO_ERROR == ptDevInstance->lInitError)
 80087bc:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 80087be:	2a00      	cmp	r2, #0
 80087c0:	d194      	bne.n	80086ec <cifXStartDevice+0x38>
            ptDevInstance->lInitError = lTempResult;
 80087c2:	64e3      	str	r3, [r4, #76]	; 0x4c
 80087c4:	e792      	b.n	80086ec <cifXStartDevice+0x38>
            (void)cifXIsBaseOSModule(ptDevInstance);
 80087c6:	4620      	mov	r0, r4
 80087c8:	f7fd fd34 	bl	8006234 <cifXIsBaseOSModule>
            (void)cifXDownloadFWFiles(ptDevInstance, &tDevChannelCfg);
 80087cc:	a903      	add	r1, sp, #12
 80087ce:	4620      	mov	r0, r4
 80087d0:	f7fe f87e 	bl	80068d0 <cifXDownloadFWFiles>
            (void)cifXDownloadCNFFiles(ptDevInstance, &tDevChannelCfg);
 80087d4:	a903      	add	r1, sp, #12
 80087d6:	4620      	mov	r0, r4
 80087d8:	f7fe f962 	bl	8006aa0 <cifXDownloadCNFFiles>
            lTempResult = cifXStartFlashFirmware(ptDevInstance, &tDevChannelCfg);
 80087dc:	a903      	add	r1, sp, #12
 80087de:	4620      	mov	r0, r4
 80087e0:	f7ff febc 	bl	800855c <cifXStartFlashFirmware>
 80087e4:	4603      	mov	r3, r0
 80087e6:	e7e9      	b.n	80087bc <cifXStartDevice+0x108>
        if( CIFX_NO_ERROR != (lRet = cifXCreateSystemDevice( ptDevInstance)))
 80087e8:	4620      	mov	r0, r4
 80087ea:	f7fe fda3 	bl	8007334 <cifXCreateSystemDevice>
 80087ee:	4605      	mov	r5, r0
 80087f0:	2800      	cmp	r0, #0
 80087f2:	f43f af7b 	beq.w	80086ec <cifXStartDevice+0x38>
          USER_Trace(ptDevInstance,
 80087f6:	4a31      	ldr	r2, [pc, #196]	; (80088bc <cifXStartDevice+0x208>)
 80087f8:	2108      	movs	r1, #8
 80087fa:	4620      	mov	r0, r4
 80087fc:	f000 ff20 	bl	8009640 <USER_Trace>
 8008800:	e774      	b.n	80086ec <cifXStartDevice+0x38>
    if (NULL == (ptDevInstance->tSyncData.pvLock = OS_CreateLock()))
 8008802:	f7fa f9ea 	bl	8002bda <OS_CreateLock>
 8008806:	f8c4 026c 	str.w	r0, [r4, #620]	; 0x26c
 800880a:	b1f8      	cbz	r0, 800884c <cifXStartDevice+0x198>
      HIL_DPM_SYSTEM_CHANNEL_T* ptSysChannel = (HIL_DPM_SYSTEM_CHANNEL_T*)ptDevInstance->tSystemDevice.pbDPMChannelStart;
 800880c:	f8d4 50fc 	ldr.w	r5, [r4, #252]	; 0xfc
      if(ptDevInstance->ulSlotNumber != HWIF_READ8(ptDevInstance, ptSysChannel->tSystemInfo.bDevIdNumber))
 8008810:	6de6      	ldr	r6, [r4, #92]	; 0x5c
 8008812:	352c      	adds	r5, #44	; 0x2c
 8008814:	4629      	mov	r1, r5
 8008816:	4620      	mov	r0, r4
 8008818:	f7fc fd2e 	bl	8005278 <HwIfRead8>
 800881c:	4286      	cmp	r6, r0
 800881e:	d00c      	beq.n	800883a <cifXStartDevice+0x186>
        HWIF_WRITE8(ptDevInstance, ptSysChannel->tSystemInfo.bDevIdNumber, (uint8_t)HOST_TO_LE32(ptDevInstance->ulSlotNumber));
 8008820:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 8008824:	f88d 300b 	strb.w	r3, [sp, #11]
 8008828:	f8d4 62c8 	ldr.w	r6, [r4, #712]	; 0x2c8
 800882c:	2001      	movs	r0, #1
 800882e:	9000      	str	r0, [sp, #0]
 8008830:	f10d 030b 	add.w	r3, sp, #11
 8008834:	462a      	mov	r2, r5
 8008836:	4621      	mov	r1, r4
 8008838:	47b0      	blx	r6
      if( eCHIP_TYPE_UNKNOWN == ptDevInstance->eChipType)
 800883a:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 800883e:	b19b      	cbz	r3, 8008868 <cifXStartDevice+0x1b4>
      lRet = cifXCreateChannels(ptDevInstance, &tDevChannelCfg);
 8008840:	a903      	add	r1, sp, #12
 8008842:	4620      	mov	r0, r4
 8008844:	f7ff fb6c 	bl	8007f20 <cifXCreateChannels>
 8008848:	4605      	mov	r5, r0
 800884a:	e752      	b.n	80086f2 <cifXStartDevice+0x3e>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 800884c:	4b1c      	ldr	r3, [pc, #112]	; (80088c0 <cifXStartDevice+0x20c>)
 800884e:	681b      	ldr	r3, [r3, #0]
 8008850:	f013 0f08 	tst.w	r3, #8
 8008854:	d101      	bne.n	800885a <cifXStartDevice+0x1a6>
      lRet = CIFX_INVALID_POINTER;
 8008856:	4d1b      	ldr	r5, [pc, #108]	; (80088c4 <cifXStartDevice+0x210>)
 8008858:	e753      	b.n	8008702 <cifXStartDevice+0x4e>
        USER_Trace(ptDevInstance,
 800885a:	4a1b      	ldr	r2, [pc, #108]	; (80088c8 <cifXStartDevice+0x214>)
 800885c:	2108      	movs	r1, #8
 800885e:	4620      	mov	r0, r4
 8008860:	f000 feee 	bl	8009640 <USER_Trace>
      lRet = CIFX_INVALID_POINTER;
 8008864:	4d17      	ldr	r5, [pc, #92]	; (80088c4 <cifXStartDevice+0x210>)
 8008866:	e74c      	b.n	8008702 <cifXStartDevice+0x4e>
        if( CIFX_NO_ERROR != cifXReadHardwareIdent( ptDevInstance, NULL, NULL))
 8008868:	2200      	movs	r2, #0
 800886a:	4611      	mov	r1, r2
 800886c:	4620      	mov	r0, r4
 800886e:	f7ff faad 	bl	8007dcc <cifXReadHardwareIdent>
 8008872:	2800      	cmp	r0, #0
 8008874:	d0e4      	beq.n	8008840 <cifXStartDevice+0x18c>
          if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 8008876:	4b12      	ldr	r3, [pc, #72]	; (80088c0 <cifXStartDevice+0x20c>)
 8008878:	681b      	ldr	r3, [r3, #0]
 800887a:	f013 0f08 	tst.w	r3, #8
 800887e:	d0df      	beq.n	8008840 <cifXStartDevice+0x18c>
            USER_Trace(ptDevInstance,
 8008880:	4a12      	ldr	r2, [pc, #72]	; (80088cc <cifXStartDevice+0x218>)
 8008882:	2108      	movs	r1, #8
 8008884:	4620      	mov	r0, r4
 8008886:	f000 fedb 	bl	8009640 <USER_Trace>
 800888a:	e7d9      	b.n	8008840 <cifXStartDevice+0x18c>
      lRet = cifXStartFlashConfiguration(ptDevInstance, &tDevChannelCfg);
 800888c:	a903      	add	r1, sp, #12
 800888e:	4620      	mov	r0, r4
 8008890:	f7fe ff52 	bl	8007738 <cifXStartFlashConfiguration>
 8008894:	4605      	mov	r5, r0
 8008896:	e731      	b.n	80086fc <cifXStartDevice+0x48>
      lRet = cifXHandleWarmstartParameter(ptDevInstance);
 8008898:	4620      	mov	r0, r4
 800889a:	f7fe ff8f 	bl	80077bc <cifXHandleWarmstartParameter>
 800889e:	4605      	mov	r5, r0
 80088a0:	e72f      	b.n	8008702 <cifXStartDevice+0x4e>
    lRet = cifXCheckCachedBufferEnable(ptDevInstance);
 80088a2:	4620      	mov	r0, r4
 80088a4:	f7ff f818 	bl	80078d8 <cifXCheckCachedBufferEnable>
 80088a8:	4605      	mov	r5, r0
 80088aa:	e72d      	b.n	8008708 <cifXStartDevice+0x54>
    lRet = cifXCheckIRQEnable(ptDevInstance);
 80088ac:	4620      	mov	r0, r4
 80088ae:	f7ff f841 	bl	8007934 <cifXCheckIRQEnable>
 80088b2:	4605      	mov	r5, r0
 80088b4:	e72b      	b.n	800870e <cifXStartDevice+0x5a>
 80088b6:	bf00      	nop
 80088b8:	0800c914 	.word	0x0800c914
 80088bc:	0800c984 	.word	0x0800c984
 80088c0:	20000038 	.word	0x20000038
 80088c4:	800a0001 	.word	0x800a0001
 80088c8:	0800c9f4 	.word	0x0800c9f4
 80088cc:	0800ca14 	.word	0x0800ca14

080088d0 <cifXTKitEnableHWInterrupt>:
/*****************************************************************************/
/*! Physically Enable Interrupts on hardware
*   \param ptDevInstance Device instance                                     */
/*****************************************************************************/
void cifXTKitEnableHWInterrupt(PDEVICEINSTANCE ptDevInstance)
{
 80088d0:	b570      	push	{r4, r5, r6, lr}
 80088d2:	b084      	sub	sp, #16
 80088d4:	4604      	mov	r4, r0
  /* Set interrupt enable bits in PCI mode only if the complete 64KByte DPM is available */
  if( (ptDevInstance->fPCICard) ||
 80088d6:	68c3      	ldr	r3, [r0, #12]
 80088d8:	b91b      	cbnz	r3, 80088e2 <cifXTKitEnableHWInterrupt+0x12>
      (ptDevInstance->ulDPMSize >= NETX_DPM_MEMORY_SIZE) )
 80088da:	6a43      	ldr	r3, [r0, #36]	; 0x24
  if( (ptDevInstance->fPCICard) ||
 80088dc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80088e0:	d318      	bcc.n	8008914 <cifXTKitEnableHWInterrupt+0x44>
  {
    /* Enable global and handshake interrupts */
    HWIF_WRITE32(ptDevInstance, ptDevInstance->ptGlobalRegisters->ulIRQEnable_0,
 80088e2:	4b0d      	ldr	r3, [pc, #52]	; (8008918 <cifXTKitEnableHWInterrupt+0x48>)
 80088e4:	9303      	str	r3, [sp, #12]
 80088e6:	f8d4 62c8 	ldr.w	r6, [r4, #712]	; 0x2c8
 80088ea:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80088ec:	2504      	movs	r5, #4
 80088ee:	9500      	str	r5, [sp, #0]
 80088f0:	ab03      	add	r3, sp, #12
 80088f2:	f502 72f8 	add.w	r2, r2, #496	; 0x1f0
 80088f6:	4621      	mov	r1, r4
 80088f8:	2001      	movs	r0, #1
 80088fa:	47b0      	blx	r6
                 HOST_TO_LE32((MSK_IRQ_EN0_INT_REQ | MSK_IRQ_EN0_HANDSHAKE) ));

    HWIF_WRITE32(ptDevInstance, ptDevInstance->ptGlobalRegisters->ulIRQEnable_1, 0);
 80088fc:	2300      	movs	r3, #0
 80088fe:	9303      	str	r3, [sp, #12]
 8008900:	f8d4 62c8 	ldr.w	r6, [r4, #712]	; 0x2c8
 8008904:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8008906:	9500      	str	r5, [sp, #0]
 8008908:	ab03      	add	r3, sp, #12
 800890a:	f502 72fa 	add.w	r2, r2, #500	; 0x1f4
 800890e:	4621      	mov	r1, r4
 8008910:	2001      	movs	r0, #1
 8008912:	47b0      	blx	r6
  }
}
 8008914:	b004      	add	sp, #16
 8008916:	bd70      	pop	{r4, r5, r6, pc}
 8008918:	8000ffff 	.word	0x8000ffff

0800891c <cifXTKitAddDevice>:
*   \param ptDevInstance Device to add (must at least include the pointer to
*                        the DPM)
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t cifXTKitAddDevice(PDEVICEINSTANCE ptDevInstance)
{
 800891c:	b570      	push	{r4, r5, r6, lr}
  int32_t lRet;

  /* Check if we have a pointer */
  if(NULL == ptDevInstance)
 800891e:	2800      	cmp	r0, #0
 8008920:	d04c      	beq.n	80089bc <cifXTKitAddDevice+0xa0>
 8008922:	4604      	mov	r4, r0
    return CIFX_INVALID_POINTER;

  /* Disable interrupts during startup phase. Just in case the user has set this flag! */
  ptDevInstance->fIrqEnabled = 0;
 8008924:	2300      	movs	r3, #0
 8008926:	6083      	str	r3, [r0, #8]

#ifdef CIFX_TOOLKIT_HWIF
  /* Validate hardware access function pointers != NULL */
  if ( (ptDevInstance->pfnHwIfRead    == NULL) ||
 8008928:	f8d0 32c4 	ldr.w	r3, [r0, #708]	; 0x2c4
 800892c:	2b00      	cmp	r3, #0
 800892e:	d047      	beq.n	80089c0 <cifXTKitAddDevice+0xa4>
       (ptDevInstance->pfnHwIfWrite   == NULL)   )
 8008930:	f8d0 32c8 	ldr.w	r3, [r0, #712]	; 0x2c8
  if ( (ptDevInstance->pfnHwIfRead    == NULL) ||
 8008934:	2b00      	cmp	r3, #0
 8008936:	d045      	beq.n	80089c4 <cifXTKitAddDevice+0xa8>
      return lRet;
  }
#endif

  /* Run the toolkit start device functions */
  lRet = cifXStartDevice(ptDevInstance);
 8008938:	f7ff febc 	bl	80086b4 <cifXStartDevice>
  if(CIFX_NO_ERROR == lRet)
 800893c:	4605      	mov	r5, r0
 800893e:	b108      	cbz	r0, 8008944 <cifXTKitAddDevice+0x28>
    /* Done with the initialisation */
    OS_LeaveLock(g_pvTkitLock);
  }

  return lRet;
}
 8008940:	4628      	mov	r0, r5
 8008942:	bd70      	pop	{r4, r5, r6, pc}
    OS_EnterLock(g_pvTkitLock);
 8008944:	4b20      	ldr	r3, [pc, #128]	; (80089c8 <cifXTKitAddDevice+0xac>)
 8008946:	6818      	ldr	r0, [r3, #0]
 8008948:	f7fa f92a 	bl	8002ba0 <OS_EnterLock>
    ++g_ulDeviceCount;
 800894c:	4b1f      	ldr	r3, [pc, #124]	; (80089cc <cifXTKitAddDevice+0xb0>)
 800894e:	6819      	ldr	r1, [r3, #0]
 8008950:	3101      	adds	r1, #1
 8008952:	6019      	str	r1, [r3, #0]
    g_pptDevices = (PDEVICEINSTANCE*)OS_Memrealloc(g_pptDevices, g_ulDeviceCount * (uint32_t)sizeof(*g_pptDevices));
 8008954:	4e1e      	ldr	r6, [pc, #120]	; (80089d0 <cifXTKitAddDevice+0xb4>)
 8008956:	0089      	lsls	r1, r1, #2
 8008958:	6830      	ldr	r0, [r6, #0]
 800895a:	f7fa f8dc 	bl	8002b16 <OS_Memrealloc>
 800895e:	6030      	str	r0, [r6, #0]
    if (NULL == g_pptDevices)
 8008960:	b168      	cbz	r0, 800897e <cifXTKitAddDevice+0x62>
      g_pptDevices[g_ulDeviceCount - 1] = ptDevInstance;
 8008962:	4b1a      	ldr	r3, [pc, #104]	; (80089cc <cifXTKitAddDevice+0xb0>)
 8008964:	681a      	ldr	r2, [r3, #0]
 8008966:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 800896a:	4413      	add	r3, r2
 800896c:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
      if(0 != (ptDevInstance->fIrqEnabled))
 8008970:	68a3      	ldr	r3, [r4, #8]
 8008972:	b993      	cbnz	r3, 800899a <cifXTKitAddDevice+0x7e>
    OS_LeaveLock(g_pvTkitLock);
 8008974:	4b14      	ldr	r3, [pc, #80]	; (80089c8 <cifXTKitAddDevice+0xac>)
 8008976:	6818      	ldr	r0, [r3, #0]
 8008978:	f7fa f91e 	bl	8002bb8 <OS_LeaveLock>
 800897c:	e7e0      	b.n	8008940 <cifXTKitAddDevice+0x24>
      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 800897e:	4b15      	ldr	r3, [pc, #84]	; (80089d4 <cifXTKitAddDevice+0xb8>)
 8008980:	681b      	ldr	r3, [r3, #0]
 8008982:	f013 0f08 	tst.w	r3, #8
 8008986:	d101      	bne.n	800898c <cifXTKitAddDevice+0x70>
      lRet = CIFX_INVALID_POINTER;
 8008988:	4d13      	ldr	r5, [pc, #76]	; (80089d8 <cifXTKitAddDevice+0xbc>)
 800898a:	e7f3      	b.n	8008974 <cifXTKitAddDevice+0x58>
        USER_Trace(ptDevInstance,
 800898c:	4a13      	ldr	r2, [pc, #76]	; (80089dc <cifXTKitAddDevice+0xc0>)
 800898e:	2108      	movs	r1, #8
 8008990:	4620      	mov	r0, r4
 8008992:	f000 fe55 	bl	8009640 <USER_Trace>
      lRet = CIFX_INVALID_POINTER;
 8008996:	4d10      	ldr	r5, [pc, #64]	; (80089d8 <cifXTKitAddDevice+0xbc>)
 8008998:	e7ec      	b.n	8008974 <cifXTKitAddDevice+0x58>
        if(CIFX_TKIT_IRQ_DSR_REQUESTED == cifXTKitISRHandler(ptDevInstance, 1))
 800899a:	2101      	movs	r1, #1
 800899c:	4620      	mov	r0, r4
 800899e:	f000 f8af 	bl	8008b00 <cifXTKitISRHandler>
 80089a2:	2802      	cmp	r0, #2
 80089a4:	d006      	beq.n	80089b4 <cifXTKitAddDevice+0x98>
        OS_EnableInterrupts(ptDevInstance->pvOSDependent);
 80089a6:	69e0      	ldr	r0, [r4, #28]
 80089a8:	f7fa f8cc 	bl	8002b44 <OS_EnableInterrupts>
        cifXTKitEnableHWInterrupt(ptDevInstance);
 80089ac:	4620      	mov	r0, r4
 80089ae:	f7ff ff8f 	bl	80088d0 <cifXTKitEnableHWInterrupt>
 80089b2:	e7df      	b.n	8008974 <cifXTKitAddDevice+0x58>
          cifXTKitDSRHandler(ptDevInstance);
 80089b4:	4620      	mov	r0, r4
 80089b6:	f000 f965 	bl	8008c84 <cifXTKitDSRHandler>
 80089ba:	e7f4      	b.n	80089a6 <cifXTKitAddDevice+0x8a>
    return CIFX_INVALID_POINTER;
 80089bc:	4d06      	ldr	r5, [pc, #24]	; (80089d8 <cifXTKitAddDevice+0xbc>)
 80089be:	e7bf      	b.n	8008940 <cifXTKitAddDevice+0x24>
    return CIFX_INVALID_PARAMETER;
 80089c0:	4d07      	ldr	r5, [pc, #28]	; (80089e0 <cifXTKitAddDevice+0xc4>)
 80089c2:	e7bd      	b.n	8008940 <cifXTKitAddDevice+0x24>
 80089c4:	4d06      	ldr	r5, [pc, #24]	; (80089e0 <cifXTKitAddDevice+0xc4>)
 80089c6:	e7bb      	b.n	8008940 <cifXTKitAddDevice+0x24>
 80089c8:	20000210 	.word	0x20000210
 80089cc:	2000021c 	.word	0x2000021c
 80089d0:	2000020c 	.word	0x2000020c
 80089d4:	20000038 	.word	0x20000038
 80089d8:	800a0001 	.word	0x800a0001
 80089dc:	0800ca30 	.word	0x0800ca30
 80089e0:	800a0005 	.word	0x800a0005

080089e4 <cifXTKitDeinit>:

/*****************************************************************************/
/*! Un-Initializes the cifX Toolkit                                          */
/*****************************************************************************/
void cifXTKitDeinit( void)
{
 80089e4:	b510      	push	{r4, lr}
  uint32_t ulIdx = 0;

  if(g_pvTkitLock)
 80089e6:	4b17      	ldr	r3, [pc, #92]	; (8008a44 <cifXTKitDeinit+0x60>)
 80089e8:	6818      	ldr	r0, [r3, #0]
 80089ea:	b108      	cbz	r0, 80089f0 <cifXTKitDeinit+0xc>
  {
    OS_EnterLock(g_pvTkitLock);
 80089ec:	f7fa f8d8 	bl	8002ba0 <OS_EnterLock>
{
 80089f0:	2400      	movs	r4, #0
 80089f2:	e006      	b.n	8008a02 <cifXTKitDeinit+0x1e>
  }

  for(ulIdx = 0; ulIdx < g_ulDeviceCount; ++ulIdx)
  {
    (void)cifXStopDevice(g_pptDevices[ulIdx]);
 80089f4:	4b14      	ldr	r3, [pc, #80]	; (8008a48 <cifXTKitDeinit+0x64>)
 80089f6:	681b      	ldr	r3, [r3, #0]
 80089f8:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80089fc:	f7ff f80c 	bl	8007a18 <cifXStopDevice>
  for(ulIdx = 0; ulIdx < g_ulDeviceCount; ++ulIdx)
 8008a00:	3401      	adds	r4, #1
 8008a02:	4b12      	ldr	r3, [pc, #72]	; (8008a4c <cifXTKitDeinit+0x68>)
 8008a04:	681b      	ldr	r3, [r3, #0]
 8008a06:	42a3      	cmp	r3, r4
 8008a08:	d8f4      	bhi.n	80089f4 <cifXTKitDeinit+0x10>
  }

  if(g_pptDevices)
 8008a0a:	4b0f      	ldr	r3, [pc, #60]	; (8008a48 <cifXTKitDeinit+0x64>)
 8008a0c:	6818      	ldr	r0, [r3, #0]
 8008a0e:	b120      	cbz	r0, 8008a1a <cifXTKitDeinit+0x36>
  {
    OS_Memfree(g_pptDevices);
 8008a10:	f7fa f87d 	bl	8002b0e <OS_Memfree>
    g_pptDevices    = NULL;
 8008a14:	4b0c      	ldr	r3, [pc, #48]	; (8008a48 <cifXTKitDeinit+0x64>)
 8008a16:	2200      	movs	r2, #0
 8008a18:	601a      	str	r2, [r3, #0]
  }
  g_ulDeviceCount = 0;
 8008a1a:	4b0c      	ldr	r3, [pc, #48]	; (8008a4c <cifXTKitDeinit+0x68>)
 8008a1c:	2200      	movs	r2, #0
 8008a1e:	601a      	str	r2, [r3, #0]

  if(g_pvTkitLock)
 8008a20:	4b08      	ldr	r3, [pc, #32]	; (8008a44 <cifXTKitDeinit+0x60>)
 8008a22:	6818      	ldr	r0, [r3, #0]
 8008a24:	b138      	cbz	r0, 8008a36 <cifXTKitDeinit+0x52>
  {
    OS_LeaveLock(g_pvTkitLock);
 8008a26:	f7fa f8c7 	bl	8002bb8 <OS_LeaveLock>
    OS_DeleteLock(g_pvTkitLock);
 8008a2a:	4c06      	ldr	r4, [pc, #24]	; (8008a44 <cifXTKitDeinit+0x60>)
 8008a2c:	6820      	ldr	r0, [r4, #0]
 8008a2e:	f7fa f8d1 	bl	8002bd4 <OS_DeleteLock>
    g_pvTkitLock = NULL;
 8008a32:	2300      	movs	r3, #0
 8008a34:	6023      	str	r3, [r4, #0]
  }

  /* Uninitialize OS functions */
  OS_Deinit();
 8008a36:	f7fa f865 	bl	8002b04 <OS_Deinit>

  g_tDriverInfo.fInitialized = 0;
 8008a3a:	4b05      	ldr	r3, [pc, #20]	; (8008a50 <cifXTKitDeinit+0x6c>)
 8008a3c:	2200      	movs	r2, #0
 8008a3e:	605a      	str	r2, [r3, #4]
  g_tDriverInfo.ulOpenCount  = 0;
 8008a40:	601a      	str	r2, [r3, #0]
}
 8008a42:	bd10      	pop	{r4, pc}
 8008a44:	20000210 	.word	0x20000210
 8008a48:	2000020c 	.word	0x2000020c
 8008a4c:	2000021c 	.word	0x2000021c
 8008a50:	20000214 	.word	0x20000214

08008a54 <cifXTKitInit>:
{
 8008a54:	b510      	push	{r4, lr}
  cifXTKitDeinit();
 8008a56:	f7ff ffc5 	bl	80089e4 <cifXTKitDeinit>
  lRet = OS_Init();
 8008a5a:	f7fa f84b 	bl	8002af4 <OS_Init>
  if(CIFX_NO_ERROR == lRet)
 8008a5e:	4604      	mov	r4, r0
 8008a60:	b108      	cbz	r0, 8008a66 <cifXTKitInit+0x12>
}
 8008a62:	4620      	mov	r0, r4
 8008a64:	bd10      	pop	{r4, pc}
    if( NULL == (g_pvTkitLock = OS_CreateLock()) )
 8008a66:	f7fa f8b8 	bl	8002bda <OS_CreateLock>
 8008a6a:	4b05      	ldr	r3, [pc, #20]	; (8008a80 <cifXTKitInit+0x2c>)
 8008a6c:	6018      	str	r0, [r3, #0]
 8008a6e:	b118      	cbz	r0, 8008a78 <cifXTKitInit+0x24>
      g_tDriverInfo.fInitialized = 1;
 8008a70:	4b04      	ldr	r3, [pc, #16]	; (8008a84 <cifXTKitInit+0x30>)
 8008a72:	2201      	movs	r2, #1
 8008a74:	605a      	str	r2, [r3, #4]
  return lRet;
 8008a76:	e7f4      	b.n	8008a62 <cifXTKitInit+0xe>
      OS_Deinit();
 8008a78:	f7fa f844 	bl	8002b04 <OS_Deinit>
      lRet = CIFX_INVALID_POINTER;
 8008a7c:	4c02      	ldr	r4, [pc, #8]	; (8008a88 <cifXTKitInit+0x34>)
 8008a7e:	e7f0      	b.n	8008a62 <cifXTKitInit+0xe>
 8008a80:	20000210 	.word	0x20000210
 8008a84:	20000214 	.word	0x20000214
 8008a88:	800a0001 	.word	0x800a0001

08008a8c <ProcessIOArea>:
static void ProcessIOArea(PCHANNELINSTANCE  ptChannel,
                          PIOINSTANCE       ptIoArea,
                          uint16_t          usChangedBits,
                          uint16_t          usUnequalBits,
                          int               fOutput)
{
 8008a8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008a8e:	460c      	mov	r4, r1
  uint16_t usBitMask = (uint16_t)(1 << ptIoArea->bHandshakeBit);
 8008a90:	7a09      	ldrb	r1, [r1, #8]
 8008a92:	f04f 0c01 	mov.w	ip, #1
 8008a96:	fa0c fc01 	lsl.w	ip, ip, r1

  if(usChangedBits & usBitMask)
 8008a9a:	ea1c 0f02 	tst.w	ip, r2
 8008a9e:	d100      	bne.n	8008aa2 <ProcessIOArea+0x16>
    if(pfnCallback)
      pfnCallback(ptIoArea->ulNotifyEvent, 0, NULL, ptIoArea->pvUser);

    OS_SetEvent(ptChannel->ahHandshakeBitEvents[ptIoArea->bHandshakeBit]);
  }
}
 8008aa0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008aa2:	4605      	mov	r5, r0
 8008aa4:	461e      	mov	r6, r3
 8008aa6:	fa1f f78c 	uxth.w	r7, ip
    uint8_t             bIOBitState = DEV_GetIOBitstate(ptChannel, ptIoArea, fOutput);
 8008aaa:	9a06      	ldr	r2, [sp, #24]
 8008aac:	4621      	mov	r1, r4
 8008aae:	f7fc fbf6 	bl	800529e <DEV_GetIOBitstate>
    switch(bIOBitState)
 8008ab2:	2803      	cmp	r0, #3
 8008ab4:	d80c      	bhi.n	8008ad0 <ProcessIOArea+0x44>
 8008ab6:	e8df f000 	tbb	[pc, r0]
 8008aba:	1302      	.short	0x1302
 8008abc:	1d17      	.short	0x1d17
      if(0 == (usUnequalBits & usBitMask))
 8008abe:	4237      	tst	r7, r6
 8008ac0:	d106      	bne.n	8008ad0 <ProcessIOArea+0x44>
        pfnCallback = ptIoArea->pfnCallback;
 8008ac2:	69a6      	ldr	r6, [r4, #24]
    if(pfnCallback)
 8008ac4:	b126      	cbz	r6, 8008ad0 <ProcessIOArea+0x44>
      pfnCallback(ptIoArea->ulNotifyEvent, 0, NULL, ptIoArea->pvUser);
 8008ac6:	69e3      	ldr	r3, [r4, #28]
 8008ac8:	2200      	movs	r2, #0
 8008aca:	4611      	mov	r1, r2
 8008acc:	6960      	ldr	r0, [r4, #20]
 8008ace:	47b0      	blx	r6
    OS_SetEvent(ptChannel->ahHandshakeBitEvents[ptIoArea->bHandshakeBit]);
 8008ad0:	7a23      	ldrb	r3, [r4, #8]
 8008ad2:	333e      	adds	r3, #62	; 0x3e
 8008ad4:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8008ad8:	6868      	ldr	r0, [r5, #4]
 8008ada:	f7fa f8bb 	bl	8002c54 <OS_SetEvent>
}
 8008ade:	e7df      	b.n	8008aa0 <ProcessIOArea+0x14>
      if(usUnequalBits & usBitMask)
 8008ae0:	4237      	tst	r7, r6
 8008ae2:	d0f5      	beq.n	8008ad0 <ProcessIOArea+0x44>
        pfnCallback = ptIoArea->pfnCallback;
 8008ae4:	69a6      	ldr	r6, [r4, #24]
 8008ae6:	e7ed      	b.n	8008ac4 <ProcessIOArea+0x38>
      if(0 == (ptChannel->usNetxFlags & usBitMask))
 8008ae8:	f8b5 30be 	ldrh.w	r3, [r5, #190]	; 0xbe
 8008aec:	423b      	tst	r3, r7
 8008aee:	d1ef      	bne.n	8008ad0 <ProcessIOArea+0x44>
        pfnCallback = ptIoArea->pfnCallback;
 8008af0:	69a6      	ldr	r6, [r4, #24]
 8008af2:	e7e7      	b.n	8008ac4 <ProcessIOArea+0x38>
      if(ptChannel->usNetxFlags & usBitMask)
 8008af4:	f8b5 30be 	ldrh.w	r3, [r5, #190]	; 0xbe
 8008af8:	423b      	tst	r3, r7
 8008afa:	d0e9      	beq.n	8008ad0 <ProcessIOArea+0x44>
        pfnCallback = ptIoArea->pfnCallback;
 8008afc:	69a6      	ldr	r6, [r4, #24]
 8008afe:	e7e1      	b.n	8008ac4 <ProcessIOArea+0x38>

08008b00 <cifXTKitISRHandler>:
{
 8008b00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008b04:	b085      	sub	sp, #20
 8008b06:	4604      	mov	r4, r0
 8008b08:	460e      	mov	r6, r1
  if( HWIF_READ32(ptDevInstance, *(uint32_t*)ptDevInstance->pbDPM) == CIFX_DPM_INVALID_CONTENT)
 8008b0a:	6a01      	ldr	r1, [r0, #32]
 8008b0c:	f7fc fbf5 	bl	80052fa <HwIfRead32>
 8008b10:	f1b0 3fff 	cmp.w	r0, #4294967295
 8008b14:	f000 80b0 	beq.w	8008c78 <cifXTKitISRHandler+0x178>
  if(!ptDevInstance->fIrqEnabled)
 8008b18:	68a5      	ldr	r5, [r4, #8]
 8008b1a:	2d00      	cmp	r5, #0
 8008b1c:	d055      	beq.n	8008bca <cifXTKitISRHandler+0xca>
    int                         iIrqToDsrBuffer   = ptDevInstance->iIrqToDsrBuffer;
 8008b1e:	6e65      	ldr	r5, [r4, #100]	; 0x64
    HIL_DPM_HANDSHAKE_ARRAY_T*  ptHandshakeBuffer = &ptIsrToDsrBuffer->tHandshakeBuffer;
 8008b20:	eb05 1305 	add.w	r3, r5, r5, lsl #4
 8008b24:	009b      	lsls	r3, r3, #2
 8008b26:	3368      	adds	r3, #104	; 0x68
 8008b28:	4423      	add	r3, r4
    if( (!ptDevInstance->fPCICard) ||
 8008b2a:	68e2      	ldr	r2, [r4, #12]
 8008b2c:	2a00      	cmp	r2, #0
 8008b2e:	d052      	beq.n	8008bd6 <cifXTKitISRHandler+0xd6>
        (!ptDevInstance->pbHandshakeBlock) )
 8008b30:	6e22      	ldr	r2, [r4, #96]	; 0x60
    if( (!ptDevInstance->fPCICard) ||
 8008b32:	2a00      	cmp	r2, #0
 8008b34:	d04f      	beq.n	8008bd6 <cifXTKitISRHandler+0xd6>
      uint32_t ulIrqState0 = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptDevInstance->ptGlobalRegisters->ulIRQState_0));
 8008b36:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8008b38:	f501 71f0 	add.w	r1, r1, #480	; 0x1e0
 8008b3c:	4620      	mov	r0, r4
 8008b3e:	f7fc fbdc 	bl	80052fa <HwIfRead32>
 8008b42:	4680      	mov	r8, r0
      uint32_t ulIrqState1 = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptDevInstance->ptGlobalRegisters->ulIRQState_1));
 8008b44:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8008b46:	f501 71f2 	add.w	r1, r1, #484	; 0x1e4
 8008b4a:	4620      	mov	r0, r4
 8008b4c:	f7fc fbd5 	bl	80052fa <HwIfRead32>
 8008b50:	4681      	mov	r9, r0
      if(  !fPCIIgnoreGlobalIntFlag &&
 8008b52:	f1b8 0f00 	cmp.w	r8, #0
 8008b56:	bfa8      	it	ge
 8008b58:	2e00      	cmpge	r6, #0
 8008b5a:	f000 808f 	beq.w	8008c7c <cifXTKitISRHandler+0x17c>
        HIL_DPM_HANDSHAKE_ARRAY_T* ptHandshakeBlock = (HIL_DPM_HANDSHAKE_ARRAY_T*)ptDevInstance->pbHandshakeBlock;
 8008b5e:	6e27      	ldr	r7, [r4, #96]	; 0x60
        HWIF_WRITE32(ptDevInstance, ptDevInstance->ptGlobalRegisters->ulIRQState_0, HOST_TO_LE32(ulIrqState0));
 8008b60:	f8cd 800c 	str.w	r8, [sp, #12]
 8008b64:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8008b66:	f04f 0804 	mov.w	r8, #4
 8008b6a:	f8cd 8000 	str.w	r8, [sp]
 8008b6e:	ab03      	add	r3, sp, #12
 8008b70:	f502 72f0 	add.w	r2, r2, #480	; 0x1e0
 8008b74:	4621      	mov	r1, r4
 8008b76:	2001      	movs	r0, #1
 8008b78:	f8d4 62c8 	ldr.w	r6, [r4, #712]	; 0x2c8
 8008b7c:	47b0      	blx	r6
        HWIF_WRITE32(ptDevInstance, ptDevInstance->ptGlobalRegisters->ulIRQState_1, HOST_TO_LE32(ulIrqState1));
 8008b7e:	f8cd 900c 	str.w	r9, [sp, #12]
 8008b82:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8008b84:	f8cd 8000 	str.w	r8, [sp]
 8008b88:	ab03      	add	r3, sp, #12
 8008b8a:	f502 72f2 	add.w	r2, r2, #484	; 0x1e4
 8008b8e:	4621      	mov	r1, r4
 8008b90:	2001      	movs	r0, #1
 8008b92:	f8d4 62c8 	ldr.w	r6, [r4, #712]	; 0x2c8
 8008b96:	47b0      	blx	r6
        ++ptDevInstance->ulIrqCounter;
 8008b98:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 8008b9c:	3301      	adds	r3, #1
 8008b9e:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
        ptIsrToDsrBuffer->fValid = 1;
 8008ba2:	eb05 1605 	add.w	r6, r5, r5, lsl #4
 8008ba6:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 8008baa:	2301      	movs	r3, #1
 8008bac:	f8c6 30a8 	str.w	r3, [r6, #168]	; 0xa8
        ptHandshakeBuffer->atHsk[HIL_DPM_SYSTEM_CHANNEL_INDEX].ulValue    = HWIF_READ32( ptDevInstance, ptHandshakeBlock->atHsk[HIL_DPM_SYSTEM_CHANNEL_INDEX].ulValue);
 8008bb0:	4639      	mov	r1, r7
 8008bb2:	4620      	mov	r0, r4
 8008bb4:	f7fc fba1 	bl	80052fa <HwIfRead32>
 8008bb8:	66b0      	str	r0, [r6, #104]	; 0x68
        ptHandshakeBuffer->atHsk[HIL_DPM_HANDSHAKE_CHANNEL_INDEX].ulValue = HWIF_READ32( ptDevInstance, ptHandshakeBlock->atHsk[HIL_DPM_HANDSHAKE_CHANNEL_INDEX].ulValue);
 8008bba:	eb07 0108 	add.w	r1, r7, r8
 8008bbe:	4620      	mov	r0, r4
 8008bc0:	f7fc fb9b 	bl	80052fa <HwIfRead32>
 8008bc4:	66f0      	str	r0, [r6, #108]	; 0x6c
        for(ulChannel = 0; ulChannel < ptDevInstance->ulCommChannelCount; ++ulChannel)
 8008bc6:	2600      	movs	r6, #0
 8008bc8:	e050      	b.n	8008c6c <cifXTKitISRHandler+0x16c>
    USER_Trace(ptDevInstance,
 8008bca:	4a2d      	ldr	r2, [pc, #180]	; (8008c80 <cifXTKitISRHandler+0x180>)
 8008bcc:	2108      	movs	r1, #8
 8008bce:	4620      	mov	r0, r4
 8008bd0:	f000 fd36 	bl	8009640 <USER_Trace>
    iRet = CIFX_TKIT_IRQ_OTHERDEVICE;
 8008bd4:	e015      	b.n	8008c02 <cifXTKitISRHandler+0x102>
      ++ptDevInstance->ulIrqCounter;
 8008bd6:	f8d4 20f0 	ldr.w	r2, [r4, #240]	; 0xf0
 8008bda:	3201      	adds	r2, #1
 8008bdc:	f8c4 20f0 	str.w	r2, [r4, #240]	; 0xf0
      ptIsrToDsrBuffer->fValid = 1;
 8008be0:	eb05 1205 	add.w	r2, r5, r5, lsl #4
 8008be4:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8008be8:	2101      	movs	r1, #1
 8008bea:	f8c2 10a8 	str.w	r1, [r2, #168]	; 0xa8
      if (NULL != ptDevInstance->pbHandshakeBlock)
 8008bee:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8008bf0:	b15a      	cbz	r2, 8008c0a <cifXTKitISRHandler+0x10a>
        HWIF_READN( ptDevInstance,
 8008bf2:	f8d4 52c4 	ldr.w	r5, [r4, #708]	; 0x2c4
 8008bf6:	2140      	movs	r1, #64	; 0x40
 8008bf8:	9100      	str	r1, [sp, #0]
 8008bfa:	4621      	mov	r1, r4
 8008bfc:	2000      	movs	r0, #0
 8008bfe:	47a8      	blx	r5
      iRet = CIFX_TKIT_IRQ_DSR_REQUESTED;
 8008c00:	2502      	movs	r5, #2
}
 8008c02:	4628      	mov	r0, r5
 8008c04:	b005      	add	sp, #20
 8008c06:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ptHandshakeBuffer->atHsk[0].ulValue = HWIF_READ32(ptDevInstance, ptDevInstance->tSystemDevice.ptHandshakeCell->ulValue);
 8008c0a:	f8d4 11e8 	ldr.w	r1, [r4, #488]	; 0x1e8
 8008c0e:	4620      	mov	r0, r4
 8008c10:	f7fc fb73 	bl	80052fa <HwIfRead32>
 8008c14:	eb05 1305 	add.w	r3, r5, r5, lsl #4
 8008c18:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8008c1c:	6698      	str	r0, [r3, #104]	; 0x68
        for(ulChannel = 0; ulChannel < ptDevInstance->ulCommChannelCount; ++ulChannel)
 8008c1e:	2600      	movs	r6, #0
 8008c20:	e010      	b.n	8008c44 <cifXTKitISRHandler+0x144>
          PCHANNELINSTANCE ptChannel = (PCHANNELINSTANCE)ptDevInstance->pptCommChannels[ulChannel];
 8008c22:	f8d4 3264 	ldr.w	r3, [r4, #612]	; 0x264
 8008c26:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
          uint32_t         ulBlockID = ptChannel->ulBlockID;
 8008c2a:	695f      	ldr	r7, [r3, #20]
          ptHandshakeBuffer->atHsk[ulBlockID].ulValue = HWIF_READ32(ptDevInstance, ptChannel->ptHandshakeCell->ulValue);
 8008c2c:	f8d3 10f4 	ldr.w	r1, [r3, #244]	; 0xf4
 8008c30:	4620      	mov	r0, r4
 8008c32:	f7fc fb62 	bl	80052fa <HwIfRead32>
 8008c36:	eb05 1305 	add.w	r3, r5, r5, lsl #4
 8008c3a:	443b      	add	r3, r7
 8008c3c:	331a      	adds	r3, #26
 8008c3e:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
        for(ulChannel = 0; ulChannel < ptDevInstance->ulCommChannelCount; ++ulChannel)
 8008c42:	3601      	adds	r6, #1
 8008c44:	f8d4 3260 	ldr.w	r3, [r4, #608]	; 0x260
 8008c48:	42b3      	cmp	r3, r6
 8008c4a:	d8ea      	bhi.n	8008c22 <cifXTKitISRHandler+0x122>
      iRet = CIFX_TKIT_IRQ_DSR_REQUESTED;
 8008c4c:	2502      	movs	r5, #2
 8008c4e:	e7d8      	b.n	8008c02 <cifXTKitISRHandler+0x102>
          ptHandshakeBuffer->atHsk[HIL_DPM_COM_CHANNEL_START_INDEX + ulChannel].ulValue = HWIF_READ32(ptDevInstance, ptHandshakeBlock->atHsk[HIL_DPM_COM_CHANNEL_START_INDEX + ulChannel].ulValue);
 8008c50:	f106 0802 	add.w	r8, r6, #2
 8008c54:	eb07 0188 	add.w	r1, r7, r8, lsl #2
 8008c58:	4620      	mov	r0, r4
 8008c5a:	f7fc fb4e 	bl	80052fa <HwIfRead32>
 8008c5e:	eb05 1305 	add.w	r3, r5, r5, lsl #4
 8008c62:	4443      	add	r3, r8
 8008c64:	331a      	adds	r3, #26
 8008c66:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
        for(ulChannel = 0; ulChannel < ptDevInstance->ulCommChannelCount; ++ulChannel)
 8008c6a:	3601      	adds	r6, #1
 8008c6c:	f8d4 3260 	ldr.w	r3, [r4, #608]	; 0x260
 8008c70:	42b3      	cmp	r3, r6
 8008c72:	d8ed      	bhi.n	8008c50 <cifXTKitISRHandler+0x150>
        iRet = CIFX_TKIT_IRQ_DSR_REQUESTED;
 8008c74:	2502      	movs	r5, #2
 8008c76:	e7c4      	b.n	8008c02 <cifXTKitISRHandler+0x102>
    return CIFX_TKIT_IRQ_OTHERDEVICE;
 8008c78:	2500      	movs	r5, #0
 8008c7a:	e7c2      	b.n	8008c02 <cifXTKitISRHandler+0x102>
        iRet = CIFX_TKIT_IRQ_OTHERDEVICE;
 8008c7c:	2500      	movs	r5, #0
 8008c7e:	e7c0      	b.n	8008c02 <cifXTKitISRHandler+0x102>
 8008c80:	0800ca90 	.word	0x0800ca90

08008c84 <cifXTKitDSRHandler>:
/*! Deferred interrupt handler
*   \param ptDevInstance Instance the DSR is requested for                   */
/*****************************************************************************/
void cifXTKitDSRHandler(PDEVICEINSTANCE ptDevInstance)
{
  if(!ptDevInstance->fResetActive)
 8008c84:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 8008c88:	2b00      	cmp	r3, #0
 8008c8a:	f040 81ab 	bne.w	8008fe4 <cifXTKitDSRHandler+0x360>
{
 8008c8e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008c92:	b085      	sub	sp, #20
 8008c94:	4606      	mov	r6, r0
  {
    /* Get actual data buffer index */
    uint32_t              ulChannel        = 0;
    PCHANNELINSTANCE      ptChannel        = &ptDevInstance->tSystemDevice;
 8008c96:	f100 04f4 	add.w	r4, r0, #244	; 0xf4
    /*            of the ISR function. This does usually happens on physical ISR functions */
    /*            but does not work if the ISR and DSR are handled as a threads! */

#endif

    iIrqToDsrBuffer  = ptDevInstance->iIrqToDsrBuffer;
 8008c9a:	f8d0 8064 	ldr.w	r8, [r0, #100]	; 0x64
    ptIrqToDsrBuffer = &ptDevInstance->atIrqToDsrBuffer[iIrqToDsrBuffer];

    if(!ptIrqToDsrBuffer->fValid)
 8008c9e:	eb08 1308 	add.w	r3, r8, r8, lsl #4
 8008ca2:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8008ca6:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8008caa:	2b00      	cmp	r3, #0
 8008cac:	f000 8197 	beq.w	8008fde <cifXTKitDSRHandler+0x35a>

      return;
    } else
    {
      /* Flip data buffer so IRQ uses the other buffer */
      ptDevInstance->iIrqToDsrBuffer ^= 0x01;
 8008cb0:	f088 0301 	eor.w	r3, r8, #1
 8008cb4:	6643      	str	r3, [r0, #100]	; 0x64

      /* Invalidate the buffer, we are now handling */
      ptIrqToDsrBuffer->fValid        = 0;
 8008cb6:	eb08 1308 	add.w	r3, r8, r8, lsl #4
 8008cba:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8008cbe:	2200      	movs	r2, #0
 8008cc0:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
    OS_IrqUnlock(ptDevInstance->pvOSDependent);
#endif

    /* Only process rest of flags if NSF_READY is set. This must be done to prevent
       confusion of the toolkit during a system start (xSysdeviceReset) */
    if(ptIrqToDsrBuffer->tHandshakeBuffer.atHsk[0].t8Bit.bNetxFlags & NSF_READY)
 8008cc4:	f893 306a 	ldrb.w	r3, [r3, #106]	; 0x6a
 8008cc8:	f013 0f01 	tst.w	r3, #1
 8008ccc:	f000 8187 	beq.w	8008fde <cifXTKitDSRHandler+0x35a>
    {
      /*--------------------------------------------------------------------*/
      /* Evaluate device synchronisation flags, the flags are fixed 16 Bit  */
      /*--------------------------------------------------------------------*/
      uint16_t  usChangedSyncBits;
      uint16_t  usOldNSyncFlags = ptDevInstance->tSyncData.usNSyncFlags; /* Remember last known netX flags */
 8008cd0:	f8b0 2274 	ldrh.w	r2, [r0, #628]	; 0x274

      /* Get pointer to the new flag data from ISR */
      HIL_DPM_HANDSHAKE_CELL_T*  ptSyncCell  = &ptIrqToDsrBuffer->tHandshakeBuffer.atHsk[NETX_HSK_SYNCH_FLAG_POS];

      /* Get the actual flags */
      ptDevInstance->tSyncData.usNSyncFlags = LE16_TO_HOST(ptSyncCell->t16Bit.usNetxFlags);
 8008cd4:	eb08 1308 	add.w	r3, r8, r8, lsl #4
 8008cd8:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8008cdc:	f8b3 906c 	ldrh.w	r9, [r3, #108]	; 0x6c
 8008ce0:	fa1f f989 	uxth.w	r9, r9
 8008ce4:	f8a0 9274 	strh.w	r9, [r0, #628]	; 0x274

      /* Check if there are changed bits since last interrupt from netX side,  */
      /* and only process sync if bits have chanded! */
      if ( 0 != (usChangedSyncBits = usOldNSyncFlags ^ ptDevInstance->tSyncData.usNSyncFlags))
 8008ce8:	ea89 0a02 	eor.w	sl, r9, r2
 8008cec:	4591      	cmp	r9, r2
 8008cee:	d039      	beq.n	8008d64 <cifXTKitDSRHandler+0xe0>
      {
        uint32_t  ulBitPos;
        uint16_t  usUnequalSyncBits;

        /* Create unequal bit mask */
        usUnequalSyncBits = ptDevInstance->tSyncData.usNSyncFlags ^ ptDevInstance->tSyncData.usHSyncFlags;
 8008cf0:	f8b0 3272 	ldrh.w	r3, [r0, #626]	; 0x272
 8008cf4:	ea89 0903 	eor.w	r9, r9, r3

        /* Signal sync events */
        for(ulBitPos = 0; ulBitPos < NETX_NUM_OF_SYNCH_FLAGS; ++ulBitPos)
 8008cf8:	2500      	movs	r5, #0
 8008cfa:	e016      	b.n	8008d2a <cifXTKitDSRHandler+0xa6>
            uint8_t bState   = HIL_FLAGS_NOT_EQUAL;
            int     fProcess = 0;

            /* Handle Sync interrupts, read actual state and set bState accordingly */
            if( HIL_SYNC_MODE_HST_CTRL == HWIF_READ8(ptDevInstance, ptSyncChannel->ptCommonStatusBlock->bSyncHskMode))
              bState = HIL_FLAGS_EQUAL;
 8008cfc:	2300      	movs	r3, #0
            if( (bState == HIL_FLAGS_NOT_EQUAL) &&
                (usUnequalSyncBits & usBitMask) )
            {
              fProcess = 1;

            } else if( (bState == HIL_FLAGS_EQUAL) &&
 8008cfe:	b99b      	cbnz	r3, 8008d28 <cifXTKitDSRHandler+0xa4>
 8008d00:	ea19 0f07 	tst.w	r9, r7
 8008d04:	d110      	bne.n	8008d28 <cifXTKitDSRHandler+0xa4>

            if(fProcess)
            {
              /* There is a valid channel */
              /* Check if we have a callback assigned */
              if (ptSyncChannel->tSynch.pfnCallback)
 8008d06:	f8db 7154 	ldr.w	r7, [fp, #340]	; 0x154
 8008d0a:	b12f      	cbz	r7, 8008d18 <cifXTKitDSRHandler+0x94>
                ptSyncChannel->tSynch.pfnCallback( CIFX_NOTIFY_SYNC, 0, NULL, ptSyncChannel->tSynch.pvUser);
 8008d0c:	f8db 3158 	ldr.w	r3, [fp, #344]	; 0x158
 8008d10:	2200      	movs	r2, #0
 8008d12:	4611      	mov	r1, r2
 8008d14:	2007      	movs	r0, #7
 8008d16:	47b8      	blx	r7

              /* Signal event to allow waiting for sync state without callback */
              if( ptDevInstance->tSyncData.ahSyncBitEvents[ulBitPos])
 8008d18:	f105 039c 	add.w	r3, r5, #156	; 0x9c
 8008d1c:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8008d20:	6898      	ldr	r0, [r3, #8]
 8008d22:	b108      	cbz	r0, 8008d28 <cifXTKitDSRHandler+0xa4>
                OS_SetEvent(ptDevInstance->tSyncData.ahSyncBitEvents[ulBitPos]);
 8008d24:	f7f9 ff96 	bl	8002c54 <OS_SetEvent>
        for(ulBitPos = 0; ulBitPos < NETX_NUM_OF_SYNCH_FLAGS; ++ulBitPos)
 8008d28:	3501      	adds	r5, #1
 8008d2a:	2d03      	cmp	r5, #3
 8008d2c:	d81a      	bhi.n	8008d64 <cifXTKitDSRHandler+0xe0>
          uint16_t          usBitMask     = (uint16_t)(1 << ulBitPos);
 8008d2e:	2701      	movs	r7, #1
 8008d30:	40af      	lsls	r7, r5
 8008d32:	b2bf      	uxth	r7, r7
          if (ulBitPos >= ptDevInstance->ulCommChannelCount)
 8008d34:	f8d6 3260 	ldr.w	r3, [r6, #608]	; 0x260
 8008d38:	42ab      	cmp	r3, r5
 8008d3a:	d913      	bls.n	8008d64 <cifXTKitDSRHandler+0xe0>
          ptSyncChannel = (PCHANNELINSTANCE)ptDevInstance->pptCommChannels[ulBitPos];
 8008d3c:	f8d6 3264 	ldr.w	r3, [r6, #612]	; 0x264
 8008d40:	f853 b025 	ldr.w	fp, [r3, r5, lsl #2]
          if ( usChangedSyncBits & usBitMask)
 8008d44:	ea1a 0f07 	tst.w	sl, r7
 8008d48:	d0ee      	beq.n	8008d28 <cifXTKitDSRHandler+0xa4>
            if( HIL_SYNC_MODE_HST_CTRL == HWIF_READ8(ptDevInstance, ptSyncChannel->ptCommonStatusBlock->bSyncHskMode))
 8008d4a:	f8db 10dc 	ldr.w	r1, [fp, #220]	; 0xdc
 8008d4e:	3120      	adds	r1, #32
 8008d50:	4630      	mov	r0, r6
 8008d52:	f7fc fa91 	bl	8005278 <HwIfRead8>
 8008d56:	2802      	cmp	r0, #2
 8008d58:	d0d0      	beq.n	8008cfc <cifXTKitDSRHandler+0x78>
            if( (bState == HIL_FLAGS_NOT_EQUAL) &&
 8008d5a:	ea19 0f07 	tst.w	r9, r7
 8008d5e:	d1d2      	bne.n	8008d06 <cifXTKitDSRHandler+0x82>
            uint8_t bState   = HIL_FLAGS_NOT_EQUAL;
 8008d60:	2301      	movs	r3, #1
 8008d62:	e7cc      	b.n	8008cfe <cifXTKitDSRHandler+0x7a>
        for(ulBitPos = 0; ulBitPos < NETX_NUM_OF_SYNCH_FLAGS; ++ulBitPos)
 8008d64:	f04f 0b00 	mov.w	fp, #0
 8008d68:	e0dc      	b.n	8008f24 <cifXTKitDSRHandler+0x2a0>
        /* Address the handshake cell */
        HIL_DPM_HANDSHAKE_CELL_T* ptHskCell = &ptIrqToDsrBuffer->tHandshakeBuffer.atHsk[ptChannel->ulBlockID];

        if(ptChannel->bHandshakeWidth == HIL_HANDSHAKE_SIZE_8BIT)
        {
          ptChannel->usNetxFlags = ptHskCell->t8Bit.bNetxFlags;
 8008d6a:	eb08 1308 	add.w	r3, r8, r8, lsl #4
 8008d6e:	4413      	add	r3, r2
 8008d70:	331a      	adds	r3, #26
 8008d72:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8008d76:	789b      	ldrb	r3, [r3, #2]
 8008d78:	f8a4 30be 	strh.w	r3, [r4, #190]	; 0xbe
 8008d7c:	e0e2      	b.n	8008f44 <cifXTKitDSRHandler+0x2c0>
          /*------------------------------------------*/

          /* -----------------------------------------*/
          /* Check COM Flag and I/O areas             */
          /* -----------------------------------------*/
          if(usChangedBits & NCF_COMMUNICATING)
 8008d7e:	f015 0f01 	tst.w	r5, #1
 8008d82:	d102      	bne.n	8008d8a <cifXTKitDSRHandler+0x106>
        for(ulBitPos = 0; ulBitPos < NETX_NUM_OF_SYNCH_FLAGS; ++ulBitPos)
 8008d84:	f04f 0a00 	mov.w	sl, #0
 8008d88:	e021      	b.n	8008dce <cifXTKitDSRHandler+0x14a>
          {
            OS_SetEvent(ptChannel->ahHandshakeBitEvents[NCF_COMMUNICATING_BIT_NO]);
 8008d8a:	f8d4 00fc 	ldr.w	r0, [r4, #252]	; 0xfc
 8008d8e:	f7f9 ff61 	bl	8002c54 <OS_SetEvent>

            /* check if notification is registered */
            if (NULL != ptChannel->tComState.pfnCallback)
 8008d92:	f8d4 a0b4 	ldr.w	sl, [r4, #180]	; 0xb4
 8008d96:	f1ba 0f00 	cmp.w	sl, #0
 8008d9a:	d0f3      	beq.n	8008d84 <cifXTKitDSRHandler+0x100>
            {
              CIFX_NOTIFY_COM_STATE_T tData;

              tData.ulComState = (ptChannel->usNetxFlags & NCF_COMMUNICATING);
 8008d9c:	f8b4 30be 	ldrh.w	r3, [r4, #190]	; 0xbe
 8008da0:	f003 0301 	and.w	r3, r3, #1
 8008da4:	9303      	str	r3, [sp, #12]

              ptChannel->tComState.pfnCallback( CIFX_NOTIFY_COM_STATE,
 8008da6:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
 8008daa:	aa03      	add	r2, sp, #12
 8008dac:	2104      	movs	r1, #4
 8008dae:	2008      	movs	r0, #8
 8008db0:	47d0      	blx	sl
 8008db2:	e7e7      	b.n	8008d84 <cifXTKitDSRHandler+0x100>

          /* Check IO - Input Areas */
          for(ulIdx = 0; ulIdx < ptChannel->ulIOInputAreas; ++ulIdx)
          {
            ProcessIOArea(ptChannel,
                          ptChannel->pptIOInputAreas[ulIdx],
 8008db4:	f8d4 313c 	ldr.w	r3, [r4, #316]	; 0x13c
            ProcessIOArea(ptChannel,
 8008db8:	f853 102a 	ldr.w	r1, [r3, sl, lsl #2]
 8008dbc:	2300      	movs	r3, #0
 8008dbe:	9300      	str	r3, [sp, #0]
 8008dc0:	464b      	mov	r3, r9
 8008dc2:	462a      	mov	r2, r5
 8008dc4:	4620      	mov	r0, r4
 8008dc6:	f7ff fe61 	bl	8008a8c <ProcessIOArea>
          for(ulIdx = 0; ulIdx < ptChannel->ulIOInputAreas; ++ulIdx)
 8008dca:	f10a 0a01 	add.w	sl, sl, #1
 8008dce:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 8008dd2:	4553      	cmp	r3, sl
 8008dd4:	d8ee      	bhi.n	8008db4 <cifXTKitDSRHandler+0x130>
                          usUnequalBits,
                          0);
          }

          /* Check IO - Output Areas */
          for(ulIdx = 0; ulIdx < ptChannel->ulIOOutputAreas; ++ulIdx)
 8008dd6:	f04f 0a00 	mov.w	sl, #0
 8008dda:	e00c      	b.n	8008df6 <cifXTKitDSRHandler+0x172>
          {
            ProcessIOArea(ptChannel,
                          ptChannel->pptIOOutputAreas[ulIdx],
 8008ddc:	f8d4 3144 	ldr.w	r3, [r4, #324]	; 0x144
            ProcessIOArea(ptChannel,
 8008de0:	f853 102a 	ldr.w	r1, [r3, sl, lsl #2]
 8008de4:	2301      	movs	r3, #1
 8008de6:	9300      	str	r3, [sp, #0]
 8008de8:	464b      	mov	r3, r9
 8008dea:	462a      	mov	r2, r5
 8008dec:	4620      	mov	r0, r4
 8008dee:	f7ff fe4d 	bl	8008a8c <ProcessIOArea>
          for(ulIdx = 0; ulIdx < ptChannel->ulIOOutputAreas; ++ulIdx)
 8008df2:	f10a 0a01 	add.w	sl, sl, #1
 8008df6:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
 8008dfa:	4553      	cmp	r3, sl
 8008dfc:	d8ee      	bhi.n	8008ddc <cifXTKitDSRHandler+0x158>
          /* -----------------------------------------*/
          /* Check COS Flags                          */
          /* -----------------------------------------*/
          /* Check netX for new COS flags             */
          /* -----------------------------------------*/
          if( usUnequalBits & NCF_NETX_COS_CMD)
 8008dfe:	f019 0f08 	tst.w	r9, #8
 8008e02:	d114      	bne.n	8008e2e <cifXTKitDSRHandler+0x1aa>
            /* Unlock flag access */
            OS_LeaveLock(ptChannel->pvLock);
          }

          /* Signal netX COS command flag change */
          if( usChangedBits & NCF_NETX_COS_CMD)
 8008e04:	f015 0f08 	tst.w	r5, #8
 8008e08:	d12a      	bne.n	8008e60 <cifXTKitDSRHandler+0x1dc>

          /* --------------------------------------------------*/
          /* Process our own COS flags (Write them to device)  */
          /* --------------------------------------------------*/
          /* Check if we have new COS flags to write */
          if ( ptChannel->ulHostCOSFlagsSaved != ptChannel->ulHostCOSFlags)
 8008e0a:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
 8008e0e:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8008e12:	429a      	cmp	r2, r3
 8008e14:	d002      	beq.n	8008e1c <cifXTKitDSRHandler+0x198>
          {
            /* Check if it is allowed to write new flags */
            if( !(usUnequalBits & NCF_HOST_COS_ACK))
 8008e16:	f019 0f04 	tst.w	r9, #4
 8008e1a:	d026      	beq.n	8008e6a <cifXTKitDSRHandler+0x1e6>
              OS_LeaveLock(ptChannel->pvLock);
            }
          }

          /* Signal host COS acknowledge flag change */
          if( usChangedBits & NCF_HOST_COS_ACK)
 8008e1c:	f015 0f04 	tst.w	r5, #4
 8008e20:	f000 80a5 	beq.w	8008f6e <cifXTKitDSRHandler+0x2ea>
            OS_SetEvent(ptChannel->ahHandshakeBitEvents[NCF_HOST_COS_ACK_BIT_NO]);
 8008e24:	f8d4 0104 	ldr.w	r0, [r4, #260]	; 0x104
 8008e28:	f7f9 ff14 	bl	8002c54 <OS_SetEvent>
 8008e2c:	e09f      	b.n	8008f6e <cifXTKitDSRHandler+0x2ea>
            OS_EnterLock(ptChannel->pvLock);
 8008e2e:	69a0      	ldr	r0, [r4, #24]
 8008e30:	f7f9 feb6 	bl	8002ba0 <OS_EnterLock>
            ulNewCOSFlags = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptChannel->ptCommonStatusBlock->ulCommunicationCOS));
 8008e34:	f8d4 10dc 	ldr.w	r1, [r4, #220]	; 0xdc
 8008e38:	4630      	mov	r0, r6
 8008e3a:	f7fc fa5e 	bl	80052fa <HwIfRead32>
            if(ptChannel->ulDeviceCOSFlags != ulNewCOSFlags)
 8008e3e:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 8008e42:	4283      	cmp	r3, r0
 8008e44:	d004      	beq.n	8008e50 <cifXTKitDSRHandler+0x1cc>
              ptChannel->ulDeviceCOSFlagsChanged  = ptChannel->ulDeviceCOSFlags ^ ulNewCOSFlags;
 8008e46:	4043      	eors	r3, r0
 8008e48:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
              ptChannel->ulDeviceCOSFlags         = ulNewCOSFlags;
 8008e4c:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
            DEV_ToggleBit(ptChannel, HCF_NETX_COS_ACK);
 8008e50:	2108      	movs	r1, #8
 8008e52:	4620      	mov	r0, r4
 8008e54:	f7fc f9e5 	bl	8005222 <DEV_ToggleBit>
            OS_LeaveLock(ptChannel->pvLock);
 8008e58:	69a0      	ldr	r0, [r4, #24]
 8008e5a:	f7f9 fead 	bl	8002bb8 <OS_LeaveLock>
 8008e5e:	e7d1      	b.n	8008e04 <cifXTKitDSRHandler+0x180>
            OS_SetEvent(ptChannel->ahHandshakeBitEvents[NCF_NETX_COS_CMD_BIT_NO]);
 8008e60:	f8d4 0108 	ldr.w	r0, [r4, #264]	; 0x108
 8008e64:	f7f9 fef6 	bl	8002c54 <OS_SetEvent>
 8008e68:	e7cf      	b.n	8008e0a <cifXTKitDSRHandler+0x186>
              OS_EnterLock(ptChannel->pvLock);
 8008e6a:	69a0      	ldr	r0, [r4, #24]
 8008e6c:	f7f9 fe98 	bl	8002ba0 <OS_EnterLock>
              HWIF_WRITE32(ptDevInstance, ptChannel->ptControlBlock->ulApplicationCOS, HOST_TO_LE32(ptChannel->ulHostCOSFlags));
 8008e70:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8008e74:	9303      	str	r3, [sp, #12]
 8008e76:	f8d4 20d0 	ldr.w	r2, [r4, #208]	; 0xd0
 8008e7a:	f04f 0a04 	mov.w	sl, #4
 8008e7e:	f8cd a000 	str.w	sl, [sp]
 8008e82:	ab03      	add	r3, sp, #12
 8008e84:	4631      	mov	r1, r6
 8008e86:	2001      	movs	r0, #1
 8008e88:	f8d6 72c8 	ldr.w	r7, [r6, #712]	; 0x2c8
 8008e8c:	47b8      	blx	r7
              ptChannel->ulHostCOSFlagsSaved = ptChannel->ulHostCOSFlags;
 8008e8e:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8008e92:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
              DEV_ToggleBit(ptChannel, HCF_HOST_COS_CMD);
 8008e96:	4651      	mov	r1, sl
 8008e98:	4620      	mov	r0, r4
 8008e9a:	f7fc f9c2 	bl	8005222 <DEV_ToggleBit>
              ptChannel->ulHostCOSFlags &= ~(HIL_APP_COS_BUS_ON_ENABLE | HIL_APP_COS_INITIALIZATION_ENABLE | HIL_APP_COS_LOCK_CONFIGURATION_ENABLE);
 8008e9e:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8008ea2:	f023 0354 	bic.w	r3, r3, #84	; 0x54
 8008ea6:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
              OS_LeaveLock(ptChannel->pvLock);
 8008eaa:	69a0      	ldr	r0, [r4, #24]
 8008eac:	f7f9 fe84 	bl	8002bb8 <OS_LeaveLock>
 8008eb0:	e7b4      	b.n	8008e1c <cifXTKitDSRHandler+0x198>
          /* Check if the hardware signals new system COS flags */
          /*----------------------------------------------------*/
          if( usUnequalBits & NSF_NETX_COS_CMD)
          {
            /* Read the flags and acknowledge them */
            HIL_DPM_SYSTEM_CHANNEL_T* ptSyschannel   = (HIL_DPM_SYSTEM_CHANNEL_T*)ptChannel->pbDPMChannelStart;
 8008eb2:	f8d4 a008 	ldr.w	sl, [r4, #8]
            uint32_t                  ulNewCOSFlags  = 0;

            /* Lock flag access */
            OS_EnterLock(ptChannel->pvLock);
 8008eb6:	69a0      	ldr	r0, [r4, #24]
 8008eb8:	f7f9 fe72 	bl	8002ba0 <OS_EnterLock>

            /* Read the actual "System COS" flags */
            ulNewCOSFlags  = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptSyschannel->tSystemState.ulSystemCOS));
 8008ebc:	f10a 01c0 	add.w	r1, sl, #192	; 0xc0
 8008ec0:	4630      	mov	r0, r6
 8008ec2:	f7fc fa1a 	bl	80052fa <HwIfRead32>

            /* Read the flags and acknowledge them */
            if(ptChannel->ulDeviceCOSFlags != ulNewCOSFlags)
 8008ec6:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 8008eca:	4283      	cmp	r3, r0
 8008ecc:	d004      	beq.n	8008ed8 <cifXTKitDSRHandler+0x254>
            {
              ptChannel->ulDeviceCOSFlagsChanged  = ptChannel->ulDeviceCOSFlags ^ ulNewCOSFlags;
 8008ece:	4043      	eors	r3, r0
 8008ed0:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
              ptChannel->ulDeviceCOSFlags         = ulNewCOSFlags;
 8008ed4:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
            }

            DEV_ToggleBit(ptChannel, HSF_NETX_COS_ACK);
 8008ed8:	2108      	movs	r1, #8
 8008eda:	4620      	mov	r0, r4
 8008edc:	f7fc f9a1 	bl	8005222 <DEV_ToggleBit>

            /* Unlock flag access */
            OS_LeaveLock(ptChannel->pvLock);
 8008ee0:	69a0      	ldr	r0, [r4, #24]
 8008ee2:	f7f9 fe69 	bl	8002bb8 <OS_LeaveLock>
 8008ee6:	e03c      	b.n	8008f62 <cifXTKitDSRHandler+0x2de>
          }

            /* Signal COS CMD bits */
          if(usChangedBits & NSF_NETX_COS_CMD)
            OS_SetEvent(ptChannel->ahHandshakeBitEvents[NSF_NETX_COS_CMD_BIT_NO]);
 8008ee8:	f8d4 0108 	ldr.w	r0, [r4, #264]	; 0x108
 8008eec:	f7f9 feb2 	bl	8002c54 <OS_SetEvent>
 8008ef0:	e03a      	b.n	8008f68 <cifXTKitDSRHandler+0x2e4>

          /* Signal COS ACK bits */
          if(usChangedBits & NSF_HOST_COS_ACK)
            OS_SetEvent(ptChannel->ahHandshakeBitEvents[NSF_HOST_COS_ACK_BIT_NO]);
 8008ef2:	f8d4 0104 	ldr.w	r0, [r4, #260]	; 0x104
 8008ef6:	f7f9 fead 	bl	8002c54 <OS_SetEvent>
 8008efa:	e038      	b.n	8008f6e <cifXTKitDSRHandler+0x2ea>
            ptChannel->tSendMbx.pfnCallback(CIFX_NOTIFY_TX_MBX_EMPTY,
                                            sizeof(tTxData),
                                            &tTxData,
                                            ptChannel->tSendMbx.pvUser);
          }
          OS_SetEvent(ptChannel->ahHandshakeBitEvents[ptChannel->tSendMbx.bSendCMDBitoffset]);
 8008efc:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 8008f00:	333e      	adds	r3, #62	; 0x3e
 8008f02:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8008f06:	6858      	ldr	r0, [r3, #4]
 8008f08:	f7f9 fea4 	bl	8002c54 <OS_SetEvent>
        }

        /* Next channel */
        if(ulChannel < ptDevInstance->ulCommChannelCount)
 8008f0c:	f8d6 3260 	ldr.w	r3, [r6, #608]	; 0x260
 8008f10:	455b      	cmp	r3, fp
 8008f12:	d903      	bls.n	8008f1c <cifXTKitDSRHandler+0x298>
          ptChannel = ptDevInstance->pptCommChannels[ulChannel];
 8008f14:	f8d6 2264 	ldr.w	r2, [r6, #612]	; 0x264
 8008f18:	f852 402b 	ldr.w	r4, [r2, fp, lsl #2]

        ulChannel++;
 8008f1c:	f10b 0b01 	add.w	fp, fp, #1

      } while(ulChannel <= ptDevInstance->ulCommChannelCount);
 8008f20:	455b      	cmp	r3, fp
 8008f22:	d35c      	bcc.n	8008fde <cifXTKitDSRHandler+0x35a>
        uint16_t usOldNetxFlags = ptChannel->usNetxFlags; /* Remember last known netX flags */
 8008f24:	f8b4 50be 	ldrh.w	r5, [r4, #190]	; 0xbe
        HIL_DPM_HANDSHAKE_CELL_T* ptHskCell = &ptIrqToDsrBuffer->tHandshakeBuffer.atHsk[ptChannel->ulBlockID];
 8008f28:	6962      	ldr	r2, [r4, #20]
        if(ptChannel->bHandshakeWidth == HIL_HANDSHAKE_SIZE_8BIT)
 8008f2a:	f894 30f8 	ldrb.w	r3, [r4, #248]	; 0xf8
 8008f2e:	2b01      	cmp	r3, #1
 8008f30:	f43f af1b 	beq.w	8008d6a <cifXTKitDSRHandler+0xe6>
          ptChannel->usNetxFlags = LE16_TO_HOST(ptHskCell->t16Bit.usNetxFlags);
 8008f34:	eb08 1308 	add.w	r3, r8, r8, lsl #4
 8008f38:	4413      	add	r3, r2
 8008f3a:	331a      	adds	r3, #26
 8008f3c:	f836 3023 	ldrh.w	r3, [r6, r3, lsl #2]
 8008f40:	f8a4 30be 	strh.w	r3, [r4, #190]	; 0xbe
        usChangedBits = usOldNetxFlags ^ ptChannel->usNetxFlags;
 8008f44:	f8b4 90be 	ldrh.w	r9, [r4, #190]	; 0xbe
 8008f48:	ea89 0505 	eor.w	r5, r9, r5
        usUnequalBits = ptChannel->usNetxFlags ^ ptChannel->usHostFlags;
 8008f4c:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
 8008f50:	ea89 0903 	eor.w	r9, r9, r3
        if(ptChannel->fIsChannel)
 8008f54:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008f56:	2b00      	cmp	r3, #0
 8008f58:	f47f af11 	bne.w	8008d7e <cifXTKitDSRHandler+0xfa>
          if( usUnequalBits & NSF_NETX_COS_CMD)
 8008f5c:	f019 0f08 	tst.w	r9, #8
 8008f60:	d1a7      	bne.n	8008eb2 <cifXTKitDSRHandler+0x22e>
          if(usChangedBits & NSF_NETX_COS_CMD)
 8008f62:	f015 0f08 	tst.w	r5, #8
 8008f66:	d1bf      	bne.n	8008ee8 <cifXTKitDSRHandler+0x264>
          if(usChangedBits & NSF_HOST_COS_ACK)
 8008f68:	f015 0f04 	tst.w	r5, #4
 8008f6c:	d1c1      	bne.n	8008ef2 <cifXTKitDSRHandler+0x26e>
        if( usChangedBits & ptChannel->tRecvMbx.ulRecvACKBitmask)
 8008f6e:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 8008f72:	421d      	tst	r5, r3
 8008f74:	d01b      	beq.n	8008fae <cifXTKitDSRHandler+0x32a>
          if( (usUnequalBits & ptChannel->tRecvMbx.ulRecvACKBitmask) &&
 8008f76:	ea19 0f03 	tst.w	r9, r3
 8008f7a:	d010      	beq.n	8008f9e <cifXTKitDSRHandler+0x31a>
              (NULL != ptChannel->tRecvMbx.pfnCallback) )
 8008f7c:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
          if( (usUnequalBits & ptChannel->tRecvMbx.ulRecvACKBitmask) &&
 8008f80:	b16b      	cbz	r3, 8008f9e <cifXTKitDSRHandler+0x31a>
            tRxData.ulRecvCount = LE16_TO_HOST(HWIF_READ16(ptDevInstance, ptChannel->tRecvMbx.ptRecvMailboxStart->usWaitingPackages));
 8008f82:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
 8008f86:	4630      	mov	r0, r6
 8008f88:	f7fc f9a4 	bl	80052d4 <HwIfRead16>
 8008f8c:	9003      	str	r0, [sp, #12]
            ptChannel->tRecvMbx.pfnCallback(CIFX_NOTIFY_RX_MBX_FULL,
 8008f8e:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 8008f92:	aa03      	add	r2, sp, #12
 8008f94:	2104      	movs	r1, #4
 8008f96:	2001      	movs	r0, #1
 8008f98:	f8d4 70ac 	ldr.w	r7, [r4, #172]	; 0xac
 8008f9c:	47b8      	blx	r7
          OS_SetEvent(ptChannel->ahHandshakeBitEvents[ptChannel->tRecvMbx.bRecvACKBitoffset]);
 8008f9e:	f894 30a0 	ldrb.w	r3, [r4, #160]	; 0xa0
 8008fa2:	333e      	adds	r3, #62	; 0x3e
 8008fa4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8008fa8:	6858      	ldr	r0, [r3, #4]
 8008faa:	f7f9 fe53 	bl	8002c54 <OS_SetEvent>
        if( usChangedBits & ptChannel->tSendMbx.ulSendCMDBitmask)
 8008fae:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8008fb0:	421d      	tst	r5, r3
 8008fb2:	d0ab      	beq.n	8008f0c <cifXTKitDSRHandler+0x288>
          if( (0    == (usUnequalBits & ptChannel->tSendMbx.ulSendCMDBitmask)) &&
 8008fb4:	ea19 0f03 	tst.w	r9, r3
 8008fb8:	d1a0      	bne.n	8008efc <cifXTKitDSRHandler+0x278>
              (NULL != ptChannel->tSendMbx.pfnCallback) )
 8008fba:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
          if( (0    == (usUnequalBits & ptChannel->tSendMbx.ulSendCMDBitmask)) &&
 8008fbe:	2b00      	cmp	r3, #0
 8008fc0:	d09c      	beq.n	8008efc <cifXTKitDSRHandler+0x278>
            tTxData.ulMaxSendCount = LE16_TO_HOST(HWIF_READ16(ptDevInstance, ptChannel->tSendMbx.ptSendMailboxStart->usPackagesAccepted));
 8008fc2:	6f61      	ldr	r1, [r4, #116]	; 0x74
 8008fc4:	4630      	mov	r0, r6
 8008fc6:	f7fc f985 	bl	80052d4 <HwIfRead16>
 8008fca:	9003      	str	r0, [sp, #12]
            ptChannel->tSendMbx.pfnCallback(CIFX_NOTIFY_TX_MBX_EMPTY,
 8008fcc:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
 8008fd0:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8008fd4:	aa03      	add	r2, sp, #12
 8008fd6:	2104      	movs	r1, #4
 8008fd8:	2002      	movs	r0, #2
 8008fda:	47a8      	blx	r5
 8008fdc:	e78e      	b.n	8008efc <cifXTKitDSRHandler+0x278>
    }
  }
}
 8008fde:	b005      	add	sp, #20
 8008fe0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008fe4:	4770      	bx	lr

08008fe6 <hboot_waitforbitstate>:
static int hboot_waitforbitstate(PDEVICEINSTANCE ptDevInstance,
                                 HBOOT_DATA_T*   ptHbootData,
                                 uint32_t        ulBitMask,
                                 uint8_t         bState,
                                 uint32_t        ulTimeout)
{
 8008fe6:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008fea:	4604      	mov	r4, r0
 8008fec:	4617      	mov	r7, r2
 8008fee:	461e      	mov	r6, r3
 8008ff0:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
  int                   iRet         = 0;
  int32_t               lStartTime   = 0;
  HBOOT_HSREGISTER_T*   ptHsk        = ptHbootData->ptHsk;
 8008ff4:	680d      	ldr	r5, [r1, #0]
  uint8_t               bActualState = 0;
  uint8_t               bHostFlags   = 0;

  UNREFERENCED_PARAMETER(ptDevInstance);

  bHostFlags = HWIF_READ8(ptDevInstance, ptHsk->t8Bit.bHostFlags);
 8008ff6:	f105 0803 	add.w	r8, r5, #3
 8008ffa:	4641      	mov	r1, r8
 8008ffc:	f7fc f93c 	bl	8005278 <HwIfRead8>
 8009000:	4682      	mov	sl, r0
  if((bHostFlags ^ HWIF_READ8(ptDevInstance, ptHsk->t8Bit.bNetXFlags)) & ulBitMask)
 8009002:	3502      	adds	r5, #2
 8009004:	4629      	mov	r1, r5
 8009006:	4620      	mov	r0, r4
 8009008:	f7fc f936 	bl	8005278 <HwIfRead8>
 800900c:	ea80 000a 	eor.w	r0, r0, sl
 8009010:	b2c0      	uxtb	r0, r0
 8009012:	4238      	tst	r0, r7
 8009014:	d009      	beq.n	800902a <hboot_waitforbitstate+0x44>
    bActualState = HIL_FLAGS_NOT_EQUAL;
 8009016:	f04f 0b01 	mov.w	fp, #1
  else
    bActualState = HIL_FLAGS_EQUAL;

  /* The desired state is already there, so just return true */
  if(bActualState == bState)
 800901a:	45b3      	cmp	fp, r6
 800901c:	d030      	beq.n	8009080 <hboot_waitforbitstate+0x9a>
    return 1;

  /* If no timeout is given, don't try to wait for the Bit change */
  if(0 == ulTimeout)
 800901e:	f1b9 0f00 	cmp.w	r9, #0
 8009022:	d105      	bne.n	8009030 <hboot_waitforbitstate+0x4a>
    return 0;
 8009024:	2000      	movs	r0, #0

  if(bActualState == bState)
    iRet = 1;

  return iRet;
}
 8009026:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bActualState = HIL_FLAGS_EQUAL;
 800902a:	f04f 0b00 	mov.w	fp, #0
 800902e:	e7f4      	b.n	800901a <hboot_waitforbitstate+0x34>
  lStartTime = (int32_t)OS_GetMilliSecCounter();
 8009030:	f7f9 fd8f 	bl	8002b52 <OS_GetMilliSecCounter>
 8009034:	4682      	mov	sl, r0
  while(bActualState != bState)
 8009036:	e00a      	b.n	800904e <hboot_waitforbitstate+0x68>
      bActualState = HIL_FLAGS_EQUAL;
 8009038:	f04f 0b00 	mov.w	fp, #0
    ulDiffTime = OS_GetMilliSecCounter() - lStartTime;
 800903c:	f7f9 fd89 	bl	8002b52 <OS_GetMilliSecCounter>
 8009040:	eba0 000a 	sub.w	r0, r0, sl
    if ( ulDiffTime > ulTimeout)
 8009044:	4581      	cmp	r9, r0
 8009046:	d317      	bcc.n	8009078 <hboot_waitforbitstate+0x92>
    OS_Sleep(0);
 8009048:	2000      	movs	r0, #0
 800904a:	f7f9 fd87 	bl	8002b5c <OS_Sleep>
  while(bActualState != bState)
 800904e:	45b3      	cmp	fp, r6
 8009050:	d012      	beq.n	8009078 <hboot_waitforbitstate+0x92>
    bHostFlags = HWIF_READ8(ptDevInstance, ptHsk->t8Bit.bHostFlags);
 8009052:	4641      	mov	r1, r8
 8009054:	4620      	mov	r0, r4
 8009056:	f7fc f90f 	bl	8005278 <HwIfRead8>
 800905a:	4683      	mov	fp, r0
    if((bHostFlags ^ HWIF_READ8(ptDevInstance, ptHsk->t8Bit.bNetXFlags)) & ulBitMask)
 800905c:	4629      	mov	r1, r5
 800905e:	4620      	mov	r0, r4
 8009060:	f7fc f90a 	bl	8005278 <HwIfRead8>
 8009064:	ea80 000b 	eor.w	r0, r0, fp
 8009068:	fa5f fc80 	uxtb.w	ip, r0
 800906c:	ea1c 0f07 	tst.w	ip, r7
 8009070:	d0e2      	beq.n	8009038 <hboot_waitforbitstate+0x52>
      bActualState = HIL_FLAGS_NOT_EQUAL;
 8009072:	f04f 0b01 	mov.w	fp, #1
 8009076:	e7e1      	b.n	800903c <hboot_waitforbitstate+0x56>
  if(bActualState == bState)
 8009078:	45b3      	cmp	fp, r6
 800907a:	d003      	beq.n	8009084 <hboot_waitforbitstate+0x9e>
  int                   iRet         = 0;
 800907c:	2000      	movs	r0, #0
 800907e:	e7d2      	b.n	8009026 <hboot_waitforbitstate+0x40>
    return 1;
 8009080:	2001      	movs	r0, #1
 8009082:	e7d0      	b.n	8009026 <hboot_waitforbitstate+0x40>
    iRet = 1;
 8009084:	2001      	movs	r0, #1
 8009086:	e7ce      	b.n	8009026 <hboot_waitforbitstate+0x40>

08009088 <hboot_send_packet>:
static int32_t hboot_send_packet(PDEVICEINSTANCE ptDevInstance,
                                 HBOOT_DATA_T*   ptHbootData,
                                 uint8_t*        pbData,
                                 uint32_t        ulDataLen,
                                 uint32_t        ulTimeout)
{
 8009088:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800908c:	b085      	sub	sp, #20
 800908e:	461d      	mov	r5, r3
  int32_t               lRet          = CIFX_NO_ERROR;
  HBOOT_HSREGISTER_T*   ptHsk         = ptHbootData->ptHsk;
 8009090:	f8d1 b000 	ldr.w	fp, [r1]
  uint8_t               bToNetXMask   = ptHbootData->tToNetXMailbox.bHskMask;
 8009094:	790e      	ldrb	r6, [r1, #4]
  uint32_t              ulMailboxSize = ptHbootData->tToNetXMailbox.ulSize;
 8009096:	688b      	ldr	r3, [r1, #8]
  void*                 pvMailbox     = ptHbootData->tToNetXMailbox.pvData;
 8009098:	f8d1 a00c 	ldr.w	sl, [r1, #12]
  volatile uint32_t*    pulMbxDataLen = ptHbootData->tToNetXMailbox.pulDataLen;
 800909c:	f8d1 9010 	ldr.w	r9, [r1, #16]

  if(ulDataLen > ulMailboxSize)
 80090a0:	42ab      	cmp	r3, r5
 80090a2:	d32f      	bcc.n	8009104 <hboot_send_packet+0x7c>
 80090a4:	4604      	mov	r4, r0
 80090a6:	4690      	mov	r8, r2
    return CIFX_INVALID_BUFFERSIZE;

  if(!hboot_waitforbitstate(ptDevInstance,
 80090a8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80090aa:	9300      	str	r3, [sp, #0]
 80090ac:	2300      	movs	r3, #0
 80090ae:	4632      	mov	r2, r6
 80090b0:	f7ff ff99 	bl	8008fe6 <hboot_waitforbitstate>
 80090b4:	b340      	cbz	r0, 8009108 <hboot_send_packet+0x80>
  } else
  {
    uint8_t bHostFlags = 0;

    /* The mailbox is free */
    HWIF_WRITEN(ptDevInstance,
 80090b6:	9500      	str	r5, [sp, #0]
 80090b8:	4643      	mov	r3, r8
 80090ba:	4652      	mov	r2, sl
 80090bc:	4621      	mov	r1, r4
 80090be:	2000      	movs	r0, #0
 80090c0:	f8d4 72c8 	ldr.w	r7, [r4, #712]	; 0x2c8
 80090c4:	47b8      	blx	r7
                pvMailbox,
                pbData,
                ulDataLen);

    HWIF_WRITE32(ptDevInstance, pulMbxDataLen[0], HOST_TO_LE32(ulDataLen));
 80090c6:	9503      	str	r5, [sp, #12]
 80090c8:	f8d4 52c8 	ldr.w	r5, [r4, #712]	; 0x2c8
 80090cc:	2304      	movs	r3, #4
 80090ce:	9300      	str	r3, [sp, #0]
 80090d0:	ab03      	add	r3, sp, #12
 80090d2:	464a      	mov	r2, r9
 80090d4:	4621      	mov	r1, r4
 80090d6:	2001      	movs	r0, #1
 80090d8:	47a8      	blx	r5

    bHostFlags = HWIF_READ8(ptDevInstance, ptHsk->t8Bit.bHostFlags);
 80090da:	f10b 0703 	add.w	r7, fp, #3
 80090de:	4639      	mov	r1, r7
 80090e0:	4620      	mov	r0, r4
 80090e2:	f7fc f8c9 	bl	8005278 <HwIfRead8>
    HWIF_WRITE8(ptDevInstance, ptHsk->t8Bit.bHostFlags, (bHostFlags ^ bToNetXMask));
 80090e6:	4046      	eors	r6, r0
 80090e8:	f88d 600c 	strb.w	r6, [sp, #12]
 80090ec:	f8d4 52c8 	ldr.w	r5, [r4, #712]	; 0x2c8
 80090f0:	2001      	movs	r0, #1
 80090f2:	9000      	str	r0, [sp, #0]
 80090f4:	ab03      	add	r3, sp, #12
 80090f6:	463a      	mov	r2, r7
 80090f8:	4621      	mov	r1, r4
 80090fa:	47a8      	blx	r5

    lRet = CIFX_NO_ERROR;
 80090fc:	2000      	movs	r0, #0
  }

  return lRet;
}
 80090fe:	b005      	add	sp, #20
 8009100:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return CIFX_INVALID_BUFFERSIZE;
 8009104:	4801      	ldr	r0, [pc, #4]	; (800910c <hboot_send_packet+0x84>)
 8009106:	e7fa      	b.n	80090fe <hboot_send_packet+0x76>
    lRet = CIFX_DEV_PUT_TIMEOUT;
 8009108:	4801      	ldr	r0, [pc, #4]	; (8009110 <hboot_send_packet+0x88>)
 800910a:	e7f8      	b.n	80090fe <hboot_send_packet+0x76>
 800910c:	800a0007 	.word	0x800a0007
 8009110:	800c0017 	.word	0x800c0017

08009114 <hboot_get_packet>:
/*****************************************************************************/
static int32_t hboot_get_packet(PDEVICEINSTANCE ptDevInstance,
                                HBOOT_DATA_T*   ptHBootData,
                                uint8_t*        pbResult,
                                uint32_t        ulTimeout)
{
 8009114:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8009118:	b085      	sub	sp, #20
 800911a:	4604      	mov	r4, r0
 800911c:	460d      	mov	r5, r1
 800911e:	4617      	mov	r7, r2
  int32_t lRet  = CIFX_DEV_GET_NO_PACKET;

  if(hboot_waitforbitstate(ptDevInstance,
 8009120:	9300      	str	r3, [sp, #0]
 8009122:	2301      	movs	r3, #1
 8009124:	2202      	movs	r2, #2
 8009126:	f7ff ff5e 	bl	8008fe6 <hboot_waitforbitstate>
 800912a:	b398      	cbz	r0, 8009194 <hboot_get_packet+0x80>
                           ptHBootData,
                           NETX50_DPM_TOHOSTMBX_MSK,
                           HIL_FLAGS_NOT_EQUAL,
                           ulTimeout))
  {
    HBOOT_HSREGISTER_T* ptHskReg      = ptHBootData->ptHsk;
 800912c:	f8d5 9000 	ldr.w	r9, [r5]
    volatile uint8_t*   pbMailbox     = (volatile uint8_t*)ptHBootData->tToHostMailbox.pvData;
 8009130:	f8d5 801c 	ldr.w	r8, [r5, #28]
    volatile uint32_t*  pulMbxDataLen = ptHBootData->tToHostMailbox.pulDataLen;
    uint8_t             bToHostMask   = ptHBootData->tToHostMailbox.bHskMask;
 8009134:	7d2e      	ldrb	r6, [r5, #20]
    uint8_t             bHostFlags    = 0;

    lRet = CIFX_NO_ERROR;

    if( LE32_TO_HOST(HWIF_READ32(ptDevInstance, pulMbxDataLen[0])) != 1)
 8009136:	6a29      	ldr	r1, [r5, #32]
 8009138:	4620      	mov	r0, r4
 800913a:	f7fc f8de 	bl	80052fa <HwIfRead32>
 800913e:	2801      	cmp	r0, #1
 8009140:	d020      	beq.n	8009184 <hboot_get_packet+0x70>
    {
      lRet = CIFX_DRV_INIT_STATE_ERROR;
 8009142:	f8df 8058 	ldr.w	r8, [pc, #88]	; 800919c <hboot_get_packet+0x88>
    } else
    {
      *pbResult = HWIF_READ8(ptDevInstance, pbMailbox[0]);
    }

    bHostFlags = HWIF_READ8(ptDevInstance, ptHskReg->t8Bit.bHostFlags);
 8009146:	f109 0703 	add.w	r7, r9, #3
 800914a:	4639      	mov	r1, r7
 800914c:	4620      	mov	r0, r4
 800914e:	f7fc f893 	bl	8005278 <HwIfRead8>
 8009152:	4605      	mov	r5, r0
    if((bHostFlags ^ HWIF_READ8(ptDevInstance, ptHskReg->t8Bit.bNetXFlags)) & bToHostMask)
 8009154:	f109 0102 	add.w	r1, r9, #2
 8009158:	4620      	mov	r0, r4
 800915a:	f7fc f88d 	bl	8005278 <HwIfRead8>
 800915e:	4068      	eors	r0, r5
 8009160:	4206      	tst	r6, r0
 8009162:	d00b      	beq.n	800917c <hboot_get_packet+0x68>
    {
      HWIF_WRITE8(ptDevInstance, ptHskReg->t8Bit.bHostFlags, (bHostFlags ^ bToHostMask));
 8009164:	406e      	eors	r6, r5
 8009166:	f88d 600f 	strb.w	r6, [sp, #15]
 800916a:	f8d4 52c8 	ldr.w	r5, [r4, #712]	; 0x2c8
 800916e:	2001      	movs	r0, #1
 8009170:	9000      	str	r0, [sp, #0]
 8009172:	f10d 030f 	add.w	r3, sp, #15
 8009176:	463a      	mov	r2, r7
 8009178:	4621      	mov	r1, r4
 800917a:	47a8      	blx	r5
    }
  }

  return lRet;
}
 800917c:	4640      	mov	r0, r8
 800917e:	b005      	add	sp, #20
 8009180:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      *pbResult = HWIF_READ8(ptDevInstance, pbMailbox[0]);
 8009184:	4641      	mov	r1, r8
 8009186:	4620      	mov	r0, r4
 8009188:	f7fc f876 	bl	8005278 <HwIfRead8>
 800918c:	7038      	strb	r0, [r7, #0]
    lRet = CIFX_NO_ERROR;
 800918e:	f04f 0800 	mov.w	r8, #0
 8009192:	e7d8      	b.n	8009146 <hboot_get_packet+0x32>
  int32_t lRet  = CIFX_DEV_GET_NO_PACKET;
 8009194:	f8df 8008 	ldr.w	r8, [pc, #8]	; 80091a0 <hboot_get_packet+0x8c>
  return lRet;
 8009198:	e7f0      	b.n	800917c <hboot_get_packet+0x68>
 800919a:	bf00      	nop
 800919c:	800b0002 	.word	0x800b0002
 80091a0:	800c0019 	.word	0x800c0019

080091a4 <hboot_transfer_packet>:
                                     HBOOT_DATA_T*   ptHBootData,
                                     uint8_t*        pbSendData,
                                     uint32_t        ulSendDataLen,
                                     uint8_t*        pbResult,
                                     uint32_t        ulTimeout)
{
 80091a4:	b570      	push	{r4, r5, r6, lr}
 80091a6:	b082      	sub	sp, #8
 80091a8:	4604      	mov	r4, r0
 80091aa:	460d      	mov	r5, r1
 80091ac:	9e07      	ldr	r6, [sp, #28]
  int32_t lRet  = CIFX_NO_ERROR;

  if(CIFX_NO_ERROR == (lRet = hboot_send_packet(ptDevInstance, ptHBootData, pbSendData, ulSendDataLen, ulTimeout)))
 80091ae:	9600      	str	r6, [sp, #0]
 80091b0:	f7ff ff6a 	bl	8009088 <hboot_send_packet>
 80091b4:	b108      	cbz	r0, 80091ba <hboot_transfer_packet+0x16>
  {
    lRet = hboot_get_packet(ptDevInstance, ptHBootData, pbResult, ulTimeout);
  }

  return lRet;
}
 80091b6:	b002      	add	sp, #8
 80091b8:	bd70      	pop	{r4, r5, r6, pc}
    lRet = hboot_get_packet(ptDevInstance, ptHBootData, pbResult, ulTimeout);
 80091ba:	4633      	mov	r3, r6
 80091bc:	9a06      	ldr	r2, [sp, #24]
 80091be:	4629      	mov	r1, r5
 80091c0:	4620      	mov	r0, r4
 80091c2:	f7ff ffa7 	bl	8009114 <hboot_get_packet>
  return lRet;
 80091c6:	e7f6      	b.n	80091b6 <hboot_transfer_packet+0x12>

080091c8 <IsNetX51or52ROM>:
{
 80091c8:	b538      	push	{r3, r4, r5, lr}
 80091ca:	4604      	mov	r4, r0
  NETX51_DPM_CONFIG_AREA_T* ptDpmCfg = (NETX51_DPM_CONFIG_AREA_T*)ptDevInstance->pbDPM;
 80091cc:	6a05      	ldr	r5, [r0, #32]
  if( (HWIF_READ8(ptDevInstance, ptDevInstance->pbDPM[NETX51_DETECT_OFFSET1]) == NETX51_DETECT_VALUE1) &&
 80091ce:	f105 01d9 	add.w	r1, r5, #217	; 0xd9
 80091d2:	f7fc f851 	bl	8005278 <HwIfRead8>
 80091d6:	28f2      	cmp	r0, #242	; 0xf2
 80091d8:	d001      	beq.n	80091de <IsNetX51or52ROM+0x16>
  int                       iRet     = 0;
 80091da:	2000      	movs	r0, #0
}
 80091dc:	bd38      	pop	{r3, r4, r5, pc}
      (HWIF_READ8(ptDevInstance, ptDevInstance->pbDPM[NETX51_DETECT_OFFSET2]) == NETX51_DETECT_VALUE2) &&
 80091de:	6a21      	ldr	r1, [r4, #32]
 80091e0:	31cc      	adds	r1, #204	; 0xcc
 80091e2:	4620      	mov	r0, r4
 80091e4:	f7fc f848 	bl	8005278 <HwIfRead8>
  if( (HWIF_READ8(ptDevInstance, ptDevInstance->pbDPM[NETX51_DETECT_OFFSET1]) == NETX51_DETECT_VALUE1) &&
 80091e8:	28f2      	cmp	r0, #242	; 0xf2
 80091ea:	d001      	beq.n	80091f0 <IsNetX51or52ROM+0x28>
  int                       iRet     = 0;
 80091ec:	2000      	movs	r0, #0
 80091ee:	e7f5      	b.n	80091dc <IsNetX51or52ROM+0x14>
      (HWIF_READ32(ptDevInstance, ptDpmCfg->aulReserved1[0]) == 0) &&
 80091f0:	f105 0130 	add.w	r1, r5, #48	; 0x30
 80091f4:	4620      	mov	r0, r4
 80091f6:	f7fc f880 	bl	80052fa <HwIfRead32>
      (HWIF_READ8(ptDevInstance, ptDevInstance->pbDPM[NETX51_DETECT_OFFSET2]) == NETX51_DETECT_VALUE2) &&
 80091fa:	b108      	cbz	r0, 8009200 <IsNetX51or52ROM+0x38>
  int                       iRet     = 0;
 80091fc:	2000      	movs	r0, #0
 80091fe:	e7ed      	b.n	80091dc <IsNetX51or52ROM+0x14>
      (HWIF_READ32(ptDevInstance, ptDpmCfg->aulReserved1[1]) == 0) )
 8009200:	f105 0134 	add.w	r1, r5, #52	; 0x34
 8009204:	4620      	mov	r0, r4
 8009206:	f7fc f878 	bl	80052fa <HwIfRead32>
      (HWIF_READ32(ptDevInstance, ptDpmCfg->aulReserved1[0]) == 0) &&
 800920a:	b108      	cbz	r0, 8009210 <IsNetX51or52ROM+0x48>
  int                       iRet     = 0;
 800920c:	2000      	movs	r0, #0
  return iRet;
 800920e:	e7e5      	b.n	80091dc <IsNetX51or52ROM+0x14>
                                HWIF_READ32(ptDevInstance, ptDpmCfg->ulDpmNetxVersion);
 8009210:	f105 01fc 	add.w	r1, r5, #252	; 0xfc
 8009214:	4620      	mov	r0, r4
 8009216:	f7fc f870 	bl	80052fa <HwIfRead32>
    uint32_t ulDpmNetxVersion = (MSK_NX56_dpm_netx_version_valid | MSK_NX56_dpm_netx_version_chiptype) &
 800921a:	f400 6360 	and.w	r3, r0, #3584	; 0xe00
    if ( (MSK_NX56_dpm_netx_version_valid | ( 2 << SRT_NX56_dpm_netx_version_chiptype)) == ulDpmNetxVersion )
 800921e:	f5b3 6f20 	cmp.w	r3, #2560	; 0xa00
 8009222:	d004      	beq.n	800922e <IsNetX51or52ROM+0x66>
      ptDevInstance->eChipType = eCHIP_TYPE_NETX51;
 8009224:	2305      	movs	r3, #5
 8009226:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    iRet = 1;
 800922a:	2001      	movs	r0, #1
 800922c:	e7d6      	b.n	80091dc <IsNetX51or52ROM+0x14>
      ptDevInstance->eChipType = eCHIP_TYPE_NETX52;
 800922e:	2306      	movs	r3, #6
 8009230:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    iRet = 1;
 8009234:	2001      	movs	r0, #1
 8009236:	e7d1      	b.n	80091dc <IsNetX51or52ROM+0x14>

08009238 <cifXStartBootloader_hboot>:
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t cifXStartBootloader_hboot(PDEVICEINSTANCE ptDevInstance,
                                  uint8_t*        pbFileData,
                                  uint32_t        ulFileDataLen)
{
 8009238:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800923c:	b08c      	sub	sp, #48	; 0x30
 800923e:	4680      	mov	r8, r0
 8009240:	460e      	mov	r6, r1
 8009242:	4614      	mov	r4, r2
  int32_t       lRet       = CIFX_NO_ERROR;
  uint32_t      ulCopyLen  = 0;
  HBOOT_DATA_T  tHBoot;

  OS_Memset(&tHBoot, 0, sizeof(tHBoot));
 8009244:	2224      	movs	r2, #36	; 0x24
 8009246:	2100      	movs	r1, #0
 8009248:	a803      	add	r0, sp, #12
 800924a:	f7f9 fc68 	bl	8002b1e <OS_Memset>

  /* Check for chip type and initialize boot data structure */
  if((eCHIP_TYPE_NETX51 == ptDevInstance->eChipType) || (eCHIP_TYPE_NETX52 == ptDevInstance->eChipType))
 800924e:	f898 3028 	ldrb.w	r3, [r8, #40]	; 0x28
 8009252:	3b05      	subs	r3, #5
 8009254:	b2db      	uxtb	r3, r3
 8009256:	2b01      	cmp	r3, #1
 8009258:	d93e      	bls.n	80092d8 <cifXStartBootloader_hboot+0xa0>
                 TRACE_LEVEL_DEBUG,
                 "Found netX51 ROMloader");
    }
  } else
  {
    PNETX50_ROMLOADER_DPM ptDpm = (PNETX50_ROMLOADER_DPM)ptDevInstance->pbDPM;
 800925a:	f8d8 3020 	ldr.w	r3, [r8, #32]

    tHBoot.ptHsk = &ptDpm->atHandshakeRegs[NETX50_DPM_HANDSHAKE_OFFSET];
 800925e:	f641 42fc 	movw	r2, #7420	; 0x1cfc
 8009262:	441a      	add	r2, r3
 8009264:	9203      	str	r2, [sp, #12]

    tHBoot.tToHostMailbox.bHskMask   = NETX50_DPM_TOHOSTMBX_MSK;
 8009266:	2202      	movs	r2, #2
 8009268:	f88d 2020 	strb.w	r2, [sp, #32]
    tHBoot.tToHostMailbox.pulDataLen = &ptDpm->ulNetxToHostDataSize;
 800926c:	f503 727f 	add.w	r2, r3, #1020	; 0x3fc
 8009270:	920b      	str	r2, [sp, #44]	; 0x2c
    tHBoot.tToHostMailbox.pvData     = (void*)ptDpm->abNetxToHostData;
 8009272:	f503 52a0 	add.w	r2, r3, #5120	; 0x1400
 8009276:	920a      	str	r2, [sp, #40]	; 0x28
    tHBoot.tToHostMailbox.ulSize     = sizeof(ptDpm->abNetxToHostData);
 8009278:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800927c:	9209      	str	r2, [sp, #36]	; 0x24

    tHBoot.tToNetXMailbox.bHskMask   = NETX50_DPM_TONETXMBX_MSK;
 800927e:	2201      	movs	r2, #1
 8009280:	f88d 2010 	strb.w	r2, [sp, #16]
    tHBoot.tToNetXMailbox.pulDataLen = &ptDpm->ulHostToNetxDataSize;
 8009284:	f503 727e 	add.w	r2, r3, #1016	; 0x3f8
 8009288:	9207      	str	r2, [sp, #28]
    tHBoot.tToNetXMailbox.pvData     = (void*)ptDpm->abHostToNetxData;
 800928a:	f503 6280 	add.w	r2, r3, #1024	; 0x400
 800928e:	9206      	str	r2, [sp, #24]
    tHBoot.tToNetXMailbox.ulSize     = sizeof(ptDpm->abHostToNetxData);
 8009290:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8009294:	9205      	str	r2, [sp, #20]

    /* Read romloader version */
    if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8009296:	4a61      	ldr	r2, [pc, #388]	; (800941c <cifXStartBootloader_hboot+0x1e4>)
 8009298:	6812      	ldr	r2, [r2, #0]
 800929a:	f012 0f01 	tst.w	r2, #1
 800929e:	d143      	bne.n	8009328 <cifXStartBootloader_hboot+0xf0>
                 "Found netX50 ROMloader, DPM layout type 0x%08X",
                 ulLayout);
    }
  }

  ulCopyLen = tHBoot.tToNetXMailbox.ulSize;
 80092a0:	9d05      	ldr	r5, [sp, #20]

  if(ulFileDataLen < sizeof(NETX_BOOTBLOCK_T))
 80092a2:	2c3f      	cmp	r4, #63	; 0x3f
 80092a4:	d94e      	bls.n	8009344 <cifXStartBootloader_hboot+0x10c>
    lRet = CIFX_FILE_TYPE_INVALID;
  }

  if(CIFX_NO_ERROR == lRet)
  {
    uint8_t bResult             = 0;
 80092a6:	2300      	movs	r3, #0
 80092a8:	f88d 300b 	strb.w	r3, [sp, #11]
    int     fLastPacketReceived = 0;

    /* Send Bootblock to device */
    if(CIFX_NO_ERROR != (lRet = hboot_transfer_packet(ptDevInstance,
 80092ac:	f241 3388 	movw	r3, #5000	; 0x1388
 80092b0:	9301      	str	r3, [sp, #4]
 80092b2:	f10d 030b 	add.w	r3, sp, #11
 80092b6:	9300      	str	r3, [sp, #0]
 80092b8:	2340      	movs	r3, #64	; 0x40
 80092ba:	4632      	mov	r2, r6
 80092bc:	a903      	add	r1, sp, #12
 80092be:	4640      	mov	r0, r8
 80092c0:	f7ff ff70 	bl	80091a4 <hboot_transfer_packet>
 80092c4:	4607      	mov	r7, r0
 80092c6:	2800      	cmp	r0, #0
 80092c8:	d144      	bne.n	8009354 <cifXStartBootloader_hboot+0x11c>
      USER_Trace(ptDevInstance,
                TRACE_LEVEL_ERROR,
                "Error transfering bootheader to netX50 Bootloader (lRet = 0x%08X)",
                 lRet);

    } else if(0 != bResult)
 80092ca:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80092ce:	2b00      	cmp	r3, #0
 80092d0:	d147      	bne.n	8009362 <cifXStartBootloader_hboot+0x12a>
      lRet = CIFX_DRV_DOWNLOAD_FAILED;

    } else
    {
      /* Everything ok. start with rest of file */
      pbFileData    += (uint32_t)sizeof(NETX_BOOTBLOCK_T);
 80092d2:	3640      	adds	r6, #64	; 0x40
      ulFileDataLen -= (uint32_t)sizeof(NETX_BOOTBLOCK_T);
 80092d4:	3c40      	subs	r4, #64	; 0x40
 80092d6:	e055      	b.n	8009384 <cifXStartBootloader_hboot+0x14c>
    PNETX51_ROMLOADER_DPM ptDpm = (PNETX51_ROMLOADER_DPM)ptDevInstance->pbDPM;
 80092d8:	f8d8 3020 	ldr.w	r3, [r8, #32]
    tHBoot.ptHsk = (HBOOT_HSREGISTER_T*)&ptDpm->tHandshake.ulHandshakeFlag;
 80092dc:	f503 72c0 	add.w	r2, r3, #384	; 0x180
 80092e0:	9203      	str	r2, [sp, #12]
    tHBoot.tToHostMailbox.bHskMask   = NETX51_DPM_TOHOSTMBX_MSK;
 80092e2:	2202      	movs	r2, #2
 80092e4:	f88d 2020 	strb.w	r2, [sp, #32]
    tHBoot.tToHostMailbox.pulDataLen = &ptDpm->tHBootConfig.ulNetXToHostDataSize;
 80092e8:	f503 72bc 	add.w	r2, r3, #376	; 0x178
 80092ec:	920b      	str	r2, [sp, #44]	; 0x2c
    tHBoot.tToHostMailbox.pvData     = (void*)ptDpm->abNetxToHostData;
 80092ee:	f503 7200 	add.w	r2, r3, #512	; 0x200
 80092f2:	920a      	str	r2, [sp, #40]	; 0x28
    tHBoot.tToHostMailbox.ulSize     = sizeof(ptDpm->abNetxToHostData);
 80092f4:	f44f 7200 	mov.w	r2, #512	; 0x200
 80092f8:	9209      	str	r2, [sp, #36]	; 0x24
    tHBoot.tToNetXMailbox.bHskMask   = NETX51_DPM_TONETXMBX_MSK;
 80092fa:	2201      	movs	r2, #1
 80092fc:	f88d 2010 	strb.w	r2, [sp, #16]
    tHBoot.tToNetXMailbox.pulDataLen = &ptDpm->tHBootConfig.ulHostToNetxDataSize;
 8009300:	f503 72be 	add.w	r2, r3, #380	; 0x17c
 8009304:	9207      	str	r2, [sp, #28]
    tHBoot.tToNetXMailbox.pvData     = (void*)ptDpm->abHostToNetxData;
 8009306:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800930a:	9306      	str	r3, [sp, #24]
    tHBoot.tToNetXMailbox.ulSize     = sizeof(ptDpm->abHostToNetxData);
 800930c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8009310:	9305      	str	r3, [sp, #20]
    if(g_ulTraceLevel & TRACE_LEVEL_DEBUG)
 8009312:	4b42      	ldr	r3, [pc, #264]	; (800941c <cifXStartBootloader_hboot+0x1e4>)
 8009314:	681b      	ldr	r3, [r3, #0]
 8009316:	f013 0f01 	tst.w	r3, #1
 800931a:	d0c1      	beq.n	80092a0 <cifXStartBootloader_hboot+0x68>
      USER_Trace(ptDevInstance,
 800931c:	4a40      	ldr	r2, [pc, #256]	; (8009420 <cifXStartBootloader_hboot+0x1e8>)
 800931e:	2101      	movs	r1, #1
 8009320:	4640      	mov	r0, r8
 8009322:	f000 f98d 	bl	8009640 <USER_Trace>
 8009326:	e7bb      	b.n	80092a0 <cifXStartBootloader_hboot+0x68>
      uint32_t ulLayout = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptDpm->aulDpmHsRegs[NETX50_DPM_BLLAYOUT_OFFSET]));
 8009328:	f641 71d8 	movw	r1, #8152	; 0x1fd8
 800932c:	4419      	add	r1, r3
 800932e:	4640      	mov	r0, r8
 8009330:	f7fb ffe3 	bl	80052fa <HwIfRead32>
      USER_Trace(ptDevInstance,
 8009334:	f3c0 2307 	ubfx	r3, r0, #8, #8
 8009338:	4a3a      	ldr	r2, [pc, #232]	; (8009424 <cifXStartBootloader_hboot+0x1ec>)
 800933a:	2101      	movs	r1, #1
 800933c:	4640      	mov	r0, r8
 800933e:	f000 f97f 	bl	8009640 <USER_Trace>
 8009342:	e7ad      	b.n	80092a0 <cifXStartBootloader_hboot+0x68>
    USER_Trace(ptDevInstance,
 8009344:	4623      	mov	r3, r4
 8009346:	4a38      	ldr	r2, [pc, #224]	; (8009428 <cifXStartBootloader_hboot+0x1f0>)
 8009348:	2108      	movs	r1, #8
 800934a:	4640      	mov	r0, r8
 800934c:	f000 f978 	bl	8009640 <USER_Trace>
    lRet = CIFX_FILE_TYPE_INVALID;
 8009350:	4f36      	ldr	r7, [pc, #216]	; (800942c <cifXStartBootloader_hboot+0x1f4>)
 8009352:	e03e      	b.n	80093d2 <cifXStartBootloader_hboot+0x19a>
      USER_Trace(ptDevInstance,
 8009354:	4603      	mov	r3, r0
 8009356:	4a36      	ldr	r2, [pc, #216]	; (8009430 <cifXStartBootloader_hboot+0x1f8>)
 8009358:	2108      	movs	r1, #8
 800935a:	4640      	mov	r0, r8
 800935c:	f000 f970 	bl	8009640 <USER_Trace>
 8009360:	e010      	b.n	8009384 <cifXStartBootloader_hboot+0x14c>
      USER_Trace(ptDevInstance,
 8009362:	4a34      	ldr	r2, [pc, #208]	; (8009434 <cifXStartBootloader_hboot+0x1fc>)
 8009364:	2108      	movs	r1, #8
 8009366:	4640      	mov	r0, r8
 8009368:	f000 f96a 	bl	8009640 <USER_Trace>
      lRet = CIFX_DRV_DOWNLOAD_FAILED;
 800936c:	4f32      	ldr	r7, [pc, #200]	; (8009438 <cifXStartBootloader_hboot+0x200>)
 800936e:	e009      	b.n	8009384 <cifXStartBootloader_hboot+0x14c>
        USER_Trace(ptDevInstance,
                  TRACE_LEVEL_ERROR,
                  "Error transferring data packet from/to netX50 Bootloader (lRet = 0x%08X)",
                   lRet);

      } else if(CIFX_NO_ERROR == (hboot_get_packet(ptDevInstance, &tHBoot, &bResult, 0)))
 8009370:	2300      	movs	r3, #0
 8009372:	f10d 020b 	add.w	r2, sp, #11
 8009376:	a903      	add	r1, sp, #12
 8009378:	4640      	mov	r0, r8
 800937a:	f7ff fecb 	bl	8009114 <hboot_get_packet>
 800937e:	b360      	cbz	r0, 80093da <cifXStartBootloader_hboot+0x1a2>
        /* Download is finished or has been aborted. Check will be done below */
        fLastPacketReceived = 1;
        break;
      }

      pbFileData    += ulCopyLen;
 8009380:	442e      	add	r6, r5
      ulFileDataLen -= ulCopyLen;
 8009382:	1b64      	subs	r4, r4, r5
           (lRet == CIFX_NO_ERROR) )
 8009384:	fab7 f387 	clz	r3, r7
 8009388:	095b      	lsrs	r3, r3, #5
    while( (ulFileDataLen > 0) &&
 800938a:	b1b4      	cbz	r4, 80093ba <cifXStartBootloader_hboot+0x182>
 800938c:	b1ab      	cbz	r3, 80093ba <cifXStartBootloader_hboot+0x182>
      if(ulFileDataLen < ulCopyLen)
 800938e:	42ac      	cmp	r4, r5
 8009390:	d200      	bcs.n	8009394 <cifXStartBootloader_hboot+0x15c>
        ulCopyLen = ulFileDataLen;
 8009392:	4625      	mov	r5, r4
      lRet = hboot_send_packet(ptDevInstance, &tHBoot, pbFileData, ulCopyLen, CIFX_TO_SEND_PACKET);
 8009394:	f241 3388 	movw	r3, #5000	; 0x1388
 8009398:	9300      	str	r3, [sp, #0]
 800939a:	462b      	mov	r3, r5
 800939c:	4632      	mov	r2, r6
 800939e:	a903      	add	r1, sp, #12
 80093a0:	4640      	mov	r0, r8
 80093a2:	f7ff fe71 	bl	8009088 <hboot_send_packet>
      if(CIFX_NO_ERROR != lRet)
 80093a6:	4607      	mov	r7, r0
 80093a8:	2800      	cmp	r0, #0
 80093aa:	d0e1      	beq.n	8009370 <cifXStartBootloader_hboot+0x138>
        USER_Trace(ptDevInstance,
 80093ac:	4603      	mov	r3, r0
 80093ae:	4a23      	ldr	r2, [pc, #140]	; (800943c <cifXStartBootloader_hboot+0x204>)
 80093b0:	2108      	movs	r1, #8
 80093b2:	4640      	mov	r0, r8
 80093b4:	f000 f944 	bl	8009640 <USER_Trace>
 80093b8:	e7e2      	b.n	8009380 <cifXStartBootloader_hboot+0x148>
    int     fLastPacketReceived = 0;
 80093ba:	2300      	movs	r3, #0
    }

    if(CIFX_NO_ERROR == lRet)
 80093bc:	b94f      	cbnz	r7, 80093d2 <cifXStartBootloader_hboot+0x19a>
    {
      if(!fLastPacketReceived &&
 80093be:	b173      	cbz	r3, 80093de <cifXStartBootloader_hboot+0x1a6>
                    TRACE_LEVEL_ERROR,
                    "Error getting final packet from netX50 ROM Loader. lRet=0x%08X",
                    lRet);
        }

      } else if( 0 != bResult)
 80093c0:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80093c4:	b12b      	cbz	r3, 80093d2 <cifXStartBootloader_hboot+0x19a>
      {
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80093c6:	4a15      	ldr	r2, [pc, #84]	; (800941c <cifXStartBootloader_hboot+0x1e4>)
 80093c8:	6812      	ldr	r2, [r2, #0]
 80093ca:	f012 0f08 	tst.w	r2, #8
 80093ce:	d11d      	bne.n	800940c <cifXStartBootloader_hboot+0x1d4>
          USER_Trace(ptDevInstance,
                    TRACE_LEVEL_ERROR,
                    "netX50 ROM Loader download error. bResult=%u",
                    bResult);
        }
        lRet = CIFX_DRV_DOWNLOAD_FAILED;
 80093d0:	4f19      	ldr	r7, [pc, #100]	; (8009438 <cifXStartBootloader_hboot+0x200>)
      }
    }
  }

  return lRet;
}
 80093d2:	4638      	mov	r0, r7
 80093d4:	b00c      	add	sp, #48	; 0x30
 80093d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        fLastPacketReceived = 1;
 80093da:	2301      	movs	r3, #1
 80093dc:	e7ee      	b.n	80093bc <cifXStartBootloader_hboot+0x184>
         (CIFX_NO_ERROR != (lRet = hboot_get_packet(ptDevInstance, &tHBoot, &bResult, CIFX_TO_SEND_PACKET))) )
 80093de:	f241 3388 	movw	r3, #5000	; 0x1388
 80093e2:	f10d 020b 	add.w	r2, sp, #11
 80093e6:	a903      	add	r1, sp, #12
 80093e8:	4640      	mov	r0, r8
 80093ea:	f7ff fe93 	bl	8009114 <hboot_get_packet>
      if(!fLastPacketReceived &&
 80093ee:	4607      	mov	r7, r0
 80093f0:	2800      	cmp	r0, #0
 80093f2:	d0e5      	beq.n	80093c0 <cifXStartBootloader_hboot+0x188>
        if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80093f4:	4b09      	ldr	r3, [pc, #36]	; (800941c <cifXStartBootloader_hboot+0x1e4>)
 80093f6:	681b      	ldr	r3, [r3, #0]
 80093f8:	f013 0f08 	tst.w	r3, #8
 80093fc:	d0e9      	beq.n	80093d2 <cifXStartBootloader_hboot+0x19a>
          USER_Trace(ptDevInstance,
 80093fe:	4603      	mov	r3, r0
 8009400:	4a0f      	ldr	r2, [pc, #60]	; (8009440 <cifXStartBootloader_hboot+0x208>)
 8009402:	2108      	movs	r1, #8
 8009404:	4640      	mov	r0, r8
 8009406:	f000 f91b 	bl	8009640 <USER_Trace>
 800940a:	e7e2      	b.n	80093d2 <cifXStartBootloader_hboot+0x19a>
          USER_Trace(ptDevInstance,
 800940c:	4a0d      	ldr	r2, [pc, #52]	; (8009444 <cifXStartBootloader_hboot+0x20c>)
 800940e:	2108      	movs	r1, #8
 8009410:	4640      	mov	r0, r8
 8009412:	f000 f915 	bl	8009640 <USER_Trace>
        lRet = CIFX_DRV_DOWNLOAD_FAILED;
 8009416:	4f08      	ldr	r7, [pc, #32]	; (8009438 <cifXStartBootloader_hboot+0x200>)
 8009418:	e7db      	b.n	80093d2 <cifXStartBootloader_hboot+0x19a>
 800941a:	bf00      	nop
 800941c:	20000038 	.word	0x20000038
 8009420:	0800cad8 	.word	0x0800cad8
 8009424:	0800caf0 	.word	0x0800caf0
 8009428:	0800cb20 	.word	0x0800cb20
 800942c:	800a000f 	.word	0x800a000f
 8009430:	0800cb70 	.word	0x0800cb70
 8009434:	0800cbb4 	.word	0x0800cbb4
 8009438:	800b0005 	.word	0x800b0005
 800943c:	0800cbe8 	.word	0x0800cbe8
 8009440:	0800cc34 	.word	0x0800cc34
 8009444:	0800cc74 	.word	0x0800cc74

08009448 <cifXStartBootloader_netX100>:
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int32_t cifXStartBootloader_netX100( PDEVICEINSTANCE ptDevInstance,
                                     uint8_t*        pbFileData,
                                     uint32_t        ulFileDataLen)
{
 8009448:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800944c:	b084      	sub	sp, #16
 800944e:	4604      	mov	r4, r0
 8009450:	4688      	mov	r8, r1
 8009452:	4615      	mov	r5, r2
  int32_t  lRet  = CIFX_DRV_INIT_STATE_ERROR;
  uint8_t* pbTmp = (uint8_t*)OS_Memalloc(ulFileDataLen);
 8009454:	4610      	mov	r0, r2
 8009456:	f7f9 fb56 	bl	8002b06 <OS_Memalloc>

  if(NULL == pbTmp)
 800945a:	b320      	cbz	r0, 80094a6 <cifXStartBootloader_netX100+0x5e>
 800945c:	4607      	mov	r7, r0
    }
    lRet = CIFX_FILE_LOAD_INSUFF_MEM;
  } else
  {
    /* Startup 2nd stage Loader */
    HWIF_WRITEN(ptDevInstance, ptDevInstance->pbDPM, pbFileData, ulFileDataLen);
 800945e:	9500      	str	r5, [sp, #0]
 8009460:	4643      	mov	r3, r8
 8009462:	6a22      	ldr	r2, [r4, #32]
 8009464:	4621      	mov	r1, r4
 8009466:	2000      	movs	r0, #0
 8009468:	f8d4 62c8 	ldr.w	r6, [r4, #712]	; 0x2c8
 800946c:	47b0      	blx	r6

    HWIF_READN(ptDevInstance, pbTmp, ptDevInstance->pbDPM, ulFileDataLen);
 800946e:	9500      	str	r5, [sp, #0]
 8009470:	463b      	mov	r3, r7
 8009472:	6a22      	ldr	r2, [r4, #32]
 8009474:	4621      	mov	r1, r4
 8009476:	2000      	movs	r0, #0
 8009478:	f8d4 62c4 	ldr.w	r6, [r4, #708]	; 0x2c4
 800947c:	47b0      	blx	r6

    if(OS_Memcmp(pbTmp, pbFileData, ulFileDataLen) != 0)
 800947e:	462a      	mov	r2, r5
 8009480:	4641      	mov	r1, r8
 8009482:	4638      	mov	r0, r7
 8009484:	f7f9 fb53 	bl	8002b2e <OS_Memcmp>
 8009488:	4605      	mov	r5, r0
 800948a:	b308      	cbz	r0, 80094d0 <cifXStartBootloader_netX100+0x88>
    {
      lRet = CIFX_DRV_DOWNLOAD_FAILED;

      if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 800948c:	4b1e      	ldr	r3, [pc, #120]	; (8009508 <cifXStartBootloader_netX100+0xc0>)
 800948e:	681b      	ldr	r3, [r3, #0]
 8009490:	f013 0f08 	tst.w	r3, #8
 8009494:	d115      	bne.n	80094c2 <cifXStartBootloader_netX100+0x7a>
      lRet = CIFX_DRV_DOWNLOAD_FAILED;
 8009496:	4d1d      	ldr	r5, [pc, #116]	; (800950c <cifXStartBootloader_netX100+0xc4>)

      /* We are done with starting the netX */
      lRet = CIFX_NO_ERROR;
    }

    OS_Memfree(pbTmp);
 8009498:	4638      	mov	r0, r7
 800949a:	f7f9 fb38 	bl	8002b0e <OS_Memfree>
  }

  return lRet;
 800949e:	4628      	mov	r0, r5
 80094a0:	b004      	add	sp, #16
 80094a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(g_ulTraceLevel & TRACE_LEVEL_ERROR)
 80094a6:	4b18      	ldr	r3, [pc, #96]	; (8009508 <cifXStartBootloader_netX100+0xc0>)
 80094a8:	681b      	ldr	r3, [r3, #0]
 80094aa:	f013 0f08 	tst.w	r3, #8
 80094ae:	d101      	bne.n	80094b4 <cifXStartBootloader_netX100+0x6c>
    lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 80094b0:	4d17      	ldr	r5, [pc, #92]	; (8009510 <cifXStartBootloader_netX100+0xc8>)
  return lRet;
 80094b2:	e7f4      	b.n	800949e <cifXStartBootloader_netX100+0x56>
      USER_Trace(ptDevInstance,
 80094b4:	4a17      	ldr	r2, [pc, #92]	; (8009514 <cifXStartBootloader_netX100+0xcc>)
 80094b6:	2108      	movs	r1, #8
 80094b8:	4620      	mov	r0, r4
 80094ba:	f000 f8c1 	bl	8009640 <USER_Trace>
    lRet = CIFX_FILE_LOAD_INSUFF_MEM;
 80094be:	4d14      	ldr	r5, [pc, #80]	; (8009510 <cifXStartBootloader_netX100+0xc8>)
 80094c0:	e7ed      	b.n	800949e <cifXStartBootloader_netX100+0x56>
        USER_Trace(ptDevInstance,
 80094c2:	4a15      	ldr	r2, [pc, #84]	; (8009518 <cifXStartBootloader_netX100+0xd0>)
 80094c4:	2108      	movs	r1, #8
 80094c6:	4620      	mov	r0, r4
 80094c8:	f000 f8ba 	bl	8009640 <USER_Trace>
      lRet = CIFX_DRV_DOWNLOAD_FAILED;
 80094cc:	4d0f      	ldr	r5, [pc, #60]	; (800950c <cifXStartBootloader_netX100+0xc4>)
 80094ce:	e7e3      	b.n	8009498 <cifXStartBootloader_netX100+0x50>
      uint32_t ulState = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptDevInstance->ptGlobalRegisters->ulSystemState));
 80094d0:	6d21      	ldr	r1, [r4, #80]	; 0x50
 80094d2:	f501 71ec 	add.w	r1, r1, #472	; 0x1d8
 80094d6:	4620      	mov	r0, r4
 80094d8:	f7fb ff0f 	bl	80052fa <HwIfRead32>
      if( ulState & MSK_SYSSTA_BOOT_ACTIVE)
 80094dc:	f010 0f08 	tst.w	r0, #8
 80094e0:	d00e      	beq.n	8009500 <cifXStartBootloader_netX100+0xb8>
        ulState |= (uint32_t)MSK_SYSSTA_BOOT_START;
 80094e2:	f040 0080 	orr.w	r0, r0, #128	; 0x80
      HWIF_WRITE32(ptDevInstance, ptDevInstance->ptGlobalRegisters->ulSystemState, HOST_TO_LE32(ulState));
 80094e6:	9003      	str	r0, [sp, #12]
 80094e8:	f8d4 62c8 	ldr.w	r6, [r4, #712]	; 0x2c8
 80094ec:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80094ee:	2304      	movs	r3, #4
 80094f0:	9300      	str	r3, [sp, #0]
 80094f2:	ab03      	add	r3, sp, #12
 80094f4:	f502 72ec 	add.w	r2, r2, #472	; 0x1d8
 80094f8:	4621      	mov	r1, r4
 80094fa:	2001      	movs	r0, #1
 80094fc:	47b0      	blx	r6
      lRet = CIFX_NO_ERROR;
 80094fe:	e7cb      	b.n	8009498 <cifXStartBootloader_netX100+0x50>
        ulState &= (uint32_t)~MSK_SYSSTA_BOOT_START;
 8009500:	f020 0080 	bic.w	r0, r0, #128	; 0x80
 8009504:	e7ef      	b.n	80094e6 <cifXStartBootloader_netX100+0x9e>
 8009506:	bf00      	nop
 8009508:	20000038 	.word	0x20000038
 800950c:	800b0005 	.word	0x800b0005
 8009510:	800a000c 	.word	0x800a000c
 8009514:	0800cca4 	.word	0x0800cca4
 8009518:	0800ccdc 	.word	0x0800ccdc

0800951c <IsNetX4x00FLASH>:
*
*   \param ptDevInstance        Current device instance
*   \return !=0 if netX4x00 has been detected                                */
/*****************************************************************************/
int IsNetX4x00FLASH(PDEVICEINSTANCE ptDevInstance)
{
 800951c:	b510      	push	{r4, lr}
 800951e:	4604      	mov	r4, r0

  /* Use the netX global register block to detect the netX chip */
  /* Note: the pointer to the global register block is set in cifXStartDevice() */

  /* ulDpm_netx_version in register block (end of DPM memory) */
  ulDpmNetxVersion = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptDevInstance->ptGlobalRegisters->reserved6));
 8009520:	6d01      	ldr	r1, [r0, #80]	; 0x50
 8009522:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
 8009526:	f7fb fee8 	bl	80052fa <HwIfRead32>

  /* Check for known version/cookie */
  if( HBOOT_DPM_NETX4000_COOKIE == ulDpmNetxVersion)
 800952a:	4b09      	ldr	r3, [pc, #36]	; (8009550 <IsNetX4x00FLASH+0x34>)
 800952c:	4298      	cmp	r0, r3
 800952e:	d004      	beq.n	800953a <IsNetX4x00FLASH+0x1e>
  {
    /* This is a netX4000 */
    ptDevInstance->eChipType = eCHIP_TYPE_NETX4000;
    iRet = 1;
  } else if( HBOOT_DPM_NETX4100_COOKIE == ulDpmNetxVersion)
 8009530:	4b08      	ldr	r3, [pc, #32]	; (8009554 <IsNetX4x00FLASH+0x38>)
 8009532:	4298      	cmp	r0, r3
 8009534:	d006      	beq.n	8009544 <IsNetX4x00FLASH+0x28>
  int iRet = 0;
 8009536:	2000      	movs	r0, #0
    ptDevInstance->eChipType = eCHIP_TYPE_NETX4100;
    iRet = 1;
  }

  return iRet;
}
 8009538:	bd10      	pop	{r4, pc}
    ptDevInstance->eChipType = eCHIP_TYPE_NETX4000;
 800953a:	2307      	movs	r3, #7
 800953c:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    iRet = 1;
 8009540:	2001      	movs	r0, #1
 8009542:	e7f9      	b.n	8009538 <IsNetX4x00FLASH+0x1c>
    ptDevInstance->eChipType = eCHIP_TYPE_NETX4100;
 8009544:	2308      	movs	r3, #8
 8009546:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    iRet = 1;
 800954a:	2001      	movs	r0, #1
 800954c:	e7f4      	b.n	8009538 <IsNetX4x00FLASH+0x1c>
 800954e:	bf00      	nop
 8009550:	84524c0b 	.word	0x84524c0b
 8009554:	93615b0b 	.word	0x93615b0b

08009558 <IsNetX4x00ROM>:
*
*   \param ptDevInstance        Current device instance
*   \return !=0 if netX4x00 has been detected                                */
/*****************************************************************************/
int IsNetX4x00ROM(PDEVICEINSTANCE ptDevInstance)
{
 8009558:	b510      	push	{r4, lr}
 800955a:	4604      	mov	r4, r0
  int iRet = 0;
  uint32_t ulDpmNetxVersion = 0;

  /* Use the netX global register block to detect the netX chip */
  HBOOT_V2_DPM_CFG_AREA_T* ptDpmCfg = (HBOOT_V2_DPM_CFG_AREA_T*)ptDevInstance->pbDPM;
 800955c:	6a01      	ldr	r1, [r0, #32]
  ulDpmNetxVersion = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptDpmCfg->ulDpm_netx_version));
 800955e:	31fc      	adds	r1, #252	; 0xfc
 8009560:	f7fb fecb 	bl	80052fa <HwIfRead32>

  if( HBOOT_DPM_NETX4000_COOKIE == ulDpmNetxVersion )
 8009564:	4b08      	ldr	r3, [pc, #32]	; (8009588 <IsNetX4x00ROM+0x30>)
 8009566:	4298      	cmp	r0, r3
 8009568:	d004      	beq.n	8009574 <IsNetX4x00ROM+0x1c>
  {
    /* This is a netX4000 */
    ptDevInstance->eChipType = eCHIP_TYPE_NETX4000;
    iRet = 1;
  } else if( HBOOT_DPM_NETX4100_COOKIE == ulDpmNetxVersion )
 800956a:	4b08      	ldr	r3, [pc, #32]	; (800958c <IsNetX4x00ROM+0x34>)
 800956c:	4298      	cmp	r0, r3
 800956e:	d006      	beq.n	800957e <IsNetX4x00ROM+0x26>
  int iRet = 0;
 8009570:	2000      	movs	r0, #0
    /* This is a netX4100 */
    ptDevInstance->eChipType = eCHIP_TYPE_NETX4100;
    iRet = 1;
  }
  return iRet;
}
 8009572:	bd10      	pop	{r4, pc}
    ptDevInstance->eChipType = eCHIP_TYPE_NETX4000;
 8009574:	2307      	movs	r3, #7
 8009576:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    iRet = 1;
 800957a:	2001      	movs	r0, #1
 800957c:	e7f9      	b.n	8009572 <IsNetX4x00ROM+0x1a>
    ptDevInstance->eChipType = eCHIP_TYPE_NETX4100;
 800957e:	2308      	movs	r3, #8
 8009580:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    iRet = 1;
 8009584:	2001      	movs	r0, #1
 8009586:	e7f4      	b.n	8009572 <IsNetX4x00ROM+0x1a>
 8009588:	84524c0b 	.word	0x84524c0b
 800958c:	93615b0b 	.word	0x93615b0b

08009590 <IsNetX90FLASH>:
*
*   \param ptDevInstance        Current device instance
*   \return !=0 if netX90 has been detected                                  */
/*****************************************************************************/
int IsNetX90FLASH(PDEVICEINSTANCE ptDevInstance)
{
 8009590:	b510      	push	{r4, lr}
 8009592:	4604      	mov	r4, r0

  /* Use the netX global register block to detect the netX chip */
  /* Note: the pointer to the global register block is set in cifXStartDevice() */

  /* ulDpm_netx_version in register block (end of DPM memory) */
  ulDpmNetxVersion = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptDevInstance->ptGlobalRegisters->reserved6));
 8009594:	6d01      	ldr	r1, [r0, #80]	; 0x50
 8009596:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
 800959a:	f7fb feae 	bl	80052fa <HwIfRead32>

  /* Check for known version/cookie */
  if( HBOOT_DPM_NETX90_COOKIE == (ulMsk & ulDpmNetxVersion))
 800959e:	4b06      	ldr	r3, [pc, #24]	; (80095b8 <IsNetX90FLASH+0x28>)
 80095a0:	4003      	ands	r3, r0
 80095a2:	4a06      	ldr	r2, [pc, #24]	; (80095bc <IsNetX90FLASH+0x2c>)
 80095a4:	4293      	cmp	r3, r2
 80095a6:	d001      	beq.n	80095ac <IsNetX90FLASH+0x1c>
  int iRet = 0;
 80095a8:	2000      	movs	r0, #0
    ptDevInstance->eChipType = eCHIP_TYPE_NETX90;
    iRet = 1;
  }

  return iRet;
}
 80095aa:	bd10      	pop	{r4, pc}
    ptDevInstance->eChipType = eCHIP_TYPE_NETX90;
 80095ac:	2309      	movs	r3, #9
 80095ae:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    iRet = 1;
 80095b2:	2001      	movs	r0, #1
 80095b4:	e7f9      	b.n	80095aa <IsNetX90FLASH+0x1a>
 80095b6:	bf00      	nop
 80095b8:	ff0000ff 	.word	0xff0000ff
 80095bc:	0900000d 	.word	0x0900000d

080095c0 <IsNetX90ROM>:
*
*   \param ptDevInstance        Current device instance
*   \return !=0 if netX90 has been detected                                  */
/*****************************************************************************/
int IsNetX90ROM(PDEVICEINSTANCE ptDevInstance)
{
 80095c0:	b570      	push	{r4, r5, r6, lr}
 80095c2:	b084      	sub	sp, #16
 80095c4:	4604      	mov	r4, r0

  /* Mask out netX90 specific differentiation */
  uint32_t ulMsk = ~((uint32_t)MSK_HBOOT_DPM_NETX90_TYPE | MSK_HBOOT_DPM_NETX90_ROMSTEP);

  /* When checking at DPM start, also look for ROMcode cookie 'NXBL' at Offset 0x100 */
  uint32_t ulCookie = 0;
 80095c6:	2600      	movs	r6, #0
 80095c8:	9603      	str	r6, [sp, #12]
  HBOOT_V2_DPM_CFG_AREA_T* ptDpmCfg = (HBOOT_V2_DPM_CFG_AREA_T*)ptDevInstance->pbDPM;
 80095ca:	6a01      	ldr	r1, [r0, #32]

  ulDpmNetxVersion = LE32_TO_HOST(HWIF_READ32(ptDevInstance, ptDpmCfg->ulDpm_netx_version));
 80095cc:	31fc      	adds	r1, #252	; 0xfc
 80095ce:	f7fb fe94 	bl	80052fa <HwIfRead32>
 80095d2:	4605      	mov	r5, r0

  HWIF_READN(ptDevInstance, &ulCookie, (ptDevInstance->pbDPM + HBOOT_V2_DPM_ID_ADR), sizeof(ulCookie));
 80095d4:	6a22      	ldr	r2, [r4, #32]
 80095d6:	2304      	movs	r3, #4
 80095d8:	9300      	str	r3, [sp, #0]
 80095da:	ab03      	add	r3, sp, #12
 80095dc:	f502 7280 	add.w	r2, r2, #256	; 0x100
 80095e0:	4621      	mov	r1, r4
 80095e2:	4630      	mov	r0, r6
 80095e4:	f8d4 62c4 	ldr.w	r6, [r4, #708]	; 0x2c4
 80095e8:	47b0      	blx	r6

  if((HBOOT_DPM_NETX90_COOKIE       == (ulMsk & ulDpmNetxVersion)) &&
 80095ea:	4b09      	ldr	r3, [pc, #36]	; (8009610 <IsNetX90ROM+0x50>)
 80095ec:	402b      	ands	r3, r5
 80095ee:	4a09      	ldr	r2, [pc, #36]	; (8009614 <IsNetX90ROM+0x54>)
 80095f0:	4293      	cmp	r3, r2
 80095f2:	d002      	beq.n	80095fa <IsNetX90ROM+0x3a>
  int iRet = 0;
 80095f4:	2000      	movs	r0, #0
    ptDevInstance->eChipType = eCHIP_TYPE_NETX90;
    iRet = 1;
  }

  return iRet;
 80095f6:	b004      	add	sp, #16
 80095f8:	bd70      	pop	{r4, r5, r6, pc}
  if((HBOOT_DPM_NETX90_COOKIE       == (ulMsk & ulDpmNetxVersion)) &&
 80095fa:	9a03      	ldr	r2, [sp, #12]
 80095fc:	4b06      	ldr	r3, [pc, #24]	; (8009618 <IsNetX90ROM+0x58>)
 80095fe:	429a      	cmp	r2, r3
 8009600:	d001      	beq.n	8009606 <IsNetX90ROM+0x46>
  int iRet = 0;
 8009602:	2000      	movs	r0, #0
  return iRet;
 8009604:	e7f7      	b.n	80095f6 <IsNetX90ROM+0x36>
    ptDevInstance->eChipType = eCHIP_TYPE_NETX90;
 8009606:	2309      	movs	r3, #9
 8009608:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    iRet = 1;
 800960c:	2001      	movs	r0, #1
 800960e:	e7f2      	b.n	80095f6 <IsNetX90ROM+0x36>
 8009610:	ff0000ff 	.word	0xff0000ff
 8009614:	0900000d 	.word	0x0900000d
 8009618:	4c42584e 	.word	0x4c42584e

0800961c <USER_GetOSFile>:
*   \return != 0 on success                                                   */
/*****************************************************************************/
int USER_GetOSFile(PCIFX_DEVICE_INFORMATION ptDevInfo, PCIFX_FILE_INFORMATION ptFileInfo)
{
	return 0;
}
 800961c:	2000      	movs	r0, #0
 800961e:	4770      	bx	lr

08009620 <USER_GetFirmwareFileCount>:
*           USER_GetFirmwareFile                                             */
/*****************************************************************************/
uint32_t USER_GetFirmwareFileCount(PCIFX_DEVICE_INFORMATION ptDevInfo)
{
	return 0;
}
 8009620:	2000      	movs	r0, #0
 8009622:	4770      	bx	lr

08009624 <USER_GetFirmwareFile>:
*   \return !=0 on success                                                   */
/*****************************************************************************/
int USER_GetFirmwareFile(PCIFX_DEVICE_INFORMATION ptDevInfo, uint32_t ulIdx, PCIFX_FILE_INFORMATION ptFileInfo)
{
	return 0;
}
 8009624:	2000      	movs	r0, #0
 8009626:	4770      	bx	lr

08009628 <USER_GetConfigurationFileCount>:
*           USER_GetConfgirationFile                                         */
/*****************************************************************************/
uint32_t USER_GetConfigurationFileCount(PCIFX_DEVICE_INFORMATION ptDevInfo)
{
	return 0;
}
 8009628:	2000      	movs	r0, #0
 800962a:	4770      	bx	lr

0800962c <USER_GetConfigurationFile>:
*   \return !=0 on success                                                   */
/*****************************************************************************/
int USER_GetConfigurationFile(PCIFX_DEVICE_INFORMATION ptDevInfo, uint32_t ulIdx, PCIFX_FILE_INFORMATION ptFileInfo)
{
	return 0;
}
 800962c:	2000      	movs	r0, #0
 800962e:	4770      	bx	lr

08009630 <USER_GetBootloaderFile>:
*                     calls to OS_OpenFile()                                 */
/*****************************************************************************/
void USER_GetBootloaderFile(PDEVICEINSTANCE ptDevInstance, PCIFX_FILE_INFORMATION ptFileInfo)
{
	return;
}
 8009630:	4770      	bx	lr

08009632 <USER_GetWarmstartParameters>:
*   \return CIFX_NO_ERROR on success                                         */
/*****************************************************************************/
int USER_GetWarmstartParameters(PCIFX_DEVICE_INFORMATION ptDevInfo, CIFX_PACKET* ptPacket)
{
	return 0;
}
 8009632:	2000      	movs	r0, #0
 8009634:	4770      	bx	lr

08009636 <USER_GetAliasName>:
*                    no alias                                                */
/*****************************************************************************/
void USER_GetAliasName(PCIFX_DEVICE_INFORMATION ptDevInfo, uint32_t ulMaxLen, char* szAlias)
{
	return;
}
 8009636:	4770      	bx	lr

08009638 <USER_GetInterruptEnable>:
*   \return !=0 to enable interrupts                                         */
/*****************************************************************************/
int USER_GetInterruptEnable(PCIFX_DEVICE_INFORMATION ptDevInfo)
{
	return 0;
}
 8009638:	2000      	movs	r0, #0
 800963a:	4770      	bx	lr

0800963c <USER_GetCachedIOBufferMode>:
*   \return eCACHED_MODE_ON to enable caching                                */
/*****************************************************************************/
int USER_GetCachedIOBufferMode(PCIFX_DEVICE_INFORMATION ptDevInfo)
{
	return 0;
}
 800963c:	2000      	movs	r0, #0
 800963e:	4770      	bx	lr

08009640 <USER_Trace>:
*   \param ptDevInstance  Device instance
*   \param ulTraceLevel   Trace level
*   \param szFormat       Format string                                      */
/*****************************************************************************/
void USER_Trace(PDEVICEINSTANCE ptDevInstance, uint32_t ulTraceLevel, const char* szFormat, ...)
{
 8009640:	b40c      	push	{r2, r3}
  /* Add an new line on the end of the trace strings if necessary */
  /* e.g. printf("\r\n\"); */
}
 8009642:	b002      	add	sp, #8
 8009644:	4770      	bx	lr
	...

08009648 <__assert_func>:
 8009648:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800964a:	4614      	mov	r4, r2
 800964c:	461a      	mov	r2, r3
 800964e:	4b09      	ldr	r3, [pc, #36]	; (8009674 <__assert_func+0x2c>)
 8009650:	681b      	ldr	r3, [r3, #0]
 8009652:	4605      	mov	r5, r0
 8009654:	68d8      	ldr	r0, [r3, #12]
 8009656:	b14c      	cbz	r4, 800966c <__assert_func+0x24>
 8009658:	4b07      	ldr	r3, [pc, #28]	; (8009678 <__assert_func+0x30>)
 800965a:	9100      	str	r1, [sp, #0]
 800965c:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8009660:	4906      	ldr	r1, [pc, #24]	; (800967c <__assert_func+0x34>)
 8009662:	462b      	mov	r3, r5
 8009664:	f000 f9b2 	bl	80099cc <fiprintf>
 8009668:	f000 fb2c 	bl	8009cc4 <abort>
 800966c:	4b04      	ldr	r3, [pc, #16]	; (8009680 <__assert_func+0x38>)
 800966e:	461c      	mov	r4, r3
 8009670:	e7f3      	b.n	800965a <__assert_func+0x12>
 8009672:	bf00      	nop
 8009674:	20000094 	.word	0x20000094
 8009678:	0800cd05 	.word	0x0800cd05
 800967c:	0800cd12 	.word	0x0800cd12
 8009680:	0800cd40 	.word	0x0800cd40

08009684 <calloc>:
 8009684:	4b02      	ldr	r3, [pc, #8]	; (8009690 <calloc+0xc>)
 8009686:	460a      	mov	r2, r1
 8009688:	4601      	mov	r1, r0
 800968a:	6818      	ldr	r0, [r3, #0]
 800968c:	f000 b802 	b.w	8009694 <_calloc_r>
 8009690:	20000094 	.word	0x20000094

08009694 <_calloc_r>:
 8009694:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8009696:	fba1 2402 	umull	r2, r4, r1, r2
 800969a:	b94c      	cbnz	r4, 80096b0 <_calloc_r+0x1c>
 800969c:	4611      	mov	r1, r2
 800969e:	9201      	str	r2, [sp, #4]
 80096a0:	f000 f83e 	bl	8009720 <_malloc_r>
 80096a4:	9a01      	ldr	r2, [sp, #4]
 80096a6:	4605      	mov	r5, r0
 80096a8:	b930      	cbnz	r0, 80096b8 <_calloc_r+0x24>
 80096aa:	4628      	mov	r0, r5
 80096ac:	b003      	add	sp, #12
 80096ae:	bd30      	pop	{r4, r5, pc}
 80096b0:	220c      	movs	r2, #12
 80096b2:	6002      	str	r2, [r0, #0]
 80096b4:	2500      	movs	r5, #0
 80096b6:	e7f8      	b.n	80096aa <_calloc_r+0x16>
 80096b8:	4621      	mov	r1, r4
 80096ba:	f000 fa36 	bl	8009b2a <memset>
 80096be:	e7f4      	b.n	80096aa <_calloc_r+0x16>

080096c0 <malloc>:
 80096c0:	4b02      	ldr	r3, [pc, #8]	; (80096cc <malloc+0xc>)
 80096c2:	4601      	mov	r1, r0
 80096c4:	6818      	ldr	r0, [r3, #0]
 80096c6:	f000 b82b 	b.w	8009720 <_malloc_r>
 80096ca:	bf00      	nop
 80096cc:	20000094 	.word	0x20000094

080096d0 <free>:
 80096d0:	4b02      	ldr	r3, [pc, #8]	; (80096dc <free+0xc>)
 80096d2:	4601      	mov	r1, r0
 80096d4:	6818      	ldr	r0, [r3, #0]
 80096d6:	f000 bafd 	b.w	8009cd4 <_free_r>
 80096da:	bf00      	nop
 80096dc:	20000094 	.word	0x20000094

080096e0 <sbrk_aligned>:
 80096e0:	b570      	push	{r4, r5, r6, lr}
 80096e2:	4e0e      	ldr	r6, [pc, #56]	; (800971c <sbrk_aligned+0x3c>)
 80096e4:	460c      	mov	r4, r1
 80096e6:	6831      	ldr	r1, [r6, #0]
 80096e8:	4605      	mov	r5, r0
 80096ea:	b911      	cbnz	r1, 80096f2 <sbrk_aligned+0x12>
 80096ec:	f000 fa8e 	bl	8009c0c <_sbrk_r>
 80096f0:	6030      	str	r0, [r6, #0]
 80096f2:	4621      	mov	r1, r4
 80096f4:	4628      	mov	r0, r5
 80096f6:	f000 fa89 	bl	8009c0c <_sbrk_r>
 80096fa:	1c43      	adds	r3, r0, #1
 80096fc:	d00a      	beq.n	8009714 <sbrk_aligned+0x34>
 80096fe:	1cc4      	adds	r4, r0, #3
 8009700:	f024 0403 	bic.w	r4, r4, #3
 8009704:	42a0      	cmp	r0, r4
 8009706:	d007      	beq.n	8009718 <sbrk_aligned+0x38>
 8009708:	1a21      	subs	r1, r4, r0
 800970a:	4628      	mov	r0, r5
 800970c:	f000 fa7e 	bl	8009c0c <_sbrk_r>
 8009710:	3001      	adds	r0, #1
 8009712:	d101      	bne.n	8009718 <sbrk_aligned+0x38>
 8009714:	f04f 34ff 	mov.w	r4, #4294967295
 8009718:	4620      	mov	r0, r4
 800971a:	bd70      	pop	{r4, r5, r6, pc}
 800971c:	20000224 	.word	0x20000224

08009720 <_malloc_r>:
 8009720:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8009724:	1ccd      	adds	r5, r1, #3
 8009726:	f025 0503 	bic.w	r5, r5, #3
 800972a:	3508      	adds	r5, #8
 800972c:	2d0c      	cmp	r5, #12
 800972e:	bf38      	it	cc
 8009730:	250c      	movcc	r5, #12
 8009732:	2d00      	cmp	r5, #0
 8009734:	4607      	mov	r7, r0
 8009736:	db01      	blt.n	800973c <_malloc_r+0x1c>
 8009738:	42a9      	cmp	r1, r5
 800973a:	d905      	bls.n	8009748 <_malloc_r+0x28>
 800973c:	230c      	movs	r3, #12
 800973e:	603b      	str	r3, [r7, #0]
 8009740:	2600      	movs	r6, #0
 8009742:	4630      	mov	r0, r6
 8009744:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8009748:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 800981c <_malloc_r+0xfc>
 800974c:	f000 f868 	bl	8009820 <__malloc_lock>
 8009750:	f8d8 3000 	ldr.w	r3, [r8]
 8009754:	461c      	mov	r4, r3
 8009756:	bb5c      	cbnz	r4, 80097b0 <_malloc_r+0x90>
 8009758:	4629      	mov	r1, r5
 800975a:	4638      	mov	r0, r7
 800975c:	f7ff ffc0 	bl	80096e0 <sbrk_aligned>
 8009760:	1c43      	adds	r3, r0, #1
 8009762:	4604      	mov	r4, r0
 8009764:	d155      	bne.n	8009812 <_malloc_r+0xf2>
 8009766:	f8d8 4000 	ldr.w	r4, [r8]
 800976a:	4626      	mov	r6, r4
 800976c:	2e00      	cmp	r6, #0
 800976e:	d145      	bne.n	80097fc <_malloc_r+0xdc>
 8009770:	2c00      	cmp	r4, #0
 8009772:	d048      	beq.n	8009806 <_malloc_r+0xe6>
 8009774:	6823      	ldr	r3, [r4, #0]
 8009776:	4631      	mov	r1, r6
 8009778:	4638      	mov	r0, r7
 800977a:	eb04 0903 	add.w	r9, r4, r3
 800977e:	f000 fa45 	bl	8009c0c <_sbrk_r>
 8009782:	4581      	cmp	r9, r0
 8009784:	d13f      	bne.n	8009806 <_malloc_r+0xe6>
 8009786:	6821      	ldr	r1, [r4, #0]
 8009788:	1a6d      	subs	r5, r5, r1
 800978a:	4629      	mov	r1, r5
 800978c:	4638      	mov	r0, r7
 800978e:	f7ff ffa7 	bl	80096e0 <sbrk_aligned>
 8009792:	3001      	adds	r0, #1
 8009794:	d037      	beq.n	8009806 <_malloc_r+0xe6>
 8009796:	6823      	ldr	r3, [r4, #0]
 8009798:	442b      	add	r3, r5
 800979a:	6023      	str	r3, [r4, #0]
 800979c:	f8d8 3000 	ldr.w	r3, [r8]
 80097a0:	2b00      	cmp	r3, #0
 80097a2:	d038      	beq.n	8009816 <_malloc_r+0xf6>
 80097a4:	685a      	ldr	r2, [r3, #4]
 80097a6:	42a2      	cmp	r2, r4
 80097a8:	d12b      	bne.n	8009802 <_malloc_r+0xe2>
 80097aa:	2200      	movs	r2, #0
 80097ac:	605a      	str	r2, [r3, #4]
 80097ae:	e00f      	b.n	80097d0 <_malloc_r+0xb0>
 80097b0:	6822      	ldr	r2, [r4, #0]
 80097b2:	1b52      	subs	r2, r2, r5
 80097b4:	d41f      	bmi.n	80097f6 <_malloc_r+0xd6>
 80097b6:	2a0b      	cmp	r2, #11
 80097b8:	d917      	bls.n	80097ea <_malloc_r+0xca>
 80097ba:	1961      	adds	r1, r4, r5
 80097bc:	42a3      	cmp	r3, r4
 80097be:	6025      	str	r5, [r4, #0]
 80097c0:	bf18      	it	ne
 80097c2:	6059      	strne	r1, [r3, #4]
 80097c4:	6863      	ldr	r3, [r4, #4]
 80097c6:	bf08      	it	eq
 80097c8:	f8c8 1000 	streq.w	r1, [r8]
 80097cc:	5162      	str	r2, [r4, r5]
 80097ce:	604b      	str	r3, [r1, #4]
 80097d0:	4638      	mov	r0, r7
 80097d2:	f104 060b 	add.w	r6, r4, #11
 80097d6:	f000 f829 	bl	800982c <__malloc_unlock>
 80097da:	f026 0607 	bic.w	r6, r6, #7
 80097de:	1d23      	adds	r3, r4, #4
 80097e0:	1af2      	subs	r2, r6, r3
 80097e2:	d0ae      	beq.n	8009742 <_malloc_r+0x22>
 80097e4:	1b9b      	subs	r3, r3, r6
 80097e6:	50a3      	str	r3, [r4, r2]
 80097e8:	e7ab      	b.n	8009742 <_malloc_r+0x22>
 80097ea:	42a3      	cmp	r3, r4
 80097ec:	6862      	ldr	r2, [r4, #4]
 80097ee:	d1dd      	bne.n	80097ac <_malloc_r+0x8c>
 80097f0:	f8c8 2000 	str.w	r2, [r8]
 80097f4:	e7ec      	b.n	80097d0 <_malloc_r+0xb0>
 80097f6:	4623      	mov	r3, r4
 80097f8:	6864      	ldr	r4, [r4, #4]
 80097fa:	e7ac      	b.n	8009756 <_malloc_r+0x36>
 80097fc:	4634      	mov	r4, r6
 80097fe:	6876      	ldr	r6, [r6, #4]
 8009800:	e7b4      	b.n	800976c <_malloc_r+0x4c>
 8009802:	4613      	mov	r3, r2
 8009804:	e7cc      	b.n	80097a0 <_malloc_r+0x80>
 8009806:	230c      	movs	r3, #12
 8009808:	603b      	str	r3, [r7, #0]
 800980a:	4638      	mov	r0, r7
 800980c:	f000 f80e 	bl	800982c <__malloc_unlock>
 8009810:	e797      	b.n	8009742 <_malloc_r+0x22>
 8009812:	6025      	str	r5, [r4, #0]
 8009814:	e7dc      	b.n	80097d0 <_malloc_r+0xb0>
 8009816:	605b      	str	r3, [r3, #4]
 8009818:	deff      	udf	#255	; 0xff
 800981a:	bf00      	nop
 800981c:	20000220 	.word	0x20000220

08009820 <__malloc_lock>:
 8009820:	4801      	ldr	r0, [pc, #4]	; (8009828 <__malloc_lock+0x8>)
 8009822:	f000 ba3f 	b.w	8009ca4 <__retarget_lock_acquire_recursive>
 8009826:	bf00      	nop
 8009828:	20000368 	.word	0x20000368

0800982c <__malloc_unlock>:
 800982c:	4801      	ldr	r0, [pc, #4]	; (8009834 <__malloc_unlock+0x8>)
 800982e:	f000 ba3a 	b.w	8009ca6 <__retarget_lock_release_recursive>
 8009832:	bf00      	nop
 8009834:	20000368 	.word	0x20000368

08009838 <realloc>:
 8009838:	4b02      	ldr	r3, [pc, #8]	; (8009844 <realloc+0xc>)
 800983a:	460a      	mov	r2, r1
 800983c:	4601      	mov	r1, r0
 800983e:	6818      	ldr	r0, [r3, #0]
 8009840:	f000 b802 	b.w	8009848 <_realloc_r>
 8009844:	20000094 	.word	0x20000094

08009848 <_realloc_r>:
 8009848:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800984c:	4680      	mov	r8, r0
 800984e:	4614      	mov	r4, r2
 8009850:	460e      	mov	r6, r1
 8009852:	b921      	cbnz	r1, 800985e <_realloc_r+0x16>
 8009854:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8009858:	4611      	mov	r1, r2
 800985a:	f7ff bf61 	b.w	8009720 <_malloc_r>
 800985e:	b92a      	cbnz	r2, 800986c <_realloc_r+0x24>
 8009860:	f000 fa38 	bl	8009cd4 <_free_r>
 8009864:	4625      	mov	r5, r4
 8009866:	4628      	mov	r0, r5
 8009868:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800986c:	f000 fa7e 	bl	8009d6c <_malloc_usable_size_r>
 8009870:	4284      	cmp	r4, r0
 8009872:	4607      	mov	r7, r0
 8009874:	d802      	bhi.n	800987c <_realloc_r+0x34>
 8009876:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 800987a:	d812      	bhi.n	80098a2 <_realloc_r+0x5a>
 800987c:	4621      	mov	r1, r4
 800987e:	4640      	mov	r0, r8
 8009880:	f7ff ff4e 	bl	8009720 <_malloc_r>
 8009884:	4605      	mov	r5, r0
 8009886:	2800      	cmp	r0, #0
 8009888:	d0ed      	beq.n	8009866 <_realloc_r+0x1e>
 800988a:	42bc      	cmp	r4, r7
 800988c:	4622      	mov	r2, r4
 800988e:	4631      	mov	r1, r6
 8009890:	bf28      	it	cs
 8009892:	463a      	movcs	r2, r7
 8009894:	f000 fa08 	bl	8009ca8 <memcpy>
 8009898:	4631      	mov	r1, r6
 800989a:	4640      	mov	r0, r8
 800989c:	f000 fa1a 	bl	8009cd4 <_free_r>
 80098a0:	e7e1      	b.n	8009866 <_realloc_r+0x1e>
 80098a2:	4635      	mov	r5, r6
 80098a4:	e7df      	b.n	8009866 <_realloc_r+0x1e>
	...

080098a8 <std>:
 80098a8:	2300      	movs	r3, #0
 80098aa:	b510      	push	{r4, lr}
 80098ac:	4604      	mov	r4, r0
 80098ae:	e9c0 3300 	strd	r3, r3, [r0]
 80098b2:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80098b6:	6083      	str	r3, [r0, #8]
 80098b8:	8181      	strh	r1, [r0, #12]
 80098ba:	6643      	str	r3, [r0, #100]	; 0x64
 80098bc:	81c2      	strh	r2, [r0, #14]
 80098be:	6183      	str	r3, [r0, #24]
 80098c0:	4619      	mov	r1, r3
 80098c2:	2208      	movs	r2, #8
 80098c4:	305c      	adds	r0, #92	; 0x5c
 80098c6:	f000 f930 	bl	8009b2a <memset>
 80098ca:	4b05      	ldr	r3, [pc, #20]	; (80098e0 <std+0x38>)
 80098cc:	6263      	str	r3, [r4, #36]	; 0x24
 80098ce:	4b05      	ldr	r3, [pc, #20]	; (80098e4 <std+0x3c>)
 80098d0:	62a3      	str	r3, [r4, #40]	; 0x28
 80098d2:	4b05      	ldr	r3, [pc, #20]	; (80098e8 <std+0x40>)
 80098d4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80098d6:	4b05      	ldr	r3, [pc, #20]	; (80098ec <std+0x44>)
 80098d8:	6224      	str	r4, [r4, #32]
 80098da:	6323      	str	r3, [r4, #48]	; 0x30
 80098dc:	bd10      	pop	{r4, pc}
 80098de:	bf00      	nop
 80098e0:	08009a51 	.word	0x08009a51
 80098e4:	08009a73 	.word	0x08009a73
 80098e8:	08009aab 	.word	0x08009aab
 80098ec:	08009acf 	.word	0x08009acf

080098f0 <stdio_exit_handler>:
 80098f0:	4a02      	ldr	r2, [pc, #8]	; (80098fc <stdio_exit_handler+0xc>)
 80098f2:	4903      	ldr	r1, [pc, #12]	; (8009900 <stdio_exit_handler+0x10>)
 80098f4:	4803      	ldr	r0, [pc, #12]	; (8009904 <stdio_exit_handler+0x14>)
 80098f6:	f000 b87b 	b.w	80099f0 <_fwalk_sglue>
 80098fa:	bf00      	nop
 80098fc:	2000003c 	.word	0x2000003c
 8009900:	0800a431 	.word	0x0800a431
 8009904:	20000048 	.word	0x20000048

08009908 <cleanup_stdio>:
 8009908:	6841      	ldr	r1, [r0, #4]
 800990a:	4b0c      	ldr	r3, [pc, #48]	; (800993c <cleanup_stdio+0x34>)
 800990c:	4299      	cmp	r1, r3
 800990e:	b510      	push	{r4, lr}
 8009910:	4604      	mov	r4, r0
 8009912:	d001      	beq.n	8009918 <cleanup_stdio+0x10>
 8009914:	f000 fd8c 	bl	800a430 <_fflush_r>
 8009918:	68a1      	ldr	r1, [r4, #8]
 800991a:	4b09      	ldr	r3, [pc, #36]	; (8009940 <cleanup_stdio+0x38>)
 800991c:	4299      	cmp	r1, r3
 800991e:	d002      	beq.n	8009926 <cleanup_stdio+0x1e>
 8009920:	4620      	mov	r0, r4
 8009922:	f000 fd85 	bl	800a430 <_fflush_r>
 8009926:	68e1      	ldr	r1, [r4, #12]
 8009928:	4b06      	ldr	r3, [pc, #24]	; (8009944 <cleanup_stdio+0x3c>)
 800992a:	4299      	cmp	r1, r3
 800992c:	d004      	beq.n	8009938 <cleanup_stdio+0x30>
 800992e:	4620      	mov	r0, r4
 8009930:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8009934:	f000 bd7c 	b.w	800a430 <_fflush_r>
 8009938:	bd10      	pop	{r4, pc}
 800993a:	bf00      	nop
 800993c:	20000228 	.word	0x20000228
 8009940:	20000290 	.word	0x20000290
 8009944:	200002f8 	.word	0x200002f8

08009948 <global_stdio_init.part.0>:
 8009948:	b510      	push	{r4, lr}
 800994a:	4b0b      	ldr	r3, [pc, #44]	; (8009978 <global_stdio_init.part.0+0x30>)
 800994c:	4c0b      	ldr	r4, [pc, #44]	; (800997c <global_stdio_init.part.0+0x34>)
 800994e:	4a0c      	ldr	r2, [pc, #48]	; (8009980 <global_stdio_init.part.0+0x38>)
 8009950:	601a      	str	r2, [r3, #0]
 8009952:	4620      	mov	r0, r4
 8009954:	2200      	movs	r2, #0
 8009956:	2104      	movs	r1, #4
 8009958:	f7ff ffa6 	bl	80098a8 <std>
 800995c:	f104 0068 	add.w	r0, r4, #104	; 0x68
 8009960:	2201      	movs	r2, #1
 8009962:	2109      	movs	r1, #9
 8009964:	f7ff ffa0 	bl	80098a8 <std>
 8009968:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 800996c:	2202      	movs	r2, #2
 800996e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8009972:	2112      	movs	r1, #18
 8009974:	f7ff bf98 	b.w	80098a8 <std>
 8009978:	20000360 	.word	0x20000360
 800997c:	20000228 	.word	0x20000228
 8009980:	080098f1 	.word	0x080098f1

08009984 <__sfp_lock_acquire>:
 8009984:	4801      	ldr	r0, [pc, #4]	; (800998c <__sfp_lock_acquire+0x8>)
 8009986:	f000 b98d 	b.w	8009ca4 <__retarget_lock_acquire_recursive>
 800998a:	bf00      	nop
 800998c:	20000369 	.word	0x20000369

08009990 <__sfp_lock_release>:
 8009990:	4801      	ldr	r0, [pc, #4]	; (8009998 <__sfp_lock_release+0x8>)
 8009992:	f000 b988 	b.w	8009ca6 <__retarget_lock_release_recursive>
 8009996:	bf00      	nop
 8009998:	20000369 	.word	0x20000369

0800999c <__sinit>:
 800999c:	b510      	push	{r4, lr}
 800999e:	4604      	mov	r4, r0
 80099a0:	f7ff fff0 	bl	8009984 <__sfp_lock_acquire>
 80099a4:	6a23      	ldr	r3, [r4, #32]
 80099a6:	b11b      	cbz	r3, 80099b0 <__sinit+0x14>
 80099a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80099ac:	f7ff bff0 	b.w	8009990 <__sfp_lock_release>
 80099b0:	4b04      	ldr	r3, [pc, #16]	; (80099c4 <__sinit+0x28>)
 80099b2:	6223      	str	r3, [r4, #32]
 80099b4:	4b04      	ldr	r3, [pc, #16]	; (80099c8 <__sinit+0x2c>)
 80099b6:	681b      	ldr	r3, [r3, #0]
 80099b8:	2b00      	cmp	r3, #0
 80099ba:	d1f5      	bne.n	80099a8 <__sinit+0xc>
 80099bc:	f7ff ffc4 	bl	8009948 <global_stdio_init.part.0>
 80099c0:	e7f2      	b.n	80099a8 <__sinit+0xc>
 80099c2:	bf00      	nop
 80099c4:	08009909 	.word	0x08009909
 80099c8:	20000360 	.word	0x20000360

080099cc <fiprintf>:
 80099cc:	b40e      	push	{r1, r2, r3}
 80099ce:	b503      	push	{r0, r1, lr}
 80099d0:	4601      	mov	r1, r0
 80099d2:	ab03      	add	r3, sp, #12
 80099d4:	4805      	ldr	r0, [pc, #20]	; (80099ec <fiprintf+0x20>)
 80099d6:	f853 2b04 	ldr.w	r2, [r3], #4
 80099da:	6800      	ldr	r0, [r0, #0]
 80099dc:	9301      	str	r3, [sp, #4]
 80099de:	f000 f9f7 	bl	8009dd0 <_vfiprintf_r>
 80099e2:	b002      	add	sp, #8
 80099e4:	f85d eb04 	ldr.w	lr, [sp], #4
 80099e8:	b003      	add	sp, #12
 80099ea:	4770      	bx	lr
 80099ec:	20000094 	.word	0x20000094

080099f0 <_fwalk_sglue>:
 80099f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80099f4:	4607      	mov	r7, r0
 80099f6:	4688      	mov	r8, r1
 80099f8:	4614      	mov	r4, r2
 80099fa:	2600      	movs	r6, #0
 80099fc:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8009a00:	f1b9 0901 	subs.w	r9, r9, #1
 8009a04:	d505      	bpl.n	8009a12 <_fwalk_sglue+0x22>
 8009a06:	6824      	ldr	r4, [r4, #0]
 8009a08:	2c00      	cmp	r4, #0
 8009a0a:	d1f7      	bne.n	80099fc <_fwalk_sglue+0xc>
 8009a0c:	4630      	mov	r0, r6
 8009a0e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8009a12:	89ab      	ldrh	r3, [r5, #12]
 8009a14:	2b01      	cmp	r3, #1
 8009a16:	d907      	bls.n	8009a28 <_fwalk_sglue+0x38>
 8009a18:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8009a1c:	3301      	adds	r3, #1
 8009a1e:	d003      	beq.n	8009a28 <_fwalk_sglue+0x38>
 8009a20:	4629      	mov	r1, r5
 8009a22:	4638      	mov	r0, r7
 8009a24:	47c0      	blx	r8
 8009a26:	4306      	orrs	r6, r0
 8009a28:	3568      	adds	r5, #104	; 0x68
 8009a2a:	e7e9      	b.n	8009a00 <_fwalk_sglue+0x10>

08009a2c <iprintf>:
 8009a2c:	b40f      	push	{r0, r1, r2, r3}
 8009a2e:	b507      	push	{r0, r1, r2, lr}
 8009a30:	4906      	ldr	r1, [pc, #24]	; (8009a4c <iprintf+0x20>)
 8009a32:	ab04      	add	r3, sp, #16
 8009a34:	6808      	ldr	r0, [r1, #0]
 8009a36:	f853 2b04 	ldr.w	r2, [r3], #4
 8009a3a:	6881      	ldr	r1, [r0, #8]
 8009a3c:	9301      	str	r3, [sp, #4]
 8009a3e:	f000 f9c7 	bl	8009dd0 <_vfiprintf_r>
 8009a42:	b003      	add	sp, #12
 8009a44:	f85d eb04 	ldr.w	lr, [sp], #4
 8009a48:	b004      	add	sp, #16
 8009a4a:	4770      	bx	lr
 8009a4c:	20000094 	.word	0x20000094

08009a50 <__sread>:
 8009a50:	b510      	push	{r4, lr}
 8009a52:	460c      	mov	r4, r1
 8009a54:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8009a58:	f000 f8c6 	bl	8009be8 <_read_r>
 8009a5c:	2800      	cmp	r0, #0
 8009a5e:	bfab      	itete	ge
 8009a60:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8009a62:	89a3      	ldrhlt	r3, [r4, #12]
 8009a64:	181b      	addge	r3, r3, r0
 8009a66:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8009a6a:	bfac      	ite	ge
 8009a6c:	6563      	strge	r3, [r4, #84]	; 0x54
 8009a6e:	81a3      	strhlt	r3, [r4, #12]
 8009a70:	bd10      	pop	{r4, pc}

08009a72 <__swrite>:
 8009a72:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009a76:	461f      	mov	r7, r3
 8009a78:	898b      	ldrh	r3, [r1, #12]
 8009a7a:	05db      	lsls	r3, r3, #23
 8009a7c:	4605      	mov	r5, r0
 8009a7e:	460c      	mov	r4, r1
 8009a80:	4616      	mov	r6, r2
 8009a82:	d505      	bpl.n	8009a90 <__swrite+0x1e>
 8009a84:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8009a88:	2302      	movs	r3, #2
 8009a8a:	2200      	movs	r2, #0
 8009a8c:	f000 f89a 	bl	8009bc4 <_lseek_r>
 8009a90:	89a3      	ldrh	r3, [r4, #12]
 8009a92:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8009a96:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8009a9a:	81a3      	strh	r3, [r4, #12]
 8009a9c:	4632      	mov	r2, r6
 8009a9e:	463b      	mov	r3, r7
 8009aa0:	4628      	mov	r0, r5
 8009aa2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8009aa6:	f000 b8c1 	b.w	8009c2c <_write_r>

08009aaa <__sseek>:
 8009aaa:	b510      	push	{r4, lr}
 8009aac:	460c      	mov	r4, r1
 8009aae:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8009ab2:	f000 f887 	bl	8009bc4 <_lseek_r>
 8009ab6:	1c43      	adds	r3, r0, #1
 8009ab8:	89a3      	ldrh	r3, [r4, #12]
 8009aba:	bf15      	itete	ne
 8009abc:	6560      	strne	r0, [r4, #84]	; 0x54
 8009abe:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8009ac2:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8009ac6:	81a3      	strheq	r3, [r4, #12]
 8009ac8:	bf18      	it	ne
 8009aca:	81a3      	strhne	r3, [r4, #12]
 8009acc:	bd10      	pop	{r4, pc}

08009ace <__sclose>:
 8009ace:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8009ad2:	f000 b867 	b.w	8009ba4 <_close_r>

08009ad6 <memcmp>:
 8009ad6:	b510      	push	{r4, lr}
 8009ad8:	3901      	subs	r1, #1
 8009ada:	4402      	add	r2, r0
 8009adc:	4290      	cmp	r0, r2
 8009ade:	d101      	bne.n	8009ae4 <memcmp+0xe>
 8009ae0:	2000      	movs	r0, #0
 8009ae2:	e005      	b.n	8009af0 <memcmp+0x1a>
 8009ae4:	7803      	ldrb	r3, [r0, #0]
 8009ae6:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8009aea:	42a3      	cmp	r3, r4
 8009aec:	d001      	beq.n	8009af2 <memcmp+0x1c>
 8009aee:	1b18      	subs	r0, r3, r4
 8009af0:	bd10      	pop	{r4, pc}
 8009af2:	3001      	adds	r0, #1
 8009af4:	e7f2      	b.n	8009adc <memcmp+0x6>

08009af6 <memmove>:
 8009af6:	4288      	cmp	r0, r1
 8009af8:	b510      	push	{r4, lr}
 8009afa:	eb01 0402 	add.w	r4, r1, r2
 8009afe:	d902      	bls.n	8009b06 <memmove+0x10>
 8009b00:	4284      	cmp	r4, r0
 8009b02:	4623      	mov	r3, r4
 8009b04:	d807      	bhi.n	8009b16 <memmove+0x20>
 8009b06:	1e43      	subs	r3, r0, #1
 8009b08:	42a1      	cmp	r1, r4
 8009b0a:	d008      	beq.n	8009b1e <memmove+0x28>
 8009b0c:	f811 2b01 	ldrb.w	r2, [r1], #1
 8009b10:	f803 2f01 	strb.w	r2, [r3, #1]!
 8009b14:	e7f8      	b.n	8009b08 <memmove+0x12>
 8009b16:	4402      	add	r2, r0
 8009b18:	4601      	mov	r1, r0
 8009b1a:	428a      	cmp	r2, r1
 8009b1c:	d100      	bne.n	8009b20 <memmove+0x2a>
 8009b1e:	bd10      	pop	{r4, pc}
 8009b20:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8009b24:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8009b28:	e7f7      	b.n	8009b1a <memmove+0x24>

08009b2a <memset>:
 8009b2a:	4402      	add	r2, r0
 8009b2c:	4603      	mov	r3, r0
 8009b2e:	4293      	cmp	r3, r2
 8009b30:	d100      	bne.n	8009b34 <memset+0xa>
 8009b32:	4770      	bx	lr
 8009b34:	f803 1b01 	strb.w	r1, [r3], #1
 8009b38:	e7f9      	b.n	8009b2e <memset+0x4>
	...

08009b3c <strncasecmp>:
 8009b3c:	b570      	push	{r4, r5, r6, lr}
 8009b3e:	4e0e      	ldr	r6, [pc, #56]	; (8009b78 <strncasecmp+0x3c>)
 8009b40:	4605      	mov	r5, r0
 8009b42:	440a      	add	r2, r1
 8009b44:	428a      	cmp	r2, r1
 8009b46:	d101      	bne.n	8009b4c <strncasecmp+0x10>
 8009b48:	2000      	movs	r0, #0
 8009b4a:	e013      	b.n	8009b74 <strncasecmp+0x38>
 8009b4c:	f815 3b01 	ldrb.w	r3, [r5], #1
 8009b50:	f811 4b01 	ldrb.w	r4, [r1], #1
 8009b54:	5cf0      	ldrb	r0, [r6, r3]
 8009b56:	f000 0003 	and.w	r0, r0, #3
 8009b5a:	2801      	cmp	r0, #1
 8009b5c:	5d30      	ldrb	r0, [r6, r4]
 8009b5e:	f000 0003 	and.w	r0, r0, #3
 8009b62:	bf08      	it	eq
 8009b64:	3320      	addeq	r3, #32
 8009b66:	2801      	cmp	r0, #1
 8009b68:	bf08      	it	eq
 8009b6a:	3420      	addeq	r4, #32
 8009b6c:	1b18      	subs	r0, r3, r4
 8009b6e:	d101      	bne.n	8009b74 <strncasecmp+0x38>
 8009b70:	2c00      	cmp	r4, #0
 8009b72:	d1e7      	bne.n	8009b44 <strncasecmp+0x8>
 8009b74:	bd70      	pop	{r4, r5, r6, pc}
 8009b76:	bf00      	nop
 8009b78:	0800cd42 	.word	0x0800cd42

08009b7c <strncpy>:
 8009b7c:	b510      	push	{r4, lr}
 8009b7e:	3901      	subs	r1, #1
 8009b80:	4603      	mov	r3, r0
 8009b82:	b132      	cbz	r2, 8009b92 <strncpy+0x16>
 8009b84:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8009b88:	f803 4b01 	strb.w	r4, [r3], #1
 8009b8c:	3a01      	subs	r2, #1
 8009b8e:	2c00      	cmp	r4, #0
 8009b90:	d1f7      	bne.n	8009b82 <strncpy+0x6>
 8009b92:	441a      	add	r2, r3
 8009b94:	2100      	movs	r1, #0
 8009b96:	4293      	cmp	r3, r2
 8009b98:	d100      	bne.n	8009b9c <strncpy+0x20>
 8009b9a:	bd10      	pop	{r4, pc}
 8009b9c:	f803 1b01 	strb.w	r1, [r3], #1
 8009ba0:	e7f9      	b.n	8009b96 <strncpy+0x1a>
	...

08009ba4 <_close_r>:
 8009ba4:	b538      	push	{r3, r4, r5, lr}
 8009ba6:	4d06      	ldr	r5, [pc, #24]	; (8009bc0 <_close_r+0x1c>)
 8009ba8:	2300      	movs	r3, #0
 8009baa:	4604      	mov	r4, r0
 8009bac:	4608      	mov	r0, r1
 8009bae:	602b      	str	r3, [r5, #0]
 8009bb0:	f7f6 ff84 	bl	8000abc <_close>
 8009bb4:	1c43      	adds	r3, r0, #1
 8009bb6:	d102      	bne.n	8009bbe <_close_r+0x1a>
 8009bb8:	682b      	ldr	r3, [r5, #0]
 8009bba:	b103      	cbz	r3, 8009bbe <_close_r+0x1a>
 8009bbc:	6023      	str	r3, [r4, #0]
 8009bbe:	bd38      	pop	{r3, r4, r5, pc}
 8009bc0:	20000364 	.word	0x20000364

08009bc4 <_lseek_r>:
 8009bc4:	b538      	push	{r3, r4, r5, lr}
 8009bc6:	4d07      	ldr	r5, [pc, #28]	; (8009be4 <_lseek_r+0x20>)
 8009bc8:	4604      	mov	r4, r0
 8009bca:	4608      	mov	r0, r1
 8009bcc:	4611      	mov	r1, r2
 8009bce:	2200      	movs	r2, #0
 8009bd0:	602a      	str	r2, [r5, #0]
 8009bd2:	461a      	mov	r2, r3
 8009bd4:	f7f6 ff7c 	bl	8000ad0 <_lseek>
 8009bd8:	1c43      	adds	r3, r0, #1
 8009bda:	d102      	bne.n	8009be2 <_lseek_r+0x1e>
 8009bdc:	682b      	ldr	r3, [r5, #0]
 8009bde:	b103      	cbz	r3, 8009be2 <_lseek_r+0x1e>
 8009be0:	6023      	str	r3, [r4, #0]
 8009be2:	bd38      	pop	{r3, r4, r5, pc}
 8009be4:	20000364 	.word	0x20000364

08009be8 <_read_r>:
 8009be8:	b538      	push	{r3, r4, r5, lr}
 8009bea:	4d07      	ldr	r5, [pc, #28]	; (8009c08 <_read_r+0x20>)
 8009bec:	4604      	mov	r4, r0
 8009bee:	4608      	mov	r0, r1
 8009bf0:	4611      	mov	r1, r2
 8009bf2:	2200      	movs	r2, #0
 8009bf4:	602a      	str	r2, [r5, #0]
 8009bf6:	461a      	mov	r2, r3
 8009bf8:	f7f6 ff42 	bl	8000a80 <_read>
 8009bfc:	1c43      	adds	r3, r0, #1
 8009bfe:	d102      	bne.n	8009c06 <_read_r+0x1e>
 8009c00:	682b      	ldr	r3, [r5, #0]
 8009c02:	b103      	cbz	r3, 8009c06 <_read_r+0x1e>
 8009c04:	6023      	str	r3, [r4, #0]
 8009c06:	bd38      	pop	{r3, r4, r5, pc}
 8009c08:	20000364 	.word	0x20000364

08009c0c <_sbrk_r>:
 8009c0c:	b538      	push	{r3, r4, r5, lr}
 8009c0e:	4d06      	ldr	r5, [pc, #24]	; (8009c28 <_sbrk_r+0x1c>)
 8009c10:	2300      	movs	r3, #0
 8009c12:	4604      	mov	r4, r0
 8009c14:	4608      	mov	r0, r1
 8009c16:	602b      	str	r3, [r5, #0]
 8009c18:	f7f6 ff5c 	bl	8000ad4 <_sbrk>
 8009c1c:	1c43      	adds	r3, r0, #1
 8009c1e:	d102      	bne.n	8009c26 <_sbrk_r+0x1a>
 8009c20:	682b      	ldr	r3, [r5, #0]
 8009c22:	b103      	cbz	r3, 8009c26 <_sbrk_r+0x1a>
 8009c24:	6023      	str	r3, [r4, #0]
 8009c26:	bd38      	pop	{r3, r4, r5, pc}
 8009c28:	20000364 	.word	0x20000364

08009c2c <_write_r>:
 8009c2c:	b538      	push	{r3, r4, r5, lr}
 8009c2e:	4d07      	ldr	r5, [pc, #28]	; (8009c4c <_write_r+0x20>)
 8009c30:	4604      	mov	r4, r0
 8009c32:	4608      	mov	r0, r1
 8009c34:	4611      	mov	r1, r2
 8009c36:	2200      	movs	r2, #0
 8009c38:	602a      	str	r2, [r5, #0]
 8009c3a:	461a      	mov	r2, r3
 8009c3c:	f7f6 ff30 	bl	8000aa0 <_write>
 8009c40:	1c43      	adds	r3, r0, #1
 8009c42:	d102      	bne.n	8009c4a <_write_r+0x1e>
 8009c44:	682b      	ldr	r3, [r5, #0]
 8009c46:	b103      	cbz	r3, 8009c4a <_write_r+0x1e>
 8009c48:	6023      	str	r3, [r4, #0]
 8009c4a:	bd38      	pop	{r3, r4, r5, pc}
 8009c4c:	20000364 	.word	0x20000364

08009c50 <__errno>:
 8009c50:	4b01      	ldr	r3, [pc, #4]	; (8009c58 <__errno+0x8>)
 8009c52:	6818      	ldr	r0, [r3, #0]
 8009c54:	4770      	bx	lr
 8009c56:	bf00      	nop
 8009c58:	20000094 	.word	0x20000094

08009c5c <__libc_init_array>:
 8009c5c:	b570      	push	{r4, r5, r6, lr}
 8009c5e:	4d0d      	ldr	r5, [pc, #52]	; (8009c94 <__libc_init_array+0x38>)
 8009c60:	4c0d      	ldr	r4, [pc, #52]	; (8009c98 <__libc_init_array+0x3c>)
 8009c62:	1b64      	subs	r4, r4, r5
 8009c64:	10a4      	asrs	r4, r4, #2
 8009c66:	2600      	movs	r6, #0
 8009c68:	42a6      	cmp	r6, r4
 8009c6a:	d109      	bne.n	8009c80 <__libc_init_array+0x24>
 8009c6c:	4d0b      	ldr	r5, [pc, #44]	; (8009c9c <__libc_init_array+0x40>)
 8009c6e:	4c0c      	ldr	r4, [pc, #48]	; (8009ca0 <__libc_init_array+0x44>)
 8009c70:	f000 fd64 	bl	800a73c <_init>
 8009c74:	1b64      	subs	r4, r4, r5
 8009c76:	10a4      	asrs	r4, r4, #2
 8009c78:	2600      	movs	r6, #0
 8009c7a:	42a6      	cmp	r6, r4
 8009c7c:	d105      	bne.n	8009c8a <__libc_init_array+0x2e>
 8009c7e:	bd70      	pop	{r4, r5, r6, pc}
 8009c80:	f855 3b04 	ldr.w	r3, [r5], #4
 8009c84:	4798      	blx	r3
 8009c86:	3601      	adds	r6, #1
 8009c88:	e7ee      	b.n	8009c68 <__libc_init_array+0xc>
 8009c8a:	f855 3b04 	ldr.w	r3, [r5], #4
 8009c8e:	4798      	blx	r3
 8009c90:	3601      	adds	r6, #1
 8009c92:	e7f2      	b.n	8009c7a <__libc_init_array+0x1e>
 8009c94:	0800ce80 	.word	0x0800ce80
 8009c98:	0800ce80 	.word	0x0800ce80
 8009c9c:	0800ce80 	.word	0x0800ce80
 8009ca0:	0800ce84 	.word	0x0800ce84

08009ca4 <__retarget_lock_acquire_recursive>:
 8009ca4:	4770      	bx	lr

08009ca6 <__retarget_lock_release_recursive>:
 8009ca6:	4770      	bx	lr

08009ca8 <memcpy>:
 8009ca8:	440a      	add	r2, r1
 8009caa:	4291      	cmp	r1, r2
 8009cac:	f100 33ff 	add.w	r3, r0, #4294967295
 8009cb0:	d100      	bne.n	8009cb4 <memcpy+0xc>
 8009cb2:	4770      	bx	lr
 8009cb4:	b510      	push	{r4, lr}
 8009cb6:	f811 4b01 	ldrb.w	r4, [r1], #1
 8009cba:	f803 4f01 	strb.w	r4, [r3, #1]!
 8009cbe:	4291      	cmp	r1, r2
 8009cc0:	d1f9      	bne.n	8009cb6 <memcpy+0xe>
 8009cc2:	bd10      	pop	{r4, pc}

08009cc4 <abort>:
 8009cc4:	b508      	push	{r3, lr}
 8009cc6:	2006      	movs	r0, #6
 8009cc8:	f000 fc98 	bl	800a5fc <raise>
 8009ccc:	2001      	movs	r0, #1
 8009cce:	f7f6 fed1 	bl	8000a74 <_exit>
	...

08009cd4 <_free_r>:
 8009cd4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8009cd6:	2900      	cmp	r1, #0
 8009cd8:	d044      	beq.n	8009d64 <_free_r+0x90>
 8009cda:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8009cde:	9001      	str	r0, [sp, #4]
 8009ce0:	2b00      	cmp	r3, #0
 8009ce2:	f1a1 0404 	sub.w	r4, r1, #4
 8009ce6:	bfb8      	it	lt
 8009ce8:	18e4      	addlt	r4, r4, r3
 8009cea:	f7ff fd99 	bl	8009820 <__malloc_lock>
 8009cee:	4a1e      	ldr	r2, [pc, #120]	; (8009d68 <_free_r+0x94>)
 8009cf0:	9801      	ldr	r0, [sp, #4]
 8009cf2:	6813      	ldr	r3, [r2, #0]
 8009cf4:	b933      	cbnz	r3, 8009d04 <_free_r+0x30>
 8009cf6:	6063      	str	r3, [r4, #4]
 8009cf8:	6014      	str	r4, [r2, #0]
 8009cfa:	b003      	add	sp, #12
 8009cfc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8009d00:	f7ff bd94 	b.w	800982c <__malloc_unlock>
 8009d04:	42a3      	cmp	r3, r4
 8009d06:	d908      	bls.n	8009d1a <_free_r+0x46>
 8009d08:	6825      	ldr	r5, [r4, #0]
 8009d0a:	1961      	adds	r1, r4, r5
 8009d0c:	428b      	cmp	r3, r1
 8009d0e:	bf01      	itttt	eq
 8009d10:	6819      	ldreq	r1, [r3, #0]
 8009d12:	685b      	ldreq	r3, [r3, #4]
 8009d14:	1949      	addeq	r1, r1, r5
 8009d16:	6021      	streq	r1, [r4, #0]
 8009d18:	e7ed      	b.n	8009cf6 <_free_r+0x22>
 8009d1a:	461a      	mov	r2, r3
 8009d1c:	685b      	ldr	r3, [r3, #4]
 8009d1e:	b10b      	cbz	r3, 8009d24 <_free_r+0x50>
 8009d20:	42a3      	cmp	r3, r4
 8009d22:	d9fa      	bls.n	8009d1a <_free_r+0x46>
 8009d24:	6811      	ldr	r1, [r2, #0]
 8009d26:	1855      	adds	r5, r2, r1
 8009d28:	42a5      	cmp	r5, r4
 8009d2a:	d10b      	bne.n	8009d44 <_free_r+0x70>
 8009d2c:	6824      	ldr	r4, [r4, #0]
 8009d2e:	4421      	add	r1, r4
 8009d30:	1854      	adds	r4, r2, r1
 8009d32:	42a3      	cmp	r3, r4
 8009d34:	6011      	str	r1, [r2, #0]
 8009d36:	d1e0      	bne.n	8009cfa <_free_r+0x26>
 8009d38:	681c      	ldr	r4, [r3, #0]
 8009d3a:	685b      	ldr	r3, [r3, #4]
 8009d3c:	6053      	str	r3, [r2, #4]
 8009d3e:	440c      	add	r4, r1
 8009d40:	6014      	str	r4, [r2, #0]
 8009d42:	e7da      	b.n	8009cfa <_free_r+0x26>
 8009d44:	d902      	bls.n	8009d4c <_free_r+0x78>
 8009d46:	230c      	movs	r3, #12
 8009d48:	6003      	str	r3, [r0, #0]
 8009d4a:	e7d6      	b.n	8009cfa <_free_r+0x26>
 8009d4c:	6825      	ldr	r5, [r4, #0]
 8009d4e:	1961      	adds	r1, r4, r5
 8009d50:	428b      	cmp	r3, r1
 8009d52:	bf04      	itt	eq
 8009d54:	6819      	ldreq	r1, [r3, #0]
 8009d56:	685b      	ldreq	r3, [r3, #4]
 8009d58:	6063      	str	r3, [r4, #4]
 8009d5a:	bf04      	itt	eq
 8009d5c:	1949      	addeq	r1, r1, r5
 8009d5e:	6021      	streq	r1, [r4, #0]
 8009d60:	6054      	str	r4, [r2, #4]
 8009d62:	e7ca      	b.n	8009cfa <_free_r+0x26>
 8009d64:	b003      	add	sp, #12
 8009d66:	bd30      	pop	{r4, r5, pc}
 8009d68:	20000220 	.word	0x20000220

08009d6c <_malloc_usable_size_r>:
 8009d6c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8009d70:	1f18      	subs	r0, r3, #4
 8009d72:	2b00      	cmp	r3, #0
 8009d74:	bfbc      	itt	lt
 8009d76:	580b      	ldrlt	r3, [r1, r0]
 8009d78:	18c0      	addlt	r0, r0, r3
 8009d7a:	4770      	bx	lr

08009d7c <__sfputc_r>:
 8009d7c:	6893      	ldr	r3, [r2, #8]
 8009d7e:	3b01      	subs	r3, #1
 8009d80:	2b00      	cmp	r3, #0
 8009d82:	b410      	push	{r4}
 8009d84:	6093      	str	r3, [r2, #8]
 8009d86:	da08      	bge.n	8009d9a <__sfputc_r+0x1e>
 8009d88:	6994      	ldr	r4, [r2, #24]
 8009d8a:	42a3      	cmp	r3, r4
 8009d8c:	db01      	blt.n	8009d92 <__sfputc_r+0x16>
 8009d8e:	290a      	cmp	r1, #10
 8009d90:	d103      	bne.n	8009d9a <__sfputc_r+0x1e>
 8009d92:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009d96:	f000 bb73 	b.w	800a480 <__swbuf_r>
 8009d9a:	6813      	ldr	r3, [r2, #0]
 8009d9c:	1c58      	adds	r0, r3, #1
 8009d9e:	6010      	str	r0, [r2, #0]
 8009da0:	7019      	strb	r1, [r3, #0]
 8009da2:	4608      	mov	r0, r1
 8009da4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009da8:	4770      	bx	lr

08009daa <__sfputs_r>:
 8009daa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009dac:	4606      	mov	r6, r0
 8009dae:	460f      	mov	r7, r1
 8009db0:	4614      	mov	r4, r2
 8009db2:	18d5      	adds	r5, r2, r3
 8009db4:	42ac      	cmp	r4, r5
 8009db6:	d101      	bne.n	8009dbc <__sfputs_r+0x12>
 8009db8:	2000      	movs	r0, #0
 8009dba:	e007      	b.n	8009dcc <__sfputs_r+0x22>
 8009dbc:	f814 1b01 	ldrb.w	r1, [r4], #1
 8009dc0:	463a      	mov	r2, r7
 8009dc2:	4630      	mov	r0, r6
 8009dc4:	f7ff ffda 	bl	8009d7c <__sfputc_r>
 8009dc8:	1c43      	adds	r3, r0, #1
 8009dca:	d1f3      	bne.n	8009db4 <__sfputs_r+0xa>
 8009dcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08009dd0 <_vfiprintf_r>:
 8009dd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009dd4:	460d      	mov	r5, r1
 8009dd6:	b09d      	sub	sp, #116	; 0x74
 8009dd8:	4614      	mov	r4, r2
 8009dda:	4698      	mov	r8, r3
 8009ddc:	4606      	mov	r6, r0
 8009dde:	b118      	cbz	r0, 8009de8 <_vfiprintf_r+0x18>
 8009de0:	6a03      	ldr	r3, [r0, #32]
 8009de2:	b90b      	cbnz	r3, 8009de8 <_vfiprintf_r+0x18>
 8009de4:	f7ff fdda 	bl	800999c <__sinit>
 8009de8:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8009dea:	07d9      	lsls	r1, r3, #31
 8009dec:	d405      	bmi.n	8009dfa <_vfiprintf_r+0x2a>
 8009dee:	89ab      	ldrh	r3, [r5, #12]
 8009df0:	059a      	lsls	r2, r3, #22
 8009df2:	d402      	bmi.n	8009dfa <_vfiprintf_r+0x2a>
 8009df4:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8009df6:	f7ff ff55 	bl	8009ca4 <__retarget_lock_acquire_recursive>
 8009dfa:	89ab      	ldrh	r3, [r5, #12]
 8009dfc:	071b      	lsls	r3, r3, #28
 8009dfe:	d501      	bpl.n	8009e04 <_vfiprintf_r+0x34>
 8009e00:	692b      	ldr	r3, [r5, #16]
 8009e02:	b99b      	cbnz	r3, 8009e2c <_vfiprintf_r+0x5c>
 8009e04:	4629      	mov	r1, r5
 8009e06:	4630      	mov	r0, r6
 8009e08:	f000 fb78 	bl	800a4fc <__swsetup_r>
 8009e0c:	b170      	cbz	r0, 8009e2c <_vfiprintf_r+0x5c>
 8009e0e:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8009e10:	07dc      	lsls	r4, r3, #31
 8009e12:	d504      	bpl.n	8009e1e <_vfiprintf_r+0x4e>
 8009e14:	f04f 30ff 	mov.w	r0, #4294967295
 8009e18:	b01d      	add	sp, #116	; 0x74
 8009e1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009e1e:	89ab      	ldrh	r3, [r5, #12]
 8009e20:	0598      	lsls	r0, r3, #22
 8009e22:	d4f7      	bmi.n	8009e14 <_vfiprintf_r+0x44>
 8009e24:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8009e26:	f7ff ff3e 	bl	8009ca6 <__retarget_lock_release_recursive>
 8009e2a:	e7f3      	b.n	8009e14 <_vfiprintf_r+0x44>
 8009e2c:	2300      	movs	r3, #0
 8009e2e:	9309      	str	r3, [sp, #36]	; 0x24
 8009e30:	2320      	movs	r3, #32
 8009e32:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8009e36:	f8cd 800c 	str.w	r8, [sp, #12]
 8009e3a:	2330      	movs	r3, #48	; 0x30
 8009e3c:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 8009ff0 <_vfiprintf_r+0x220>
 8009e40:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8009e44:	f04f 0901 	mov.w	r9, #1
 8009e48:	4623      	mov	r3, r4
 8009e4a:	469a      	mov	sl, r3
 8009e4c:	f813 2b01 	ldrb.w	r2, [r3], #1
 8009e50:	b10a      	cbz	r2, 8009e56 <_vfiprintf_r+0x86>
 8009e52:	2a25      	cmp	r2, #37	; 0x25
 8009e54:	d1f9      	bne.n	8009e4a <_vfiprintf_r+0x7a>
 8009e56:	ebba 0b04 	subs.w	fp, sl, r4
 8009e5a:	d00b      	beq.n	8009e74 <_vfiprintf_r+0xa4>
 8009e5c:	465b      	mov	r3, fp
 8009e5e:	4622      	mov	r2, r4
 8009e60:	4629      	mov	r1, r5
 8009e62:	4630      	mov	r0, r6
 8009e64:	f7ff ffa1 	bl	8009daa <__sfputs_r>
 8009e68:	3001      	adds	r0, #1
 8009e6a:	f000 80a9 	beq.w	8009fc0 <_vfiprintf_r+0x1f0>
 8009e6e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009e70:	445a      	add	r2, fp
 8009e72:	9209      	str	r2, [sp, #36]	; 0x24
 8009e74:	f89a 3000 	ldrb.w	r3, [sl]
 8009e78:	2b00      	cmp	r3, #0
 8009e7a:	f000 80a1 	beq.w	8009fc0 <_vfiprintf_r+0x1f0>
 8009e7e:	2300      	movs	r3, #0
 8009e80:	f04f 32ff 	mov.w	r2, #4294967295
 8009e84:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8009e88:	f10a 0a01 	add.w	sl, sl, #1
 8009e8c:	9304      	str	r3, [sp, #16]
 8009e8e:	9307      	str	r3, [sp, #28]
 8009e90:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8009e94:	931a      	str	r3, [sp, #104]	; 0x68
 8009e96:	4654      	mov	r4, sl
 8009e98:	2205      	movs	r2, #5
 8009e9a:	f814 1b01 	ldrb.w	r1, [r4], #1
 8009e9e:	4854      	ldr	r0, [pc, #336]	; (8009ff0 <_vfiprintf_r+0x220>)
 8009ea0:	f7f6 f9e6 	bl	8000270 <memchr>
 8009ea4:	9a04      	ldr	r2, [sp, #16]
 8009ea6:	b9d8      	cbnz	r0, 8009ee0 <_vfiprintf_r+0x110>
 8009ea8:	06d1      	lsls	r1, r2, #27
 8009eaa:	bf44      	itt	mi
 8009eac:	2320      	movmi	r3, #32
 8009eae:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8009eb2:	0713      	lsls	r3, r2, #28
 8009eb4:	bf44      	itt	mi
 8009eb6:	232b      	movmi	r3, #43	; 0x2b
 8009eb8:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8009ebc:	f89a 3000 	ldrb.w	r3, [sl]
 8009ec0:	2b2a      	cmp	r3, #42	; 0x2a
 8009ec2:	d015      	beq.n	8009ef0 <_vfiprintf_r+0x120>
 8009ec4:	9a07      	ldr	r2, [sp, #28]
 8009ec6:	4654      	mov	r4, sl
 8009ec8:	2000      	movs	r0, #0
 8009eca:	f04f 0c0a 	mov.w	ip, #10
 8009ece:	4621      	mov	r1, r4
 8009ed0:	f811 3b01 	ldrb.w	r3, [r1], #1
 8009ed4:	3b30      	subs	r3, #48	; 0x30
 8009ed6:	2b09      	cmp	r3, #9
 8009ed8:	d94d      	bls.n	8009f76 <_vfiprintf_r+0x1a6>
 8009eda:	b1b0      	cbz	r0, 8009f0a <_vfiprintf_r+0x13a>
 8009edc:	9207      	str	r2, [sp, #28]
 8009ede:	e014      	b.n	8009f0a <_vfiprintf_r+0x13a>
 8009ee0:	eba0 0308 	sub.w	r3, r0, r8
 8009ee4:	fa09 f303 	lsl.w	r3, r9, r3
 8009ee8:	4313      	orrs	r3, r2
 8009eea:	9304      	str	r3, [sp, #16]
 8009eec:	46a2      	mov	sl, r4
 8009eee:	e7d2      	b.n	8009e96 <_vfiprintf_r+0xc6>
 8009ef0:	9b03      	ldr	r3, [sp, #12]
 8009ef2:	1d19      	adds	r1, r3, #4
 8009ef4:	681b      	ldr	r3, [r3, #0]
 8009ef6:	9103      	str	r1, [sp, #12]
 8009ef8:	2b00      	cmp	r3, #0
 8009efa:	bfbb      	ittet	lt
 8009efc:	425b      	neglt	r3, r3
 8009efe:	f042 0202 	orrlt.w	r2, r2, #2
 8009f02:	9307      	strge	r3, [sp, #28]
 8009f04:	9307      	strlt	r3, [sp, #28]
 8009f06:	bfb8      	it	lt
 8009f08:	9204      	strlt	r2, [sp, #16]
 8009f0a:	7823      	ldrb	r3, [r4, #0]
 8009f0c:	2b2e      	cmp	r3, #46	; 0x2e
 8009f0e:	d10c      	bne.n	8009f2a <_vfiprintf_r+0x15a>
 8009f10:	7863      	ldrb	r3, [r4, #1]
 8009f12:	2b2a      	cmp	r3, #42	; 0x2a
 8009f14:	d134      	bne.n	8009f80 <_vfiprintf_r+0x1b0>
 8009f16:	9b03      	ldr	r3, [sp, #12]
 8009f18:	1d1a      	adds	r2, r3, #4
 8009f1a:	681b      	ldr	r3, [r3, #0]
 8009f1c:	9203      	str	r2, [sp, #12]
 8009f1e:	2b00      	cmp	r3, #0
 8009f20:	bfb8      	it	lt
 8009f22:	f04f 33ff 	movlt.w	r3, #4294967295
 8009f26:	3402      	adds	r4, #2
 8009f28:	9305      	str	r3, [sp, #20]
 8009f2a:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 800a000 <_vfiprintf_r+0x230>
 8009f2e:	7821      	ldrb	r1, [r4, #0]
 8009f30:	2203      	movs	r2, #3
 8009f32:	4650      	mov	r0, sl
 8009f34:	f7f6 f99c 	bl	8000270 <memchr>
 8009f38:	b138      	cbz	r0, 8009f4a <_vfiprintf_r+0x17a>
 8009f3a:	9b04      	ldr	r3, [sp, #16]
 8009f3c:	eba0 000a 	sub.w	r0, r0, sl
 8009f40:	2240      	movs	r2, #64	; 0x40
 8009f42:	4082      	lsls	r2, r0
 8009f44:	4313      	orrs	r3, r2
 8009f46:	3401      	adds	r4, #1
 8009f48:	9304      	str	r3, [sp, #16]
 8009f4a:	f814 1b01 	ldrb.w	r1, [r4], #1
 8009f4e:	4829      	ldr	r0, [pc, #164]	; (8009ff4 <_vfiprintf_r+0x224>)
 8009f50:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8009f54:	2206      	movs	r2, #6
 8009f56:	f7f6 f98b 	bl	8000270 <memchr>
 8009f5a:	2800      	cmp	r0, #0
 8009f5c:	d03f      	beq.n	8009fde <_vfiprintf_r+0x20e>
 8009f5e:	4b26      	ldr	r3, [pc, #152]	; (8009ff8 <_vfiprintf_r+0x228>)
 8009f60:	bb1b      	cbnz	r3, 8009faa <_vfiprintf_r+0x1da>
 8009f62:	9b03      	ldr	r3, [sp, #12]
 8009f64:	3307      	adds	r3, #7
 8009f66:	f023 0307 	bic.w	r3, r3, #7
 8009f6a:	3308      	adds	r3, #8
 8009f6c:	9303      	str	r3, [sp, #12]
 8009f6e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009f70:	443b      	add	r3, r7
 8009f72:	9309      	str	r3, [sp, #36]	; 0x24
 8009f74:	e768      	b.n	8009e48 <_vfiprintf_r+0x78>
 8009f76:	fb0c 3202 	mla	r2, ip, r2, r3
 8009f7a:	460c      	mov	r4, r1
 8009f7c:	2001      	movs	r0, #1
 8009f7e:	e7a6      	b.n	8009ece <_vfiprintf_r+0xfe>
 8009f80:	2300      	movs	r3, #0
 8009f82:	3401      	adds	r4, #1
 8009f84:	9305      	str	r3, [sp, #20]
 8009f86:	4619      	mov	r1, r3
 8009f88:	f04f 0c0a 	mov.w	ip, #10
 8009f8c:	4620      	mov	r0, r4
 8009f8e:	f810 2b01 	ldrb.w	r2, [r0], #1
 8009f92:	3a30      	subs	r2, #48	; 0x30
 8009f94:	2a09      	cmp	r2, #9
 8009f96:	d903      	bls.n	8009fa0 <_vfiprintf_r+0x1d0>
 8009f98:	2b00      	cmp	r3, #0
 8009f9a:	d0c6      	beq.n	8009f2a <_vfiprintf_r+0x15a>
 8009f9c:	9105      	str	r1, [sp, #20]
 8009f9e:	e7c4      	b.n	8009f2a <_vfiprintf_r+0x15a>
 8009fa0:	fb0c 2101 	mla	r1, ip, r1, r2
 8009fa4:	4604      	mov	r4, r0
 8009fa6:	2301      	movs	r3, #1
 8009fa8:	e7f0      	b.n	8009f8c <_vfiprintf_r+0x1bc>
 8009faa:	ab03      	add	r3, sp, #12
 8009fac:	9300      	str	r3, [sp, #0]
 8009fae:	462a      	mov	r2, r5
 8009fb0:	4b12      	ldr	r3, [pc, #72]	; (8009ffc <_vfiprintf_r+0x22c>)
 8009fb2:	a904      	add	r1, sp, #16
 8009fb4:	4630      	mov	r0, r6
 8009fb6:	f3af 8000 	nop.w
 8009fba:	4607      	mov	r7, r0
 8009fbc:	1c78      	adds	r0, r7, #1
 8009fbe:	d1d6      	bne.n	8009f6e <_vfiprintf_r+0x19e>
 8009fc0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8009fc2:	07d9      	lsls	r1, r3, #31
 8009fc4:	d405      	bmi.n	8009fd2 <_vfiprintf_r+0x202>
 8009fc6:	89ab      	ldrh	r3, [r5, #12]
 8009fc8:	059a      	lsls	r2, r3, #22
 8009fca:	d402      	bmi.n	8009fd2 <_vfiprintf_r+0x202>
 8009fcc:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8009fce:	f7ff fe6a 	bl	8009ca6 <__retarget_lock_release_recursive>
 8009fd2:	89ab      	ldrh	r3, [r5, #12]
 8009fd4:	065b      	lsls	r3, r3, #25
 8009fd6:	f53f af1d 	bmi.w	8009e14 <_vfiprintf_r+0x44>
 8009fda:	9809      	ldr	r0, [sp, #36]	; 0x24
 8009fdc:	e71c      	b.n	8009e18 <_vfiprintf_r+0x48>
 8009fde:	ab03      	add	r3, sp, #12
 8009fe0:	9300      	str	r3, [sp, #0]
 8009fe2:	462a      	mov	r2, r5
 8009fe4:	4b05      	ldr	r3, [pc, #20]	; (8009ffc <_vfiprintf_r+0x22c>)
 8009fe6:	a904      	add	r1, sp, #16
 8009fe8:	4630      	mov	r0, r6
 8009fea:	f000 f879 	bl	800a0e0 <_printf_i>
 8009fee:	e7e4      	b.n	8009fba <_vfiprintf_r+0x1ea>
 8009ff0:	0800ce42 	.word	0x0800ce42
 8009ff4:	0800ce4c 	.word	0x0800ce4c
 8009ff8:	00000000 	.word	0x00000000
 8009ffc:	08009dab 	.word	0x08009dab
 800a000:	0800ce48 	.word	0x0800ce48

0800a004 <_printf_common>:
 800a004:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800a008:	4616      	mov	r6, r2
 800a00a:	4699      	mov	r9, r3
 800a00c:	688a      	ldr	r2, [r1, #8]
 800a00e:	690b      	ldr	r3, [r1, #16]
 800a010:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800a014:	4293      	cmp	r3, r2
 800a016:	bfb8      	it	lt
 800a018:	4613      	movlt	r3, r2
 800a01a:	6033      	str	r3, [r6, #0]
 800a01c:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 800a020:	4607      	mov	r7, r0
 800a022:	460c      	mov	r4, r1
 800a024:	b10a      	cbz	r2, 800a02a <_printf_common+0x26>
 800a026:	3301      	adds	r3, #1
 800a028:	6033      	str	r3, [r6, #0]
 800a02a:	6823      	ldr	r3, [r4, #0]
 800a02c:	0699      	lsls	r1, r3, #26
 800a02e:	bf42      	ittt	mi
 800a030:	6833      	ldrmi	r3, [r6, #0]
 800a032:	3302      	addmi	r3, #2
 800a034:	6033      	strmi	r3, [r6, #0]
 800a036:	6825      	ldr	r5, [r4, #0]
 800a038:	f015 0506 	ands.w	r5, r5, #6
 800a03c:	d106      	bne.n	800a04c <_printf_common+0x48>
 800a03e:	f104 0a19 	add.w	sl, r4, #25
 800a042:	68e3      	ldr	r3, [r4, #12]
 800a044:	6832      	ldr	r2, [r6, #0]
 800a046:	1a9b      	subs	r3, r3, r2
 800a048:	42ab      	cmp	r3, r5
 800a04a:	dc26      	bgt.n	800a09a <_printf_common+0x96>
 800a04c:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 800a050:	1e13      	subs	r3, r2, #0
 800a052:	6822      	ldr	r2, [r4, #0]
 800a054:	bf18      	it	ne
 800a056:	2301      	movne	r3, #1
 800a058:	0692      	lsls	r2, r2, #26
 800a05a:	d42b      	bmi.n	800a0b4 <_printf_common+0xb0>
 800a05c:	f104 0243 	add.w	r2, r4, #67	; 0x43
 800a060:	4649      	mov	r1, r9
 800a062:	4638      	mov	r0, r7
 800a064:	47c0      	blx	r8
 800a066:	3001      	adds	r0, #1
 800a068:	d01e      	beq.n	800a0a8 <_printf_common+0xa4>
 800a06a:	6823      	ldr	r3, [r4, #0]
 800a06c:	6922      	ldr	r2, [r4, #16]
 800a06e:	f003 0306 	and.w	r3, r3, #6
 800a072:	2b04      	cmp	r3, #4
 800a074:	bf02      	ittt	eq
 800a076:	68e5      	ldreq	r5, [r4, #12]
 800a078:	6833      	ldreq	r3, [r6, #0]
 800a07a:	1aed      	subeq	r5, r5, r3
 800a07c:	68a3      	ldr	r3, [r4, #8]
 800a07e:	bf0c      	ite	eq
 800a080:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 800a084:	2500      	movne	r5, #0
 800a086:	4293      	cmp	r3, r2
 800a088:	bfc4      	itt	gt
 800a08a:	1a9b      	subgt	r3, r3, r2
 800a08c:	18ed      	addgt	r5, r5, r3
 800a08e:	2600      	movs	r6, #0
 800a090:	341a      	adds	r4, #26
 800a092:	42b5      	cmp	r5, r6
 800a094:	d11a      	bne.n	800a0cc <_printf_common+0xc8>
 800a096:	2000      	movs	r0, #0
 800a098:	e008      	b.n	800a0ac <_printf_common+0xa8>
 800a09a:	2301      	movs	r3, #1
 800a09c:	4652      	mov	r2, sl
 800a09e:	4649      	mov	r1, r9
 800a0a0:	4638      	mov	r0, r7
 800a0a2:	47c0      	blx	r8
 800a0a4:	3001      	adds	r0, #1
 800a0a6:	d103      	bne.n	800a0b0 <_printf_common+0xac>
 800a0a8:	f04f 30ff 	mov.w	r0, #4294967295
 800a0ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800a0b0:	3501      	adds	r5, #1
 800a0b2:	e7c6      	b.n	800a042 <_printf_common+0x3e>
 800a0b4:	18e1      	adds	r1, r4, r3
 800a0b6:	1c5a      	adds	r2, r3, #1
 800a0b8:	2030      	movs	r0, #48	; 0x30
 800a0ba:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 800a0be:	4422      	add	r2, r4
 800a0c0:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 800a0c4:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 800a0c8:	3302      	adds	r3, #2
 800a0ca:	e7c7      	b.n	800a05c <_printf_common+0x58>
 800a0cc:	2301      	movs	r3, #1
 800a0ce:	4622      	mov	r2, r4
 800a0d0:	4649      	mov	r1, r9
 800a0d2:	4638      	mov	r0, r7
 800a0d4:	47c0      	blx	r8
 800a0d6:	3001      	adds	r0, #1
 800a0d8:	d0e6      	beq.n	800a0a8 <_printf_common+0xa4>
 800a0da:	3601      	adds	r6, #1
 800a0dc:	e7d9      	b.n	800a092 <_printf_common+0x8e>
	...

0800a0e0 <_printf_i>:
 800a0e0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800a0e4:	7e0f      	ldrb	r7, [r1, #24]
 800a0e6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800a0e8:	2f78      	cmp	r7, #120	; 0x78
 800a0ea:	4691      	mov	r9, r2
 800a0ec:	4680      	mov	r8, r0
 800a0ee:	460c      	mov	r4, r1
 800a0f0:	469a      	mov	sl, r3
 800a0f2:	f101 0243 	add.w	r2, r1, #67	; 0x43
 800a0f6:	d807      	bhi.n	800a108 <_printf_i+0x28>
 800a0f8:	2f62      	cmp	r7, #98	; 0x62
 800a0fa:	d80a      	bhi.n	800a112 <_printf_i+0x32>
 800a0fc:	2f00      	cmp	r7, #0
 800a0fe:	f000 80d4 	beq.w	800a2aa <_printf_i+0x1ca>
 800a102:	2f58      	cmp	r7, #88	; 0x58
 800a104:	f000 80c0 	beq.w	800a288 <_printf_i+0x1a8>
 800a108:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800a10c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 800a110:	e03a      	b.n	800a188 <_printf_i+0xa8>
 800a112:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 800a116:	2b15      	cmp	r3, #21
 800a118:	d8f6      	bhi.n	800a108 <_printf_i+0x28>
 800a11a:	a101      	add	r1, pc, #4	; (adr r1, 800a120 <_printf_i+0x40>)
 800a11c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 800a120:	0800a179 	.word	0x0800a179
 800a124:	0800a18d 	.word	0x0800a18d
 800a128:	0800a109 	.word	0x0800a109
 800a12c:	0800a109 	.word	0x0800a109
 800a130:	0800a109 	.word	0x0800a109
 800a134:	0800a109 	.word	0x0800a109
 800a138:	0800a18d 	.word	0x0800a18d
 800a13c:	0800a109 	.word	0x0800a109
 800a140:	0800a109 	.word	0x0800a109
 800a144:	0800a109 	.word	0x0800a109
 800a148:	0800a109 	.word	0x0800a109
 800a14c:	0800a291 	.word	0x0800a291
 800a150:	0800a1b9 	.word	0x0800a1b9
 800a154:	0800a24b 	.word	0x0800a24b
 800a158:	0800a109 	.word	0x0800a109
 800a15c:	0800a109 	.word	0x0800a109
 800a160:	0800a2b3 	.word	0x0800a2b3
 800a164:	0800a109 	.word	0x0800a109
 800a168:	0800a1b9 	.word	0x0800a1b9
 800a16c:	0800a109 	.word	0x0800a109
 800a170:	0800a109 	.word	0x0800a109
 800a174:	0800a253 	.word	0x0800a253
 800a178:	682b      	ldr	r3, [r5, #0]
 800a17a:	1d1a      	adds	r2, r3, #4
 800a17c:	681b      	ldr	r3, [r3, #0]
 800a17e:	602a      	str	r2, [r5, #0]
 800a180:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800a184:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800a188:	2301      	movs	r3, #1
 800a18a:	e09f      	b.n	800a2cc <_printf_i+0x1ec>
 800a18c:	6820      	ldr	r0, [r4, #0]
 800a18e:	682b      	ldr	r3, [r5, #0]
 800a190:	0607      	lsls	r7, r0, #24
 800a192:	f103 0104 	add.w	r1, r3, #4
 800a196:	6029      	str	r1, [r5, #0]
 800a198:	d501      	bpl.n	800a19e <_printf_i+0xbe>
 800a19a:	681e      	ldr	r6, [r3, #0]
 800a19c:	e003      	b.n	800a1a6 <_printf_i+0xc6>
 800a19e:	0646      	lsls	r6, r0, #25
 800a1a0:	d5fb      	bpl.n	800a19a <_printf_i+0xba>
 800a1a2:	f9b3 6000 	ldrsh.w	r6, [r3]
 800a1a6:	2e00      	cmp	r6, #0
 800a1a8:	da03      	bge.n	800a1b2 <_printf_i+0xd2>
 800a1aa:	232d      	movs	r3, #45	; 0x2d
 800a1ac:	4276      	negs	r6, r6
 800a1ae:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800a1b2:	485a      	ldr	r0, [pc, #360]	; (800a31c <_printf_i+0x23c>)
 800a1b4:	230a      	movs	r3, #10
 800a1b6:	e012      	b.n	800a1de <_printf_i+0xfe>
 800a1b8:	682b      	ldr	r3, [r5, #0]
 800a1ba:	6820      	ldr	r0, [r4, #0]
 800a1bc:	1d19      	adds	r1, r3, #4
 800a1be:	6029      	str	r1, [r5, #0]
 800a1c0:	0605      	lsls	r5, r0, #24
 800a1c2:	d501      	bpl.n	800a1c8 <_printf_i+0xe8>
 800a1c4:	681e      	ldr	r6, [r3, #0]
 800a1c6:	e002      	b.n	800a1ce <_printf_i+0xee>
 800a1c8:	0641      	lsls	r1, r0, #25
 800a1ca:	d5fb      	bpl.n	800a1c4 <_printf_i+0xe4>
 800a1cc:	881e      	ldrh	r6, [r3, #0]
 800a1ce:	4853      	ldr	r0, [pc, #332]	; (800a31c <_printf_i+0x23c>)
 800a1d0:	2f6f      	cmp	r7, #111	; 0x6f
 800a1d2:	bf0c      	ite	eq
 800a1d4:	2308      	moveq	r3, #8
 800a1d6:	230a      	movne	r3, #10
 800a1d8:	2100      	movs	r1, #0
 800a1da:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 800a1de:	6865      	ldr	r5, [r4, #4]
 800a1e0:	60a5      	str	r5, [r4, #8]
 800a1e2:	2d00      	cmp	r5, #0
 800a1e4:	bfa2      	ittt	ge
 800a1e6:	6821      	ldrge	r1, [r4, #0]
 800a1e8:	f021 0104 	bicge.w	r1, r1, #4
 800a1ec:	6021      	strge	r1, [r4, #0]
 800a1ee:	b90e      	cbnz	r6, 800a1f4 <_printf_i+0x114>
 800a1f0:	2d00      	cmp	r5, #0
 800a1f2:	d04b      	beq.n	800a28c <_printf_i+0x1ac>
 800a1f4:	4615      	mov	r5, r2
 800a1f6:	fbb6 f1f3 	udiv	r1, r6, r3
 800a1fa:	fb03 6711 	mls	r7, r3, r1, r6
 800a1fe:	5dc7      	ldrb	r7, [r0, r7]
 800a200:	f805 7d01 	strb.w	r7, [r5, #-1]!
 800a204:	4637      	mov	r7, r6
 800a206:	42bb      	cmp	r3, r7
 800a208:	460e      	mov	r6, r1
 800a20a:	d9f4      	bls.n	800a1f6 <_printf_i+0x116>
 800a20c:	2b08      	cmp	r3, #8
 800a20e:	d10b      	bne.n	800a228 <_printf_i+0x148>
 800a210:	6823      	ldr	r3, [r4, #0]
 800a212:	07de      	lsls	r6, r3, #31
 800a214:	d508      	bpl.n	800a228 <_printf_i+0x148>
 800a216:	6923      	ldr	r3, [r4, #16]
 800a218:	6861      	ldr	r1, [r4, #4]
 800a21a:	4299      	cmp	r1, r3
 800a21c:	bfde      	ittt	le
 800a21e:	2330      	movle	r3, #48	; 0x30
 800a220:	f805 3c01 	strble.w	r3, [r5, #-1]
 800a224:	f105 35ff 	addle.w	r5, r5, #4294967295
 800a228:	1b52      	subs	r2, r2, r5
 800a22a:	6122      	str	r2, [r4, #16]
 800a22c:	f8cd a000 	str.w	sl, [sp]
 800a230:	464b      	mov	r3, r9
 800a232:	aa03      	add	r2, sp, #12
 800a234:	4621      	mov	r1, r4
 800a236:	4640      	mov	r0, r8
 800a238:	f7ff fee4 	bl	800a004 <_printf_common>
 800a23c:	3001      	adds	r0, #1
 800a23e:	d14a      	bne.n	800a2d6 <_printf_i+0x1f6>
 800a240:	f04f 30ff 	mov.w	r0, #4294967295
 800a244:	b004      	add	sp, #16
 800a246:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800a24a:	6823      	ldr	r3, [r4, #0]
 800a24c:	f043 0320 	orr.w	r3, r3, #32
 800a250:	6023      	str	r3, [r4, #0]
 800a252:	4833      	ldr	r0, [pc, #204]	; (800a320 <_printf_i+0x240>)
 800a254:	2778      	movs	r7, #120	; 0x78
 800a256:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 800a25a:	6823      	ldr	r3, [r4, #0]
 800a25c:	6829      	ldr	r1, [r5, #0]
 800a25e:	061f      	lsls	r7, r3, #24
 800a260:	f851 6b04 	ldr.w	r6, [r1], #4
 800a264:	d402      	bmi.n	800a26c <_printf_i+0x18c>
 800a266:	065f      	lsls	r7, r3, #25
 800a268:	bf48      	it	mi
 800a26a:	b2b6      	uxthmi	r6, r6
 800a26c:	07df      	lsls	r7, r3, #31
 800a26e:	bf48      	it	mi
 800a270:	f043 0320 	orrmi.w	r3, r3, #32
 800a274:	6029      	str	r1, [r5, #0]
 800a276:	bf48      	it	mi
 800a278:	6023      	strmi	r3, [r4, #0]
 800a27a:	b91e      	cbnz	r6, 800a284 <_printf_i+0x1a4>
 800a27c:	6823      	ldr	r3, [r4, #0]
 800a27e:	f023 0320 	bic.w	r3, r3, #32
 800a282:	6023      	str	r3, [r4, #0]
 800a284:	2310      	movs	r3, #16
 800a286:	e7a7      	b.n	800a1d8 <_printf_i+0xf8>
 800a288:	4824      	ldr	r0, [pc, #144]	; (800a31c <_printf_i+0x23c>)
 800a28a:	e7e4      	b.n	800a256 <_printf_i+0x176>
 800a28c:	4615      	mov	r5, r2
 800a28e:	e7bd      	b.n	800a20c <_printf_i+0x12c>
 800a290:	682b      	ldr	r3, [r5, #0]
 800a292:	6826      	ldr	r6, [r4, #0]
 800a294:	6961      	ldr	r1, [r4, #20]
 800a296:	1d18      	adds	r0, r3, #4
 800a298:	6028      	str	r0, [r5, #0]
 800a29a:	0635      	lsls	r5, r6, #24
 800a29c:	681b      	ldr	r3, [r3, #0]
 800a29e:	d501      	bpl.n	800a2a4 <_printf_i+0x1c4>
 800a2a0:	6019      	str	r1, [r3, #0]
 800a2a2:	e002      	b.n	800a2aa <_printf_i+0x1ca>
 800a2a4:	0670      	lsls	r0, r6, #25
 800a2a6:	d5fb      	bpl.n	800a2a0 <_printf_i+0x1c0>
 800a2a8:	8019      	strh	r1, [r3, #0]
 800a2aa:	2300      	movs	r3, #0
 800a2ac:	6123      	str	r3, [r4, #16]
 800a2ae:	4615      	mov	r5, r2
 800a2b0:	e7bc      	b.n	800a22c <_printf_i+0x14c>
 800a2b2:	682b      	ldr	r3, [r5, #0]
 800a2b4:	1d1a      	adds	r2, r3, #4
 800a2b6:	602a      	str	r2, [r5, #0]
 800a2b8:	681d      	ldr	r5, [r3, #0]
 800a2ba:	6862      	ldr	r2, [r4, #4]
 800a2bc:	2100      	movs	r1, #0
 800a2be:	4628      	mov	r0, r5
 800a2c0:	f7f5 ffd6 	bl	8000270 <memchr>
 800a2c4:	b108      	cbz	r0, 800a2ca <_printf_i+0x1ea>
 800a2c6:	1b40      	subs	r0, r0, r5
 800a2c8:	6060      	str	r0, [r4, #4]
 800a2ca:	6863      	ldr	r3, [r4, #4]
 800a2cc:	6123      	str	r3, [r4, #16]
 800a2ce:	2300      	movs	r3, #0
 800a2d0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800a2d4:	e7aa      	b.n	800a22c <_printf_i+0x14c>
 800a2d6:	6923      	ldr	r3, [r4, #16]
 800a2d8:	462a      	mov	r2, r5
 800a2da:	4649      	mov	r1, r9
 800a2dc:	4640      	mov	r0, r8
 800a2de:	47d0      	blx	sl
 800a2e0:	3001      	adds	r0, #1
 800a2e2:	d0ad      	beq.n	800a240 <_printf_i+0x160>
 800a2e4:	6823      	ldr	r3, [r4, #0]
 800a2e6:	079b      	lsls	r3, r3, #30
 800a2e8:	d413      	bmi.n	800a312 <_printf_i+0x232>
 800a2ea:	68e0      	ldr	r0, [r4, #12]
 800a2ec:	9b03      	ldr	r3, [sp, #12]
 800a2ee:	4298      	cmp	r0, r3
 800a2f0:	bfb8      	it	lt
 800a2f2:	4618      	movlt	r0, r3
 800a2f4:	e7a6      	b.n	800a244 <_printf_i+0x164>
 800a2f6:	2301      	movs	r3, #1
 800a2f8:	4632      	mov	r2, r6
 800a2fa:	4649      	mov	r1, r9
 800a2fc:	4640      	mov	r0, r8
 800a2fe:	47d0      	blx	sl
 800a300:	3001      	adds	r0, #1
 800a302:	d09d      	beq.n	800a240 <_printf_i+0x160>
 800a304:	3501      	adds	r5, #1
 800a306:	68e3      	ldr	r3, [r4, #12]
 800a308:	9903      	ldr	r1, [sp, #12]
 800a30a:	1a5b      	subs	r3, r3, r1
 800a30c:	42ab      	cmp	r3, r5
 800a30e:	dcf2      	bgt.n	800a2f6 <_printf_i+0x216>
 800a310:	e7eb      	b.n	800a2ea <_printf_i+0x20a>
 800a312:	2500      	movs	r5, #0
 800a314:	f104 0619 	add.w	r6, r4, #25
 800a318:	e7f5      	b.n	800a306 <_printf_i+0x226>
 800a31a:	bf00      	nop
 800a31c:	0800ce53 	.word	0x0800ce53
 800a320:	0800ce64 	.word	0x0800ce64

0800a324 <__sflush_r>:
 800a324:	898a      	ldrh	r2, [r1, #12]
 800a326:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a32a:	4605      	mov	r5, r0
 800a32c:	0710      	lsls	r0, r2, #28
 800a32e:	460c      	mov	r4, r1
 800a330:	d458      	bmi.n	800a3e4 <__sflush_r+0xc0>
 800a332:	684b      	ldr	r3, [r1, #4]
 800a334:	2b00      	cmp	r3, #0
 800a336:	dc05      	bgt.n	800a344 <__sflush_r+0x20>
 800a338:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800a33a:	2b00      	cmp	r3, #0
 800a33c:	dc02      	bgt.n	800a344 <__sflush_r+0x20>
 800a33e:	2000      	movs	r0, #0
 800a340:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a344:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800a346:	2e00      	cmp	r6, #0
 800a348:	d0f9      	beq.n	800a33e <__sflush_r+0x1a>
 800a34a:	2300      	movs	r3, #0
 800a34c:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 800a350:	682f      	ldr	r7, [r5, #0]
 800a352:	6a21      	ldr	r1, [r4, #32]
 800a354:	602b      	str	r3, [r5, #0]
 800a356:	d032      	beq.n	800a3be <__sflush_r+0x9a>
 800a358:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800a35a:	89a3      	ldrh	r3, [r4, #12]
 800a35c:	075a      	lsls	r2, r3, #29
 800a35e:	d505      	bpl.n	800a36c <__sflush_r+0x48>
 800a360:	6863      	ldr	r3, [r4, #4]
 800a362:	1ac0      	subs	r0, r0, r3
 800a364:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800a366:	b10b      	cbz	r3, 800a36c <__sflush_r+0x48>
 800a368:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800a36a:	1ac0      	subs	r0, r0, r3
 800a36c:	2300      	movs	r3, #0
 800a36e:	4602      	mov	r2, r0
 800a370:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800a372:	6a21      	ldr	r1, [r4, #32]
 800a374:	4628      	mov	r0, r5
 800a376:	47b0      	blx	r6
 800a378:	1c43      	adds	r3, r0, #1
 800a37a:	89a3      	ldrh	r3, [r4, #12]
 800a37c:	d106      	bne.n	800a38c <__sflush_r+0x68>
 800a37e:	6829      	ldr	r1, [r5, #0]
 800a380:	291d      	cmp	r1, #29
 800a382:	d82b      	bhi.n	800a3dc <__sflush_r+0xb8>
 800a384:	4a29      	ldr	r2, [pc, #164]	; (800a42c <__sflush_r+0x108>)
 800a386:	410a      	asrs	r2, r1
 800a388:	07d6      	lsls	r6, r2, #31
 800a38a:	d427      	bmi.n	800a3dc <__sflush_r+0xb8>
 800a38c:	2200      	movs	r2, #0
 800a38e:	6062      	str	r2, [r4, #4]
 800a390:	04d9      	lsls	r1, r3, #19
 800a392:	6922      	ldr	r2, [r4, #16]
 800a394:	6022      	str	r2, [r4, #0]
 800a396:	d504      	bpl.n	800a3a2 <__sflush_r+0x7e>
 800a398:	1c42      	adds	r2, r0, #1
 800a39a:	d101      	bne.n	800a3a0 <__sflush_r+0x7c>
 800a39c:	682b      	ldr	r3, [r5, #0]
 800a39e:	b903      	cbnz	r3, 800a3a2 <__sflush_r+0x7e>
 800a3a0:	6560      	str	r0, [r4, #84]	; 0x54
 800a3a2:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800a3a4:	602f      	str	r7, [r5, #0]
 800a3a6:	2900      	cmp	r1, #0
 800a3a8:	d0c9      	beq.n	800a33e <__sflush_r+0x1a>
 800a3aa:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800a3ae:	4299      	cmp	r1, r3
 800a3b0:	d002      	beq.n	800a3b8 <__sflush_r+0x94>
 800a3b2:	4628      	mov	r0, r5
 800a3b4:	f7ff fc8e 	bl	8009cd4 <_free_r>
 800a3b8:	2000      	movs	r0, #0
 800a3ba:	6360      	str	r0, [r4, #52]	; 0x34
 800a3bc:	e7c0      	b.n	800a340 <__sflush_r+0x1c>
 800a3be:	2301      	movs	r3, #1
 800a3c0:	4628      	mov	r0, r5
 800a3c2:	47b0      	blx	r6
 800a3c4:	1c41      	adds	r1, r0, #1
 800a3c6:	d1c8      	bne.n	800a35a <__sflush_r+0x36>
 800a3c8:	682b      	ldr	r3, [r5, #0]
 800a3ca:	2b00      	cmp	r3, #0
 800a3cc:	d0c5      	beq.n	800a35a <__sflush_r+0x36>
 800a3ce:	2b1d      	cmp	r3, #29
 800a3d0:	d001      	beq.n	800a3d6 <__sflush_r+0xb2>
 800a3d2:	2b16      	cmp	r3, #22
 800a3d4:	d101      	bne.n	800a3da <__sflush_r+0xb6>
 800a3d6:	602f      	str	r7, [r5, #0]
 800a3d8:	e7b1      	b.n	800a33e <__sflush_r+0x1a>
 800a3da:	89a3      	ldrh	r3, [r4, #12]
 800a3dc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800a3e0:	81a3      	strh	r3, [r4, #12]
 800a3e2:	e7ad      	b.n	800a340 <__sflush_r+0x1c>
 800a3e4:	690f      	ldr	r7, [r1, #16]
 800a3e6:	2f00      	cmp	r7, #0
 800a3e8:	d0a9      	beq.n	800a33e <__sflush_r+0x1a>
 800a3ea:	0793      	lsls	r3, r2, #30
 800a3ec:	680e      	ldr	r6, [r1, #0]
 800a3ee:	bf08      	it	eq
 800a3f0:	694b      	ldreq	r3, [r1, #20]
 800a3f2:	600f      	str	r7, [r1, #0]
 800a3f4:	bf18      	it	ne
 800a3f6:	2300      	movne	r3, #0
 800a3f8:	eba6 0807 	sub.w	r8, r6, r7
 800a3fc:	608b      	str	r3, [r1, #8]
 800a3fe:	f1b8 0f00 	cmp.w	r8, #0
 800a402:	dd9c      	ble.n	800a33e <__sflush_r+0x1a>
 800a404:	6a21      	ldr	r1, [r4, #32]
 800a406:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800a408:	4643      	mov	r3, r8
 800a40a:	463a      	mov	r2, r7
 800a40c:	4628      	mov	r0, r5
 800a40e:	47b0      	blx	r6
 800a410:	2800      	cmp	r0, #0
 800a412:	dc06      	bgt.n	800a422 <__sflush_r+0xfe>
 800a414:	89a3      	ldrh	r3, [r4, #12]
 800a416:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800a41a:	81a3      	strh	r3, [r4, #12]
 800a41c:	f04f 30ff 	mov.w	r0, #4294967295
 800a420:	e78e      	b.n	800a340 <__sflush_r+0x1c>
 800a422:	4407      	add	r7, r0
 800a424:	eba8 0800 	sub.w	r8, r8, r0
 800a428:	e7e9      	b.n	800a3fe <__sflush_r+0xda>
 800a42a:	bf00      	nop
 800a42c:	dfbffffe 	.word	0xdfbffffe

0800a430 <_fflush_r>:
 800a430:	b538      	push	{r3, r4, r5, lr}
 800a432:	690b      	ldr	r3, [r1, #16]
 800a434:	4605      	mov	r5, r0
 800a436:	460c      	mov	r4, r1
 800a438:	b913      	cbnz	r3, 800a440 <_fflush_r+0x10>
 800a43a:	2500      	movs	r5, #0
 800a43c:	4628      	mov	r0, r5
 800a43e:	bd38      	pop	{r3, r4, r5, pc}
 800a440:	b118      	cbz	r0, 800a44a <_fflush_r+0x1a>
 800a442:	6a03      	ldr	r3, [r0, #32]
 800a444:	b90b      	cbnz	r3, 800a44a <_fflush_r+0x1a>
 800a446:	f7ff faa9 	bl	800999c <__sinit>
 800a44a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800a44e:	2b00      	cmp	r3, #0
 800a450:	d0f3      	beq.n	800a43a <_fflush_r+0xa>
 800a452:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800a454:	07d0      	lsls	r0, r2, #31
 800a456:	d404      	bmi.n	800a462 <_fflush_r+0x32>
 800a458:	0599      	lsls	r1, r3, #22
 800a45a:	d402      	bmi.n	800a462 <_fflush_r+0x32>
 800a45c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800a45e:	f7ff fc21 	bl	8009ca4 <__retarget_lock_acquire_recursive>
 800a462:	4628      	mov	r0, r5
 800a464:	4621      	mov	r1, r4
 800a466:	f7ff ff5d 	bl	800a324 <__sflush_r>
 800a46a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800a46c:	07da      	lsls	r2, r3, #31
 800a46e:	4605      	mov	r5, r0
 800a470:	d4e4      	bmi.n	800a43c <_fflush_r+0xc>
 800a472:	89a3      	ldrh	r3, [r4, #12]
 800a474:	059b      	lsls	r3, r3, #22
 800a476:	d4e1      	bmi.n	800a43c <_fflush_r+0xc>
 800a478:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800a47a:	f7ff fc14 	bl	8009ca6 <__retarget_lock_release_recursive>
 800a47e:	e7dd      	b.n	800a43c <_fflush_r+0xc>

0800a480 <__swbuf_r>:
 800a480:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a482:	460e      	mov	r6, r1
 800a484:	4614      	mov	r4, r2
 800a486:	4605      	mov	r5, r0
 800a488:	b118      	cbz	r0, 800a492 <__swbuf_r+0x12>
 800a48a:	6a03      	ldr	r3, [r0, #32]
 800a48c:	b90b      	cbnz	r3, 800a492 <__swbuf_r+0x12>
 800a48e:	f7ff fa85 	bl	800999c <__sinit>
 800a492:	69a3      	ldr	r3, [r4, #24]
 800a494:	60a3      	str	r3, [r4, #8]
 800a496:	89a3      	ldrh	r3, [r4, #12]
 800a498:	071a      	lsls	r2, r3, #28
 800a49a:	d525      	bpl.n	800a4e8 <__swbuf_r+0x68>
 800a49c:	6923      	ldr	r3, [r4, #16]
 800a49e:	b31b      	cbz	r3, 800a4e8 <__swbuf_r+0x68>
 800a4a0:	6823      	ldr	r3, [r4, #0]
 800a4a2:	6922      	ldr	r2, [r4, #16]
 800a4a4:	1a98      	subs	r0, r3, r2
 800a4a6:	6963      	ldr	r3, [r4, #20]
 800a4a8:	b2f6      	uxtb	r6, r6
 800a4aa:	4283      	cmp	r3, r0
 800a4ac:	4637      	mov	r7, r6
 800a4ae:	dc04      	bgt.n	800a4ba <__swbuf_r+0x3a>
 800a4b0:	4621      	mov	r1, r4
 800a4b2:	4628      	mov	r0, r5
 800a4b4:	f7ff ffbc 	bl	800a430 <_fflush_r>
 800a4b8:	b9e0      	cbnz	r0, 800a4f4 <__swbuf_r+0x74>
 800a4ba:	68a3      	ldr	r3, [r4, #8]
 800a4bc:	3b01      	subs	r3, #1
 800a4be:	60a3      	str	r3, [r4, #8]
 800a4c0:	6823      	ldr	r3, [r4, #0]
 800a4c2:	1c5a      	adds	r2, r3, #1
 800a4c4:	6022      	str	r2, [r4, #0]
 800a4c6:	701e      	strb	r6, [r3, #0]
 800a4c8:	6962      	ldr	r2, [r4, #20]
 800a4ca:	1c43      	adds	r3, r0, #1
 800a4cc:	429a      	cmp	r2, r3
 800a4ce:	d004      	beq.n	800a4da <__swbuf_r+0x5a>
 800a4d0:	89a3      	ldrh	r3, [r4, #12]
 800a4d2:	07db      	lsls	r3, r3, #31
 800a4d4:	d506      	bpl.n	800a4e4 <__swbuf_r+0x64>
 800a4d6:	2e0a      	cmp	r6, #10
 800a4d8:	d104      	bne.n	800a4e4 <__swbuf_r+0x64>
 800a4da:	4621      	mov	r1, r4
 800a4dc:	4628      	mov	r0, r5
 800a4de:	f7ff ffa7 	bl	800a430 <_fflush_r>
 800a4e2:	b938      	cbnz	r0, 800a4f4 <__swbuf_r+0x74>
 800a4e4:	4638      	mov	r0, r7
 800a4e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a4e8:	4621      	mov	r1, r4
 800a4ea:	4628      	mov	r0, r5
 800a4ec:	f000 f806 	bl	800a4fc <__swsetup_r>
 800a4f0:	2800      	cmp	r0, #0
 800a4f2:	d0d5      	beq.n	800a4a0 <__swbuf_r+0x20>
 800a4f4:	f04f 37ff 	mov.w	r7, #4294967295
 800a4f8:	e7f4      	b.n	800a4e4 <__swbuf_r+0x64>
	...

0800a4fc <__swsetup_r>:
 800a4fc:	b538      	push	{r3, r4, r5, lr}
 800a4fe:	4b2a      	ldr	r3, [pc, #168]	; (800a5a8 <__swsetup_r+0xac>)
 800a500:	4605      	mov	r5, r0
 800a502:	6818      	ldr	r0, [r3, #0]
 800a504:	460c      	mov	r4, r1
 800a506:	b118      	cbz	r0, 800a510 <__swsetup_r+0x14>
 800a508:	6a03      	ldr	r3, [r0, #32]
 800a50a:	b90b      	cbnz	r3, 800a510 <__swsetup_r+0x14>
 800a50c:	f7ff fa46 	bl	800999c <__sinit>
 800a510:	89a3      	ldrh	r3, [r4, #12]
 800a512:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 800a516:	0718      	lsls	r0, r3, #28
 800a518:	d422      	bmi.n	800a560 <__swsetup_r+0x64>
 800a51a:	06d9      	lsls	r1, r3, #27
 800a51c:	d407      	bmi.n	800a52e <__swsetup_r+0x32>
 800a51e:	2309      	movs	r3, #9
 800a520:	602b      	str	r3, [r5, #0]
 800a522:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 800a526:	81a3      	strh	r3, [r4, #12]
 800a528:	f04f 30ff 	mov.w	r0, #4294967295
 800a52c:	e034      	b.n	800a598 <__swsetup_r+0x9c>
 800a52e:	0758      	lsls	r0, r3, #29
 800a530:	d512      	bpl.n	800a558 <__swsetup_r+0x5c>
 800a532:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800a534:	b141      	cbz	r1, 800a548 <__swsetup_r+0x4c>
 800a536:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800a53a:	4299      	cmp	r1, r3
 800a53c:	d002      	beq.n	800a544 <__swsetup_r+0x48>
 800a53e:	4628      	mov	r0, r5
 800a540:	f7ff fbc8 	bl	8009cd4 <_free_r>
 800a544:	2300      	movs	r3, #0
 800a546:	6363      	str	r3, [r4, #52]	; 0x34
 800a548:	89a3      	ldrh	r3, [r4, #12]
 800a54a:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 800a54e:	81a3      	strh	r3, [r4, #12]
 800a550:	2300      	movs	r3, #0
 800a552:	6063      	str	r3, [r4, #4]
 800a554:	6923      	ldr	r3, [r4, #16]
 800a556:	6023      	str	r3, [r4, #0]
 800a558:	89a3      	ldrh	r3, [r4, #12]
 800a55a:	f043 0308 	orr.w	r3, r3, #8
 800a55e:	81a3      	strh	r3, [r4, #12]
 800a560:	6923      	ldr	r3, [r4, #16]
 800a562:	b94b      	cbnz	r3, 800a578 <__swsetup_r+0x7c>
 800a564:	89a3      	ldrh	r3, [r4, #12]
 800a566:	f403 7320 	and.w	r3, r3, #640	; 0x280
 800a56a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800a56e:	d003      	beq.n	800a578 <__swsetup_r+0x7c>
 800a570:	4621      	mov	r1, r4
 800a572:	4628      	mov	r0, r5
 800a574:	f000 f884 	bl	800a680 <__smakebuf_r>
 800a578:	89a0      	ldrh	r0, [r4, #12]
 800a57a:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 800a57e:	f010 0301 	ands.w	r3, r0, #1
 800a582:	d00a      	beq.n	800a59a <__swsetup_r+0x9e>
 800a584:	2300      	movs	r3, #0
 800a586:	60a3      	str	r3, [r4, #8]
 800a588:	6963      	ldr	r3, [r4, #20]
 800a58a:	425b      	negs	r3, r3
 800a58c:	61a3      	str	r3, [r4, #24]
 800a58e:	6923      	ldr	r3, [r4, #16]
 800a590:	b943      	cbnz	r3, 800a5a4 <__swsetup_r+0xa8>
 800a592:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 800a596:	d1c4      	bne.n	800a522 <__swsetup_r+0x26>
 800a598:	bd38      	pop	{r3, r4, r5, pc}
 800a59a:	0781      	lsls	r1, r0, #30
 800a59c:	bf58      	it	pl
 800a59e:	6963      	ldrpl	r3, [r4, #20]
 800a5a0:	60a3      	str	r3, [r4, #8]
 800a5a2:	e7f4      	b.n	800a58e <__swsetup_r+0x92>
 800a5a4:	2000      	movs	r0, #0
 800a5a6:	e7f7      	b.n	800a598 <__swsetup_r+0x9c>
 800a5a8:	20000094 	.word	0x20000094

0800a5ac <_raise_r>:
 800a5ac:	291f      	cmp	r1, #31
 800a5ae:	b538      	push	{r3, r4, r5, lr}
 800a5b0:	4604      	mov	r4, r0
 800a5b2:	460d      	mov	r5, r1
 800a5b4:	d904      	bls.n	800a5c0 <_raise_r+0x14>
 800a5b6:	2316      	movs	r3, #22
 800a5b8:	6003      	str	r3, [r0, #0]
 800a5ba:	f04f 30ff 	mov.w	r0, #4294967295
 800a5be:	bd38      	pop	{r3, r4, r5, pc}
 800a5c0:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 800a5c2:	b112      	cbz	r2, 800a5ca <_raise_r+0x1e>
 800a5c4:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 800a5c8:	b94b      	cbnz	r3, 800a5de <_raise_r+0x32>
 800a5ca:	4620      	mov	r0, r4
 800a5cc:	f000 f830 	bl	800a630 <_getpid_r>
 800a5d0:	462a      	mov	r2, r5
 800a5d2:	4601      	mov	r1, r0
 800a5d4:	4620      	mov	r0, r4
 800a5d6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800a5da:	f000 b817 	b.w	800a60c <_kill_r>
 800a5de:	2b01      	cmp	r3, #1
 800a5e0:	d00a      	beq.n	800a5f8 <_raise_r+0x4c>
 800a5e2:	1c59      	adds	r1, r3, #1
 800a5e4:	d103      	bne.n	800a5ee <_raise_r+0x42>
 800a5e6:	2316      	movs	r3, #22
 800a5e8:	6003      	str	r3, [r0, #0]
 800a5ea:	2001      	movs	r0, #1
 800a5ec:	e7e7      	b.n	800a5be <_raise_r+0x12>
 800a5ee:	2400      	movs	r4, #0
 800a5f0:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 800a5f4:	4628      	mov	r0, r5
 800a5f6:	4798      	blx	r3
 800a5f8:	2000      	movs	r0, #0
 800a5fa:	e7e0      	b.n	800a5be <_raise_r+0x12>

0800a5fc <raise>:
 800a5fc:	4b02      	ldr	r3, [pc, #8]	; (800a608 <raise+0xc>)
 800a5fe:	4601      	mov	r1, r0
 800a600:	6818      	ldr	r0, [r3, #0]
 800a602:	f7ff bfd3 	b.w	800a5ac <_raise_r>
 800a606:	bf00      	nop
 800a608:	20000094 	.word	0x20000094

0800a60c <_kill_r>:
 800a60c:	b538      	push	{r3, r4, r5, lr}
 800a60e:	4d07      	ldr	r5, [pc, #28]	; (800a62c <_kill_r+0x20>)
 800a610:	2300      	movs	r3, #0
 800a612:	4604      	mov	r4, r0
 800a614:	4608      	mov	r0, r1
 800a616:	4611      	mov	r1, r2
 800a618:	602b      	str	r3, [r5, #0]
 800a61a:	f7f6 fa23 	bl	8000a64 <_kill>
 800a61e:	1c43      	adds	r3, r0, #1
 800a620:	d102      	bne.n	800a628 <_kill_r+0x1c>
 800a622:	682b      	ldr	r3, [r5, #0]
 800a624:	b103      	cbz	r3, 800a628 <_kill_r+0x1c>
 800a626:	6023      	str	r3, [r4, #0]
 800a628:	bd38      	pop	{r3, r4, r5, pc}
 800a62a:	bf00      	nop
 800a62c:	20000364 	.word	0x20000364

0800a630 <_getpid_r>:
 800a630:	f7f6 ba16 	b.w	8000a60 <_getpid>

0800a634 <__swhatbuf_r>:
 800a634:	b570      	push	{r4, r5, r6, lr}
 800a636:	460c      	mov	r4, r1
 800a638:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800a63c:	2900      	cmp	r1, #0
 800a63e:	b096      	sub	sp, #88	; 0x58
 800a640:	4615      	mov	r5, r2
 800a642:	461e      	mov	r6, r3
 800a644:	da0d      	bge.n	800a662 <__swhatbuf_r+0x2e>
 800a646:	89a3      	ldrh	r3, [r4, #12]
 800a648:	f013 0f80 	tst.w	r3, #128	; 0x80
 800a64c:	f04f 0100 	mov.w	r1, #0
 800a650:	bf0c      	ite	eq
 800a652:	f44f 6380 	moveq.w	r3, #1024	; 0x400
 800a656:	2340      	movne	r3, #64	; 0x40
 800a658:	2000      	movs	r0, #0
 800a65a:	6031      	str	r1, [r6, #0]
 800a65c:	602b      	str	r3, [r5, #0]
 800a65e:	b016      	add	sp, #88	; 0x58
 800a660:	bd70      	pop	{r4, r5, r6, pc}
 800a662:	466a      	mov	r2, sp
 800a664:	f000 f848 	bl	800a6f8 <_fstat_r>
 800a668:	2800      	cmp	r0, #0
 800a66a:	dbec      	blt.n	800a646 <__swhatbuf_r+0x12>
 800a66c:	9901      	ldr	r1, [sp, #4]
 800a66e:	f401 4170 	and.w	r1, r1, #61440	; 0xf000
 800a672:	f5a1 5300 	sub.w	r3, r1, #8192	; 0x2000
 800a676:	4259      	negs	r1, r3
 800a678:	4159      	adcs	r1, r3
 800a67a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800a67e:	e7eb      	b.n	800a658 <__swhatbuf_r+0x24>

0800a680 <__smakebuf_r>:
 800a680:	898b      	ldrh	r3, [r1, #12]
 800a682:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800a684:	079d      	lsls	r5, r3, #30
 800a686:	4606      	mov	r6, r0
 800a688:	460c      	mov	r4, r1
 800a68a:	d507      	bpl.n	800a69c <__smakebuf_r+0x1c>
 800a68c:	f104 0347 	add.w	r3, r4, #71	; 0x47
 800a690:	6023      	str	r3, [r4, #0]
 800a692:	6123      	str	r3, [r4, #16]
 800a694:	2301      	movs	r3, #1
 800a696:	6163      	str	r3, [r4, #20]
 800a698:	b002      	add	sp, #8
 800a69a:	bd70      	pop	{r4, r5, r6, pc}
 800a69c:	ab01      	add	r3, sp, #4
 800a69e:	466a      	mov	r2, sp
 800a6a0:	f7ff ffc8 	bl	800a634 <__swhatbuf_r>
 800a6a4:	9900      	ldr	r1, [sp, #0]
 800a6a6:	4605      	mov	r5, r0
 800a6a8:	4630      	mov	r0, r6
 800a6aa:	f7ff f839 	bl	8009720 <_malloc_r>
 800a6ae:	b948      	cbnz	r0, 800a6c4 <__smakebuf_r+0x44>
 800a6b0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800a6b4:	059a      	lsls	r2, r3, #22
 800a6b6:	d4ef      	bmi.n	800a698 <__smakebuf_r+0x18>
 800a6b8:	f023 0303 	bic.w	r3, r3, #3
 800a6bc:	f043 0302 	orr.w	r3, r3, #2
 800a6c0:	81a3      	strh	r3, [r4, #12]
 800a6c2:	e7e3      	b.n	800a68c <__smakebuf_r+0xc>
 800a6c4:	89a3      	ldrh	r3, [r4, #12]
 800a6c6:	6020      	str	r0, [r4, #0]
 800a6c8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a6cc:	81a3      	strh	r3, [r4, #12]
 800a6ce:	9b00      	ldr	r3, [sp, #0]
 800a6d0:	6163      	str	r3, [r4, #20]
 800a6d2:	9b01      	ldr	r3, [sp, #4]
 800a6d4:	6120      	str	r0, [r4, #16]
 800a6d6:	b15b      	cbz	r3, 800a6f0 <__smakebuf_r+0x70>
 800a6d8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800a6dc:	4630      	mov	r0, r6
 800a6de:	f000 f81d 	bl	800a71c <_isatty_r>
 800a6e2:	b128      	cbz	r0, 800a6f0 <__smakebuf_r+0x70>
 800a6e4:	89a3      	ldrh	r3, [r4, #12]
 800a6e6:	f023 0303 	bic.w	r3, r3, #3
 800a6ea:	f043 0301 	orr.w	r3, r3, #1
 800a6ee:	81a3      	strh	r3, [r4, #12]
 800a6f0:	89a3      	ldrh	r3, [r4, #12]
 800a6f2:	431d      	orrs	r5, r3
 800a6f4:	81a5      	strh	r5, [r4, #12]
 800a6f6:	e7cf      	b.n	800a698 <__smakebuf_r+0x18>

0800a6f8 <_fstat_r>:
 800a6f8:	b538      	push	{r3, r4, r5, lr}
 800a6fa:	4d07      	ldr	r5, [pc, #28]	; (800a718 <_fstat_r+0x20>)
 800a6fc:	2300      	movs	r3, #0
 800a6fe:	4604      	mov	r4, r0
 800a700:	4608      	mov	r0, r1
 800a702:	4611      	mov	r1, r2
 800a704:	602b      	str	r3, [r5, #0]
 800a706:	f7f6 f9dc 	bl	8000ac2 <_fstat>
 800a70a:	1c43      	adds	r3, r0, #1
 800a70c:	d102      	bne.n	800a714 <_fstat_r+0x1c>
 800a70e:	682b      	ldr	r3, [r5, #0]
 800a710:	b103      	cbz	r3, 800a714 <_fstat_r+0x1c>
 800a712:	6023      	str	r3, [r4, #0]
 800a714:	bd38      	pop	{r3, r4, r5, pc}
 800a716:	bf00      	nop
 800a718:	20000364 	.word	0x20000364

0800a71c <_isatty_r>:
 800a71c:	b538      	push	{r3, r4, r5, lr}
 800a71e:	4d06      	ldr	r5, [pc, #24]	; (800a738 <_isatty_r+0x1c>)
 800a720:	2300      	movs	r3, #0
 800a722:	4604      	mov	r4, r0
 800a724:	4608      	mov	r0, r1
 800a726:	602b      	str	r3, [r5, #0]
 800a728:	f7f6 f9d0 	bl	8000acc <_isatty>
 800a72c:	1c43      	adds	r3, r0, #1
 800a72e:	d102      	bne.n	800a736 <_isatty_r+0x1a>
 800a730:	682b      	ldr	r3, [r5, #0]
 800a732:	b103      	cbz	r3, 800a736 <_isatty_r+0x1a>
 800a734:	6023      	str	r3, [r4, #0]
 800a736:	bd38      	pop	{r3, r4, r5, pc}
 800a738:	20000364 	.word	0x20000364

0800a73c <_init>:
 800a73c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a73e:	bf00      	nop
 800a740:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800a742:	bc08      	pop	{r3}
 800a744:	469e      	mov	lr, r3
 800a746:	4770      	bx	lr

0800a748 <_fini>:
 800a748:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a74a:	bf00      	nop
 800a74c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800a74e:	bc08      	pop	{r3}
 800a750:	469e      	mov	lr, r3
 800a752:	4770      	bx	lr
