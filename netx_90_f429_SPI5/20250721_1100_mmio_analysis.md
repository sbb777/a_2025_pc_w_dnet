# MMIO 제어 코드 분석 및 개선 방안

이 문서는 `netX_Dual-Port_Memory_Interface_DPM_17_EN.pdf` 문서를 기반으로 현재 MMIO 제어 코드의 문제점을 분석하고, 이를 해결하기 위한 개선 방안을 제시합니다.

## 1. 문제 분석: LED가 동작하지 않는 원인

컴파일 에러 없이 코드가 실행됨에도 불구하고 LED가 동작하지 않는 가장 유력한 원인은 **패킷 통신의 세부 구현 누락**입니다.

`cifX` 툴킷을 사용한 통신은 단순히 `xChannelPutPacket`을 호출하는 것만으로 완료되지 않습니다. DPM 문서는 **핸드셰이크 플래그(Handshake Flags)**를 사용한 동기화 과정이 필수적임을 강조합니다. (문서 4.1.7절, 46페이지 참조)

### 현재 코드의 문제점

*   **동기화 부재**: 현재 코드는 `Send Mailbox`가 비어 있는지 확인하는 과정 없이 패킷을 전송합니다. 만약 펌웨어가 이전 패킷을 처리 중인 상태에서 새로운 패킷이 전송되면, 해당 패킷은 무시되거나 덮어써질 수 있습니다.
*   **응답(Confirmation) 미확인**: `xChannelPutPacket`으로 명령을 보낸 후, 펌웨어가 해당 명령을 잘 처리했는지 확인하는 응답 패킷을 확인하는 로직이 없습니다. 따라서 명령이 성공했는지, 실패했다면 그 원인은 무엇인지 알 수 없습니다.
*   **부정확한 파라미터 가능성**: 사용된 패킷의 목적지 주소(`0x20`), 커맨드(`0xB1`, `0xB2`) 등이 현재 펌웨어 설정과 다를 수 있습니다. 특히, DIO 제어와 같은 기능은 통신 채널이 아닌 시스템 채널(`ulDest = 0x00`)을 통해야 할 수도 있습니다.

## 2. 해결 및 개선 방안

문서에서 제시하는 정석적인 패킷 통신 절차에 따라 코드를 수정해야 합니다. 이는 다음과 같은 단계로 이루어집니다.

1.  **송신 전 메일박스 상태 확인 (Handshake)**
    *   패킷을 보내기 전에, `HCF_SEND_MBX_CMD` 플래그와 `NCF_SEND_MBX_ACK` 플래그를 XOR 연산하여 메일박스가 비어있는지 확인합니다.

2.  **패킷 전송 및 핸드셰이크 플래그 토글**
    *   메일박스가 비어있다면, `xChannelPutPacket`으로 패킷을 전송합니다.
    *   전송 직후, `HCF_SEND_MBX_CMD` 플래그를 토글하여 펌웨어에게 새로운 패킷이 도착했음을 알립니다.

3.  **응답 대기 및 확인**
    *   명령을 보낸 후, `Receive Mailbox`에 응답 패킷이 도착하기를 기다립니다. 이는 `NCF_RECV_MBX_CMD`와 `HCF_RECV_MBX_ACK` 플래그를 통해 확인할 수 있습니다.
    *   응답 패킷이 도착하면, `xChannelGetPacket`으로 패킷을 읽어옵니다.
    *   응답 패킷 헤더의 `ulSta` 필드를 확인하여 명령 처리 결과(성공/에러 코드)를 확인합니다.
    *   응답 패킷을 정상적으로 수신했음을 알리기 위해 `HCF_RECV_MBX_ACK` 플래그를 토글합니다.

## 3. 수정된 코드 예시 (개념)

다음은 위 절차를 반영한 수도 코드입니다.

```c
// 1. 메일박스가 비어있는지 확인
while ( (usHostFlags ^ usNetxFlags) & HCF_SEND_MBX_CMD ) {
    // 메일박스가 찰 때까지 대기
    OS_Sleep(1);
}

// 2. 패킷 생성 및 전송
DIO_SET_LINE_STATE_REQ tReq;
// ... (패킷 내용 채우기)
xChannelPutPacket(hChannel, (CIFX_PACKET*)&tReq, 1000);

// 3. 송신 플래그 토글
// usHostFlags ^= HCF_SEND_MBX_CMD;
// (실제 구현에서는 레지스터 직접 조작 필요)

// 4. 응답 대기
while ( !((usHostFlags ^ usNetxFlags) & NCF_RECV_MBX_CMD) ) {
    // 응답이 올 때까지 대기
    OS_Sleep(1);
}

// 5. 응답 패킷 읽기 및 처리
CIFX_PACKET tRsp;
xChannelGetPacket(hChannel, sizeof(tRsp), &tRsp, 1000);
if (tRsp.tHeader.ulSta != CIFX_NO_ERROR) {
    // 에러 처리
}

// 6. 수신 확인 플래그 토글
// usHostFlags ^= HCF_RECV_MBX_ACK;
// (실제 구현에서는 레지스터 직접 조작 필요)
```

## 4. 다음 단계

위 분석 내용을 바탕으로 `mmio_control.c`의 함수들을 **핸드셰이크와 응답 확인 로직을 포함**하도록 수정하겠습니다. 만약 수정 후에도 동작하지 않는다면, 패킷의 `ulDest`를 `0x00` (시스템 채널)으로 변경하여 테스트를 진행할 것입니다.
